{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashMap.java", "func_name": "LongHashMap.keys", "original_string": "public long[] keys() {\n        long[] values = new long[size];\n        int idx = 0;\n        for (Entry entry : table) {\n            while (entry != null) {\n                values[idx++] = entry.key;\n                entry = entry.next;\n            }\n        }\n        return values;\n    }", "language": "java", "code": "public long[] keys() {\n        long[] values = new long[size];\n        int idx = 0;\n        for (Entry entry : table) {\n            while (entry != null) {\n                values[idx++] = entry.key;\n                entry = entry.next;\n            }\n        }\n        return values;\n    }", "code_tokens": ["public", "long", "[", "]", "keys", "(", ")", "{", "long", "[", "]", "values", "=", "new", "long", "[", "size", "]", ";", "int", "idx", "=", "0", ";", "for", "(", "Entry", "entry", ":", "table", ")", "{", "while", "(", "entry", "!=", "null", ")", "{", "values", "[", "idx", "++", "]", "=", "entry", ".", "key", ";", "entry", "=", "entry", ".", "next", ";", "}", "}", "return", "values", ";", "}"], "docstring": "Returns all keys in no particular order.", "docstring_tokens": ["Returns", "all", "keys", "in", "no", "particular", "order", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashMap.java#L136-L146", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashMap.java", "func_name": "LongHashMap.entries", "original_string": "public Entry<T>[] entries() {\n        @SuppressWarnings(\"unchecked\")\n        Entry<T>[] entries = new Entry[size];\n        int idx = 0;\n        for (Entry entry : table) {\n            while (entry != null) {\n                entries[idx++] = entry;\n                entry = entry.next;\n            }\n        }\n        return entries;\n    }", "language": "java", "code": "public Entry<T>[] entries() {\n        @SuppressWarnings(\"unchecked\")\n        Entry<T>[] entries = new Entry[size];\n        int idx = 0;\n        for (Entry entry : table) {\n            while (entry != null) {\n                entries[idx++] = entry;\n                entry = entry.next;\n            }\n        }\n        return entries;\n    }", "code_tokens": ["public", "Entry", "<", "T", ">", "[", "]", "entries", "(", ")", "{", "@", "SuppressWarnings", "(", "\"unchecked\"", ")", "Entry", "<", "T", ">", "[", "]", "entries", "=", "new", "Entry", "[", "size", "]", ";", "int", "idx", "=", "0", ";", "for", "(", "Entry", "entry", ":", "table", ")", "{", "while", "(", "entry", "!=", "null", ")", "{", "entries", "[", "idx", "++", "]", "=", "entry", ";", "entry", "=", "entry", ".", "next", ";", "}", "}", "return", "entries", ";", "}"], "docstring": "Returns all entries in no particular order.", "docstring_tokens": ["Returns", "all", "entries", "in", "no", "particular", "order", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashMap.java#L151-L162", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashSet.java", "func_name": "LongHashSet.add", "original_string": "public boolean add(long key) {\n        final int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;\n        final Entry entryOriginal = table[index];\n        for (Entry entry = entryOriginal; entry != null; entry = entry.next) {\n            if (entry.key == key) {\n                return false;\n            }\n        }\n        table[index] = new Entry(key, entryOriginal);\n        size++;\n        if (size > threshold) {\n            setCapacity(2 * capacity);\n        }\n        return true;\n    }", "language": "java", "code": "public boolean add(long key) {\n        final int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;\n        final Entry entryOriginal = table[index];\n        for (Entry entry = entryOriginal; entry != null; entry = entry.next) {\n            if (entry.key == key) {\n                return false;\n            }\n        }\n        table[index] = new Entry(key, entryOriginal);\n        size++;\n        if (size > threshold) {\n            setCapacity(2 * capacity);\n        }\n        return true;\n    }", "code_tokens": ["public", "boolean", "add", "(", "long", "key", ")", "{", "final", "int", "index", "=", "(", "(", "(", "(", "int", ")", "(", "key", ">>>", "32", ")", ")", "^", "(", "(", "int", ")", "(", "key", ")", ")", ")", "&", "0x7fffffff", ")", "%", "capacity", ";", "final", "Entry", "entryOriginal", "=", "table", "[", "index", "]", ";", "for", "(", "Entry", "entry", "=", "entryOriginal", ";", "entry", "!=", "null", ";", "entry", "=", "entry", ".", "next", ")", "{", "if", "(", "entry", ".", "key", "==", "key", ")", "{", "return", "false", ";", "}", "}", "table", "[", "index", "]", "=", "new", "Entry", "(", "key", ",", "entryOriginal", ")", ";", "size", "++", ";", "if", "(", "size", ">", "threshold", ")", "{", "setCapacity", "(", "2", "*", "capacity", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Adds the given value to the set.\n\n@return true if the value was actually new", "docstring_tokens": ["Adds", "the", "given", "value", "to", "the", "set", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashSet.java#L88-L102", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashSet.java", "func_name": "LongHashSet.remove", "original_string": "public boolean remove(long key) {\n        int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;\n        Entry previous = null;\n        Entry entry = table[index];\n        while (entry != null) {\n            Entry next = entry.next;\n            if (entry.key == key) {\n                if (previous == null) {\n                    table[index] = next;\n                } else {\n                    previous.next = next;\n                }\n                size--;\n                return true;\n            }\n            previous = entry;\n            entry = next;\n        }\n        return false;\n    }", "language": "java", "code": "public boolean remove(long key) {\n        int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;\n        Entry previous = null;\n        Entry entry = table[index];\n        while (entry != null) {\n            Entry next = entry.next;\n            if (entry.key == key) {\n                if (previous == null) {\n                    table[index] = next;\n                } else {\n                    previous.next = next;\n                }\n                size--;\n                return true;\n            }\n            previous = entry;\n            entry = next;\n        }\n        return false;\n    }", "code_tokens": ["public", "boolean", "remove", "(", "long", "key", ")", "{", "int", "index", "=", "(", "(", "(", "(", "int", ")", "(", "key", ">>>", "32", ")", ")", "^", "(", "(", "int", ")", "(", "key", ")", ")", ")", "&", "0x7fffffff", ")", "%", "capacity", ";", "Entry", "previous", "=", "null", ";", "Entry", "entry", "=", "table", "[", "index", "]", ";", "while", "(", "entry", "!=", "null", ")", "{", "Entry", "next", "=", "entry", ".", "next", ";", "if", "(", "entry", ".", "key", "==", "key", ")", "{", "if", "(", "previous", "==", "null", ")", "{", "table", "[", "index", "]", "=", "next", ";", "}", "else", "{", "previous", ".", "next", "=", "next", ";", "}", "size", "--", ";", "return", "true", ";", "}", "previous", "=", "entry", ";", "entry", "=", "next", ";", "}", "return", "false", ";", "}"], "docstring": "Removes the given value to the set.\n\n@return true if the value was actually removed", "docstring_tokens": ["Removes", "the", "given", "value", "to", "the", "set", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/collections/LongHashSet.java#L109-L128", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java", "func_name": "ObjectCache.put", "original_string": "public VALUE put(KEY key, VALUE object) {\n        CacheEntry<VALUE> entry;\n        if (referenceType == ReferenceType.WEAK) {\n            entry = new CacheEntry<>(new WeakReference<>(object), null);\n        } else if (referenceType == ReferenceType.SOFT) {\n            entry = new CacheEntry<>(new SoftReference<>(object), null);\n        } else {\n            entry = new CacheEntry<>(null, object);\n        }\n\n        countPutCountSinceEviction++;\n        countPut++;\n        if (isExpiring && nextCleanUpTimestamp == 0) {\n            nextCleanUpTimestamp = System.currentTimeMillis() + expirationMillis + 1;\n        }\n\n        CacheEntry<VALUE> oldEntry;\n        synchronized (this) {\n            if (values.size() >= maxSize) {\n                evictToTargetSize(maxSize - 1);\n            }\n            oldEntry = values.put(key, entry);\n        }\n        return getValueForRemoved(oldEntry);\n    }", "language": "java", "code": "public VALUE put(KEY key, VALUE object) {\n        CacheEntry<VALUE> entry;\n        if (referenceType == ReferenceType.WEAK) {\n            entry = new CacheEntry<>(new WeakReference<>(object), null);\n        } else if (referenceType == ReferenceType.SOFT) {\n            entry = new CacheEntry<>(new SoftReference<>(object), null);\n        } else {\n            entry = new CacheEntry<>(null, object);\n        }\n\n        countPutCountSinceEviction++;\n        countPut++;\n        if (isExpiring && nextCleanUpTimestamp == 0) {\n            nextCleanUpTimestamp = System.currentTimeMillis() + expirationMillis + 1;\n        }\n\n        CacheEntry<VALUE> oldEntry;\n        synchronized (this) {\n            if (values.size() >= maxSize) {\n                evictToTargetSize(maxSize - 1);\n            }\n            oldEntry = values.put(key, entry);\n        }\n        return getValueForRemoved(oldEntry);\n    }", "code_tokens": ["public", "VALUE", "put", "(", "KEY", "key", ",", "VALUE", "object", ")", "{", "CacheEntry", "<", "VALUE", ">", "entry", ";", "if", "(", "referenceType", "==", "ReferenceType", ".", "WEAK", ")", "{", "entry", "=", "new", "CacheEntry", "<>", "(", "new", "WeakReference", "<>", "(", "object", ")", ",", "null", ")", ";", "}", "else", "if", "(", "referenceType", "==", "ReferenceType", ".", "SOFT", ")", "{", "entry", "=", "new", "CacheEntry", "<>", "(", "new", "SoftReference", "<>", "(", "object", ")", ",", "null", ")", ";", "}", "else", "{", "entry", "=", "new", "CacheEntry", "<>", "(", "null", ",", "object", ")", ";", "}", "countPutCountSinceEviction", "++", ";", "countPut", "++", ";", "if", "(", "isExpiring", "&&", "nextCleanUpTimestamp", "==", "0", ")", "{", "nextCleanUpTimestamp", "=", "System", ".", "currentTimeMillis", "(", ")", "+", "expirationMillis", "+", "1", ";", "}", "CacheEntry", "<", "VALUE", ">", "oldEntry", ";", "synchronized", "(", "this", ")", "{", "if", "(", "values", ".", "size", "(", ")", ">=", "maxSize", ")", "{", "evictToTargetSize", "(", "maxSize", "-", "1", ")", ";", "}", "oldEntry", "=", "values", ".", "put", "(", "key", ",", "entry", ")", ";", "}", "return", "getValueForRemoved", "(", "oldEntry", ")", ";", "}"], "docstring": "Stores an new entry in the cache.", "docstring_tokens": ["Stores", "an", "new", "entry", "in", "the", "cache", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java#L91-L115", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java", "func_name": "ObjectCache.putAll", "original_string": "public void putAll(Map<KEY, VALUE> mapDataToPut) {\n        int targetSize = maxSize - mapDataToPut.size();\n        if (maxSize > 0 && values.size() > targetSize) {\n            evictToTargetSize(targetSize);\n        }\n        Set<Entry<KEY, VALUE>> entries = mapDataToPut.entrySet();\n        for (Entry<KEY, VALUE> entry : entries) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }", "language": "java", "code": "public void putAll(Map<KEY, VALUE> mapDataToPut) {\n        int targetSize = maxSize - mapDataToPut.size();\n        if (maxSize > 0 && values.size() > targetSize) {\n            evictToTargetSize(targetSize);\n        }\n        Set<Entry<KEY, VALUE>> entries = mapDataToPut.entrySet();\n        for (Entry<KEY, VALUE> entry : entries) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }", "code_tokens": ["public", "void", "putAll", "(", "Map", "<", "KEY", ",", "VALUE", ">", "mapDataToPut", ")", "{", "int", "targetSize", "=", "maxSize", "-", "mapDataToPut", ".", "size", "(", ")", ";", "if", "(", "maxSize", ">", "0", "&&", "values", ".", "size", "(", ")", ">", "targetSize", ")", "{", "evictToTargetSize", "(", "targetSize", ")", ";", "}", "Set", "<", "Entry", "<", "KEY", ",", "VALUE", ">", ">", "entries", "=", "mapDataToPut", ".", "entrySet", "(", ")", ";", "for", "(", "Entry", "<", "KEY", ",", "VALUE", ">", "entry", ":", "entries", ")", "{", "put", "(", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}"], "docstring": "Stores all entries contained in the given map in the cache.", "docstring_tokens": ["Stores", "all", "entries", "contained", "in", "the", "given", "map", "in", "the", "cache", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java#L147-L156", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java", "func_name": "ObjectCache.get", "original_string": "public VALUE get(KEY key) {\n        CacheEntry<VALUE> entry;\n        synchronized (this) {\n            entry = values.get(key);\n        }\n        VALUE value;\n        if (entry != null) {\n            if (isExpiring) {\n                long age = System.currentTimeMillis() - entry.timeCreated;\n                if (age < expirationMillis) {\n                    value = getValue(key, entry);\n                } else {\n                    countExpired++;\n                    synchronized (this) {\n                        values.remove(key);\n                    }\n                    value = null;\n                }\n            } else {\n                value = getValue(key, entry);\n            }\n        } else {\n            value = null;\n        }\n        if (value != null) {\n            countHit++;\n        } else {\n            countMiss++;\n        }\n        return value;\n    }", "language": "java", "code": "public VALUE get(KEY key) {\n        CacheEntry<VALUE> entry;\n        synchronized (this) {\n            entry = values.get(key);\n        }\n        VALUE value;\n        if (entry != null) {\n            if (isExpiring) {\n                long age = System.currentTimeMillis() - entry.timeCreated;\n                if (age < expirationMillis) {\n                    value = getValue(key, entry);\n                } else {\n                    countExpired++;\n                    synchronized (this) {\n                        values.remove(key);\n                    }\n                    value = null;\n                }\n            } else {\n                value = getValue(key, entry);\n            }\n        } else {\n            value = null;\n        }\n        if (value != null) {\n            countHit++;\n        } else {\n            countMiss++;\n        }\n        return value;\n    }", "code_tokens": ["public", "VALUE", "get", "(", "KEY", "key", ")", "{", "CacheEntry", "<", "VALUE", ">", "entry", ";", "synchronized", "(", "this", ")", "{", "entry", "=", "values", ".", "get", "(", "key", ")", ";", "}", "VALUE", "value", ";", "if", "(", "entry", "!=", "null", ")", "{", "if", "(", "isExpiring", ")", "{", "long", "age", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "entry", ".", "timeCreated", ";", "if", "(", "age", "<", "expirationMillis", ")", "{", "value", "=", "getValue", "(", "key", ",", "entry", ")", ";", "}", "else", "{", "countExpired", "++", ";", "synchronized", "(", "this", ")", "{", "values", ".", "remove", "(", "key", ")", ";", "}", "value", "=", "null", ";", "}", "}", "else", "{", "value", "=", "getValue", "(", "key", ",", "entry", ")", ";", "}", "}", "else", "{", "value", "=", "null", ";", "}", "if", "(", "value", "!=", "null", ")", "{", "countHit", "++", ";", "}", "else", "{", "countMiss", "++", ";", "}", "return", "value", ";", "}"], "docstring": "Get the cached entry or null if no valid cached entry is found.", "docstring_tokens": ["Get", "the", "cached", "entry", "or", "null", "if", "no", "valid", "cached", "entry", "is", "found", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java#L159-L189", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java", "func_name": "ObjectCache.cleanUpObsoleteEntries", "original_string": "public synchronized int cleanUpObsoleteEntries() {\n        countPutCountSinceEviction = 0;\n        nextCleanUpTimestamp = 0;\n\n        int countCleaned = 0;\n        long timeLimit = isExpiring ? System.currentTimeMillis() - expirationMillis : 0;\n        Iterator<CacheEntry<VALUE>> iterator = values.values().iterator();\n        while (iterator.hasNext()) {\n            CacheEntry<VALUE> cacheEntry = iterator.next();\n            if (!isStrongReference && cacheEntry.reference == null) {\n                countRefCleared++;\n                countCleaned++;\n                iterator.remove();\n            } else if (cacheEntry.timeCreated < timeLimit) {\n                countExpired++;\n                countCleaned++;\n                iterator.remove();\n            }\n        }\n        return countCleaned;\n    }", "language": "java", "code": "public synchronized int cleanUpObsoleteEntries() {\n        countPutCountSinceEviction = 0;\n        nextCleanUpTimestamp = 0;\n\n        int countCleaned = 0;\n        long timeLimit = isExpiring ? System.currentTimeMillis() - expirationMillis : 0;\n        Iterator<CacheEntry<VALUE>> iterator = values.values().iterator();\n        while (iterator.hasNext()) {\n            CacheEntry<VALUE> cacheEntry = iterator.next();\n            if (!isStrongReference && cacheEntry.reference == null) {\n                countRefCleared++;\n                countCleaned++;\n                iterator.remove();\n            } else if (cacheEntry.timeCreated < timeLimit) {\n                countExpired++;\n                countCleaned++;\n                iterator.remove();\n            }\n        }\n        return countCleaned;\n    }", "code_tokens": ["public", "synchronized", "int", "cleanUpObsoleteEntries", "(", ")", "{", "countPutCountSinceEviction", "=", "0", ";", "nextCleanUpTimestamp", "=", "0", ";", "int", "countCleaned", "=", "0", ";", "long", "timeLimit", "=", "isExpiring", "?", "System", ".", "currentTimeMillis", "(", ")", "-", "expirationMillis", ":", "0", ";", "Iterator", "<", "CacheEntry", "<", "VALUE", ">", ">", "iterator", "=", "values", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iterator", ".", "hasNext", "(", ")", ")", "{", "CacheEntry", "<", "VALUE", ">", "cacheEntry", "=", "iterator", ".", "next", "(", ")", ";", "if", "(", "!", "isStrongReference", "&&", "cacheEntry", ".", "reference", "==", "null", ")", "{", "countRefCleared", "++", ";", "countCleaned", "++", ";", "iterator", ".", "remove", "(", ")", ";", "}", "else", "if", "(", "cacheEntry", ".", "timeCreated", "<", "timeLimit", ")", "{", "countExpired", "++", ";", "countCleaned", "++", ";", "iterator", ".", "remove", "(", ")", ";", "}", "}", "return", "countCleaned", ";", "}"], "docstring": "Iterates over all entries to check for obsolete ones (time expired or reference cleared).\n<p/>\nNote: Usually you don't need to call this method explicitly, because it is called internally in certain\nconditions when space has to be reclaimed.", "docstring_tokens": ["Iterates", "over", "all", "entries", "to", "check", "for", "obsolete", "ones", "(", "time", "expired", "or", "reference", "cleared", ")", ".", "<p", "/", ">", "Note", ":", "Usually", "you", "don", "t", "need", "to", "call", "this", "method", "explicitly", "because", "it", "is", "called", "internally", "in", "certain", "conditions", "when", "space", "has", "to", "be", "reclaimed", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/ObjectCache.java#L234-L254", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/hash/PrimitiveDataChecksum.java", "func_name": "PrimitiveDataChecksum.updateUtf8", "original_string": "public void updateUtf8(String string) {\n        if (string != null) {\n            byte[] bytes;\n            try {\n                bytes = string.getBytes(\"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            update(bytes, 0, bytes.length);\n        }\n    }", "language": "java", "code": "public void updateUtf8(String string) {\n        if (string != null) {\n            byte[] bytes;\n            try {\n                bytes = string.getBytes(\"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            update(bytes, 0, bytes.length);\n        }\n    }", "code_tokens": ["public", "void", "updateUtf8", "(", "String", "string", ")", "{", "if", "(", "string", "!=", "null", ")", "{", "byte", "[", "]", "bytes", ";", "try", "{", "bytes", "=", "string", ".", "getBytes", "(", "\"UTF-8\"", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "update", "(", "bytes", ",", "0", ",", "bytes", ".", "length", ")", ";", "}", "}"], "docstring": "Note: leaves the checksum untouched if given value is null (provide a special value for stronger hashing).", "docstring_tokens": ["Note", ":", "leaves", "the", "checksum", "untouched", "if", "given", "value", "is", "null", "(", "provide", "a", "special", "value", "for", "stronger", "hashing", ")", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/hash/PrimitiveDataChecksum.java#L51-L61", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/hash/PrimitiveDataChecksum.java", "func_name": "PrimitiveDataChecksum.updateUtf8", "original_string": "public void updateUtf8(String[] strings) {\n        if (strings != null) {\n            for (String string : strings) {\n                updateUtf8(string);\n            }\n        }\n    }", "language": "java", "code": "public void updateUtf8(String[] strings) {\n        if (strings != null) {\n            for (String string : strings) {\n                updateUtf8(string);\n            }\n        }\n    }", "code_tokens": ["public", "void", "updateUtf8", "(", "String", "[", "]", "strings", ")", "{", "if", "(", "strings", "!=", "null", ")", "{", "for", "(", "String", "string", ":", "strings", ")", "{", "updateUtf8", "(", "string", ")", ";", "}", "}", "}"], "docstring": "Note: leaves the checksum untouched if given value is null (provide a special value for stronger hashing).", "docstring_tokens": ["Note", ":", "leaves", "the", "checksum", "untouched", "if", "given", "value", "is", "null", "(", "provide", "a", "special", "value", "for", "stronger", "hashing", ")", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/hash/PrimitiveDataChecksum.java#L64-L70", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/hash/Murmur3F.java", "func_name": "Murmur3F.updateLongLE", "original_string": "public void updateLongLE(long value) {\n        finished = false;\n        switch (partialPos) {\n            case 0:\n                partialK1 = value;\n                break;\n            case 8:\n                partialK2 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Cannot mix long with other alignments than 8: \" + partialPos);\n        }\n\n        partialPos += 8;\n        if (partialPos == 16) {\n            applyKs(partialK1, partialK2);\n            partialPos = 0;\n        }\n        length += 8;\n    }", "language": "java", "code": "public void updateLongLE(long value) {\n        finished = false;\n        switch (partialPos) {\n            case 0:\n                partialK1 = value;\n                break;\n            case 8:\n                partialK2 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Cannot mix long with other alignments than 8: \" + partialPos);\n        }\n\n        partialPos += 8;\n        if (partialPos == 16) {\n            applyKs(partialK1, partialK2);\n            partialPos = 0;\n        }\n        length += 8;\n    }", "code_tokens": ["public", "void", "updateLongLE", "(", "long", "value", ")", "{", "finished", "=", "false", ";", "switch", "(", "partialPos", ")", "{", "case", "0", ":", "partialK1", "=", "value", ";", "break", ";", "case", "8", ":", "partialK2", "=", "value", ";", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"Cannot mix long with other alignments than 8: \"", "+", "partialPos", ")", ";", "}", "partialPos", "+=", "8", ";", "if", "(", "partialPos", "==", "16", ")", "{", "applyKs", "(", "partialK1", ",", "partialK2", ")", ";", "partialPos", "=", "0", ";", "}", "length", "+=", "8", ";", "}"], "docstring": "Special update method to hash long values very efficiently using Java's native little endian (LE) byte order.\nNote, that you cannot mix this with other (previous) hash updates, because it only supports 8-bytes alignment.", "docstring_tokens": ["Special", "update", "method", "to", "hash", "long", "values", "very", "efficiently", "using", "Java", "s", "native", "little", "endian", "(", "LE", ")", "byte", "order", ".", "Note", "that", "you", "cannot", "mix", "this", "with", "other", "(", "previous", ")", "hash", "updates", "because", "it", "only", "supports", "8", "-", "bytes", "alignment", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/hash/Murmur3F.java#L119-L138", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/IoUtils.java", "func_name": "IoUtils.copyAllBytes", "original_string": "public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {\n        int byteCount = 0;\n        byte[] buffer = new byte[BUFFER_SIZE];\n        while (true) {\n            int read = in.read(buffer);\n            if (read == -1) {\n                break;\n            }\n            out.write(buffer, 0, read);\n            byteCount += read;\n        }\n        return byteCount;\n    }", "language": "java", "code": "public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {\n        int byteCount = 0;\n        byte[] buffer = new byte[BUFFER_SIZE];\n        while (true) {\n            int read = in.read(buffer);\n            if (read == -1) {\n                break;\n            }\n            out.write(buffer, 0, read);\n            byteCount += read;\n        }\n        return byteCount;\n    }", "code_tokens": ["public", "static", "int", "copyAllBytes", "(", "InputStream", "in", ",", "OutputStream", "out", ")", "throws", "IOException", "{", "int", "byteCount", "=", "0", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "BUFFER_SIZE", "]", ";", "while", "(", "true", ")", "{", "int", "read", "=", "in", ".", "read", "(", "buffer", ")", ";", "if", "(", "read", "==", "-", "1", ")", "{", "break", ";", "}", "out", ".", "write", "(", "buffer", ",", "0", ",", "read", ")", ";", "byteCount", "+=", "read", ";", "}", "return", "byteCount", ";", "}"], "docstring": "Copies all available data from in to out without closing any stream.\n\n@return number of bytes copied", "docstring_tokens": ["Copies", "all", "available", "data", "from", "in", "to", "out", "without", "closing", "any", "stream", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/IoUtils.java#L130-L142", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java", "func_name": "CircularByteBuffer.get", "original_string": "public synchronized int get() {\n        if (available == 0) {\n            return -1;\n        }\n        byte value = buffer[idxGet];\n        idxGet = (idxGet + 1) % capacity;\n        available--;\n        return value;\n    }", "language": "java", "code": "public synchronized int get() {\n        if (available == 0) {\n            return -1;\n        }\n        byte value = buffer[idxGet];\n        idxGet = (idxGet + 1) % capacity;\n        available--;\n        return value;\n    }", "code_tokens": ["public", "synchronized", "int", "get", "(", ")", "{", "if", "(", "available", "==", "0", ")", "{", "return", "-", "1", ";", "}", "byte", "value", "=", "buffer", "[", "idxGet", "]", ";", "idxGet", "=", "(", "idxGet", "+", "1", ")", "%", "capacity", ";", "available", "--", ";", "return", "value", ";", "}"], "docstring": "Gets a single byte return or -1 if no data is available.", "docstring_tokens": ["Gets", "a", "single", "byte", "return", "or", "-", "1", "if", "no", "data", "is", "available", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java#L56-L64", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java", "func_name": "CircularByteBuffer.get", "original_string": "public synchronized int get(byte[] dst, int off, int len) {\n        if (available == 0) {\n            return 0;\n        }\n\n        // limit is last index to read + 1\n        int limit = idxGet < idxPut ? idxPut : capacity;\n        int count = Math.min(limit - idxGet, len);\n        System.arraycopy(buffer, idxGet, dst, off, count);\n        idxGet += count;\n\n        if (idxGet == capacity) {\n            // Array end reached, check if we have more\n            int count2 = Math.min(len - count, idxPut);\n            if (count2 > 0) {\n                System.arraycopy(buffer, 0, dst, off + count, count2);\n                idxGet = count2;\n                count += count2;\n            } else {\n                idxGet = 0;\n            }\n        }\n        available -= count;\n        return count;\n    }", "language": "java", "code": "public synchronized int get(byte[] dst, int off, int len) {\n        if (available == 0) {\n            return 0;\n        }\n\n        // limit is last index to read + 1\n        int limit = idxGet < idxPut ? idxPut : capacity;\n        int count = Math.min(limit - idxGet, len);\n        System.arraycopy(buffer, idxGet, dst, off, count);\n        idxGet += count;\n\n        if (idxGet == capacity) {\n            // Array end reached, check if we have more\n            int count2 = Math.min(len - count, idxPut);\n            if (count2 > 0) {\n                System.arraycopy(buffer, 0, dst, off + count, count2);\n                idxGet = count2;\n                count += count2;\n            } else {\n                idxGet = 0;\n            }\n        }\n        available -= count;\n        return count;\n    }", "code_tokens": ["public", "synchronized", "int", "get", "(", "byte", "[", "]", "dst", ",", "int", "off", ",", "int", "len", ")", "{", "if", "(", "available", "==", "0", ")", "{", "return", "0", ";", "}", "// limit is last index to read + 1", "int", "limit", "=", "idxGet", "<", "idxPut", "?", "idxPut", ":", "capacity", ";", "int", "count", "=", "Math", ".", "min", "(", "limit", "-", "idxGet", ",", "len", ")", ";", "System", ".", "arraycopy", "(", "buffer", ",", "idxGet", ",", "dst", ",", "off", ",", "count", ")", ";", "idxGet", "+=", "count", ";", "if", "(", "idxGet", "==", "capacity", ")", "{", "// Array end reached, check if we have more", "int", "count2", "=", "Math", ".", "min", "(", "len", "-", "count", ",", "idxPut", ")", ";", "if", "(", "count2", ">", "0", ")", "{", "System", ".", "arraycopy", "(", "buffer", ",", "0", ",", "dst", ",", "off", "+", "count", ",", "count2", ")", ";", "idxGet", "=", "count2", ";", "count", "+=", "count2", ";", "}", "else", "{", "idxGet", "=", "0", ";", "}", "}", "available", "-=", "count", ";", "return", "count", ";", "}"], "docstring": "Gets as many of the requested bytes as available from this buffer.\n\n@return number of bytes actually got from this buffer (0 if no bytes are available)", "docstring_tokens": ["Gets", "as", "many", "of", "the", "requested", "bytes", "as", "available", "from", "this", "buffer", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java#L80-L104", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java", "func_name": "CircularByteBuffer.put", "original_string": "public synchronized boolean put(byte value) {\n        if (available == capacity) {\n            return false;\n        }\n        buffer[idxPut] = value;\n        idxPut = (idxPut + 1) % capacity;\n        available++;\n        return true;\n    }", "language": "java", "code": "public synchronized boolean put(byte value) {\n        if (available == capacity) {\n            return false;\n        }\n        buffer[idxPut] = value;\n        idxPut = (idxPut + 1) % capacity;\n        available++;\n        return true;\n    }", "code_tokens": ["public", "synchronized", "boolean", "put", "(", "byte", "value", ")", "{", "if", "(", "available", "==", "capacity", ")", "{", "return", "false", ";", "}", "buffer", "[", "idxPut", "]", "=", "value", ";", "idxPut", "=", "(", "idxPut", "+", "1", ")", "%", "capacity", ";", "available", "++", ";", "return", "true", ";", "}"], "docstring": "Puts a single byte if the buffer is not yet full.\n\n@return true if the byte was put, or false if the buffer is full", "docstring_tokens": ["Puts", "a", "single", "byte", "if", "the", "buffer", "is", "not", "yet", "full", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java#L112-L120", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java", "func_name": "CircularByteBuffer.put", "original_string": "public synchronized int put(byte[] src, int off, int len) {\n        if (available == capacity) {\n            return 0;\n        }\n\n        // limit is last index to put + 1\n        int limit = idxPut < idxGet ? idxGet : capacity;\n        int count = Math.min(limit - idxPut, len);\n        System.arraycopy(src, off, buffer, idxPut, count);\n        idxPut += count;\n\n        if (idxPut == capacity) {\n            // Array end reached, check if we have more\n            int count2 = Math.min(len - count, idxGet);\n            if (count2 > 0) {\n                System.arraycopy(src, off + count, buffer, 0, count2);\n                idxPut = count2;\n                count += count2;\n            } else {\n                idxPut = 0;\n            }\n        }\n        available += count;\n        return count;\n    }", "language": "java", "code": "public synchronized int put(byte[] src, int off, int len) {\n        if (available == capacity) {\n            return 0;\n        }\n\n        // limit is last index to put + 1\n        int limit = idxPut < idxGet ? idxGet : capacity;\n        int count = Math.min(limit - idxPut, len);\n        System.arraycopy(src, off, buffer, idxPut, count);\n        idxPut += count;\n\n        if (idxPut == capacity) {\n            // Array end reached, check if we have more\n            int count2 = Math.min(len - count, idxGet);\n            if (count2 > 0) {\n                System.arraycopy(src, off + count, buffer, 0, count2);\n                idxPut = count2;\n                count += count2;\n            } else {\n                idxPut = 0;\n            }\n        }\n        available += count;\n        return count;\n    }", "code_tokens": ["public", "synchronized", "int", "put", "(", "byte", "[", "]", "src", ",", "int", "off", ",", "int", "len", ")", "{", "if", "(", "available", "==", "capacity", ")", "{", "return", "0", ";", "}", "// limit is last index to put + 1", "int", "limit", "=", "idxPut", "<", "idxGet", "?", "idxGet", ":", "capacity", ";", "int", "count", "=", "Math", ".", "min", "(", "limit", "-", "idxPut", ",", "len", ")", ";", "System", ".", "arraycopy", "(", "src", ",", "off", ",", "buffer", ",", "idxPut", ",", "count", ")", ";", "idxPut", "+=", "count", ";", "if", "(", "idxPut", "==", "capacity", ")", "{", "// Array end reached, check if we have more", "int", "count2", "=", "Math", ".", "min", "(", "len", "-", "count", ",", "idxGet", ")", ";", "if", "(", "count2", ">", "0", ")", "{", "System", ".", "arraycopy", "(", "src", ",", "off", "+", "count", ",", "buffer", ",", "0", ",", "count2", ")", ";", "idxPut", "=", "count2", ";", "count", "+=", "count2", ";", "}", "else", "{", "idxPut", "=", "0", ";", "}", "}", "available", "+=", "count", ";", "return", "count", ";", "}"], "docstring": "Puts as many of the given bytes as possible into this buffer.\n\n@return number of bytes actually put into this buffer (0 if the buffer is full)", "docstring_tokens": ["Puts", "as", "many", "of", "the", "given", "bytes", "as", "possible", "into", "this", "buffer", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java#L136-L160", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java", "func_name": "CircularByteBuffer.skip", "original_string": "public synchronized int skip(int count) {\n        if (count > available) {\n            count = available;\n        }\n        idxGet = (idxGet + count) % capacity;\n        available -= count;\n        return count;\n    }", "language": "java", "code": "public synchronized int skip(int count) {\n        if (count > available) {\n            count = available;\n        }\n        idxGet = (idxGet + count) % capacity;\n        available -= count;\n        return count;\n    }", "code_tokens": ["public", "synchronized", "int", "skip", "(", "int", "count", ")", "{", "if", "(", "count", ">", "available", ")", "{", "count", "=", "available", ";", "}", "idxGet", "=", "(", "idxGet", "+", "count", ")", "%", "capacity", ";", "available", "-=", "count", ";", "return", "count", ";", "}"], "docstring": "Skips the given count of bytes, but at most the currently available count.\n\n@return number of bytes actually skipped from this buffer (0 if no bytes are available)", "docstring_tokens": ["Skips", "the", "given", "count", "of", "bytes", "but", "at", "most", "the", "currently", "available", "count", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/CircularByteBuffer.java#L174-L181", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java", "func_name": "FileUtils.copyFile", "original_string": "public static void copyFile(File from, File to) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(from));\n        try {\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(to));\n            try {\n                IoUtils.copyAllBytes(in, out);\n            } finally {\n                IoUtils.safeClose(out);\n            }\n        } finally {\n            IoUtils.safeClose(in);\n        }\n    }", "language": "java", "code": "public static void copyFile(File from, File to) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(from));\n        try {\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(to));\n            try {\n                IoUtils.copyAllBytes(in, out);\n            } finally {\n                IoUtils.safeClose(out);\n            }\n        } finally {\n            IoUtils.safeClose(in);\n        }\n    }", "code_tokens": ["public", "static", "void", "copyFile", "(", "File", "from", ",", "File", "to", ")", "throws", "IOException", "{", "InputStream", "in", "=", "new", "BufferedInputStream", "(", "new", "FileInputStream", "(", "from", ")", ")", ";", "try", "{", "OutputStream", "out", "=", "new", "BufferedOutputStream", "(", "new", "FileOutputStream", "(", "to", ")", ")", ";", "try", "{", "IoUtils", ".", "copyAllBytes", "(", "in", ",", "out", ")", ";", "}", "finally", "{", "IoUtils", ".", "safeClose", "(", "out", ")", ";", "}", "}", "finally", "{", "IoUtils", ".", "safeClose", "(", "in", ")", ";", "}", "}"], "docstring": "Copies a file to another location.", "docstring_tokens": ["Copies", "a", "file", "to", "another", "location", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java#L79-L91", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java", "func_name": "FileUtils.copyFile", "original_string": "public static void copyFile(String fromFilename, String toFilename) throws IOException {\n        copyFile(new File(fromFilename), new File(toFilename));\n    }", "language": "java", "code": "public static void copyFile(String fromFilename, String toFilename) throws IOException {\n        copyFile(new File(fromFilename), new File(toFilename));\n    }", "code_tokens": ["public", "static", "void", "copyFile", "(", "String", "fromFilename", ",", "String", "toFilename", ")", "throws", "IOException", "{", "copyFile", "(", "new", "File", "(", "fromFilename", ")", ",", "new", "File", "(", "toFilename", ")", ")", ";", "}"], "docstring": "Copies a file to another location.", "docstring_tokens": ["Copies", "a", "file", "to", "another", "location", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java#L94-L96", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java", "func_name": "FileUtils.readObject", "original_string": "public static Object readObject(File file) throws IOException,\n            ClassNotFoundException {\n        FileInputStream fileIn = new FileInputStream(file);\n        ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(fileIn));\n        try {\n            return in.readObject();\n        } finally {\n            IoUtils.safeClose(in);\n        }\n    }", "language": "java", "code": "public static Object readObject(File file) throws IOException,\n            ClassNotFoundException {\n        FileInputStream fileIn = new FileInputStream(file);\n        ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(fileIn));\n        try {\n            return in.readObject();\n        } finally {\n            IoUtils.safeClose(in);\n        }\n    }", "code_tokens": ["public", "static", "Object", "readObject", "(", "File", "file", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "FileInputStream", "fileIn", "=", "new", "FileInputStream", "(", "file", ")", ";", "ObjectInputStream", "in", "=", "new", "ObjectInputStream", "(", "new", "BufferedInputStream", "(", "fileIn", ")", ")", ";", "try", "{", "return", "in", ".", "readObject", "(", ")", ";", "}", "finally", "{", "IoUtils", ".", "safeClose", "(", "in", ")", ";", "}", "}"], "docstring": "To read an object in a quick & dirty way. Prepare to handle failures when object serialization changes!", "docstring_tokens": ["To", "read", "an", "object", "in", "a", "quick", "&", "dirty", "way", ".", "Prepare", "to", "handle", "failures", "when", "object", "serialization", "changes!"], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java#L99-L108", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java", "func_name": "FileUtils.writeObject", "original_string": "public static void writeObject(File file, Object object) throws IOException {\n        FileOutputStream fileOut = new FileOutputStream(file);\n        ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(fileOut));\n        try {\n            out.writeObject(object);\n            out.flush();\n            // Force sync\n            fileOut.getFD().sync();\n        } finally {\n            IoUtils.safeClose(out);\n        }\n    }", "language": "java", "code": "public static void writeObject(File file, Object object) throws IOException {\n        FileOutputStream fileOut = new FileOutputStream(file);\n        ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(fileOut));\n        try {\n            out.writeObject(object);\n            out.flush();\n            // Force sync\n            fileOut.getFD().sync();\n        } finally {\n            IoUtils.safeClose(out);\n        }\n    }", "code_tokens": ["public", "static", "void", "writeObject", "(", "File", "file", ",", "Object", "object", ")", "throws", "IOException", "{", "FileOutputStream", "fileOut", "=", "new", "FileOutputStream", "(", "file", ")", ";", "ObjectOutputStream", "out", "=", "new", "ObjectOutputStream", "(", "new", "BufferedOutputStream", "(", "fileOut", ")", ")", ";", "try", "{", "out", ".", "writeObject", "(", "object", ")", ";", "out", ".", "flush", "(", ")", ";", "// Force sync", "fileOut", ".", "getFD", "(", ")", ".", "sync", "(", ")", ";", "}", "finally", "{", "IoUtils", ".", "safeClose", "(", "out", ")", ";", "}", "}"], "docstring": "To store an object in a quick & dirty way.", "docstring_tokens": ["To", "store", "an", "object", "in", "a", "quick", "&", "dirty", "way", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java#L111-L122", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java", "func_name": "FileUtils.deleteDirRecursive", "original_string": "public static void deleteDirRecursive(File dir) throws IOException {\n        File failed = deleteDirRecursiveInternal(dir, true);\n        if (failed != null) {\n            throw new IOException(\"Could not delete file: \" + failed.getPath());\n        }\n    }", "language": "java", "code": "public static void deleteDirRecursive(File dir) throws IOException {\n        File failed = deleteDirRecursiveInternal(dir, true);\n        if (failed != null) {\n            throw new IOException(\"Could not delete file: \" + failed.getPath());\n        }\n    }", "code_tokens": ["public", "static", "void", "deleteDirRecursive", "(", "File", "dir", ")", "throws", "IOException", "{", "File", "failed", "=", "deleteDirRecursiveInternal", "(", "dir", ",", "true", ")", ";", "if", "(", "failed", "!=", "null", ")", "{", "throw", "new", "IOException", "(", "\"Could not delete file: \"", "+", "failed", ".", "getPath", "(", ")", ")", ";", "}", "}"], "docstring": "Deletes all files within the given directory recursively (including subdirectories).\nThis method fails fast with an IOException on the first file that could not be deleted.", "docstring_tokens": ["Deletes", "all", "files", "within", "the", "given", "directory", "recursively", "(", "including", "subdirectories", ")", ".", "This", "method", "fails", "fast", "with", "an", "IOException", "on", "the", "first", "file", "that", "could", "not", "be", "deleted", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/io/FileUtils.java#L157-L162", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/DateUtils.java", "func_name": "DateUtils.setTime", "original_string": "public static void setTime(Calendar calendar, int hourOfDay, int minute, int second, int millisecond) {\n        calendar.set(Calendar.HOUR_OF_DAY, hourOfDay);\n        calendar.set(Calendar.MINUTE, minute);\n        calendar.set(Calendar.SECOND, second);\n        calendar.set(Calendar.MILLISECOND, millisecond);\n    }", "language": "java", "code": "public static void setTime(Calendar calendar, int hourOfDay, int minute, int second, int millisecond) {\n        calendar.set(Calendar.HOUR_OF_DAY, hourOfDay);\n        calendar.set(Calendar.MINUTE, minute);\n        calendar.set(Calendar.SECOND, second);\n        calendar.set(Calendar.MILLISECOND, millisecond);\n    }", "code_tokens": ["public", "static", "void", "setTime", "(", "Calendar", "calendar", ",", "int", "hourOfDay", ",", "int", "minute", ",", "int", "second", ",", "int", "millisecond", ")", "{", "calendar", ".", "set", "(", "Calendar", ".", "HOUR_OF_DAY", ",", "hourOfDay", ")", ";", "calendar", ".", "set", "(", "Calendar", ".", "MINUTE", ",", "minute", ")", ";", "calendar", ".", "set", "(", "Calendar", ".", "SECOND", ",", "second", ")", ";", "calendar", ".", "set", "(", "Calendar", ".", "MILLISECOND", ",", "millisecond", ")", ";", "}"], "docstring": "Sets hour, minutes, seconds and milliseconds to the given values. Leaves date info untouched.", "docstring_tokens": ["Sets", "hour", "minutes", "seconds", "and", "milliseconds", "to", "the", "given", "values", ".", "Leaves", "date", "info", "untouched", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/DateUtils.java#L51-L56", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/DateUtils.java", "func_name": "DateUtils.getDayAsReadableInt", "original_string": "public static int getDayAsReadableInt(long time) {\n        Calendar cal = calendarThreadLocal.get();\n        cal.setTimeInMillis(time);\n        return getDayAsReadableInt(cal);\n    }", "language": "java", "code": "public static int getDayAsReadableInt(long time) {\n        Calendar cal = calendarThreadLocal.get();\n        cal.setTimeInMillis(time);\n        return getDayAsReadableInt(cal);\n    }", "code_tokens": ["public", "static", "int", "getDayAsReadableInt", "(", "long", "time", ")", "{", "Calendar", "cal", "=", "calendarThreadLocal", ".", "get", "(", ")", ";", "cal", ".", "setTimeInMillis", "(", "time", ")", ";", "return", "getDayAsReadableInt", "(", "cal", ")", ";", "}"], "docstring": "Readable yyyyMMdd int representation of a day, which is also sortable.", "docstring_tokens": ["Readable", "yyyyMMdd", "int", "representation", "of", "a", "day", "which", "is", "also", "sortable", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/DateUtils.java#L59-L63", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/DateUtils.java", "func_name": "DateUtils.getDayAsReadableInt", "original_string": "public static int getDayAsReadableInt(Calendar calendar) {\n        int day = calendar.get(Calendar.DAY_OF_MONTH);\n        int month = calendar.get(Calendar.MONTH) + 1;\n        int year = calendar.get(Calendar.YEAR);\n        return year * 10000 + month * 100 + day;\n    }", "language": "java", "code": "public static int getDayAsReadableInt(Calendar calendar) {\n        int day = calendar.get(Calendar.DAY_OF_MONTH);\n        int month = calendar.get(Calendar.MONTH) + 1;\n        int year = calendar.get(Calendar.YEAR);\n        return year * 10000 + month * 100 + day;\n    }", "code_tokens": ["public", "static", "int", "getDayAsReadableInt", "(", "Calendar", "calendar", ")", "{", "int", "day", "=", "calendar", ".", "get", "(", "Calendar", ".", "DAY_OF_MONTH", ")", ";", "int", "month", "=", "calendar", ".", "get", "(", "Calendar", ".", "MONTH", ")", "+", "1", ";", "int", "year", "=", "calendar", ".", "get", "(", "Calendar", ".", "YEAR", ")", ";", "return", "year", "*", "10000", "+", "month", "*", "100", "+", "day", ";", "}"], "docstring": "Readable yyyyMMdd representation of a day, which is also sortable.", "docstring_tokens": ["Readable", "yyyyMMdd", "representation", "of", "a", "day", "which", "is", "also", "sortable", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/DateUtils.java#L66-L71", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.split", "original_string": "public static String[] split(String string, char delimiter) {\n        int delimeterCount = 0;\n        int start = 0;\n        int end;\n        while ((end = string.indexOf(delimiter, start)) != -1) {\n            delimeterCount++;\n            start = end + 1;\n        }\n\n        String[] result = new String[delimeterCount + 1];\n        start = 0;\n        for (int i = 0; i < delimeterCount; i++) {\n            end = string.indexOf(delimiter, start);\n            result[i] = string.substring(start, end);\n            start = end + 1;\n        }\n        result[delimeterCount] = string.substring(start, string.length());\n        return result;\n    }", "language": "java", "code": "public static String[] split(String string, char delimiter) {\n        int delimeterCount = 0;\n        int start = 0;\n        int end;\n        while ((end = string.indexOf(delimiter, start)) != -1) {\n            delimeterCount++;\n            start = end + 1;\n        }\n\n        String[] result = new String[delimeterCount + 1];\n        start = 0;\n        for (int i = 0; i < delimeterCount; i++) {\n            end = string.indexOf(delimiter, start);\n            result[i] = string.substring(start, end);\n            start = end + 1;\n        }\n        result[delimeterCount] = string.substring(start, string.length());\n        return result;\n    }", "code_tokens": ["public", "static", "String", "[", "]", "split", "(", "String", "string", ",", "char", "delimiter", ")", "{", "int", "delimeterCount", "=", "0", ";", "int", "start", "=", "0", ";", "int", "end", ";", "while", "(", "(", "end", "=", "string", ".", "indexOf", "(", "delimiter", ",", "start", ")", ")", "!=", "-", "1", ")", "{", "delimeterCount", "++", ";", "start", "=", "end", "+", "1", ";", "}", "String", "[", "]", "result", "=", "new", "String", "[", "delimeterCount", "+", "1", "]", ";", "start", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "delimeterCount", ";", "i", "++", ")", "{", "end", "=", "string", ".", "indexOf", "(", "delimiter", ",", "start", ")", ";", "result", "[", "i", "]", "=", "string", ".", "substring", "(", "start", ",", "end", ")", ";", "start", "=", "end", "+", "1", ";", "}", "result", "[", "delimeterCount", "]", "=", "string", ".", "substring", "(", "start", ",", "string", ".", "length", "(", ")", ")", ";", "return", "result", ";", "}"], "docstring": "Splits a String based on a single character, which is usually faster than regex-based String.split().\nNOTE: split(\"AA;BB;;\", ';') == [\"AA\", \"BB\", \"\", \"\"], this may be different from String.split()", "docstring_tokens": ["Splits", "a", "String", "based", "on", "a", "single", "character", "which", "is", "usually", "faster", "than", "regex", "-", "based", "String", ".", "split", "()", ".", "NOTE", ":", "split", "(", "AA", ";", "BB", ";;", ";", ")", "==", "[", "AA", "BB", "]", "this", "may", "be", "different", "from", "String", ".", "split", "()"], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L43-L61", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.encodeUrl", "original_string": "public static String encodeUrl(String stringToEncode) {\n        try {\n            return URLEncoder.encode(stringToEncode, \"UTF-8\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "language": "java", "code": "public static String encodeUrl(String stringToEncode) {\n        try {\n            return URLEncoder.encode(stringToEncode, \"UTF-8\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "code_tokens": ["public", "static", "String", "encodeUrl", "(", "String", "stringToEncode", ")", "{", "try", "{", "return", "URLEncoder", ".", "encode", "(", "stringToEncode", ",", "\"UTF-8\"", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "e1", ")", ";", "}", "}"], "docstring": "URL-Encodes a given string using UTF-8 (some web pages have problems with UTF-8 and umlauts, consider\n{@link #encodeUrlIso(String)} also). No UnsupportedEncodingException to handle as it is dealt with in this\nmethod.", "docstring_tokens": ["URL", "-", "Encodes", "a", "given", "string", "using", "UTF", "-", "8", "(", "some", "web", "pages", "have", "problems", "with", "UTF", "-", "8", "and", "umlauts", "consider", "{"], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L68-L74", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.encodeUrlIso", "original_string": "public static String encodeUrlIso(String stringToEncode) {\n        try {\n            return URLEncoder.encode(stringToEncode, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "language": "java", "code": "public static String encodeUrlIso(String stringToEncode) {\n        try {\n            return URLEncoder.encode(stringToEncode, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "code_tokens": ["public", "static", "String", "encodeUrlIso", "(", "String", "stringToEncode", ")", "{", "try", "{", "return", "URLEncoder", ".", "encode", "(", "stringToEncode", ",", "\"ISO-8859-1\"", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "e1", ")", ";", "}", "}"], "docstring": "URL-encodes a given string using ISO-8859-1, which may work better with web pages and umlauts compared to UTF-8.\nNo UnsupportedEncodingException to handle as it is dealt with in this method.", "docstring_tokens": ["URL", "-", "encodes", "a", "given", "string", "using", "ISO", "-", "8859", "-", "1", "which", "may", "work", "better", "with", "web", "pages", "and", "umlauts", "compared", "to", "UTF", "-", "8", ".", "No", "UnsupportedEncodingException", "to", "handle", "as", "it", "is", "dealt", "with", "in", "this", "method", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L80-L86", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.decodeUrl", "original_string": "public static String decodeUrl(String stringToDecode) {\n        try {\n            return URLDecoder.decode(stringToDecode, \"UTF-8\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "language": "java", "code": "public static String decodeUrl(String stringToDecode) {\n        try {\n            return URLDecoder.decode(stringToDecode, \"UTF-8\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "code_tokens": ["public", "static", "String", "decodeUrl", "(", "String", "stringToDecode", ")", "{", "try", "{", "return", "URLDecoder", ".", "decode", "(", "stringToDecode", ",", "\"UTF-8\"", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "e1", ")", ";", "}", "}"], "docstring": "URL-Decodes a given string using UTF-8. No UnsupportedEncodingException to handle as it is dealt with in this\nmethod.", "docstring_tokens": ["URL", "-", "Decodes", "a", "given", "string", "using", "UTF", "-", "8", ".", "No", "UnsupportedEncodingException", "to", "handle", "as", "it", "is", "dealt", "with", "in", "this", "method", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L92-L98", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.decodeUrlIso", "original_string": "public static String decodeUrlIso(String stringToDecode) {\n        try {\n            return URLDecoder.decode(stringToDecode, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "language": "java", "code": "public static String decodeUrlIso(String stringToDecode) {\n        try {\n            return URLDecoder.decode(stringToDecode, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e1) {\n            throw new RuntimeException(e1);\n        }\n    }", "code_tokens": ["public", "static", "String", "decodeUrlIso", "(", "String", "stringToDecode", ")", "{", "try", "{", "return", "URLDecoder", ".", "decode", "(", "stringToDecode", ",", "\"ISO-8859-1\"", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "e1", ")", ";", "}", "}"], "docstring": "URL-Decodes a given string using ISO-8859-1. No UnsupportedEncodingException to handle as it is dealt with in\nthis method.", "docstring_tokens": ["URL", "-", "Decodes", "a", "given", "string", "using", "ISO", "-", "8859", "-", "1", ".", "No", "UnsupportedEncodingException", "to", "handle", "as", "it", "is", "dealt", "with", "in", "this", "method", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L104-L110", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.digest", "original_string": "public static String digest(String string, String digestAlgo, String encoding) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(digestAlgo);\n            digester.update(string.getBytes(encoding));\n            return hex(digester.digest());\n        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }", "language": "java", "code": "public static String digest(String string, String digestAlgo, String encoding) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(digestAlgo);\n            digester.update(string.getBytes(encoding));\n            return hex(digester.digest());\n        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }", "code_tokens": ["public", "static", "String", "digest", "(", "String", "string", ",", "String", "digestAlgo", ",", "String", "encoding", ")", "{", "try", "{", "MessageDigest", "digester", "=", "MessageDigest", ".", "getInstance", "(", "digestAlgo", ")", ";", "digester", ".", "update", "(", "string", ".", "getBytes", "(", "encoding", ")", ")", ";", "return", "hex", "(", "digester", ".", "digest", "(", ")", ")", ";", "}", "catch", "(", "NoSuchAlgorithmException", "|", "UnsupportedEncodingException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}"], "docstring": "Generates a digest (hex string) for the given string", "docstring_tokens": ["Generates", "a", "digest", "(", "hex", "string", ")", "for", "the", "given", "string"], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L132-L140", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.resolveEntity", "original_string": "public static String resolveEntity(String entity) {\n        if (entity.length() > 1 && entity.charAt(0) == '#') {\n            if (entity.charAt(1) == 'x') {\n                return String.valueOf((char) Integer.parseInt(entity.substring(2), 16));\n            } else {\n                return String.valueOf((char) Integer.parseInt(entity.substring(1)));\n            }\n        } else if (entity.equals(\"apos\")) {\n            return \"'\";\n        } else if (entity.equals(\"quot\")) {\n            return \"\\\"\";\n        } else if (entity.equals(\"gt\")) {\n            return \">\";\n        } else if (entity.equals(\"lt\")) {\n            return \"<\";\n        } else if (entity.equals(\"amp\")) {\n            return \"&\";\n        } else {\n            return entity;\n        }\n    }", "language": "java", "code": "public static String resolveEntity(String entity) {\n        if (entity.length() > 1 && entity.charAt(0) == '#') {\n            if (entity.charAt(1) == 'x') {\n                return String.valueOf((char) Integer.parseInt(entity.substring(2), 16));\n            } else {\n                return String.valueOf((char) Integer.parseInt(entity.substring(1)));\n            }\n        } else if (entity.equals(\"apos\")) {\n            return \"'\";\n        } else if (entity.equals(\"quot\")) {\n            return \"\\\"\";\n        } else if (entity.equals(\"gt\")) {\n            return \">\";\n        } else if (entity.equals(\"lt\")) {\n            return \"<\";\n        } else if (entity.equals(\"amp\")) {\n            return \"&\";\n        } else {\n            return entity;\n        }\n    }", "code_tokens": ["public", "static", "String", "resolveEntity", "(", "String", "entity", ")", "{", "if", "(", "entity", ".", "length", "(", ")", ">", "1", "&&", "entity", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "if", "(", "entity", ".", "charAt", "(", "1", ")", "==", "'", "'", ")", "{", "return", "String", ".", "valueOf", "(", "(", "char", ")", "Integer", ".", "parseInt", "(", "entity", ".", "substring", "(", "2", ")", ",", "16", ")", ")", ";", "}", "else", "{", "return", "String", ".", "valueOf", "(", "(", "char", ")", "Integer", ".", "parseInt", "(", "entity", ".", "substring", "(", "1", ")", ")", ")", ";", "}", "}", "else", "if", "(", "entity", ".", "equals", "(", "\"apos\"", ")", ")", "{", "return", "\"'\"", ";", "}", "else", "if", "(", "entity", ".", "equals", "(", "\"quot\"", ")", ")", "{", "return", "\"\\\"\"", ";", "}", "else", "if", "(", "entity", ".", "equals", "(", "\"gt\"", ")", ")", "{", "return", "\">\"", ";", "}", "else", "if", "(", "entity", ".", "equals", "(", "\"lt\"", ")", ")", "{", "return", "\"<\"", ";", "}", "else", "if", "(", "entity", ".", "equals", "(", "\"amp\"", ")", ")", "{", "return", "\"&\"", ";", "}", "else", "{", "return", "entity", ";", "}", "}"], "docstring": "Simple HTML/XML entity resolving: Only supports unicode enitities and a very limited number text represented\nentities (apos, quot, gt, lt, and amp). There are many more: http://www.w3.org/TR/REC-html40/sgml/dtd.html\n\n@param entity The entity name without & and ; (null throws NPE)\n@return Resolved entity or the entity itself if it could not be resolved.", "docstring_tokens": ["Simple", "HTML", "/", "XML", "entity", "resolving", ":", "Only", "supports", "unicode", "enitities", "and", "a", "very", "limited", "number", "text", "represented", "entities", "(", "apos", "quot", "gt", "lt", "and", "amp", ")", ".", "There", "are", "many", "more", ":", "http", ":", "//", "www", ".", "w3", ".", "org", "/", "TR", "/", "REC", "-", "html40", "/", "sgml", "/", "dtd", ".", "html"], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L192-L212", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.ellipsize", "original_string": "public static String ellipsize(String text, int maxLength, String end) {\n        if (text != null && text.length() > maxLength) {\n            return text.substring(0, maxLength - end.length()) + end;\n        }\n        return text;\n    }", "language": "java", "code": "public static String ellipsize(String text, int maxLength, String end) {\n        if (text != null && text.length() > maxLength) {\n            return text.substring(0, maxLength - end.length()) + end;\n        }\n        return text;\n    }", "code_tokens": ["public", "static", "String", "ellipsize", "(", "String", "text", ",", "int", "maxLength", ",", "String", "end", ")", "{", "if", "(", "text", "!=", "null", "&&", "text", ".", "length", "(", ")", ">", "maxLength", ")", "{", "return", "text", ".", "substring", "(", "0", ",", "maxLength", "-", "end", ".", "length", "(", ")", ")", "+", "end", ";", "}", "return", "text", ";", "}"], "docstring": "Cuts the string at the end if it's longer than maxLength and appends the given end string to it. The length of\nthe resulting string is always less or equal to the given maxLength. It's valid to pass a null text; in this\ncase null is returned.", "docstring_tokens": ["Cuts", "the", "string", "at", "the", "end", "if", "it", "s", "longer", "than", "maxLength", "and", "appends", "the", "given", "end", "string", "to", "it", ".", "The", "length", "of", "the", "resulting", "string", "is", "always", "less", "or", "equal", "to", "the", "given", "maxLength", ".", "It", "s", "valid", "to", "pass", "a", "null", "text", ";", "in", "this", "case", "null", "is", "returned", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L228-L233", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.join", "original_string": "public static String join(Iterable<?> iterable, String separator) {\n        if (iterable != null) {\n            StringBuilder buf = new StringBuilder();\n            Iterator<?> it = iterable.iterator();\n            char singleChar = separator.length() == 1 ? separator.charAt(0) : 0;\n            while (it.hasNext()) {\n                buf.append(it.next());\n                if (it.hasNext()) {\n                    if (singleChar != 0) {\n                        // More efficient\n                        buf.append(singleChar);\n                    } else {\n                        buf.append(separator);\n                    }\n                }\n            }\n            return buf.toString();\n        } else {\n            return \"\";\n        }\n    }", "language": "java", "code": "public static String join(Iterable<?> iterable, String separator) {\n        if (iterable != null) {\n            StringBuilder buf = new StringBuilder();\n            Iterator<?> it = iterable.iterator();\n            char singleChar = separator.length() == 1 ? separator.charAt(0) : 0;\n            while (it.hasNext()) {\n                buf.append(it.next());\n                if (it.hasNext()) {\n                    if (singleChar != 0) {\n                        // More efficient\n                        buf.append(singleChar);\n                    } else {\n                        buf.append(separator);\n                    }\n                }\n            }\n            return buf.toString();\n        } else {\n            return \"\";\n        }\n    }", "code_tokens": ["public", "static", "String", "join", "(", "Iterable", "<", "?", ">", "iterable", ",", "String", "separator", ")", "{", "if", "(", "iterable", "!=", "null", ")", "{", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", ")", ";", "Iterator", "<", "?", ">", "it", "=", "iterable", ".", "iterator", "(", ")", ";", "char", "singleChar", "=", "separator", ".", "length", "(", ")", "==", "1", "?", "separator", ".", "charAt", "(", "0", ")", ":", "0", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "buf", ".", "append", "(", "it", ".", "next", "(", ")", ")", ";", "if", "(", "it", ".", "hasNext", "(", ")", ")", "{", "if", "(", "singleChar", "!=", "0", ")", "{", "// More efficient", "buf", ".", "append", "(", "singleChar", ")", ";", "}", "else", "{", "buf", ".", "append", "(", "separator", ")", ";", "}", "}", "}", "return", "buf", ".", "toString", "(", ")", ";", "}", "else", "{", "return", "\"\"", ";", "}", "}"], "docstring": "Joins the given iterable objects using the given separator into a single string.\n\n@return the joined string or an empty string if iterable is null", "docstring_tokens": ["Joins", "the", "given", "iterable", "objects", "using", "the", "given", "separator", "into", "a", "single", "string", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L259-L279", "partition": "train"}
{"repo": "greenrobot/essentials", "path": "java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java", "func_name": "StringUtils.join", "original_string": "public static String join(int[] array, String separator) {\n        if (array != null) {\n            StringBuilder buf = new StringBuilder(Math.max(16, (separator.length() + 1) * array.length));\n            char singleChar = separator.length() == 1 ? separator.charAt(0) : 0;\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    if (singleChar != 0) {\n                        // More efficient\n                        buf.append(singleChar);\n                    } else {\n                        buf.append(separator);\n                    }\n                }\n                buf.append(array[i]);\n            }\n            return buf.toString();\n        } else {\n            return \"\";\n        }\n    }", "language": "java", "code": "public static String join(int[] array, String separator) {\n        if (array != null) {\n            StringBuilder buf = new StringBuilder(Math.max(16, (separator.length() + 1) * array.length));\n            char singleChar = separator.length() == 1 ? separator.charAt(0) : 0;\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    if (singleChar != 0) {\n                        // More efficient\n                        buf.append(singleChar);\n                    } else {\n                        buf.append(separator);\n                    }\n                }\n                buf.append(array[i]);\n            }\n            return buf.toString();\n        } else {\n            return \"\";\n        }\n    }", "code_tokens": ["public", "static", "String", "join", "(", "int", "[", "]", "array", ",", "String", "separator", ")", "{", "if", "(", "array", "!=", "null", ")", "{", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", "Math", ".", "max", "(", "16", ",", "(", "separator", ".", "length", "(", ")", "+", "1", ")", "*", "array", ".", "length", ")", ")", ";", "char", "singleChar", "=", "separator", ".", "length", "(", ")", "==", "1", "?", "separator", ".", "charAt", "(", "0", ")", ":", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "array", ".", "length", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "0", ")", "{", "if", "(", "singleChar", "!=", "0", ")", "{", "// More efficient", "buf", ".", "append", "(", "singleChar", ")", ";", "}", "else", "{", "buf", ".", "append", "(", "separator", ")", ";", "}", "}", "buf", ".", "append", "(", "array", "[", "i", "]", ")", ";", "}", "return", "buf", ".", "toString", "(", ")", ";", "}", "else", "{", "return", "\"\"", ";", "}", "}"], "docstring": "Joins the given ints using the given separator into a single string.\n\n@return the joined string or an empty string if the int array is null", "docstring_tokens": ["Joins", "the", "given", "ints", "using", "the", "given", "separator", "into", "a", "single", "string", "."], "sha": "31eaaeb410174004196c9ef9c9469e0d02afd94b", "url": "https://github.com/greenrobot/essentials/blob/31eaaeb410174004196c9ef9c9469e0d02afd94b/java-essentials/src/main/java/org/greenrobot/essentials/StringUtils.java#L286-L305", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Bufferer.java", "func_name": "Bufferer.buffer", "original_string": "Geometry buffer(Geometry geometry, double distance,\n\t\t\tSpatialReference sr, double densify_dist,\n\t\t\tint max_vertex_in_complete_circle, ProgressTracker progress_tracker) {\n\t\tif (geometry == null)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (densify_dist < 0)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (geometry.isEmpty())\n\t\t\treturn new Polygon(geometry.getDescription());\n\n\t\tEnvelope2D env2D = new Envelope2D();\n\t\tgeometry.queryLooseEnvelope2D(env2D);\n\t\tif (distance > 0)\n\t\t\tenv2D.inflate(distance, distance);\n\n\t\tm_progress_tracker = progress_tracker;\n\n\t\tm_original_geom_type = geometry.getType().value();\n\t\tm_geometry = geometry;\n\t\tm_tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv2D, true);// conservative to have same effect as simplify\n\t\tm_small_tolerance = InternalUtils\n\t\t\t\t.calculateToleranceFromGeometry(null, env2D, true);// conservative\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to have\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// same\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// effect as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// simplify\n\n\t\tif (max_vertex_in_complete_circle <= 0) {\n\t\t\tmax_vertex_in_complete_circle = 96;// 96 is the value used by SG.\n\t\t\t\t\t\t\t\t\t\t\t\t// This is the number of\n\t\t\t\t\t\t\t\t\t\t\t\t// vertices in the full circle.\n\t\t}\n\t\t\n\t\tm_spatialReference = sr;\n\t\tm_distance = distance;\n\t\tm_abs_distance = Math.abs(m_distance);\n\t\tm_abs_distance_reversed = m_abs_distance != 0 ? 1.0 / m_abs_distance\n\t\t\t\t: 0;\n\n\t\tif (NumberUtils.isNaN(densify_dist) || densify_dist == 0) {\n\t\t\tdensify_dist = m_abs_distance * 1e-5;\n\t\t} else {\n\t\t\tif (densify_dist > m_abs_distance * 0.5)\n\t\t\t\tdensify_dist = m_abs_distance * 0.5;// do not allow too\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// large densify\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance (the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// value will be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// adjusted\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// anyway later)\n\t\t}\n\n\t\tif (max_vertex_in_complete_circle < 12)\n\t\t\tmax_vertex_in_complete_circle = 12;\n\n\t\t\n\t\tdouble max_dd = Math.abs(distance)\n\t\t\t\t* (1 - Math.cos(Math.PI / max_vertex_in_complete_circle));\n\n\t\tif (max_dd > densify_dist)\n\t\t\tdensify_dist = max_dd;// the densify distance has to agree with the\n\t\t\t\t\t\t\t\t\t// max_vertex_in_complete_circle\n\t\telse {\n\t\t\tdouble vertex_count = Math.PI\n\t\t\t\t\t/ Math.acos(1.0 - densify_dist / Math.abs(distance));\n\t\t\tif (vertex_count < (double) max_vertex_in_complete_circle - 1.0) {\n\t\t\t\tmax_vertex_in_complete_circle = (int) vertex_count;\n\t\t\t\tif (max_vertex_in_complete_circle < 12) {\n\t\t\t\t\tmax_vertex_in_complete_circle = 12;\n\t\t\t\t\tdensify_dist = Math.abs(distance)\n\t\t\t\t\t\t\t* (1 - Math.cos(Math.PI\n\t\t\t\t\t\t\t\t\t/ max_vertex_in_complete_circle));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_densify_dist = densify_dist;\n\t\tm_max_vertex_in_complete_circle = max_vertex_in_complete_circle;\n\t\t// when filtering close points we do not want the filter to distort\n\t\t// generated buffer too much.\n\t\tm_filter_tolerance = Math.min(m_small_tolerance,\n\t\t\t\tdensify_dist * 0.25);\n\t\t\n\t\t\n\t\tm_circle_template_size = calcN_();\n\t\tif (m_circle_template_size != m_old_circle_template_size) {\n\t\t\t// we have an optimization for this method to be called several\n\t\t\t// times. Here we detected too many changes and need to regenerate\n\t\t\t// the data.\n\t\t\tm_circle_template.clear();\n\t\t\tm_old_circle_template_size = m_circle_template_size;\n\t\t}\n\n\t\tGeometry result_geom = buffer_();\n\t\tm_geometry = null;\n\t\treturn result_geom;\t\t\n\t}", "language": "java", "code": "Geometry buffer(Geometry geometry, double distance,\n\t\t\tSpatialReference sr, double densify_dist,\n\t\t\tint max_vertex_in_complete_circle, ProgressTracker progress_tracker) {\n\t\tif (geometry == null)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (densify_dist < 0)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (geometry.isEmpty())\n\t\t\treturn new Polygon(geometry.getDescription());\n\n\t\tEnvelope2D env2D = new Envelope2D();\n\t\tgeometry.queryLooseEnvelope2D(env2D);\n\t\tif (distance > 0)\n\t\t\tenv2D.inflate(distance, distance);\n\n\t\tm_progress_tracker = progress_tracker;\n\n\t\tm_original_geom_type = geometry.getType().value();\n\t\tm_geometry = geometry;\n\t\tm_tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv2D, true);// conservative to have same effect as simplify\n\t\tm_small_tolerance = InternalUtils\n\t\t\t\t.calculateToleranceFromGeometry(null, env2D, true);// conservative\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to have\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// same\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// effect as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// simplify\n\n\t\tif (max_vertex_in_complete_circle <= 0) {\n\t\t\tmax_vertex_in_complete_circle = 96;// 96 is the value used by SG.\n\t\t\t\t\t\t\t\t\t\t\t\t// This is the number of\n\t\t\t\t\t\t\t\t\t\t\t\t// vertices in the full circle.\n\t\t}\n\t\t\n\t\tm_spatialReference = sr;\n\t\tm_distance = distance;\n\t\tm_abs_distance = Math.abs(m_distance);\n\t\tm_abs_distance_reversed = m_abs_distance != 0 ? 1.0 / m_abs_distance\n\t\t\t\t: 0;\n\n\t\tif (NumberUtils.isNaN(densify_dist) || densify_dist == 0) {\n\t\t\tdensify_dist = m_abs_distance * 1e-5;\n\t\t} else {\n\t\t\tif (densify_dist > m_abs_distance * 0.5)\n\t\t\t\tdensify_dist = m_abs_distance * 0.5;// do not allow too\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// large densify\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance (the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// value will be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// adjusted\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// anyway later)\n\t\t}\n\n\t\tif (max_vertex_in_complete_circle < 12)\n\t\t\tmax_vertex_in_complete_circle = 12;\n\n\t\t\n\t\tdouble max_dd = Math.abs(distance)\n\t\t\t\t* (1 - Math.cos(Math.PI / max_vertex_in_complete_circle));\n\n\t\tif (max_dd > densify_dist)\n\t\t\tdensify_dist = max_dd;// the densify distance has to agree with the\n\t\t\t\t\t\t\t\t\t// max_vertex_in_complete_circle\n\t\telse {\n\t\t\tdouble vertex_count = Math.PI\n\t\t\t\t\t/ Math.acos(1.0 - densify_dist / Math.abs(distance));\n\t\t\tif (vertex_count < (double) max_vertex_in_complete_circle - 1.0) {\n\t\t\t\tmax_vertex_in_complete_circle = (int) vertex_count;\n\t\t\t\tif (max_vertex_in_complete_circle < 12) {\n\t\t\t\t\tmax_vertex_in_complete_circle = 12;\n\t\t\t\t\tdensify_dist = Math.abs(distance)\n\t\t\t\t\t\t\t* (1 - Math.cos(Math.PI\n\t\t\t\t\t\t\t\t\t/ max_vertex_in_complete_circle));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_densify_dist = densify_dist;\n\t\tm_max_vertex_in_complete_circle = max_vertex_in_complete_circle;\n\t\t// when filtering close points we do not want the filter to distort\n\t\t// generated buffer too much.\n\t\tm_filter_tolerance = Math.min(m_small_tolerance,\n\t\t\t\tdensify_dist * 0.25);\n\t\t\n\t\t\n\t\tm_circle_template_size = calcN_();\n\t\tif (m_circle_template_size != m_old_circle_template_size) {\n\t\t\t// we have an optimization for this method to be called several\n\t\t\t// times. Here we detected too many changes and need to regenerate\n\t\t\t// the data.\n\t\t\tm_circle_template.clear();\n\t\t\tm_old_circle_template_size = m_circle_template_size;\n\t\t}\n\n\t\tGeometry result_geom = buffer_();\n\t\tm_geometry = null;\n\t\treturn result_geom;\t\t\n\t}", "code_tokens": ["Geometry", "buffer", "(", "Geometry", "geometry", ",", "double", "distance", ",", "SpatialReference", "sr", ",", "double", "densify_dist", ",", "int", "max_vertex_in_complete_circle", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "geometry", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "densify_dist", "<", "0", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", "new", "Polygon", "(", "geometry", ".", "getDescription", "(", ")", ")", ";", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "geometry", ".", "queryLooseEnvelope2D", "(", "env2D", ")", ";", "if", "(", "distance", ">", "0", ")", "env2D", ".", "inflate", "(", "distance", ",", "distance", ")", ";", "m_progress_tracker", "=", "progress_tracker", ";", "m_original_geom_type", "=", "geometry", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "m_geometry", "=", "geometry", ";", "m_tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "sr", ",", "env2D", ",", "true", ")", ";", "// conservative to have same effect as simplify", "m_small_tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "null", ",", "env2D", ",", "true", ")", ";", "// conservative", "// to have", "// same", "// effect as", "// simplify", "if", "(", "max_vertex_in_complete_circle", "<=", "0", ")", "{", "max_vertex_in_complete_circle", "=", "96", ";", "// 96 is the value used by SG.", "// This is the number of", "// vertices in the full circle.", "}", "m_spatialReference", "=", "sr", ";", "m_distance", "=", "distance", ";", "m_abs_distance", "=", "Math", ".", "abs", "(", "m_distance", ")", ";", "m_abs_distance_reversed", "=", "m_abs_distance", "!=", "0", "?", "1.0", "/", "m_abs_distance", ":", "0", ";", "if", "(", "NumberUtils", ".", "isNaN", "(", "densify_dist", ")", "||", "densify_dist", "==", "0", ")", "{", "densify_dist", "=", "m_abs_distance", "*", "1e-5", ";", "}", "else", "{", "if", "(", "densify_dist", ">", "m_abs_distance", "*", "0.5", ")", "densify_dist", "=", "m_abs_distance", "*", "0.5", ";", "// do not allow too", "// large densify", "// distance (the", "// value will be", "// adjusted", "// anyway later)", "}", "if", "(", "max_vertex_in_complete_circle", "<", "12", ")", "max_vertex_in_complete_circle", "=", "12", ";", "double", "max_dd", "=", "Math", ".", "abs", "(", "distance", ")", "*", "(", "1", "-", "Math", ".", "cos", "(", "Math", ".", "PI", "/", "max_vertex_in_complete_circle", ")", ")", ";", "if", "(", "max_dd", ">", "densify_dist", ")", "densify_dist", "=", "max_dd", ";", "// the densify distance has to agree with the", "// max_vertex_in_complete_circle", "else", "{", "double", "vertex_count", "=", "Math", ".", "PI", "/", "Math", ".", "acos", "(", "1.0", "-", "densify_dist", "/", "Math", ".", "abs", "(", "distance", ")", ")", ";", "if", "(", "vertex_count", "<", "(", "double", ")", "max_vertex_in_complete_circle", "-", "1.0", ")", "{", "max_vertex_in_complete_circle", "=", "(", "int", ")", "vertex_count", ";", "if", "(", "max_vertex_in_complete_circle", "<", "12", ")", "{", "max_vertex_in_complete_circle", "=", "12", ";", "densify_dist", "=", "Math", ".", "abs", "(", "distance", ")", "*", "(", "1", "-", "Math", ".", "cos", "(", "Math", ".", "PI", "/", "max_vertex_in_complete_circle", ")", ")", ";", "}", "}", "}", "m_densify_dist", "=", "densify_dist", ";", "m_max_vertex_in_complete_circle", "=", "max_vertex_in_complete_circle", ";", "// when filtering close points we do not want the filter to distort", "// generated buffer too much.", "m_filter_tolerance", "=", "Math", ".", "min", "(", "m_small_tolerance", ",", "densify_dist", "*", "0.25", ")", ";", "m_circle_template_size", "=", "calcN_", "(", ")", ";", "if", "(", "m_circle_template_size", "!=", "m_old_circle_template_size", ")", "{", "// we have an optimization for this method to be called several", "// times. Here we detected too many changes and need to regenerate", "// the data.", "m_circle_template", ".", "clear", "(", ")", ";", "m_old_circle_template_size", "=", "m_circle_template_size", ";", "}", "Geometry", "result_geom", "=", "buffer_", "(", ")", ";", "m_geometry", "=", "null", ";", "return", "result_geom", ";", "}"], "docstring": "Result is always a polygon. For non positive distance and non-areas\nreturns an empty polygon. For points returns circles.", "docstring_tokens": ["Result", "is", "always", "a", "polygon", ".", "For", "non", "positive", "distance", "and", "non", "-", "areas", "returns", "an", "empty", "polygon", ".", "For", "points", "returns", "circles", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Bufferer.java#L52-L150", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Bufferer.java", "func_name": "Bufferer.clipFilter_", "original_string": "private static int clipFilter_(EditShape edit_shape,\n\t\t\tint fixed_vertices_index, int from_vertex, int to_vertex, int dir,\n\t\t\tdouble abs_distance, double densify_distance, final int max_filter) {\n\t\t// Note: vertices marked with fixed_vertices_index cannot be deleted.\n\n\t\tPoint2D pt1 = edit_shape.getXY(from_vertex);\n\t\tPoint2D pt2 = edit_shape.getXY(to_vertex);\n\t\tif (pt1.equals(pt2))\n\t\t\treturn -1;\n\n\t\tdouble densify_distance_delta = densify_distance * 0.25;// distance by\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// which we can\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// move the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point closer\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to the chord\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (introducing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an error into\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the buffer).\n\t\tdouble erase_distance_delta = densify_distance * 0.25;// distance when\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// we can erase\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the point\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (introducing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an error into\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the buffer).\n\t\t// This function goal is to modify or remove vertices between\n\t\t// from_vertex and to_vertex in such a way that the result would not\n\t\t// affect buffer to the left of the\n\t\t// chain.\n\t\tPoint2D v_gap = new Point2D();\n\t\tv_gap.sub(pt2, pt1);\n\t\tdouble gap_length = v_gap.length();\n\t\tdouble h2_4 = gap_length * gap_length * 0.25;\n\t\tdouble sqr_center_to_chord = abs_distance * abs_distance - h2_4; // squared\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chord\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// circle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center\n\t\tif (sqr_center_to_chord <= h2_4)\n\t\t\treturn -1;// center to chord distance is less than half gap, that\n\t\t\t\t\t\t// means the gap is too wide for useful filtering (maybe\n\t\t\t\t\t\t// this).\n\n\t\tdouble center_to_chord = Math.sqrt(sqr_center_to_chord); // distance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// circle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chord.\n\n\t\tv_gap.normalize();\n\t\tPoint2D v_gap_norm = new Point2D(v_gap);\n\t\tv_gap_norm.rightPerpendicular();\n\t\tdouble chord_to_corner = h2_4 / center_to_chord; // cos(a) =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center_to_chord /\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chord_to_corner =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance / cos(a)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// -\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center_to_chord;\n\t\tboolean can_erase_corner_point = chord_to_corner <= erase_distance_delta;\n\t\tPoint2D chord_midpoint = new Point2D();\n\t\tMathUtils.lerp(pt2, pt1, 0.5, chord_midpoint);\n\t\tPoint2D corner = new Point2D(v_gap_norm);\n\t\tdouble corrected_chord_to_corner = chord_to_corner\n\t\t\t\t- densify_distance_delta;// using slightly smaller than needed\n\t\t\t\t\t\t\t\t\t\t\t// distance let us filter more.\n\t\tcorner.scaleAdd(Math.max(0.0, corrected_chord_to_corner),\n\t\t\t\tchord_midpoint);\n\t\t// corner = (p1 + p2) * 0.5 + v_gap_norm * chord_to_corner;\n\n\t\tPoint2D center = new Point2D(v_gap_norm);\n\t\tcenter.negate();\n\t\tcenter.scaleAdd(center_to_chord, chord_midpoint);\n\n\t\tdouble allowed_distance = abs_distance - erase_distance_delta;\n\t\tdouble sqr_allowed_distance = MathUtils.sqr(allowed_distance);\n\t\tdouble sqr_large_distance = sqr_allowed_distance * (1.9 * 1.9);\n\n\t\tPoint2D co_p1 = new Point2D();\n\t\tco_p1.sub(corner, pt1);\n\t\tPoint2D co_p2 = new Point2D();\n\t\tco_p2.sub(corner, pt2);\n\n\t\tboolean large_distance = false;// set to true when distance\n\t\tint cnt = 0;\n\t\tchar[] locations = new char[64];\n\t\t{\n\t\t\t// check all vertices in the gap verifying that the gap can be\n\t\t\t// clipped.\n\t\t\t//\n\n\t\t\tPoint2D pt = new Point2D();\n\t\t\t// firstly remove any duplicate vertices in the end.\n\t\t\tfor (int v = edit_shape.getPrevVertex(to_vertex, dir); v != from_vertex;) {\n\t\t\t\tif (edit_shape.getUserIndex(v, fixed_vertices_index) == 1)\n\t\t\t\t\treturn -1;// this range contains protected vertex\n\n\t\t\t\tedit_shape.getXY(v, pt);\n\t\t\t\tif (pt.equals(pt2)) {\n\t\t\t\t\tint v1 = edit_shape.getPrevVertex(v, dir);\n\t\t\t\t\tedit_shape.removeVertex(v, false);\n\t\t\t\t\tv = v1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPoint2D prev_prev_pt = new Point2D();\n\t\t\tprev_prev_pt.setNaN();\n\t\t\tPoint2D prev_pt = new Point2D();\n\t\t\tprev_pt.setCoords(pt1);\n\t\t\tlocations[cnt++] = 1;\n\t\t\tint prev_v = from_vertex;\n\t\t\tPoint2D dummyPt = new Point2D();\n\t\t\tfor (int v = edit_shape.getNextVertex(from_vertex, dir); v != to_vertex;) {\n\t\t\t\tif (edit_shape.getUserIndex(v, fixed_vertices_index) == 1)\n\t\t\t\t\treturn -1;// this range contains protected vertex\n\n\t\t\t\tedit_shape.getXY(v, pt);\n\t\t\t\tif (pt.equals(prev_pt)) {\n\t\t\t\t\tint v1 = edit_shape.getNextVertex(v, dir);\n\t\t\t\t\tedit_shape.removeVertex(v, false);\n\t\t\t\t\tv = v1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlocations[cnt++] = 0;\n\n\t\t\t\tPoint2D v1 = new Point2D();\n\t\t\t\tv1.sub(pt, pt1);\n\t\t\t\tif (v1.dotProduct(v_gap_norm) < 0)// we are crossing on the\n\t\t\t\t\t\t\t\t\t\t\t\t\t// wrong site of the chord.\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Just bail out earlier.\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Maybe we could continue\n\t\t\t\t\t\t\t\t\t\t\t\t\t// clipping though here, but\n\t\t\t\t\t\t\t\t\t\t\t\t\t// it seems to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t// unnecessary complicated.\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (Point2D.sqrDistance(pt, pt1) > sqr_large_distance\n\t\t\t\t\t\t|| Point2D.sqrDistance(pt, pt2) > sqr_large_distance)\n\t\t\t\t\tlarge_distance = true; // too far from points, may\n\t\t\t\t\t\t\t\t\t\t\t// contribute to the outline (in\n\t\t\t\t\t\t\t\t\t\t\t// case of a large loop)\n\n\t\t\t\tchar next_location = 0;\n\n\t\t\t\tdummyPt.sub(pt, pt1);\n\t\t\t\tdouble cs1 = dummyPt.crossProduct(co_p1);\n\t\t\t\tif (cs1 >= 0) {\n\t\t\t\t\tnext_location = 1;\n\t\t\t\t}\n\n\t\t\t\tdummyPt.sub(pt, pt2);\n\t\t\t\tdouble cs2 = dummyPt.crossProduct(co_p2);\n\t\t\t\tif (cs2 <= 0) {\n\t\t\t\t\tnext_location |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (next_location == 0)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tlocations[cnt - 1] = next_location;\n\t\t\t\tprev_prev_pt.setCoords(prev_pt);\n\t\t\t\tprev_pt.setCoords(pt);\n\t\t\t\tprev_v = v;\n\t\t\t\tv = edit_shape.getNextVertex(v, dir);\n\t\t\t}\n\n\t\t\tif (cnt == 1)\n\t\t\t\treturn 0;\n\n\t\t\tassert (!pt2.equals(prev_pt));\n\t\t\tlocations[cnt++] = 2;\n\t\t}\n\n\t\tboolean can_clip_all = true;\n\t\t// we can remove all points and replace them with a single corner point\n\t\t// if we are moving from location 1 via location 3 to location 2\n\t\tfor (int i = 1, k = 0; i < cnt; i++) {\n\t\t\tif (locations[i] != locations[i - 1]) {\n\t\t\t\tk++;\n\t\t\t\tcan_clip_all = k < 3\n\t\t\t\t\t\t&& ((k == 1 && locations[i] == 3) || (k == 2 && locations[i] == 2));\n\t\t\t\tif (!can_clip_all)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt > 2 && can_clip_all && (cnt == 3 || !large_distance)) {\n\t\t\tint clip_count = 0;\n\t\t\tint v = edit_shape.getNextVertex(from_vertex, dir);\n\t\t\tif (!can_erase_corner_point) {\n\t\t\t\tedit_shape.setXY(v, corner);\n\t\t\t\tv = edit_shape.getNextVertex(v, dir);\n\t\t\t}\n\n\t\t\t// we can remove all vertices between from and to, because they\n\t\t\t// don't contribute\n\t\t\twhile (v != to_vertex) {\n\t\t\t\tint v1 = edit_shape.getNextVertex(v, dir);\n\t\t\t\tedit_shape.removeVertex(v, false);\n\t\t\t\tv = v1;\n\t\t\t\t++clip_count;\n\t\t\t}\n\n\t\t\treturn clip_count;\n\t\t}\n\n\t\tif (cnt == 3) {\n\t\t\tboolean case1 = (locations[0] == 1 && locations[1] == 2 && locations[2] == 2);\n\t\t\tboolean case2 = (locations[0] == 1 && locations[1] == 1 && locations[2] == 2);\n\t\t\tif (case1 || case2) {\n\t\t\t\t// special case, when we cannot clip, but we can move the point\n\t\t\t\tPoint2D p1 = edit_shape.getXY(from_vertex);\n\t\t\t\tint v = edit_shape.getNextVertex(from_vertex, dir);\n\t\t\t\tPoint2D p2 = edit_shape.getXY(v);\n\t\t\t\tPoint2D p3 = edit_shape.getXY(edit_shape.getNextVertex(v, dir));\n\t\t\t\tif (case2) {\n\t\t\t\t\tPoint2D temp = p1;\n\t\t\t\t\tp1 = p3;\n\t\t\t\t\tp3 = temp;\n\t\t\t\t}\n\n\t\t\t\tPoint2D vec = new Point2D();\n\t\t\t\tvec.sub(p1, p2);\n\t\t\t\tp3.sub(p2);\n\t\t\t\tdouble veclen = vec.length();\n\t\t\t\tdouble w = p3.length();\n\t\t\t\tdouble wcosa = vec.dotProduct(p3) / veclen;\n\t\t\t\tdouble wsina = Math.abs(p3.crossProduct(vec) / veclen);\n\t\t\t\tdouble z = 2 * abs_distance - wsina;\n\t\t\t\tif (z < 0)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tdouble x = wcosa + Math.sqrt(wsina * z);\n\t\t\t\tif (x > veclen)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tPoint2D hvec = new Point2D();\n\t\t\t\thvec.scaleAdd(-x / veclen, vec, p3); // hvec = p3 - vec * (x /\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// veclen);\n\t\t\t\tdouble h = hvec.length();\n\t\t\t\tdouble y = -(h * h * veclen) / (2 * hvec.dotProduct(vec));\n\n\t\t\t\tdouble t = (x - y) / veclen;\n\t\t\t\tMathUtils.lerp(p2, p1, t, p2);\n\t\t\t\tedit_shape.setXY(v, p2);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (large_distance && cnt > 3) {\n\t\t\t// we are processing more than 3 points and there are some points\n\t\t\t// further than the\n\t\t\treturn 0;\n\t\t}\n\n\t\tint v_prev = -1;\n\t\tPoint2D pt_prev = new Point2D();\n\t\tint v_cur = from_vertex;\n\t\tPoint2D pt_cur = new Point2D(pt1);\n\t\tint cur_location = 1;\n\t\tint prev_location = -1; // 1 - semiplane to the right of [f,c]. 3 -\n\t\t\t\t\t\t\t\t// semiplane to the right of [c,t], 2 - both\n\t\t\t\t\t\t\t\t// above fc and ct, 0 - cannot clip, -1 -\n\t\t\t\t\t\t\t\t// unknown\n\t\tint v_next = v_cur;\n\t\tint clip_count = 0;\n\t\tcnt = 1;\n\t\twhile (v_next != to_vertex) {\n\t\t\tv_next = edit_shape.getNextVertex(v_next, dir);\n\t\t\tint next_location = locations[cnt++];\n\t\t\tif (next_location == 0) {\n\t\t\t\tif (v_next == to_vertex)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPoint2D pt_next = edit_shape.getXY(v_next);\n\n\t\t\tif (prev_location != -1) {\n\t\t\t\tint common_location = (prev_location & cur_location & next_location);\n\t\t\t\tif ((common_location & 3) != 0) {\n\t\t\t\t\t// prev and next are on the same semiplane as the current we\n\t\t\t\t\t// can safely remove the current point.\n\t\t\t\t\tedit_shape.removeVertex(v_cur, true);\n\t\t\t\t\tclip_count++;// do not change prev point.\n\t\t\t\t\tv_cur = v_next;\n\t\t\t\t\tpt_cur.setCoords(pt_next);\n\t\t\t\t\tcur_location = next_location;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cur_location == 3 && prev_location != 0\n\t\t\t\t\t\t&& next_location != 0) {\n\t\t\t\t\tassert ((prev_location & next_location) == 0);// going from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// one semi\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// plane to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// another\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// via the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// mid.\n\t\t\t\t\tpt_cur.setCoords(corner);\n\t\t\t\t\tif (can_erase_corner_point || pt_cur.equals(pt_prev)) {// this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// can\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\tedit_shape.removeVertex(v_cur, true);\n\t\t\t\t\t\tclip_count++;// do not change prev point.\n\t\t\t\t\t\tv_cur = v_next;\n\t\t\t\t\t\tpt_cur.setCoords(pt_next);\n\t\t\t\t\t\tcur_location = next_location;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedit_shape.setXY(v_cur, pt_cur); // snap to the corner\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (next_location == 0\n\t\t\t\t\t\t\t&& cur_location != 0\n\t\t\t\t\t\t\t|| next_location != 0\n\t\t\t\t\t\t\t&& cur_location == 0\n\t\t\t\t\t\t\t|| ((next_location | cur_location) == 3\n\t\t\t\t\t\t\t\t\t&& next_location != 3 && cur_location != 3)) {\n\t\t\t\t\t\t// clip\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev_location = cur_location;\n\t\t\tv_prev = v_cur;\n\t\t\tpt_prev.setCoords(pt_cur);\n\t\t\tv_cur = v_next;\n\t\t\tcur_location = next_location;\n\t\t\tpt_cur.setCoords(pt_next);\n\t\t}\n\n\t\treturn clip_count;\n\t}", "language": "java", "code": "private static int clipFilter_(EditShape edit_shape,\n\t\t\tint fixed_vertices_index, int from_vertex, int to_vertex, int dir,\n\t\t\tdouble abs_distance, double densify_distance, final int max_filter) {\n\t\t// Note: vertices marked with fixed_vertices_index cannot be deleted.\n\n\t\tPoint2D pt1 = edit_shape.getXY(from_vertex);\n\t\tPoint2D pt2 = edit_shape.getXY(to_vertex);\n\t\tif (pt1.equals(pt2))\n\t\t\treturn -1;\n\n\t\tdouble densify_distance_delta = densify_distance * 0.25;// distance by\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// which we can\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// move the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point closer\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to the chord\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (introducing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an error into\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the buffer).\n\t\tdouble erase_distance_delta = densify_distance * 0.25;// distance when\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// we can erase\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the point\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (introducing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an error into\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the buffer).\n\t\t// This function goal is to modify or remove vertices between\n\t\t// from_vertex and to_vertex in such a way that the result would not\n\t\t// affect buffer to the left of the\n\t\t// chain.\n\t\tPoint2D v_gap = new Point2D();\n\t\tv_gap.sub(pt2, pt1);\n\t\tdouble gap_length = v_gap.length();\n\t\tdouble h2_4 = gap_length * gap_length * 0.25;\n\t\tdouble sqr_center_to_chord = abs_distance * abs_distance - h2_4; // squared\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chord\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// circle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center\n\t\tif (sqr_center_to_chord <= h2_4)\n\t\t\treturn -1;// center to chord distance is less than half gap, that\n\t\t\t\t\t\t// means the gap is too wide for useful filtering (maybe\n\t\t\t\t\t\t// this).\n\n\t\tdouble center_to_chord = Math.sqrt(sqr_center_to_chord); // distance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// circle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chord.\n\n\t\tv_gap.normalize();\n\t\tPoint2D v_gap_norm = new Point2D(v_gap);\n\t\tv_gap_norm.rightPerpendicular();\n\t\tdouble chord_to_corner = h2_4 / center_to_chord; // cos(a) =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center_to_chord /\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chord_to_corner =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// distance / cos(a)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// -\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// center_to_chord;\n\t\tboolean can_erase_corner_point = chord_to_corner <= erase_distance_delta;\n\t\tPoint2D chord_midpoint = new Point2D();\n\t\tMathUtils.lerp(pt2, pt1, 0.5, chord_midpoint);\n\t\tPoint2D corner = new Point2D(v_gap_norm);\n\t\tdouble corrected_chord_to_corner = chord_to_corner\n\t\t\t\t- densify_distance_delta;// using slightly smaller than needed\n\t\t\t\t\t\t\t\t\t\t\t// distance let us filter more.\n\t\tcorner.scaleAdd(Math.max(0.0, corrected_chord_to_corner),\n\t\t\t\tchord_midpoint);\n\t\t// corner = (p1 + p2) * 0.5 + v_gap_norm * chord_to_corner;\n\n\t\tPoint2D center = new Point2D(v_gap_norm);\n\t\tcenter.negate();\n\t\tcenter.scaleAdd(center_to_chord, chord_midpoint);\n\n\t\tdouble allowed_distance = abs_distance - erase_distance_delta;\n\t\tdouble sqr_allowed_distance = MathUtils.sqr(allowed_distance);\n\t\tdouble sqr_large_distance = sqr_allowed_distance * (1.9 * 1.9);\n\n\t\tPoint2D co_p1 = new Point2D();\n\t\tco_p1.sub(corner, pt1);\n\t\tPoint2D co_p2 = new Point2D();\n\t\tco_p2.sub(corner, pt2);\n\n\t\tboolean large_distance = false;// set to true when distance\n\t\tint cnt = 0;\n\t\tchar[] locations = new char[64];\n\t\t{\n\t\t\t// check all vertices in the gap verifying that the gap can be\n\t\t\t// clipped.\n\t\t\t//\n\n\t\t\tPoint2D pt = new Point2D();\n\t\t\t// firstly remove any duplicate vertices in the end.\n\t\t\tfor (int v = edit_shape.getPrevVertex(to_vertex, dir); v != from_vertex;) {\n\t\t\t\tif (edit_shape.getUserIndex(v, fixed_vertices_index) == 1)\n\t\t\t\t\treturn -1;// this range contains protected vertex\n\n\t\t\t\tedit_shape.getXY(v, pt);\n\t\t\t\tif (pt.equals(pt2)) {\n\t\t\t\t\tint v1 = edit_shape.getPrevVertex(v, dir);\n\t\t\t\t\tedit_shape.removeVertex(v, false);\n\t\t\t\t\tv = v1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPoint2D prev_prev_pt = new Point2D();\n\t\t\tprev_prev_pt.setNaN();\n\t\t\tPoint2D prev_pt = new Point2D();\n\t\t\tprev_pt.setCoords(pt1);\n\t\t\tlocations[cnt++] = 1;\n\t\t\tint prev_v = from_vertex;\n\t\t\tPoint2D dummyPt = new Point2D();\n\t\t\tfor (int v = edit_shape.getNextVertex(from_vertex, dir); v != to_vertex;) {\n\t\t\t\tif (edit_shape.getUserIndex(v, fixed_vertices_index) == 1)\n\t\t\t\t\treturn -1;// this range contains protected vertex\n\n\t\t\t\tedit_shape.getXY(v, pt);\n\t\t\t\tif (pt.equals(prev_pt)) {\n\t\t\t\t\tint v1 = edit_shape.getNextVertex(v, dir);\n\t\t\t\t\tedit_shape.removeVertex(v, false);\n\t\t\t\t\tv = v1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlocations[cnt++] = 0;\n\n\t\t\t\tPoint2D v1 = new Point2D();\n\t\t\t\tv1.sub(pt, pt1);\n\t\t\t\tif (v1.dotProduct(v_gap_norm) < 0)// we are crossing on the\n\t\t\t\t\t\t\t\t\t\t\t\t\t// wrong site of the chord.\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Just bail out earlier.\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Maybe we could continue\n\t\t\t\t\t\t\t\t\t\t\t\t\t// clipping though here, but\n\t\t\t\t\t\t\t\t\t\t\t\t\t// it seems to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t// unnecessary complicated.\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (Point2D.sqrDistance(pt, pt1) > sqr_large_distance\n\t\t\t\t\t\t|| Point2D.sqrDistance(pt, pt2) > sqr_large_distance)\n\t\t\t\t\tlarge_distance = true; // too far from points, may\n\t\t\t\t\t\t\t\t\t\t\t// contribute to the outline (in\n\t\t\t\t\t\t\t\t\t\t\t// case of a large loop)\n\n\t\t\t\tchar next_location = 0;\n\n\t\t\t\tdummyPt.sub(pt, pt1);\n\t\t\t\tdouble cs1 = dummyPt.crossProduct(co_p1);\n\t\t\t\tif (cs1 >= 0) {\n\t\t\t\t\tnext_location = 1;\n\t\t\t\t}\n\n\t\t\t\tdummyPt.sub(pt, pt2);\n\t\t\t\tdouble cs2 = dummyPt.crossProduct(co_p2);\n\t\t\t\tif (cs2 <= 0) {\n\t\t\t\t\tnext_location |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (next_location == 0)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tlocations[cnt - 1] = next_location;\n\t\t\t\tprev_prev_pt.setCoords(prev_pt);\n\t\t\t\tprev_pt.setCoords(pt);\n\t\t\t\tprev_v = v;\n\t\t\t\tv = edit_shape.getNextVertex(v, dir);\n\t\t\t}\n\n\t\t\tif (cnt == 1)\n\t\t\t\treturn 0;\n\n\t\t\tassert (!pt2.equals(prev_pt));\n\t\t\tlocations[cnt++] = 2;\n\t\t}\n\n\t\tboolean can_clip_all = true;\n\t\t// we can remove all points and replace them with a single corner point\n\t\t// if we are moving from location 1 via location 3 to location 2\n\t\tfor (int i = 1, k = 0; i < cnt; i++) {\n\t\t\tif (locations[i] != locations[i - 1]) {\n\t\t\t\tk++;\n\t\t\t\tcan_clip_all = k < 3\n\t\t\t\t\t\t&& ((k == 1 && locations[i] == 3) || (k == 2 && locations[i] == 2));\n\t\t\t\tif (!can_clip_all)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt > 2 && can_clip_all && (cnt == 3 || !large_distance)) {\n\t\t\tint clip_count = 0;\n\t\t\tint v = edit_shape.getNextVertex(from_vertex, dir);\n\t\t\tif (!can_erase_corner_point) {\n\t\t\t\tedit_shape.setXY(v, corner);\n\t\t\t\tv = edit_shape.getNextVertex(v, dir);\n\t\t\t}\n\n\t\t\t// we can remove all vertices between from and to, because they\n\t\t\t// don't contribute\n\t\t\twhile (v != to_vertex) {\n\t\t\t\tint v1 = edit_shape.getNextVertex(v, dir);\n\t\t\t\tedit_shape.removeVertex(v, false);\n\t\t\t\tv = v1;\n\t\t\t\t++clip_count;\n\t\t\t}\n\n\t\t\treturn clip_count;\n\t\t}\n\n\t\tif (cnt == 3) {\n\t\t\tboolean case1 = (locations[0] == 1 && locations[1] == 2 && locations[2] == 2);\n\t\t\tboolean case2 = (locations[0] == 1 && locations[1] == 1 && locations[2] == 2);\n\t\t\tif (case1 || case2) {\n\t\t\t\t// special case, when we cannot clip, but we can move the point\n\t\t\t\tPoint2D p1 = edit_shape.getXY(from_vertex);\n\t\t\t\tint v = edit_shape.getNextVertex(from_vertex, dir);\n\t\t\t\tPoint2D p2 = edit_shape.getXY(v);\n\t\t\t\tPoint2D p3 = edit_shape.getXY(edit_shape.getNextVertex(v, dir));\n\t\t\t\tif (case2) {\n\t\t\t\t\tPoint2D temp = p1;\n\t\t\t\t\tp1 = p3;\n\t\t\t\t\tp3 = temp;\n\t\t\t\t}\n\n\t\t\t\tPoint2D vec = new Point2D();\n\t\t\t\tvec.sub(p1, p2);\n\t\t\t\tp3.sub(p2);\n\t\t\t\tdouble veclen = vec.length();\n\t\t\t\tdouble w = p3.length();\n\t\t\t\tdouble wcosa = vec.dotProduct(p3) / veclen;\n\t\t\t\tdouble wsina = Math.abs(p3.crossProduct(vec) / veclen);\n\t\t\t\tdouble z = 2 * abs_distance - wsina;\n\t\t\t\tif (z < 0)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tdouble x = wcosa + Math.sqrt(wsina * z);\n\t\t\t\tif (x > veclen)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tPoint2D hvec = new Point2D();\n\t\t\t\thvec.scaleAdd(-x / veclen, vec, p3); // hvec = p3 - vec * (x /\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// veclen);\n\t\t\t\tdouble h = hvec.length();\n\t\t\t\tdouble y = -(h * h * veclen) / (2 * hvec.dotProduct(vec));\n\n\t\t\t\tdouble t = (x - y) / veclen;\n\t\t\t\tMathUtils.lerp(p2, p1, t, p2);\n\t\t\t\tedit_shape.setXY(v, p2);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (large_distance && cnt > 3) {\n\t\t\t// we are processing more than 3 points and there are some points\n\t\t\t// further than the\n\t\t\treturn 0;\n\t\t}\n\n\t\tint v_prev = -1;\n\t\tPoint2D pt_prev = new Point2D();\n\t\tint v_cur = from_vertex;\n\t\tPoint2D pt_cur = new Point2D(pt1);\n\t\tint cur_location = 1;\n\t\tint prev_location = -1; // 1 - semiplane to the right of [f,c]. 3 -\n\t\t\t\t\t\t\t\t// semiplane to the right of [c,t], 2 - both\n\t\t\t\t\t\t\t\t// above fc and ct, 0 - cannot clip, -1 -\n\t\t\t\t\t\t\t\t// unknown\n\t\tint v_next = v_cur;\n\t\tint clip_count = 0;\n\t\tcnt = 1;\n\t\twhile (v_next != to_vertex) {\n\t\t\tv_next = edit_shape.getNextVertex(v_next, dir);\n\t\t\tint next_location = locations[cnt++];\n\t\t\tif (next_location == 0) {\n\t\t\t\tif (v_next == to_vertex)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPoint2D pt_next = edit_shape.getXY(v_next);\n\n\t\t\tif (prev_location != -1) {\n\t\t\t\tint common_location = (prev_location & cur_location & next_location);\n\t\t\t\tif ((common_location & 3) != 0) {\n\t\t\t\t\t// prev and next are on the same semiplane as the current we\n\t\t\t\t\t// can safely remove the current point.\n\t\t\t\t\tedit_shape.removeVertex(v_cur, true);\n\t\t\t\t\tclip_count++;// do not change prev point.\n\t\t\t\t\tv_cur = v_next;\n\t\t\t\t\tpt_cur.setCoords(pt_next);\n\t\t\t\t\tcur_location = next_location;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cur_location == 3 && prev_location != 0\n\t\t\t\t\t\t&& next_location != 0) {\n\t\t\t\t\tassert ((prev_location & next_location) == 0);// going from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// one semi\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// plane to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// another\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// via the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// mid.\n\t\t\t\t\tpt_cur.setCoords(corner);\n\t\t\t\t\tif (can_erase_corner_point || pt_cur.equals(pt_prev)) {// this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// can\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\tedit_shape.removeVertex(v_cur, true);\n\t\t\t\t\t\tclip_count++;// do not change prev point.\n\t\t\t\t\t\tv_cur = v_next;\n\t\t\t\t\t\tpt_cur.setCoords(pt_next);\n\t\t\t\t\t\tcur_location = next_location;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedit_shape.setXY(v_cur, pt_cur); // snap to the corner\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (next_location == 0\n\t\t\t\t\t\t\t&& cur_location != 0\n\t\t\t\t\t\t\t|| next_location != 0\n\t\t\t\t\t\t\t&& cur_location == 0\n\t\t\t\t\t\t\t|| ((next_location | cur_location) == 3\n\t\t\t\t\t\t\t\t\t&& next_location != 3 && cur_location != 3)) {\n\t\t\t\t\t\t// clip\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev_location = cur_location;\n\t\t\tv_prev = v_cur;\n\t\t\tpt_prev.setCoords(pt_cur);\n\t\t\tv_cur = v_next;\n\t\t\tcur_location = next_location;\n\t\t\tpt_cur.setCoords(pt_next);\n\t\t}\n\n\t\treturn clip_count;\n\t}", "code_tokens": ["private", "static", "int", "clipFilter_", "(", "EditShape", "edit_shape", ",", "int", "fixed_vertices_index", ",", "int", "from_vertex", ",", "int", "to_vertex", ",", "int", "dir", ",", "double", "abs_distance", ",", "double", "densify_distance", ",", "final", "int", "max_filter", ")", "{", "// Note: vertices marked with fixed_vertices_index cannot be deleted.", "Point2D", "pt1", "=", "edit_shape", ".", "getXY", "(", "from_vertex", ")", ";", "Point2D", "pt2", "=", "edit_shape", ".", "getXY", "(", "to_vertex", ")", ";", "if", "(", "pt1", ".", "equals", "(", "pt2", ")", ")", "return", "-", "1", ";", "double", "densify_distance_delta", "=", "densify_distance", "*", "0.25", ";", "// distance by", "// which we can", "// move the", "// point closer", "// to the chord", "// (introducing", "// an error into", "// the buffer).", "double", "erase_distance_delta", "=", "densify_distance", "*", "0.25", ";", "// distance when", "// we can erase", "// the point", "// (introducing", "// an error into", "// the buffer).", "// This function goal is to modify or remove vertices between", "// from_vertex and to_vertex in such a way that the result would not", "// affect buffer to the left of the", "// chain.", "Point2D", "v_gap", "=", "new", "Point2D", "(", ")", ";", "v_gap", ".", "sub", "(", "pt2", ",", "pt1", ")", ";", "double", "gap_length", "=", "v_gap", ".", "length", "(", ")", ";", "double", "h2_4", "=", "gap_length", "*", "gap_length", "*", "0.25", ";", "double", "sqr_center_to_chord", "=", "abs_distance", "*", "abs_distance", "-", "h2_4", ";", "// squared", "// distance", "// from", "// the", "// chord", "// to", "// the", "// circle", "// center", "if", "(", "sqr_center_to_chord", "<=", "h2_4", ")", "return", "-", "1", ";", "// center to chord distance is less than half gap, that", "// means the gap is too wide for useful filtering (maybe", "// this).", "double", "center_to_chord", "=", "Math", ".", "sqrt", "(", "sqr_center_to_chord", ")", ";", "// distance", "// from", "// circle", "// center to", "// the", "// chord.", "v_gap", ".", "normalize", "(", ")", ";", "Point2D", "v_gap_norm", "=", "new", "Point2D", "(", "v_gap", ")", ";", "v_gap_norm", ".", "rightPerpendicular", "(", ")", ";", "double", "chord_to_corner", "=", "h2_4", "/", "center_to_chord", ";", "// cos(a) =", "// center_to_chord /", "// distance;", "// chord_to_corner =", "// distance / cos(a)", "// -", "// center_to_chord;", "boolean", "can_erase_corner_point", "=", "chord_to_corner", "<=", "erase_distance_delta", ";", "Point2D", "chord_midpoint", "=", "new", "Point2D", "(", ")", ";", "MathUtils", ".", "lerp", "(", "pt2", ",", "pt1", ",", "0.5", ",", "chord_midpoint", ")", ";", "Point2D", "corner", "=", "new", "Point2D", "(", "v_gap_norm", ")", ";", "double", "corrected_chord_to_corner", "=", "chord_to_corner", "-", "densify_distance_delta", ";", "// using slightly smaller than needed", "// distance let us filter more.", "corner", ".", "scaleAdd", "(", "Math", ".", "max", "(", "0.0", ",", "corrected_chord_to_corner", ")", ",", "chord_midpoint", ")", ";", "// corner = (p1 + p2) * 0.5 + v_gap_norm * chord_to_corner;", "Point2D", "center", "=", "new", "Point2D", "(", "v_gap_norm", ")", ";", "center", ".", "negate", "(", ")", ";", "center", ".", "scaleAdd", "(", "center_to_chord", ",", "chord_midpoint", ")", ";", "double", "allowed_distance", "=", "abs_distance", "-", "erase_distance_delta", ";", "double", "sqr_allowed_distance", "=", "MathUtils", ".", "sqr", "(", "allowed_distance", ")", ";", "double", "sqr_large_distance", "=", "sqr_allowed_distance", "*", "(", "1.9", "*", "1.9", ")", ";", "Point2D", "co_p1", "=", "new", "Point2D", "(", ")", ";", "co_p1", ".", "sub", "(", "corner", ",", "pt1", ")", ";", "Point2D", "co_p2", "=", "new", "Point2D", "(", ")", ";", "co_p2", ".", "sub", "(", "corner", ",", "pt2", ")", ";", "boolean", "large_distance", "=", "false", ";", "// set to true when distance", "int", "cnt", "=", "0", ";", "char", "[", "]", "locations", "=", "new", "char", "[", "64", "]", ";", "{", "// check all vertices in the gap verifying that the gap can be", "// clipped.", "//", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "// firstly remove any duplicate vertices in the end.", "for", "(", "int", "v", "=", "edit_shape", ".", "getPrevVertex", "(", "to_vertex", ",", "dir", ")", ";", "v", "!=", "from_vertex", ";", ")", "{", "if", "(", "edit_shape", ".", "getUserIndex", "(", "v", ",", "fixed_vertices_index", ")", "==", "1", ")", "return", "-", "1", ";", "// this range contains protected vertex", "edit_shape", ".", "getXY", "(", "v", ",", "pt", ")", ";", "if", "(", "pt", ".", "equals", "(", "pt2", ")", ")", "{", "int", "v1", "=", "edit_shape", ".", "getPrevVertex", "(", "v", ",", "dir", ")", ";", "edit_shape", ".", "removeVertex", "(", "v", ",", "false", ")", ";", "v", "=", "v1", ";", "continue", ";", "}", "else", "{", "break", ";", "}", "}", "Point2D", "prev_prev_pt", "=", "new", "Point2D", "(", ")", ";", "prev_prev_pt", ".", "setNaN", "(", ")", ";", "Point2D", "prev_pt", "=", "new", "Point2D", "(", ")", ";", "prev_pt", ".", "setCoords", "(", "pt1", ")", ";", "locations", "[", "cnt", "++", "]", "=", "1", ";", "int", "prev_v", "=", "from_vertex", ";", "Point2D", "dummyPt", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "v", "=", "edit_shape", ".", "getNextVertex", "(", "from_vertex", ",", "dir", ")", ";", "v", "!=", "to_vertex", ";", ")", "{", "if", "(", "edit_shape", ".", "getUserIndex", "(", "v", ",", "fixed_vertices_index", ")", "==", "1", ")", "return", "-", "1", ";", "// this range contains protected vertex", "edit_shape", ".", "getXY", "(", "v", ",", "pt", ")", ";", "if", "(", "pt", ".", "equals", "(", "prev_pt", ")", ")", "{", "int", "v1", "=", "edit_shape", ".", "getNextVertex", "(", "v", ",", "dir", ")", ";", "edit_shape", ".", "removeVertex", "(", "v", ",", "false", ")", ";", "v", "=", "v1", ";", "continue", ";", "}", "locations", "[", "cnt", "++", "]", "=", "0", ";", "Point2D", "v1", "=", "new", "Point2D", "(", ")", ";", "v1", ".", "sub", "(", "pt", ",", "pt1", ")", ";", "if", "(", "v1", ".", "dotProduct", "(", "v_gap_norm", ")", "<", "0", ")", "// we are crossing on the", "// wrong site of the chord.", "// Just bail out earlier.", "// Maybe we could continue", "// clipping though here, but", "// it seems to be", "// unnecessary complicated.", "return", "0", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt", ",", "pt1", ")", ">", "sqr_large_distance", "||", "Point2D", ".", "sqrDistance", "(", "pt", ",", "pt2", ")", ">", "sqr_large_distance", ")", "large_distance", "=", "true", ";", "// too far from points, may", "// contribute to the outline (in", "// case of a large loop)", "char", "next_location", "=", "0", ";", "dummyPt", ".", "sub", "(", "pt", ",", "pt1", ")", ";", "double", "cs1", "=", "dummyPt", ".", "crossProduct", "(", "co_p1", ")", ";", "if", "(", "cs1", ">=", "0", ")", "{", "next_location", "=", "1", ";", "}", "dummyPt", ".", "sub", "(", "pt", ",", "pt2", ")", ";", "double", "cs2", "=", "dummyPt", ".", "crossProduct", "(", "co_p2", ")", ";", "if", "(", "cs2", "<=", "0", ")", "{", "next_location", "|=", "2", ";", "}", "if", "(", "next_location", "==", "0", ")", "return", "0", ";", "locations", "[", "cnt", "-", "1", "]", "=", "next_location", ";", "prev_prev_pt", ".", "setCoords", "(", "prev_pt", ")", ";", "prev_pt", ".", "setCoords", "(", "pt", ")", ";", "prev_v", "=", "v", ";", "v", "=", "edit_shape", ".", "getNextVertex", "(", "v", ",", "dir", ")", ";", "}", "if", "(", "cnt", "==", "1", ")", "return", "0", ";", "assert", "(", "!", "pt2", ".", "equals", "(", "prev_pt", ")", ")", ";", "locations", "[", "cnt", "++", "]", "=", "2", ";", "}", "boolean", "can_clip_all", "=", "true", ";", "// we can remove all points and replace them with a single corner point", "// if we are moving from location 1 via location 3 to location 2", "for", "(", "int", "i", "=", "1", ",", "k", "=", "0", ";", "i", "<", "cnt", ";", "i", "++", ")", "{", "if", "(", "locations", "[", "i", "]", "!=", "locations", "[", "i", "-", "1", "]", ")", "{", "k", "++", ";", "can_clip_all", "=", "k", "<", "3", "&&", "(", "(", "k", "==", "1", "&&", "locations", "[", "i", "]", "==", "3", ")", "||", "(", "k", "==", "2", "&&", "locations", "[", "i", "]", "==", "2", ")", ")", ";", "if", "(", "!", "can_clip_all", ")", "return", "0", ";", "}", "}", "if", "(", "cnt", ">", "2", "&&", "can_clip_all", "&&", "(", "cnt", "==", "3", "||", "!", "large_distance", ")", ")", "{", "int", "clip_count", "=", "0", ";", "int", "v", "=", "edit_shape", ".", "getNextVertex", "(", "from_vertex", ",", "dir", ")", ";", "if", "(", "!", "can_erase_corner_point", ")", "{", "edit_shape", ".", "setXY", "(", "v", ",", "corner", ")", ";", "v", "=", "edit_shape", ".", "getNextVertex", "(", "v", ",", "dir", ")", ";", "}", "// we can remove all vertices between from and to, because they", "// don't contribute", "while", "(", "v", "!=", "to_vertex", ")", "{", "int", "v1", "=", "edit_shape", ".", "getNextVertex", "(", "v", ",", "dir", ")", ";", "edit_shape", ".", "removeVertex", "(", "v", ",", "false", ")", ";", "v", "=", "v1", ";", "++", "clip_count", ";", "}", "return", "clip_count", ";", "}", "if", "(", "cnt", "==", "3", ")", "{", "boolean", "case1", "=", "(", "locations", "[", "0", "]", "==", "1", "&&", "locations", "[", "1", "]", "==", "2", "&&", "locations", "[", "2", "]", "==", "2", ")", ";", "boolean", "case2", "=", "(", "locations", "[", "0", "]", "==", "1", "&&", "locations", "[", "1", "]", "==", "1", "&&", "locations", "[", "2", "]", "==", "2", ")", ";", "if", "(", "case1", "||", "case2", ")", "{", "// special case, when we cannot clip, but we can move the point", "Point2D", "p1", "=", "edit_shape", ".", "getXY", "(", "from_vertex", ")", ";", "int", "v", "=", "edit_shape", ".", "getNextVertex", "(", "from_vertex", ",", "dir", ")", ";", "Point2D", "p2", "=", "edit_shape", ".", "getXY", "(", "v", ")", ";", "Point2D", "p3", "=", "edit_shape", ".", "getXY", "(", "edit_shape", ".", "getNextVertex", "(", "v", ",", "dir", ")", ")", ";", "if", "(", "case2", ")", "{", "Point2D", "temp", "=", "p1", ";", "p1", "=", "p3", ";", "p3", "=", "temp", ";", "}", "Point2D", "vec", "=", "new", "Point2D", "(", ")", ";", "vec", ".", "sub", "(", "p1", ",", "p2", ")", ";", "p3", ".", "sub", "(", "p2", ")", ";", "double", "veclen", "=", "vec", ".", "length", "(", ")", ";", "double", "w", "=", "p3", ".", "length", "(", ")", ";", "double", "wcosa", "=", "vec", ".", "dotProduct", "(", "p3", ")", "/", "veclen", ";", "double", "wsina", "=", "Math", ".", "abs", "(", "p3", ".", "crossProduct", "(", "vec", ")", "/", "veclen", ")", ";", "double", "z", "=", "2", "*", "abs_distance", "-", "wsina", ";", "if", "(", "z", "<", "0", ")", "return", "0", ";", "double", "x", "=", "wcosa", "+", "Math", ".", "sqrt", "(", "wsina", "*", "z", ")", ";", "if", "(", "x", ">", "veclen", ")", "return", "0", ";", "Point2D", "hvec", "=", "new", "Point2D", "(", ")", ";", "hvec", ".", "scaleAdd", "(", "-", "x", "/", "veclen", ",", "vec", ",", "p3", ")", ";", "// hvec = p3 - vec * (x /", "// veclen);", "double", "h", "=", "hvec", ".", "length", "(", ")", ";", "double", "y", "=", "-", "(", "h", "*", "h", "*", "veclen", ")", "/", "(", "2", "*", "hvec", ".", "dotProduct", "(", "vec", ")", ")", ";", "double", "t", "=", "(", "x", "-", "y", ")", "/", "veclen", ";", "MathUtils", ".", "lerp", "(", "p2", ",", "p1", ",", "t", ",", "p2", ")", ";", "edit_shape", ".", "setXY", "(", "v", ",", "p2", ")", ";", "return", "0", ";", "}", "}", "if", "(", "large_distance", "&&", "cnt", ">", "3", ")", "{", "// we are processing more than 3 points and there are some points", "// further than the", "return", "0", ";", "}", "int", "v_prev", "=", "-", "1", ";", "Point2D", "pt_prev", "=", "new", "Point2D", "(", ")", ";", "int", "v_cur", "=", "from_vertex", ";", "Point2D", "pt_cur", "=", "new", "Point2D", "(", "pt1", ")", ";", "int", "cur_location", "=", "1", ";", "int", "prev_location", "=", "-", "1", ";", "// 1 - semiplane to the right of [f,c]. 3 -", "// semiplane to the right of [c,t], 2 - both", "// above fc and ct, 0 - cannot clip, -1 -", "// unknown", "int", "v_next", "=", "v_cur", ";", "int", "clip_count", "=", "0", ";", "cnt", "=", "1", ";", "while", "(", "v_next", "!=", "to_vertex", ")", "{", "v_next", "=", "edit_shape", ".", "getNextVertex", "(", "v_next", ",", "dir", ")", ";", "int", "next_location", "=", "locations", "[", "cnt", "++", "]", ";", "if", "(", "next_location", "==", "0", ")", "{", "if", "(", "v_next", "==", "to_vertex", ")", "break", ";", "continue", ";", "}", "Point2D", "pt_next", "=", "edit_shape", ".", "getXY", "(", "v_next", ")", ";", "if", "(", "prev_location", "!=", "-", "1", ")", "{", "int", "common_location", "=", "(", "prev_location", "&", "cur_location", "&", "next_location", ")", ";", "if", "(", "(", "common_location", "&", "3", ")", "!=", "0", ")", "{", "// prev and next are on the same semiplane as the current we", "// can safely remove the current point.", "edit_shape", ".", "removeVertex", "(", "v_cur", ",", "true", ")", ";", "clip_count", "++", ";", "// do not change prev point.", "v_cur", "=", "v_next", ";", "pt_cur", ".", "setCoords", "(", "pt_next", ")", ";", "cur_location", "=", "next_location", ";", "continue", ";", "}", "if", "(", "cur_location", "==", "3", "&&", "prev_location", "!=", "0", "&&", "next_location", "!=", "0", ")", "{", "assert", "(", "(", "prev_location", "&", "next_location", ")", "==", "0", ")", ";", "// going from", "// one semi", "// plane to", "// another", "// via the", "// mid.", "pt_cur", ".", "setCoords", "(", "corner", ")", ";", "if", "(", "can_erase_corner_point", "||", "pt_cur", ".", "equals", "(", "pt_prev", ")", ")", "{", "// this", "// point", "// can", "// be", "// removed", "edit_shape", ".", "removeVertex", "(", "v_cur", ",", "true", ")", ";", "clip_count", "++", ";", "// do not change prev point.", "v_cur", "=", "v_next", ";", "pt_cur", ".", "setCoords", "(", "pt_next", ")", ";", "cur_location", "=", "next_location", ";", "continue", ";", "}", "else", "{", "edit_shape", ".", "setXY", "(", "v_cur", ",", "pt_cur", ")", ";", "// snap to the corner", "}", "}", "else", "{", "if", "(", "next_location", "==", "0", "&&", "cur_location", "!=", "0", "||", "next_location", "!=", "0", "&&", "cur_location", "==", "0", "||", "(", "(", "next_location", "|", "cur_location", ")", "==", "3", "&&", "next_location", "!=", "3", "&&", "cur_location", "!=", "3", ")", ")", "{", "// clip", "}", "}", "}", "prev_location", "=", "cur_location", ";", "v_prev", "=", "v_cur", ";", "pt_prev", ".", "setCoords", "(", "pt_cur", ")", ";", "v_cur", "=", "v_next", ";", "cur_location", "=", "next_location", ";", "pt_cur", ".", "setCoords", "(", "pt_next", ")", ";", "}", "return", "clip_count", ";", "}"], "docstring": "they do not contribute to the buffer.", "docstring_tokens": ["they", "do", "not", "contribute", "to", "the", "buffer", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Bufferer.java#L1419-L1763", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SimpleRasterizer.java", "func_name": "SimpleRasterizer.setup", "original_string": "public void setup(int width, int height, ScanCallback callback)\n\t{\n\t\twidth_ = width; height_ = height;\n\t\tySortedEdges_ = null;\n\t\tactiveEdgesTable_ = null;\n\t\tnumEdges_ = 0;\n\t\tcallback_ = callback;\n\t\tif (scanBuffer_ == null)\n\t\t\tscanBuffer_ = new int[128 * 3];\n\t\t\n\t\tstartAddingEdges();\n\t}", "language": "java", "code": "public void setup(int width, int height, ScanCallback callback)\n\t{\n\t\twidth_ = width; height_ = height;\n\t\tySortedEdges_ = null;\n\t\tactiveEdgesTable_ = null;\n\t\tnumEdges_ = 0;\n\t\tcallback_ = callback;\n\t\tif (scanBuffer_ == null)\n\t\t\tscanBuffer_ = new int[128 * 3];\n\t\t\n\t\tstartAddingEdges();\n\t}", "code_tokens": ["public", "void", "setup", "(", "int", "width", ",", "int", "height", ",", "ScanCallback", "callback", ")", "{", "width_", "=", "width", ";", "height_", "=", "height", ";", "ySortedEdges_", "=", "null", ";", "activeEdgesTable_", "=", "null", ";", "numEdges_", "=", "0", ";", "callback_", "=", "callback", ";", "if", "(", "scanBuffer_", "==", "null", ")", "scanBuffer_", "=", "new", "int", "[", "128", "*", "3", "]", ";", "startAddingEdges", "(", ")", ";", "}"], "docstring": "Sets up the rasterizer.", "docstring_tokens": ["Sets", "up", "the", "rasterizer", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SimpleRasterizer.java#L69-L80", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SimpleRasterizer.java", "func_name": "SimpleRasterizer.addTriangle", "original_string": "public final void addTriangle(double x1, double y1, double x2, double y2, double x3, double y3) {\n\t\taddEdge(x1, y1, x2, y2);\n\t\taddEdge(x2, y2, x3, y3);\n\t\taddEdge(x1, y1, x3, y3);\n\t}", "language": "java", "code": "public final void addTriangle(double x1, double y1, double x2, double y2, double x3, double y3) {\n\t\taddEdge(x1, y1, x2, y2);\n\t\taddEdge(x2, y2, x3, y3);\n\t\taddEdge(x1, y1, x3, y3);\n\t}", "code_tokens": ["public", "final", "void", "addTriangle", "(", "double", "x1", ",", "double", "y1", ",", "double", "x2", ",", "double", "y2", ",", "double", "x3", ",", "double", "y3", ")", "{", "addEdge", "(", "x1", ",", "y1", ",", "x2", ",", "y2", ")", ";", "addEdge", "(", "x2", ",", "y2", ",", "x3", ",", "y3", ")", ";", "addEdge", "(", "x1", ",", "y1", ",", "x3", ",", "y3", ")", ";", "}"], "docstring": "Adds edges of a triangle.", "docstring_tokens": ["Adds", "edges", "of", "a", "triangle", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SimpleRasterizer.java#L103-L107", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SimpleRasterizer.java", "func_name": "SimpleRasterizer.addRing", "original_string": "public final void addRing(double xy[]) {\n\t\tfor (int i = 2; i < xy.length; i += 2) {\n\t\t\taddEdge(xy[i-2], xy[i - 1], xy[i], xy[i + 1]);\n\t\t}\n\t}", "language": "java", "code": "public final void addRing(double xy[]) {\n\t\tfor (int i = 2; i < xy.length; i += 2) {\n\t\t\taddEdge(xy[i-2], xy[i - 1], xy[i], xy[i + 1]);\n\t\t}\n\t}", "code_tokens": ["public", "final", "void", "addRing", "(", "double", "xy", "[", "]", ")", "{", "for", "(", "int", "i", "=", "2", ";", "i", "<", "xy", ".", "length", ";", "i", "+=", "2", ")", "{", "addEdge", "(", "xy", "[", "i", "-", "2", "]", ",", "xy", "[", "i", "-", "1", "]", ",", "xy", "[", "i", "]", ",", "xy", "[", "i", "+", "1", "]", ")", ";", "}", "}"], "docstring": "Adds edges of the ring to the rasterizer.\n@param xy interleaved coordinates x1, y1, x2, y2,...", "docstring_tokens": ["Adds", "edges", "of", "the", "ring", "to", "the", "rasterizer", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SimpleRasterizer.java#L113-L117", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SimpleRasterizer.java", "func_name": "SimpleRasterizer.startAddingEdges", "original_string": "public final void startAddingEdges() {\n\t\tif (numEdges_ > 0) {\n\t\t\tfor (int i = 0; i < height_; i++) {\n\t\t\t\tfor (Edge e = ySortedEdges_[i]; e != null;) {\n\t\t\t\t\tEdge p = e;\n\t\t\t\t\te = e.next;\n\t\t\t\t\tp.next = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tySortedEdges_[i] = null;\n\t\t\t}\n\n\t\t\tactiveEdgesTable_ = null;\n\t\t}\n\t\t\n\t\tminY_ = height_;\n\t\tmaxY_ = -1;\n\t\tnumEdges_ = 0;\t\n\t}", "language": "java", "code": "public final void startAddingEdges() {\n\t\tif (numEdges_ > 0) {\n\t\t\tfor (int i = 0; i < height_; i++) {\n\t\t\t\tfor (Edge e = ySortedEdges_[i]; e != null;) {\n\t\t\t\t\tEdge p = e;\n\t\t\t\t\te = e.next;\n\t\t\t\t\tp.next = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tySortedEdges_[i] = null;\n\t\t\t}\n\n\t\t\tactiveEdgesTable_ = null;\n\t\t}\n\t\t\n\t\tminY_ = height_;\n\t\tmaxY_ = -1;\n\t\tnumEdges_ = 0;\t\n\t}", "code_tokens": ["public", "final", "void", "startAddingEdges", "(", ")", "{", "if", "(", "numEdges_", ">", "0", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "height_", ";", "i", "++", ")", "{", "for", "(", "Edge", "e", "=", "ySortedEdges_", "[", "i", "]", ";", "e", "!=", "null", ";", ")", "{", "Edge", "p", "=", "e", ";", "e", "=", "e", ".", "next", ";", "p", ".", "next", "=", "null", ";", "}", "ySortedEdges_", "[", "i", "]", "=", "null", ";", "}", "activeEdgesTable_", "=", "null", ";", "}", "minY_", "=", "height_", ";", "maxY_", "=", "-", "1", ";", "numEdges_", "=", "0", ";", "}"], "docstring": "Call before starting the edges.\n\nFor example to render two polygons that consist of a single ring:\nstartAddingEdges();\naddRing(...);\nrenderEdges(Rasterizer.EVEN_ODD);\naddRing(...);\nrenderEdges(Rasterizer.EVEN_ODD);\n\nFor example to render a polygon consisting of three rings:\nstartAddingEdges();\naddRing(...);\naddRing(...);\naddRing(...);\nrenderEdges(Rasterizer.EVEN_ODD);", "docstring_tokens": ["Call", "before", "starting", "the", "edges", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SimpleRasterizer.java#L136-L154", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SimpleRasterizer.java", "func_name": "SimpleRasterizer.renderEdges", "original_string": "public final void renderEdges(int fillMode) {\n\t\tevenOdd_ = fillMode == EVEN_ODD;\n\t\tfor (int line = minY_; line <= maxY_; line++) {\n\t\t\tadvanceAET_();\n\t\t\taddNewEdgesToAET_(line);\n\t\t\temitScans_();\n\t\t}\n\t\t\n\t\tstartAddingEdges();//reset for new edges\n\t}", "language": "java", "code": "public final void renderEdges(int fillMode) {\n\t\tevenOdd_ = fillMode == EVEN_ODD;\n\t\tfor (int line = minY_; line <= maxY_; line++) {\n\t\t\tadvanceAET_();\n\t\t\taddNewEdgesToAET_(line);\n\t\t\temitScans_();\n\t\t}\n\t\t\n\t\tstartAddingEdges();//reset for new edges\n\t}", "code_tokens": ["public", "final", "void", "renderEdges", "(", "int", "fillMode", ")", "{", "evenOdd_", "=", "fillMode", "==", "EVEN_ODD", ";", "for", "(", "int", "line", "=", "minY_", ";", "line", "<=", "maxY_", ";", "line", "++", ")", "{", "advanceAET_", "(", ")", ";", "addNewEdgesToAET_", "(", "line", ")", ";", "emitScans_", "(", ")", ";", "}", "startAddingEdges", "(", ")", ";", "//reset for new edges", "}"], "docstring": "Renders all edges added so far, and removes them.\nCalls startAddingEdges after it's done.\n@param fillMode Fill mode for the polygon fill can be one of two values: EVEN_ODD or WINDING.\n\nNote, as any other graphics algorithm, the scan line rasterizer doesn't require polygons\nto be topologically simple, or have correct ring orientation.", "docstring_tokens": ["Renders", "all", "edges", "added", "so", "far", "and", "removes", "them", ".", "Calls", "startAddingEdges", "after", "it", "s", "done", ".", "@param", "fillMode", "Fill", "mode", "for", "the", "polygon", "fill", "can", "be", "one", "of", "two", "values", ":", "EVEN_ODD", "or", "WINDING", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SimpleRasterizer.java#L164-L173", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SimpleRasterizer.java", "func_name": "SimpleRasterizer.addEdge", "original_string": "public final void addEdge(double x1, double y1, double x2, double y2) {\n\t\tif (y1 == y2)\n\t\t\treturn;\n\t\t\t\n\t\tint dir = 1;\n\t\tif (y1 > y2) {\n\t\t\tdouble temp;\n\t\t\ttemp = x1; x1 = x2; x2 = temp;\n\t\t\ttemp = y1; y1 = y2; y2 = temp;\n\t\t\tdir = -1;\n\t\t}\n\t\t\n\t\tif (y2 < 0 || y1 >= height_)\n\t\t\treturn;\n\n\t\tif (x1 < 0 && x2 < 0)\n\t\t{\n\t\t\tx1 = -1; x2 = -1;\n\t\t}\n\t\telse if (x1 >= width_ && x2 >= width_)\n\t\t{\n\t\t\tx1 = width_; x2 = width_;\n\t\t}\n\t\t\n\t\t//clip to extent\n\t\tdouble dxdy = (x2 - x1) / (y2 - y1);\n\n\t\tif (y2 > height_) {\n\t\t\ty2 = height_;\n\t\t\tx2 = dxdy * (y2 - y1) + x1;\n\t\t}\n\t\t\n\t\tif (y1 < 0) {\n\t\t\tx1 = dxdy * (0 - y1) + x1;\n\t\t\ty1 = 0;\n\t\t}\n\n\t\t//do not clip x unless it is too small or too big\n\t\tint bigX = Math.max(width_ + 1, 0x7fffff);\n\t\tif (x1 < -0x7fffff) {\n\t\t    //from earlier logic, x2 >= -1, therefore dxdy is not 0\n\t\t\ty1 = (0 - x1) / dxdy + y1;\n\t\t\tx1 = 0;\n\t\t}\n\t\telse if (x1 > bigX) {\n\t\t\t//from earlier logic, x2 <= width_, therefore dxdy is not 0\n\t\t\ty1 = (width_ - x1) / dxdy + y1;\n\t\t\tx1 = width_;\n\t\t}\n\n\t\tif (x2 < -0x7fffff) {\n\t\t\t//from earlier logic, x1 >= -1, therefore dxdy is not 0\n\t\t\ty2 = (0 - x1) / dxdy + y1;\n\t\t\tx2 = 0;\n\t\t}\n\t\telse if (x2 > bigX) {\n\t\t\t//from earlier logic, x1 <= width_, therefore dxdy is not 0\n\t\t\ty2 = (width_ - x1) / dxdy + y1;\n\t\t\tx2 = width_;\n\t\t}\n\t\t\n\t\tint ystart = (int)y1;\n\t\tint yend = (int)y2;\n\t\tif (ystart == yend)\n\t\t\treturn;\n\t\t\n\t\tEdge e = new Edge();\n\t\t\n\t\te.x = (long)(x1 * 4294967296.0);\n\t\te.y = ystart;\n\t\te.ymax = yend;\n\t\te.dxdy = (long)(dxdy * 4294967296.0);\n\t\te.dir = dir;\n\t\t\n\t\tif (ySortedEdges_ == null) {\n\t\t\tySortedEdges_ = new Edge[height_];\n\t\t}\n\n\t\te.next = ySortedEdges_[e.y];\n\t\tySortedEdges_[e.y] = e;\n\t\t\n\t\tif (e.y < minY_)\n\t\t\tminY_ = e.y;\n\t\t\n\t\tif (e.ymax > maxY_)\n\t\t\tmaxY_ = e.ymax;\n\t\t\n\t\tnumEdges_++;\n\t}", "language": "java", "code": "public final void addEdge(double x1, double y1, double x2, double y2) {\n\t\tif (y1 == y2)\n\t\t\treturn;\n\t\t\t\n\t\tint dir = 1;\n\t\tif (y1 > y2) {\n\t\t\tdouble temp;\n\t\t\ttemp = x1; x1 = x2; x2 = temp;\n\t\t\ttemp = y1; y1 = y2; y2 = temp;\n\t\t\tdir = -1;\n\t\t}\n\t\t\n\t\tif (y2 < 0 || y1 >= height_)\n\t\t\treturn;\n\n\t\tif (x1 < 0 && x2 < 0)\n\t\t{\n\t\t\tx1 = -1; x2 = -1;\n\t\t}\n\t\telse if (x1 >= width_ && x2 >= width_)\n\t\t{\n\t\t\tx1 = width_; x2 = width_;\n\t\t}\n\t\t\n\t\t//clip to extent\n\t\tdouble dxdy = (x2 - x1) / (y2 - y1);\n\n\t\tif (y2 > height_) {\n\t\t\ty2 = height_;\n\t\t\tx2 = dxdy * (y2 - y1) + x1;\n\t\t}\n\t\t\n\t\tif (y1 < 0) {\n\t\t\tx1 = dxdy * (0 - y1) + x1;\n\t\t\ty1 = 0;\n\t\t}\n\n\t\t//do not clip x unless it is too small or too big\n\t\tint bigX = Math.max(width_ + 1, 0x7fffff);\n\t\tif (x1 < -0x7fffff) {\n\t\t    //from earlier logic, x2 >= -1, therefore dxdy is not 0\n\t\t\ty1 = (0 - x1) / dxdy + y1;\n\t\t\tx1 = 0;\n\t\t}\n\t\telse if (x1 > bigX) {\n\t\t\t//from earlier logic, x2 <= width_, therefore dxdy is not 0\n\t\t\ty1 = (width_ - x1) / dxdy + y1;\n\t\t\tx1 = width_;\n\t\t}\n\n\t\tif (x2 < -0x7fffff) {\n\t\t\t//from earlier logic, x1 >= -1, therefore dxdy is not 0\n\t\t\ty2 = (0 - x1) / dxdy + y1;\n\t\t\tx2 = 0;\n\t\t}\n\t\telse if (x2 > bigX) {\n\t\t\t//from earlier logic, x1 <= width_, therefore dxdy is not 0\n\t\t\ty2 = (width_ - x1) / dxdy + y1;\n\t\t\tx2 = width_;\n\t\t}\n\t\t\n\t\tint ystart = (int)y1;\n\t\tint yend = (int)y2;\n\t\tif (ystart == yend)\n\t\t\treturn;\n\t\t\n\t\tEdge e = new Edge();\n\t\t\n\t\te.x = (long)(x1 * 4294967296.0);\n\t\te.y = ystart;\n\t\te.ymax = yend;\n\t\te.dxdy = (long)(dxdy * 4294967296.0);\n\t\te.dir = dir;\n\t\t\n\t\tif (ySortedEdges_ == null) {\n\t\t\tySortedEdges_ = new Edge[height_];\n\t\t}\n\n\t\te.next = ySortedEdges_[e.y];\n\t\tySortedEdges_[e.y] = e;\n\t\t\n\t\tif (e.y < minY_)\n\t\t\tminY_ = e.y;\n\t\t\n\t\tif (e.ymax > maxY_)\n\t\t\tmaxY_ = e.ymax;\n\t\t\n\t\tnumEdges_++;\n\t}", "code_tokens": ["public", "final", "void", "addEdge", "(", "double", "x1", ",", "double", "y1", ",", "double", "x2", ",", "double", "y2", ")", "{", "if", "(", "y1", "==", "y2", ")", "return", ";", "int", "dir", "=", "1", ";", "if", "(", "y1", ">", "y2", ")", "{", "double", "temp", ";", "temp", "=", "x1", ";", "x1", "=", "x2", ";", "x2", "=", "temp", ";", "temp", "=", "y1", ";", "y1", "=", "y2", ";", "y2", "=", "temp", ";", "dir", "=", "-", "1", ";", "}", "if", "(", "y2", "<", "0", "||", "y1", ">=", "height_", ")", "return", ";", "if", "(", "x1", "<", "0", "&&", "x2", "<", "0", ")", "{", "x1", "=", "-", "1", ";", "x2", "=", "-", "1", ";", "}", "else", "if", "(", "x1", ">=", "width_", "&&", "x2", ">=", "width_", ")", "{", "x1", "=", "width_", ";", "x2", "=", "width_", ";", "}", "//clip to extent", "double", "dxdy", "=", "(", "x2", "-", "x1", ")", "/", "(", "y2", "-", "y1", ")", ";", "if", "(", "y2", ">", "height_", ")", "{", "y2", "=", "height_", ";", "x2", "=", "dxdy", "*", "(", "y2", "-", "y1", ")", "+", "x1", ";", "}", "if", "(", "y1", "<", "0", ")", "{", "x1", "=", "dxdy", "*", "(", "0", "-", "y1", ")", "+", "x1", ";", "y1", "=", "0", ";", "}", "//do not clip x unless it is too small or too big", "int", "bigX", "=", "Math", ".", "max", "(", "width_", "+", "1", ",", "0x7fffff", ")", ";", "if", "(", "x1", "<", "-", "0x7fffff", ")", "{", "//from earlier logic, x2 >= -1, therefore dxdy is not 0", "y1", "=", "(", "0", "-", "x1", ")", "/", "dxdy", "+", "y1", ";", "x1", "=", "0", ";", "}", "else", "if", "(", "x1", ">", "bigX", ")", "{", "//from earlier logic, x2 <= width_, therefore dxdy is not 0", "y1", "=", "(", "width_", "-", "x1", ")", "/", "dxdy", "+", "y1", ";", "x1", "=", "width_", ";", "}", "if", "(", "x2", "<", "-", "0x7fffff", ")", "{", "//from earlier logic, x1 >= -1, therefore dxdy is not 0", "y2", "=", "(", "0", "-", "x1", ")", "/", "dxdy", "+", "y1", ";", "x2", "=", "0", ";", "}", "else", "if", "(", "x2", ">", "bigX", ")", "{", "//from earlier logic, x1 <= width_, therefore dxdy is not 0", "y2", "=", "(", "width_", "-", "x1", ")", "/", "dxdy", "+", "y1", ";", "x2", "=", "width_", ";", "}", "int", "ystart", "=", "(", "int", ")", "y1", ";", "int", "yend", "=", "(", "int", ")", "y2", ";", "if", "(", "ystart", "==", "yend", ")", "return", ";", "Edge", "e", "=", "new", "Edge", "(", ")", ";", "e", ".", "x", "=", "(", "long", ")", "(", "x1", "*", "4294967296.0", ")", ";", "e", ".", "y", "=", "ystart", ";", "e", ".", "ymax", "=", "yend", ";", "e", ".", "dxdy", "=", "(", "long", ")", "(", "dxdy", "*", "4294967296.0", ")", ";", "e", ".", "dir", "=", "dir", ";", "if", "(", "ySortedEdges_", "==", "null", ")", "{", "ySortedEdges_", "=", "new", "Edge", "[", "height_", "]", ";", "}", "e", ".", "next", "=", "ySortedEdges_", "[", "e", ".", "y", "]", ";", "ySortedEdges_", "[", "e", ".", "y", "]", "=", "e", ";", "if", "(", "e", ".", "y", "<", "minY_", ")", "minY_", "=", "e", ".", "y", ";", "if", "(", "e", ".", "ymax", ">", "maxY_", ")", "maxY_", "=", "e", ".", "ymax", ";", "numEdges_", "++", ";", "}"], "docstring": "Add a single edge.\n@param x1\n@param y1\n@param x2\n@param y2", "docstring_tokens": ["Add", "a", "single", "edge", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SimpleRasterizer.java#L182-L270", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocal.java", "func_name": "OperatorSimplifyLocal.execute", "original_string": "@Override\n\tpublic GeometryCursor execute(GeometryCursor geoms,\n\t\t\tSpatialReference spatialRef, boolean bForceSimplify,\n\t\t\tProgressTracker progressTracker) {\n\t\treturn new OperatorSimplifyCursor(geoms, spatialRef, bForceSimplify,\n\t\t\t\tprogressTracker);\n\t}", "language": "java", "code": "@Override\n\tpublic GeometryCursor execute(GeometryCursor geoms,\n\t\t\tSpatialReference spatialRef, boolean bForceSimplify,\n\t\t\tProgressTracker progressTracker) {\n\t\treturn new OperatorSimplifyCursor(geoms, spatialRef, bForceSimplify,\n\t\t\t\tprogressTracker);\n\t}", "code_tokens": ["@", "Override", "public", "GeometryCursor", "execute", "(", "GeometryCursor", "geoms", ",", "SpatialReference", "spatialRef", ",", "boolean", "bForceSimplify", ",", "ProgressTracker", "progressTracker", ")", "{", "return", "new", "OperatorSimplifyCursor", "(", "geoms", ",", "spatialRef", ",", "bForceSimplify", ",", "progressTracker", ")", ";", "}"], "docstring": "Reviewed vs. Feb 8 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Feb", "8", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocal.java#L29-L35", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocal.java", "func_name": "OperatorSimplifyLocal.isSimpleAsFeature", "original_string": "@Override\n\tpublic boolean isSimpleAsFeature(Geometry geom,\n\t\t\tSpatialReference spatialRef, boolean bForceTest,\n\t\t\tNonSimpleResult result, ProgressTracker progressTracker) {\n\t\tint res = OperatorSimplifyLocalHelper.isSimpleAsFeature(geom,\n\t\t\t\tspatialRef, bForceTest, result, progressTracker);\n\t\treturn res > 0;\n\t}", "language": "java", "code": "@Override\n\tpublic boolean isSimpleAsFeature(Geometry geom,\n\t\t\tSpatialReference spatialRef, boolean bForceTest,\n\t\t\tNonSimpleResult result, ProgressTracker progressTracker) {\n\t\tint res = OperatorSimplifyLocalHelper.isSimpleAsFeature(geom,\n\t\t\t\tspatialRef, bForceTest, result, progressTracker);\n\t\treturn res > 0;\n\t}", "code_tokens": ["@", "Override", "public", "boolean", "isSimpleAsFeature", "(", "Geometry", "geom", ",", "SpatialReference", "spatialRef", ",", "boolean", "bForceTest", ",", "NonSimpleResult", "result", ",", "ProgressTracker", "progressTracker", ")", "{", "int", "res", "=", "OperatorSimplifyLocalHelper", ".", "isSimpleAsFeature", "(", "geom", ",", "spatialRef", ",", "bForceTest", ",", "result", ",", "progressTracker", ")", ";", "return", "res", ">", "0", ";", "}"], "docstring": "Reviewed vs. Feb 8 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Feb", "8", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocal.java#L38-L45", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Line.java", "func_name": "Line.intersectionWithEnvelope2D", "original_string": "int intersectionWithEnvelope2D(Envelope2D clipEnv2D,\n\t\t\tboolean includeEnvBoundary, double[] segParams,\n\t\t\tdouble[] envelopeDistances) {\n\t\tPoint2D p1 = getStartXY();\n\t\tPoint2D p2 = getEndXY();\n\n\t\t// includeEnvBoundary xxx ???\n\n\t\tint modified = clipEnv2D.clipLine(p1, p2, 0, segParams,\n\t\t\t\tenvelopeDistances);\n\t\treturn modified != 0 ? 2 : 0;\n\n\t}", "language": "java", "code": "int intersectionWithEnvelope2D(Envelope2D clipEnv2D,\n\t\t\tboolean includeEnvBoundary, double[] segParams,\n\t\t\tdouble[] envelopeDistances) {\n\t\tPoint2D p1 = getStartXY();\n\t\tPoint2D p2 = getEndXY();\n\n\t\t// includeEnvBoundary xxx ???\n\n\t\tint modified = clipEnv2D.clipLine(p1, p2, 0, segParams,\n\t\t\t\tenvelopeDistances);\n\t\treturn modified != 0 ? 2 : 0;\n\n\t}", "code_tokens": ["int", "intersectionWithEnvelope2D", "(", "Envelope2D", "clipEnv2D", ",", "boolean", "includeEnvBoundary", ",", "double", "[", "]", "segParams", ",", "double", "[", "]", "envelopeDistances", ")", "{", "Point2D", "p1", "=", "getStartXY", "(", ")", ";", "Point2D", "p2", "=", "getEndXY", "(", ")", ";", "// includeEnvBoundary xxx ???", "int", "modified", "=", "clipEnv2D", ".", "clipLine", "(", "p1", ",", "p2", ",", "0", ",", "segParams", ",", "envelopeDistances", ")", ";", "return", "modified", "!=", "0", "?", "2", ":", "0", ";", "}"], "docstring": "inside clipEnv2D.", "docstring_tokens": ["inside", "clipEnv2D", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Line.java#L346-L358", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Line.java", "func_name": "Line._side", "original_string": "int _side(double ptX, double ptY) {\n\t\tPoint2D v1 = new Point2D(ptX, ptY);\n\t\tv1.sub(getStartXY());\n\t\tPoint2D v2 = new Point2D();\n\t\tv2.sub(getEndXY(), getStartXY());\n\t\tdouble cross = v2.crossProduct(v1);\n\t\tdouble crossError = 4 * NumberUtils.doubleEps()\n\t\t\t\t* (Math.abs(v2.x * v1.y) + Math.abs(v2.y * v1.x));\n\t\treturn cross > crossError ? -1 : cross < -crossError ? 1 : 0;\n\t}", "language": "java", "code": "int _side(double ptX, double ptY) {\n\t\tPoint2D v1 = new Point2D(ptX, ptY);\n\t\tv1.sub(getStartXY());\n\t\tPoint2D v2 = new Point2D();\n\t\tv2.sub(getEndXY(), getStartXY());\n\t\tdouble cross = v2.crossProduct(v1);\n\t\tdouble crossError = 4 * NumberUtils.doubleEps()\n\t\t\t\t* (Math.abs(v2.x * v1.y) + Math.abs(v2.y * v1.x));\n\t\treturn cross > crossError ? -1 : cross < -crossError ? 1 : 0;\n\t}", "code_tokens": ["int", "_side", "(", "double", "ptX", ",", "double", "ptY", ")", "{", "Point2D", "v1", "=", "new", "Point2D", "(", "ptX", ",", "ptY", ")", ";", "v1", ".", "sub", "(", "getStartXY", "(", ")", ")", ";", "Point2D", "v2", "=", "new", "Point2D", "(", ")", ";", "v2", ".", "sub", "(", "getEndXY", "(", ")", ",", "getStartXY", "(", ")", ")", ";", "double", "cross", "=", "v2", ".", "crossProduct", "(", "v1", ")", ";", "double", "crossError", "=", "4", "*", "NumberUtils", ".", "doubleEps", "(", ")", "*", "(", "Math", ".", "abs", "(", "v2", ".", "x", "*", "v1", ".", "y", ")", "+", "Math", ".", "abs", "(", "v2", ".", "y", "*", "v1", ".", "x", ")", ")", ";", "return", "cross", ">", "crossError", "?", "-", "1", ":", "cross", "<", "-", "crossError", "?", "1", ":", "0", ";", "}"], "docstring": "of the roundoff error)", "docstring_tokens": ["of", "the", "roundoff", "error", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Line.java#L428-L437", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Line.java", "func_name": "Line._isIntersectingHelper", "original_string": "static boolean _isIntersectingHelper(Line line1, Line line2) {\n\t\tint s11 = line1._side(line2.m_xStart, line2.m_yStart);\n\t\tint s12 = line1._side(line2.m_xEnd, line2.m_yEnd);\n\t\tif (s11 < 0 && s12 < 0 || s11 > 0 && s12 > 0)\n\t\t\treturn false;// no intersection. The line2 lies to one side of an\n\t\t\t\t\t\t\t// infinite line passing through line1\n\n\t\tint s21 = line2._side(line1.m_xStart, line1.m_yStart);\n\t\tint s22 = line2._side(line1.m_xEnd, line1.m_yEnd);\n\t\tif (s21 < 0 && s22 < 0 || s21 > 0 && s22 > 0)\n\t\t\treturn false;// no intersection.The line1 lies to one side of an\n\t\t\t\t\t\t\t// infinite line passing through line2\n\n\t\tdouble len1 = line1.calculateLength2D();\n\t\tdouble len2 = line2.calculateLength2D();\n\t\tif (len1 > len2) {\n\t\t\treturn line1._projectionIntersect(line2);\n\t\t} else {\n\t\t\treturn line2._projectionIntersect(line1);\n\t\t}\n\t}", "language": "java", "code": "static boolean _isIntersectingHelper(Line line1, Line line2) {\n\t\tint s11 = line1._side(line2.m_xStart, line2.m_yStart);\n\t\tint s12 = line1._side(line2.m_xEnd, line2.m_yEnd);\n\t\tif (s11 < 0 && s12 < 0 || s11 > 0 && s12 > 0)\n\t\t\treturn false;// no intersection. The line2 lies to one side of an\n\t\t\t\t\t\t\t// infinite line passing through line1\n\n\t\tint s21 = line2._side(line1.m_xStart, line1.m_yStart);\n\t\tint s22 = line2._side(line1.m_xEnd, line1.m_yEnd);\n\t\tif (s21 < 0 && s22 < 0 || s21 > 0 && s22 > 0)\n\t\t\treturn false;// no intersection.The line1 lies to one side of an\n\t\t\t\t\t\t\t// infinite line passing through line2\n\n\t\tdouble len1 = line1.calculateLength2D();\n\t\tdouble len2 = line2.calculateLength2D();\n\t\tif (len1 > len2) {\n\t\t\treturn line1._projectionIntersect(line2);\n\t\t} else {\n\t\t\treturn line2._projectionIntersect(line1);\n\t\t}\n\t}", "code_tokens": ["static", "boolean", "_isIntersectingHelper", "(", "Line", "line1", ",", "Line", "line2", ")", "{", "int", "s11", "=", "line1", ".", "_side", "(", "line2", ".", "m_xStart", ",", "line2", ".", "m_yStart", ")", ";", "int", "s12", "=", "line1", ".", "_side", "(", "line2", ".", "m_xEnd", ",", "line2", ".", "m_yEnd", ")", ";", "if", "(", "s11", "<", "0", "&&", "s12", "<", "0", "||", "s11", ">", "0", "&&", "s12", ">", "0", ")", "return", "false", ";", "// no intersection. The line2 lies to one side of an", "// infinite line passing through line1", "int", "s21", "=", "line2", ".", "_side", "(", "line1", ".", "m_xStart", ",", "line1", ".", "m_yStart", ")", ";", "int", "s22", "=", "line2", ".", "_side", "(", "line1", ".", "m_xEnd", ",", "line1", ".", "m_yEnd", ")", ";", "if", "(", "s21", "<", "0", "&&", "s22", "<", "0", "||", "s21", ">", "0", "&&", "s22", ">", "0", ")", "return", "false", ";", "// no intersection.The line1 lies to one side of an", "// infinite line passing through line2", "double", "len1", "=", "line1", ".", "calculateLength2D", "(", ")", ";", "double", "len2", "=", "line2", ".", "calculateLength2D", "(", ")", ";", "if", "(", "len1", ">", "len2", ")", "{", "return", "line1", ".", "_projectionIntersect", "(", "line2", ")", ";", "}", "else", "{", "return", "line2", ".", "_projectionIntersect", "(", "line1", ")", ";", "}", "}"], "docstring": "Tests if two lines intersect using projection of one line to another.", "docstring_tokens": ["Tests", "if", "two", "lines", "intersect", "using", "projection", "of", "one", "line", "to", "another", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Line.java#L600-L620", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.jsonToGeometry", "original_string": "public static MapGeometry jsonToGeometry(JsonParser json) {\n\t\tMapGeometry geom = OperatorImportFromJson.local().execute(Geometry.Type.Unknown, new JsonParserReader(json));\n\t\treturn geom;\n\t}", "language": "java", "code": "public static MapGeometry jsonToGeometry(JsonParser json) {\n\t\tMapGeometry geom = OperatorImportFromJson.local().execute(Geometry.Type.Unknown, new JsonParserReader(json));\n\t\treturn geom;\n\t}", "code_tokens": ["public", "static", "MapGeometry", "jsonToGeometry", "(", "JsonParser", "json", ")", "{", "MapGeometry", "geom", "=", "OperatorImportFromJson", ".", "local", "(", ")", ".", "execute", "(", "Geometry", ".", "Type", ".", "Unknown", ",", "new", "JsonParserReader", "(", "json", ")", ")", ";", "return", "geom", ";", "}"], "docstring": "Imports the MapGeometry from its JSON representation. M and Z values are\nnot imported from JSON representation.\n\nSee OperatorImportFromJson.\n\n@param json\nThe JSON representation of the geometry (with spatial\nreference).\n@return The MapGeometry instance containing the imported geometry and its\nspatial reference.", "docstring_tokens": ["Imports", "the", "MapGeometry", "from", "its", "JSON", "representation", ".", "M", "and", "Z", "values", "are", "not", "imported", "from", "JSON", "representation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L58-L61", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.jsonToGeometry", "original_string": "public static MapGeometry jsonToGeometry(String json) {\n\t\tMapGeometry geom = OperatorImportFromJson.local().execute(Geometry.Type.Unknown, json);\n\t\treturn geom;\n\t}", "language": "java", "code": "public static MapGeometry jsonToGeometry(String json) {\n\t\tMapGeometry geom = OperatorImportFromJson.local().execute(Geometry.Type.Unknown, json);\n\t\treturn geom;\n\t}", "code_tokens": ["public", "static", "MapGeometry", "jsonToGeometry", "(", "String", "json", ")", "{", "MapGeometry", "geom", "=", "OperatorImportFromJson", ".", "local", "(", ")", ".", "execute", "(", "Geometry", ".", "Type", ".", "Unknown", ",", "json", ")", ";", "return", "geom", ";", "}"], "docstring": "Imports the MapGeometry from its JSON representation. M and Z values are\nnot imported from JSON representation.\n\nSee OperatorImportFromJson.\n\n@param json\nThe JSON representation of the geometry (with spatial\nreference).\n@return The MapGeometry instance containing the imported geometry and its\nspatial reference.", "docstring_tokens": ["Imports", "the", "MapGeometry", "from", "its", "JSON", "representation", ".", "M", "and", "Z", "values", "are", "not", "imported", "from", "JSON", "representation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L92-L95", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geometryToJson", "original_string": "public static String geometryToJson(int wkid, Geometry geometry) {\n\t\treturn GeometryEngine.geometryToJson(\n\t\t\t\twkid > 0 ? SpatialReference.create(wkid) : null, geometry);\n\t}", "language": "java", "code": "public static String geometryToJson(int wkid, Geometry geometry) {\n\t\treturn GeometryEngine.geometryToJson(\n\t\t\t\twkid > 0 ? SpatialReference.create(wkid) : null, geometry);\n\t}", "code_tokens": ["public", "static", "String", "geometryToJson", "(", "int", "wkid", ",", "Geometry", "geometry", ")", "{", "return", "GeometryEngine", ".", "geometryToJson", "(", "wkid", ">", "0", "?", "SpatialReference", ".", "create", "(", "wkid", ")", ":", "null", ",", "geometry", ")", ";", "}"], "docstring": "Exports the specified geometry instance to it's JSON representation.\n\nSee OperatorExportToJson.\n\n@see GeometryEngine#geometryToJson(SpatialReference spatialiReference,\nGeometry geometry)\n@param wkid\nThe spatial reference Well Known ID to be used for the JSON\nrepresentation.\n@param geometry\nThe geometry to be exported to JSON.\n@return The JSON representation of the specified Geometry.", "docstring_tokens": ["Exports", "the", "specified", "geometry", "instance", "to", "it", "s", "JSON", "representation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L111-L114", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geometryToJson", "original_string": "public static String geometryToJson(SpatialReference spatialReference,\n\t\t\tGeometry geometry) {\n\t\tOperatorExportToJson exporter = (OperatorExportToJson) factory\n\t\t\t\t.getOperator(Operator.Type.ExportToJson);\n\n\t\treturn exporter.execute(spatialReference, geometry);\n\t}", "language": "java", "code": "public static String geometryToJson(SpatialReference spatialReference,\n\t\t\tGeometry geometry) {\n\t\tOperatorExportToJson exporter = (OperatorExportToJson) factory\n\t\t\t\t.getOperator(Operator.Type.ExportToJson);\n\n\t\treturn exporter.execute(spatialReference, geometry);\n\t}", "code_tokens": ["public", "static", "String", "geometryToJson", "(", "SpatialReference", "spatialReference", ",", "Geometry", "geometry", ")", "{", "OperatorExportToJson", "exporter", "=", "(", "OperatorExportToJson", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ExportToJson", ")", ";", "return", "exporter", ".", "execute", "(", "spatialReference", ",", "geometry", ")", ";", "}"], "docstring": "Exports the specified geometry instance to it's JSON representation. M\nand Z values are not imported from JSON representation.\n\nSee OperatorExportToJson.\n\n@param spatialReference\nThe spatial reference of associated object.\n@param geometry\nThe geometry.\n@return The JSON representation of the specified geometry.", "docstring_tokens": ["Exports", "the", "specified", "geometry", "instance", "to", "it", "s", "JSON", "representation", ".", "M", "and", "Z", "values", "are", "not", "imported", "from", "JSON", "representation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L128-L134", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geoJsonToGeometry", "original_string": "public static MapGeometry geoJsonToGeometry(String json, int importFlags, Geometry.Type type) {\n\t\tMapGeometry geom = OperatorImportFromGeoJson.local().execute(importFlags, type, json, null);\n\t\treturn geom;\n\t}", "language": "java", "code": "public static MapGeometry geoJsonToGeometry(String json, int importFlags, Geometry.Type type) {\n\t\tMapGeometry geom = OperatorImportFromGeoJson.local().execute(importFlags, type, json, null);\n\t\treturn geom;\n\t}", "code_tokens": ["public", "static", "MapGeometry", "geoJsonToGeometry", "(", "String", "json", ",", "int", "importFlags", ",", "Geometry", ".", "Type", "type", ")", "{", "MapGeometry", "geom", "=", "OperatorImportFromGeoJson", ".", "local", "(", ")", ".", "execute", "(", "importFlags", ",", "type", ",", "json", ",", "null", ")", ";", "return", "geom", ";", "}"], "docstring": "Imports the MapGeometry from its JSON representation. M and Z values are\nnot imported from JSON representation.\n\nSee OperatorImportFromJson.\n\n@param json\nThe JSON representation of the geometry (with spatial\nreference).\n@return The MapGeometry instance containing the imported geometry and its\nspatial reference.", "docstring_tokens": ["Imports", "the", "MapGeometry", "from", "its", "JSON", "representation", ".", "M", "and", "Z", "values", "are", "not", "imported", "from", "JSON", "representation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L155-L158", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geometryFromEsriShape", "original_string": "public static Geometry geometryFromEsriShape(byte[] esriShapeBuffer,\n\t\t\tGeometry.Type geometryType) {\n\t\tOperatorImportFromESRIShape op = (OperatorImportFromESRIShape) factory\n\t\t\t\t.getOperator(Operator.Type.ImportFromESRIShape);\n\t\treturn op\n\t\t\t\t.execute(\n\t\t\t\t\t\tShapeImportFlags.ShapeImportNonTrusted,\n\t\t\t\t\t\tgeometryType,\n\t\t\t\t\t\tByteBuffer.wrap(esriShapeBuffer).order(\n\t\t\t\t\t\t\t\tByteOrder.LITTLE_ENDIAN));\n\t}", "language": "java", "code": "public static Geometry geometryFromEsriShape(byte[] esriShapeBuffer,\n\t\t\tGeometry.Type geometryType) {\n\t\tOperatorImportFromESRIShape op = (OperatorImportFromESRIShape) factory\n\t\t\t\t.getOperator(Operator.Type.ImportFromESRIShape);\n\t\treturn op\n\t\t\t\t.execute(\n\t\t\t\t\t\tShapeImportFlags.ShapeImportNonTrusted,\n\t\t\t\t\t\tgeometryType,\n\t\t\t\t\t\tByteBuffer.wrap(esriShapeBuffer).order(\n\t\t\t\t\t\t\t\tByteOrder.LITTLE_ENDIAN));\n\t}", "code_tokens": ["public", "static", "Geometry", "geometryFromEsriShape", "(", "byte", "[", "]", "esriShapeBuffer", ",", "Geometry", ".", "Type", "geometryType", ")", "{", "OperatorImportFromESRIShape", "op", "=", "(", "OperatorImportFromESRIShape", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ImportFromESRIShape", ")", ";", "return", "op", ".", "execute", "(", "ShapeImportFlags", ".", "ShapeImportNonTrusted", ",", "geometryType", ",", "ByteBuffer", ".", "wrap", "(", "esriShapeBuffer", ")", ".", "order", "(", "ByteOrder", ".", "LITTLE_ENDIAN", ")", ")", ";", "}"], "docstring": "Imports geometry from the ESRI shape file format.\n\nSee OperatorImportFromESRIShape.\n\n@param esriShapeBuffer\nThe buffer containing geometry in the ESRI shape file format.\n@param geometryType\nThe required type of the Geometry to be imported. Use\nGeometry.Type.Unknown if the geometry type needs to be\ndetermined from the buffer content.\n@return The geometry or null if the buffer contains null shape.\n@throws GeometryException\nwhen the geometryType is not Geometry.Type.Unknown and the\nbuffer contains geometry that cannot be converted to the\ngiven geometryType. or the buffer is corrupt. Another\nexception possible is IllegalArgumentsException.", "docstring_tokens": ["Imports", "geometry", "from", "the", "ESRI", "shape", "file", "format", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L214-L224", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geometryToEsriShape", "original_string": "public static byte[] geometryToEsriShape(Geometry geometry) {\n\t\tif (geometry == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tOperatorExportToESRIShape op = (OperatorExportToESRIShape) factory\n\t\t\t\t.getOperator(Operator.Type.ExportToESRIShape);\n\t\treturn op.execute(0, geometry).array();\n\t}", "language": "java", "code": "public static byte[] geometryToEsriShape(Geometry geometry) {\n\t\tif (geometry == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tOperatorExportToESRIShape op = (OperatorExportToESRIShape) factory\n\t\t\t\t.getOperator(Operator.Type.ExportToESRIShape);\n\t\treturn op.execute(0, geometry).array();\n\t}", "code_tokens": ["public", "static", "byte", "[", "]", "geometryToEsriShape", "(", "Geometry", "geometry", ")", "{", "if", "(", "geometry", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "OperatorExportToESRIShape", "op", "=", "(", "OperatorExportToESRIShape", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ExportToESRIShape", ")", ";", "return", "op", ".", "execute", "(", "0", ",", "geometry", ")", ".", "array", "(", ")", ";", "}"], "docstring": "Exports geometry to the ESRI shape file format.\n\nSee OperatorExportToESRIShape.\n\n@param geometry\nThe geometry to export. (null value is not allowed)\n@return Array containing the exported ESRI shape file.", "docstring_tokens": ["Exports", "geometry", "to", "the", "ESRI", "shape", "file", "format", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L235-L241", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geometryFromWkt", "original_string": "public static Geometry geometryFromWkt(String wkt, int importFlags,\n\t\t\tGeometry.Type geometryType) {\n\t\tOperatorImportFromWkt op = (OperatorImportFromWkt) factory\n\t\t\t\t.getOperator(Operator.Type.ImportFromWkt);\n\t\treturn op.execute(importFlags, geometryType, wkt, null);\n\t}", "language": "java", "code": "public static Geometry geometryFromWkt(String wkt, int importFlags,\n\t\t\tGeometry.Type geometryType) {\n\t\tOperatorImportFromWkt op = (OperatorImportFromWkt) factory\n\t\t\t\t.getOperator(Operator.Type.ImportFromWkt);\n\t\treturn op.execute(importFlags, geometryType, wkt, null);\n\t}", "code_tokens": ["public", "static", "Geometry", "geometryFromWkt", "(", "String", "wkt", ",", "int", "importFlags", ",", "Geometry", ".", "Type", "geometryType", ")", "{", "OperatorImportFromWkt", "op", "=", "(", "OperatorImportFromWkt", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ImportFromWkt", ")", ";", "return", "op", ".", "execute", "(", "importFlags", ",", "geometryType", ",", "wkt", ",", "null", ")", ";", "}"], "docstring": "Imports a geometry from a WKT string.\n\nSee OperatorImportFromWkt.\n\n@param wkt The string containing the geometry in WKT format.\n@param importFlags Use the {@link WktImportFlags} interface.\n@param geometryType The required type of the Geometry to be imported. Use Geometry.Type.Unknown if the geometry type needs to be determined from the WKT context.\n@return The geometry.\n@throws GeometryException when the geometryType is not Geometry.Type.Unknown and the WKT contains a geometry that cannot be converted to the given geometryType.\n@throws IllegalArgumentException if an error is found while parsing the WKT string.", "docstring_tokens": ["Imports", "a", "geometry", "from", "a", "WKT", "string", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L255-L260", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.geometryToWkt", "original_string": "public static String geometryToWkt(Geometry geometry, int exportFlags) {\n\t\tOperatorExportToWkt op = (OperatorExportToWkt) factory\n\t\t\t\t.getOperator(Operator.Type.ExportToWkt);\n\t\treturn op.execute(exportFlags, geometry, null);\n\t}", "language": "java", "code": "public static String geometryToWkt(Geometry geometry, int exportFlags) {\n\t\tOperatorExportToWkt op = (OperatorExportToWkt) factory\n\t\t\t\t.getOperator(Operator.Type.ExportToWkt);\n\t\treturn op.execute(exportFlags, geometry, null);\n\t}", "code_tokens": ["public", "static", "String", "geometryToWkt", "(", "Geometry", "geometry", ",", "int", "exportFlags", ")", "{", "OperatorExportToWkt", "op", "=", "(", "OperatorExportToWkt", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ExportToWkt", ")", ";", "return", "op", ".", "execute", "(", "exportFlags", ",", "geometry", ",", "null", ")", ";", "}"], "docstring": "Exports a geometry to a string in WKT format.\n\nSee OperatorExportToWkt.\n\n@param geometry The geometry to export. (null value is not allowed)\n@param exportFlags Use the {@link WktExportFlags} interface.\n@return A String containing the exported geometry in WKT format.", "docstring_tokens": ["Exports", "a", "geometry", "to", "a", "string", "in", "WKT", "format", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L271-L275", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.union", "original_string": "public static Geometry union(Geometry[] geometries,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorUnion op = (OperatorUnion) factory\n\t\t\t\t.getOperator(Operator.Type.Union);\n\n\t\tSimpleGeometryCursor inputGeometries = new SimpleGeometryCursor(\n\t\t\t\tgeometries);\n\t\tGeometryCursor result = op.execute(inputGeometries, spatialReference,\n\t\t\t\tnull);\n\t\treturn result.next();\n\t}", "language": "java", "code": "public static Geometry union(Geometry[] geometries,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorUnion op = (OperatorUnion) factory\n\t\t\t\t.getOperator(Operator.Type.Union);\n\n\t\tSimpleGeometryCursor inputGeometries = new SimpleGeometryCursor(\n\t\t\t\tgeometries);\n\t\tGeometryCursor result = op.execute(inputGeometries, spatialReference,\n\t\t\t\tnull);\n\t\treturn result.next();\n\t}", "code_tokens": ["public", "static", "Geometry", "union", "(", "Geometry", "[", "]", "geometries", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorUnion", "op", "=", "(", "OperatorUnion", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Union", ")", ";", "SimpleGeometryCursor", "inputGeometries", "=", "new", "SimpleGeometryCursor", "(", "geometries", ")", ";", "GeometryCursor", "result", "=", "op", ".", "execute", "(", "inputGeometries", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ".", "next", "(", ")", ";", "}"], "docstring": "Constructs a new geometry by union an array of geometries. All inputs\nmust be of the same type of geometries and share one spatial reference.\n\nSee OperatorUnion.\n\n@param geometries\nThe geometries to union.\n@param spatialReference\nThe spatial reference of the geometries.\n@return The geometry object representing the resultant union.", "docstring_tokens": ["Constructs", "a", "new", "geometry", "by", "union", "an", "array", "of", "geometries", ".", "All", "inputs", "must", "be", "of", "the", "same", "type", "of", "geometries", "and", "share", "one", "spatial", "reference", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L289-L299", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.difference", "original_string": "public static Geometry difference(Geometry geometry1, Geometry substractor,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorDifference op = (OperatorDifference) factory\n\t\t\t\t.getOperator(Operator.Type.Difference);\n\t\tGeometry result = op.execute(geometry1, substractor, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static Geometry difference(Geometry geometry1, Geometry substractor,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorDifference op = (OperatorDifference) factory\n\t\t\t\t.getOperator(Operator.Type.Difference);\n\t\tGeometry result = op.execute(geometry1, substractor, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "Geometry", "difference", "(", "Geometry", "geometry1", ",", "Geometry", "substractor", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorDifference", "op", "=", "(", "OperatorDifference", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Difference", ")", ";", "Geometry", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "substractor", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Creates the difference of two geometries. The dimension of geometry2 has\nto be equal to or greater than that of geometry1.\n\nSee OperatorDifference.\n\n@param geometry1\nThe geometry being subtracted.\n@param substractor\nThe geometry object to subtract from.\n@param spatialReference\nThe spatial reference of the geometries.\n@return The geometry of the differences.", "docstring_tokens": ["Creates", "the", "difference", "of", "two", "geometries", ".", "The", "dimension", "of", "geometry2", "has", "to", "be", "equal", "to", "or", "greater", "than", "that", "of", "geometry1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L315-L322", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.symmetricDifference", "original_string": "public static Geometry symmetricDifference(Geometry leftGeometry,\n\t\t\tGeometry rightGeometry, SpatialReference spatialReference) {\n\t\tOperatorSymmetricDifference op = (OperatorSymmetricDifference) factory\n\t\t\t\t.getOperator(Operator.Type.SymmetricDifference);\n\t\tGeometry result = op.execute(leftGeometry, rightGeometry,\n\t\t\t\tspatialReference, null);\n\t\treturn result;\n\t}", "language": "java", "code": "public static Geometry symmetricDifference(Geometry leftGeometry,\n\t\t\tGeometry rightGeometry, SpatialReference spatialReference) {\n\t\tOperatorSymmetricDifference op = (OperatorSymmetricDifference) factory\n\t\t\t\t.getOperator(Operator.Type.SymmetricDifference);\n\t\tGeometry result = op.execute(leftGeometry, rightGeometry,\n\t\t\t\tspatialReference, null);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "Geometry", "symmetricDifference", "(", "Geometry", "leftGeometry", ",", "Geometry", "rightGeometry", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorSymmetricDifference", "op", "=", "(", "OperatorSymmetricDifference", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "SymmetricDifference", ")", ";", "Geometry", "result", "=", "op", ".", "execute", "(", "leftGeometry", ",", "rightGeometry", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Creates the symmetric difference of two geometries.\n\nSee OperatorSymmetricDifference.\n\n@param leftGeometry\nis one of the Geometry instances in the XOR operation.\n@param rightGeometry\nis one of the Geometry instances in the XOR operation.\n@param spatialReference\nThe spatial reference of the geometries.\n@return Returns the result of the symmetric difference.", "docstring_tokens": ["Creates", "the", "symmetric", "difference", "of", "two", "geometries", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L337-L344", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.disjoint", "original_string": "public static boolean disjoint(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorDisjoint op = (OperatorDisjoint) factory\n\t\t\t\t.getOperator(Operator.Type.Disjoint);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean disjoint(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorDisjoint op = (OperatorDisjoint) factory\n\t\t\t\t.getOperator(Operator.Type.Disjoint);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "disjoint", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorDisjoint", "op", "=", "(", "OperatorDisjoint", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Disjoint", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "See OperatorDisjoint.", "docstring_tokens": ["See", "OperatorDisjoint", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L372-L379", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.intersect", "original_string": "static Geometry[] intersect(Geometry[] inputGeometries, Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\tinputGeometries);\n\t\tSimpleGeometryCursor intersectorCursor = new SimpleGeometryCursor(\n\t\t\t\tgeometry);\n\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\tintersectorCursor, spatialReference, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = result.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] resultarr = resultGeoms.toArray(new Geometry[0]);\n\t\treturn resultarr;\n\t}", "language": "java", "code": "static Geometry[] intersect(Geometry[] inputGeometries, Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\tinputGeometries);\n\t\tSimpleGeometryCursor intersectorCursor = new SimpleGeometryCursor(\n\t\t\t\tgeometry);\n\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\tintersectorCursor, spatialReference, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = result.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] resultarr = resultGeoms.toArray(new Geometry[0]);\n\t\treturn resultarr;\n\t}", "code_tokens": ["static", "Geometry", "[", "]", "intersect", "(", "Geometry", "[", "]", "inputGeometries", ",", "Geometry", "geometry", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorIntersection", "op", "=", "(", "OperatorIntersection", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Intersection", ")", ";", "SimpleGeometryCursor", "inputGeometriesCursor", "=", "new", "SimpleGeometryCursor", "(", "inputGeometries", ")", ";", "SimpleGeometryCursor", "intersectorCursor", "=", "new", "SimpleGeometryCursor", "(", "geometry", ")", ";", "GeometryCursor", "result", "=", "op", ".", "execute", "(", "inputGeometriesCursor", ",", "intersectorCursor", ",", "spatialReference", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "resultGeoms", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "g", ";", "while", "(", "(", "g", "=", "result", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "resultGeoms", ".", "add", "(", "g", ")", ";", "}", "Geometry", "[", "]", "resultarr", "=", "resultGeoms", ".", "toArray", "(", "new", "Geometry", "[", "0", "]", ")", ";", "return", "resultarr", ";", "}"], "docstring": "Constructs the set-theoretic intersection between an array of geometries\nand another geometry.\n\nSee OperatorIntersection (also for dimension specific intersection).\n\n@param inputGeometries\nAn array of geometry objects.\n@param geometry\nThe geometry object.\n@return Any array of geometry objects showing the intersection.", "docstring_tokens": ["Constructs", "the", "set", "-", "theoretic", "intersection", "between", "an", "array", "of", "geometries", "and", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L393-L412", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.intersect", "original_string": "public static Geometry intersect(Geometry geometry1, Geometry intersector,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tGeometry result = op.execute(geometry1, intersector, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static Geometry intersect(Geometry geometry1, Geometry intersector,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tGeometry result = op.execute(geometry1, intersector, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "Geometry", "intersect", "(", "Geometry", "geometry1", ",", "Geometry", "intersector", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorIntersection", "op", "=", "(", "OperatorIntersection", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Intersection", ")", ";", "Geometry", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "intersector", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Creates a geometry through intersection between two geometries.\n\nSee OperatorIntersection.\n\n@param geometry1\nThe first geometry.\n@param intersector\nThe geometry to intersect the first geometry.\n@param spatialReference\nThe spatial reference of the geometries.\n@return The geometry created through intersection.", "docstring_tokens": ["Creates", "a", "geometry", "through", "intersection", "between", "two", "geometries", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L427-L434", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.within", "original_string": "public static boolean within(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorWithin op = (OperatorWithin) factory\n\t\t\t\t.getOperator(Operator.Type.Within);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean within(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorWithin op = (OperatorWithin) factory\n\t\t\t\t.getOperator(Operator.Type.Within);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "within", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorWithin", "op", "=", "(", "OperatorWithin", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Within", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Indicates if one geometry is within another geometry.\n\nSee OperatorWithin.\n\n@param geometry1\nThe base geometry that is tested for within relationship to\nthe other geometry.\n@param geometry2\nThe comparison geometry that is tested for the contains\nrelationship to the other geometry.\n@param spatialReference\nThe spatial reference of the geometries.\n@return TRUE if the first geometry is within the other geometry.", "docstring_tokens": ["Indicates", "if", "one", "geometry", "is", "within", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L451-L458", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.contains", "original_string": "public static boolean contains(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorContains op = (OperatorContains) factory\n\t\t\t\t.getOperator(Operator.Type.Contains);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean contains(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorContains op = (OperatorContains) factory\n\t\t\t\t.getOperator(Operator.Type.Contains);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "contains", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorContains", "op", "=", "(", "OperatorContains", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Contains", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Indicates if one geometry contains another geometry.\n\nSee OperatorContains.\n\n@param geometry1\nThe geometry that is tested for the contains relationship to\nthe other geometry..\n@param geometry2\nThe geometry that is tested for within relationship to the\nother geometry.\n@param spatialReference\nThe spatial reference of the geometries.\n@return TRUE if geometry1 contains geometry2.", "docstring_tokens": ["Indicates", "if", "one", "geometry", "contains", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L475-L482", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.crosses", "original_string": "public static boolean crosses(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorCrosses op = (OperatorCrosses) factory\n\t\t\t\t.getOperator(Operator.Type.Crosses);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean crosses(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorCrosses op = (OperatorCrosses) factory\n\t\t\t\t.getOperator(Operator.Type.Crosses);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "crosses", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorCrosses", "op", "=", "(", "OperatorCrosses", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Crosses", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Indicates if one geometry crosses another geometry.\n\nSee OperatorCrosses.\n\n@param geometry1\nThe geometry to cross.\n@param geometry2\nThe geometry being crossed.\n@param spatialReference\nThe spatial reference of the geometries.\n@return TRUE if geometry1 crosses geometry2.", "docstring_tokens": ["Indicates", "if", "one", "geometry", "crosses", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L497-L504", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.touches", "original_string": "public static boolean touches(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorTouches op = (OperatorTouches) factory\n\t\t\t\t.getOperator(Operator.Type.Touches);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean touches(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorTouches op = (OperatorTouches) factory\n\t\t\t\t.getOperator(Operator.Type.Touches);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "touches", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorTouches", "op", "=", "(", "OperatorTouches", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Touches", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Indicates if one geometry touches another geometry.\n\nSee OperatorTouches.\n\n@param geometry1\nThe geometry to touch.\n@param geometry2\nThe geometry to be touched.\n@param spatialReference\nThe spatial reference of the geometries.\n@return TRUE if geometry1 touches geometry2.", "docstring_tokens": ["Indicates", "if", "one", "geometry", "touches", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L519-L526", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.overlaps", "original_string": "public static boolean overlaps(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorOverlaps op = (OperatorOverlaps) factory\n\t\t\t\t.getOperator(Operator.Type.Overlaps);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean overlaps(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorOverlaps op = (OperatorOverlaps) factory\n\t\t\t\t.getOperator(Operator.Type.Overlaps);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\tnull);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "overlaps", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorOverlaps", "op", "=", "(", "OperatorOverlaps", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Overlaps", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Indicates if one geometry overlaps another geometry.\n\nSee OperatorOverlaps.\n\n@param geometry1\nThe geometry to overlap.\n@param geometry2\nThe geometry to be overlapped.\n@param spatialReference\nThe spatial reference of the geometries.\n@return TRUE if geometry1 overlaps geometry2.", "docstring_tokens": ["Indicates", "if", "one", "geometry", "overlaps", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L541-L548", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.relate", "original_string": "public static boolean relate(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference, String relation) {\n\t\tOperatorRelate op = (OperatorRelate) factory\n\t\t\t\t.getOperator(Operator.Type.Relate);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\trelation, null);\n\t\treturn result;\n\t}", "language": "java", "code": "public static boolean relate(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference, String relation) {\n\t\tOperatorRelate op = (OperatorRelate) factory\n\t\t\t\t.getOperator(Operator.Type.Relate);\n\t\tboolean result = op.execute(geometry1, geometry2, spatialReference,\n\t\t\t\trelation, null);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "boolean", "relate", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ",", "String", "relation", ")", "{", "OperatorRelate", "op", "=", "(", "OperatorRelate", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Relate", ")", ";", "boolean", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "spatialReference", ",", "relation", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Indicates if the given relation holds for the two geometries.\n\nSee OperatorRelate.\n\n@param geometry1\nThe first geometry for the relation.\n@param geometry2\nThe second geometry for the relation.\n@param spatialReference\nThe spatial reference of the geometries.\n@param relation\nThe DE-9IM relation.\n@return TRUE if the given relation holds between geometry1 and geometry2.", "docstring_tokens": ["Indicates", "if", "the", "given", "relation", "holds", "for", "the", "two", "geometries", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L565-L572", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.distance", "original_string": "public static double distance(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorDistance op = (OperatorDistance) factory\n\t\t\t\t.getOperator(Operator.Type.Distance);\n\t\tdouble result = op.execute(geometry1, geometry2, null);\n\t\treturn result;\n\t}", "language": "java", "code": "public static double distance(Geometry geometry1, Geometry geometry2,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorDistance op = (OperatorDistance) factory\n\t\t\t\t.getOperator(Operator.Type.Distance);\n\t\tdouble result = op.execute(geometry1, geometry2, null);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "double", "distance", "(", "Geometry", "geometry1", ",", "Geometry", "geometry2", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorDistance", "op", "=", "(", "OperatorDistance", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Distance", ")", ";", "double", "result", "=", "op", ".", "execute", "(", "geometry1", ",", "geometry2", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Calculates the 2D planar distance between two geometries.\n\nSee OperatorDistance.\n\n@param geometry1\nGeometry.\n@param geometry2\nGeometry.\n@param spatialReference\nThe spatial reference of the geometries. This parameter is not\nused and can be null.\n@return The distance between the two geometries.", "docstring_tokens": ["Calculates", "the", "2D", "planar", "distance", "between", "two", "geometries", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L588-L594", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.clip", "original_string": "public static Geometry clip(Geometry geometry, Envelope envelope,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorClip op = (OperatorClip) factory\n\t\t\t\t.getOperator(Operator.Type.Clip);\n\t\tGeometry result = op.execute(geometry, Envelope2D.construct(\n\t\t\t\tenvelope.getXMin(), envelope.getYMin(), envelope.getXMax(),\n\t\t\t\tenvelope.getYMax()), spatialReference, null);\n\t\treturn result;\n\t}", "language": "java", "code": "public static Geometry clip(Geometry geometry, Envelope envelope,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorClip op = (OperatorClip) factory\n\t\t\t\t.getOperator(Operator.Type.Clip);\n\t\tGeometry result = op.execute(geometry, Envelope2D.construct(\n\t\t\t\tenvelope.getXMin(), envelope.getYMin(), envelope.getXMax(),\n\t\t\t\tenvelope.getYMax()), spatialReference, null);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "Geometry", "clip", "(", "Geometry", "geometry", ",", "Envelope", "envelope", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorClip", "op", "=", "(", "OperatorClip", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Clip", ")", ";", "Geometry", "result", "=", "op", ".", "execute", "(", "geometry", ",", "Envelope2D", ".", "construct", "(", "envelope", ".", "getXMin", "(", ")", ",", "envelope", ".", "getYMin", "(", ")", ",", "envelope", ".", "getXMax", "(", ")", ",", "envelope", ".", "getYMax", "(", ")", ")", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Calculates the clipped geometry from a target geometry using an envelope.\n\nSee OperatorClip.\n\n@param geometry\nThe geometry to be clipped.\n@param envelope\nThe envelope used to clip.\n@param spatialReference\nThe spatial reference of the geometries.\n@return The geometry created by clipping.", "docstring_tokens": ["Calculates", "the", "clipped", "geometry", "from", "a", "target", "geometry", "using", "an", "envelope", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L609-L617", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.cut", "original_string": "public static Geometry[] cut(Geometry cuttee, Polyline cutter,\n\t\t\tSpatialReference spatialReference) {\n\t\tif (cuttee == null || cutter == null)\n\t\t\treturn null;\n\n\t\tOperatorCut op = (OperatorCut) factory.getOperator(Operator.Type.Cut);\n\t\tGeometryCursor cursor = op.execute(true, cuttee, cutter,\n\t\t\t\tspatialReference, null);\n\t\tArrayList<Geometry> cutsList = new ArrayList<Geometry>();\n\n\t\tGeometry geometry;\n\t\twhile ((geometry = cursor.next()) != null) {\n\t\t\tif (!geometry.isEmpty()) {\n\t\t\t\tcutsList.add(geometry);\n\t\t\t}\n\t\t}\n\n\t\treturn cutsList.toArray(new Geometry[0]);\n\t}", "language": "java", "code": "public static Geometry[] cut(Geometry cuttee, Polyline cutter,\n\t\t\tSpatialReference spatialReference) {\n\t\tif (cuttee == null || cutter == null)\n\t\t\treturn null;\n\n\t\tOperatorCut op = (OperatorCut) factory.getOperator(Operator.Type.Cut);\n\t\tGeometryCursor cursor = op.execute(true, cuttee, cutter,\n\t\t\t\tspatialReference, null);\n\t\tArrayList<Geometry> cutsList = new ArrayList<Geometry>();\n\n\t\tGeometry geometry;\n\t\twhile ((geometry = cursor.next()) != null) {\n\t\t\tif (!geometry.isEmpty()) {\n\t\t\t\tcutsList.add(geometry);\n\t\t\t}\n\t\t}\n\n\t\treturn cutsList.toArray(new Geometry[0]);\n\t}", "code_tokens": ["public", "static", "Geometry", "[", "]", "cut", "(", "Geometry", "cuttee", ",", "Polyline", "cutter", ",", "SpatialReference", "spatialReference", ")", "{", "if", "(", "cuttee", "==", "null", "||", "cutter", "==", "null", ")", "return", "null", ";", "OperatorCut", "op", "=", "(", "OperatorCut", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Cut", ")", ";", "GeometryCursor", "cursor", "=", "op", ".", "execute", "(", "true", ",", "cuttee", ",", "cutter", ",", "spatialReference", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "cutsList", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "geometry", ";", "while", "(", "(", "geometry", "=", "cursor", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "!", "geometry", ".", "isEmpty", "(", ")", ")", "{", "cutsList", ".", "add", "(", "geometry", ")", ";", "}", "}", "return", "cutsList", ".", "toArray", "(", "new", "Geometry", "[", "0", "]", ")", ";", "}"], "docstring": "Calculates the cut geometry from a target geometry using a polyline. For\nPolylines, all left cuts will be grouped together in the first Geometry,\nRight cuts and coincident cuts are grouped in the second Geometry, and\neach undefined cut, along with any uncut parts, are output as separate\nPolylines. For Polygons, all left cuts are grouped in the first Polygon,\nall right cuts are in the second Polygon, and each undefined cut, along\nwith any left-over parts after cutting, are output as a separate Polygon.\nIf there were no cuts then the array will be empty. An undefined cut will\nonly be produced if a left cut or right cut was produced, and there was a\npart left over after cutting or a cut is bounded to the left and right of\nthe cutter.\n\nSee OperatorCut.\n\n@param cuttee\nThe geometry to be cut.\n@param cutter\nThe polyline to cut the geometry.\n@param spatialReference\nThe spatial reference of the geometries.\n@return An array of geometries created from cutting.", "docstring_tokens": ["Calculates", "the", "cut", "geometry", "from", "a", "target", "geometry", "using", "a", "polyline", ".", "For", "Polylines", "all", "left", "cuts", "will", "be", "grouped", "together", "in", "the", "first", "Geometry", "Right", "cuts", "and", "coincident", "cuts", "are", "grouped", "in", "the", "second", "Geometry", "and", "each", "undefined", "cut", "along", "with", "any", "uncut", "parts", "are", "output", "as", "separate", "Polylines", ".", "For", "Polygons", "all", "left", "cuts", "are", "grouped", "in", "the", "first", "Polygon", "all", "right", "cuts", "are", "in", "the", "second", "Polygon", "and", "each", "undefined", "cut", "along", "with", "any", "left", "-", "over", "parts", "after", "cutting", "are", "output", "as", "a", "separate", "Polygon", ".", "If", "there", "were", "no", "cuts", "then", "the", "array", "will", "be", "empty", ".", "An", "undefined", "cut", "will", "only", "be", "produced", "if", "a", "left", "cut", "or", "right", "cut", "was", "produced", "and", "there", "was", "a", "part", "left", "over", "after", "cutting", "or", "a", "cut", "is", "bounded", "to", "the", "left", "and", "right", "of", "the", "cutter", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L642-L660", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.buffer", "original_string": "public static Polygon[] buffer(Geometry[] geometries,\n\t\t\tSpatialReference spatialReference, double[] distances,\n\t\t\tboolean toUnionResults) {\n\t\t// initially assume distances are in unit of spatial reference\n\t\tdouble[] bufferDistances = distances;\n\n\t\tOperatorBuffer op = (OperatorBuffer) factory\n\t\t\t\t.getOperator(Operator.Type.Buffer);\n\n\t\tif (toUnionResults) {\n\t\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\t\tgeometries);\n\t\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\t\tspatialReference, bufferDistances, toUnionResults, null);\n\n\t\t\tArrayList<Polygon> resultGeoms = new ArrayList<Polygon>();\n\t\t\tGeometry g;\n\t\t\twhile ((g = result.next()) != null) {\n\t\t\t\tresultGeoms.add((Polygon) g);\n\t\t\t}\n\t\t\tPolygon[] buffers = resultGeoms.toArray(new Polygon[0]);\n\t\t\treturn buffers;\n\t\t} else {\n\t\t\tPolygon[] buffers = new Polygon[geometries.length];\n\t\t\tfor (int i = 0; i < geometries.length; i++) {\n\t\t\t\tbuffers[i] = (Polygon) op.execute(geometries[i],\n\t\t\t\t\t\tspatialReference, bufferDistances[i], null);\n\t\t\t}\n\t\t\treturn buffers;\n\t\t}\n\t}", "language": "java", "code": "public static Polygon[] buffer(Geometry[] geometries,\n\t\t\tSpatialReference spatialReference, double[] distances,\n\t\t\tboolean toUnionResults) {\n\t\t// initially assume distances are in unit of spatial reference\n\t\tdouble[] bufferDistances = distances;\n\n\t\tOperatorBuffer op = (OperatorBuffer) factory\n\t\t\t\t.getOperator(Operator.Type.Buffer);\n\n\t\tif (toUnionResults) {\n\t\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\t\tgeometries);\n\t\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\t\tspatialReference, bufferDistances, toUnionResults, null);\n\n\t\t\tArrayList<Polygon> resultGeoms = new ArrayList<Polygon>();\n\t\t\tGeometry g;\n\t\t\twhile ((g = result.next()) != null) {\n\t\t\t\tresultGeoms.add((Polygon) g);\n\t\t\t}\n\t\t\tPolygon[] buffers = resultGeoms.toArray(new Polygon[0]);\n\t\t\treturn buffers;\n\t\t} else {\n\t\t\tPolygon[] buffers = new Polygon[geometries.length];\n\t\t\tfor (int i = 0; i < geometries.length; i++) {\n\t\t\t\tbuffers[i] = (Polygon) op.execute(geometries[i],\n\t\t\t\t\t\tspatialReference, bufferDistances[i], null);\n\t\t\t}\n\t\t\treturn buffers;\n\t\t}\n\t}", "code_tokens": ["public", "static", "Polygon", "[", "]", "buffer", "(", "Geometry", "[", "]", "geometries", ",", "SpatialReference", "spatialReference", ",", "double", "[", "]", "distances", ",", "boolean", "toUnionResults", ")", "{", "// initially assume distances are in unit of spatial reference", "double", "[", "]", "bufferDistances", "=", "distances", ";", "OperatorBuffer", "op", "=", "(", "OperatorBuffer", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Buffer", ")", ";", "if", "(", "toUnionResults", ")", "{", "SimpleGeometryCursor", "inputGeometriesCursor", "=", "new", "SimpleGeometryCursor", "(", "geometries", ")", ";", "GeometryCursor", "result", "=", "op", ".", "execute", "(", "inputGeometriesCursor", ",", "spatialReference", ",", "bufferDistances", ",", "toUnionResults", ",", "null", ")", ";", "ArrayList", "<", "Polygon", ">", "resultGeoms", "=", "new", "ArrayList", "<", "Polygon", ">", "(", ")", ";", "Geometry", "g", ";", "while", "(", "(", "g", "=", "result", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "resultGeoms", ".", "add", "(", "(", "Polygon", ")", "g", ")", ";", "}", "Polygon", "[", "]", "buffers", "=", "resultGeoms", ".", "toArray", "(", "new", "Polygon", "[", "0", "]", ")", ";", "return", "buffers", ";", "}", "else", "{", "Polygon", "[", "]", "buffers", "=", "new", "Polygon", "[", "geometries", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "geometries", ".", "length", ";", "i", "++", ")", "{", "buffers", "[", "i", "]", "=", "(", "Polygon", ")", "op", ".", "execute", "(", "geometries", "[", "i", "]", ",", "spatialReference", ",", "bufferDistances", "[", "i", "]", ",", "null", ")", ";", "}", "return", "buffers", ";", "}", "}"], "docstring": "Calculates a buffer polygon for each geometry at each of the\ncorresponding specified distances.  It is assumed that all geometries have\nthe same spatial reference. There is an option to union the\nreturned geometries.\n\nSee OperatorBuffer.\n\n@param geometries An array of geometries to be buffered.\n@param spatialReference The spatial reference of the geometries.\n@param distances The corresponding distances for the input geometries to be buffered.\n@param toUnionResults TRUE if all geometries buffered at a given distance are to be unioned into a single polygon.\n@return The buffer of the geometries.", "docstring_tokens": ["Calculates", "a", "buffer", "polygon", "for", "each", "geometry", "at", "each", "of", "the", "corresponding", "specified", "distances", ".", "It", "is", "assumed", "that", "all", "geometries", "have", "the", "same", "spatial", "reference", ".", "There", "is", "an", "option", "to", "union", "the", "returned", "geometries", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L675-L705", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.buffer", "original_string": "public static Polygon buffer(Geometry geometry,\n\t\t\tSpatialReference spatialReference, double distance) {\n\t\tdouble bufferDistance = distance;\n\n\t\tOperatorBuffer op = (OperatorBuffer) factory\n\t\t\t\t.getOperator(Operator.Type.Buffer);\n\t\tGeometry result = op.execute(geometry, spatialReference,\n\t\t\t\tbufferDistance, null);\n\t\treturn (Polygon) result;\n\t}", "language": "java", "code": "public static Polygon buffer(Geometry geometry,\n\t\t\tSpatialReference spatialReference, double distance) {\n\t\tdouble bufferDistance = distance;\n\n\t\tOperatorBuffer op = (OperatorBuffer) factory\n\t\t\t\t.getOperator(Operator.Type.Buffer);\n\t\tGeometry result = op.execute(geometry, spatialReference,\n\t\t\t\tbufferDistance, null);\n\t\treturn (Polygon) result;\n\t}", "code_tokens": ["public", "static", "Polygon", "buffer", "(", "Geometry", "geometry", ",", "SpatialReference", "spatialReference", ",", "double", "distance", ")", "{", "double", "bufferDistance", "=", "distance", ";", "OperatorBuffer", "op", "=", "(", "OperatorBuffer", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Buffer", ")", ";", "Geometry", "result", "=", "op", ".", "execute", "(", "geometry", ",", "spatialReference", ",", "bufferDistance", ",", "null", ")", ";", "return", "(", "Polygon", ")", "result", ";", "}"], "docstring": "Calculates a buffer polygon of the geometry as specified by the\ndistance input. The buffer is implemented in the xy-plane.\n\nSee OperatorBuffer\n\n@param geometry Geometry to be buffered.\n@param spatialReference The spatial reference of the geometry.\n@param distance The specified distance for buffer. Same units as the spatial reference.\n@return The buffer polygon at the specified distances.", "docstring_tokens": ["Calculates", "a", "buffer", "polygon", "of", "the", "geometry", "as", "specified", "by", "the", "distance", "input", ".", "The", "buffer", "is", "implemented", "in", "the", "xy", "-", "plane", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L718-L727", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.convexHull", "original_string": "public static Geometry convexHull(Geometry geometry) {\n\t\tOperatorConvexHull op = (OperatorConvexHull) factory\n\t\t\t\t.getOperator(Operator.Type.ConvexHull);\n\t\treturn op.execute(geometry, null);\n\t}", "language": "java", "code": "public static Geometry convexHull(Geometry geometry) {\n\t\tOperatorConvexHull op = (OperatorConvexHull) factory\n\t\t\t\t.getOperator(Operator.Type.ConvexHull);\n\t\treturn op.execute(geometry, null);\n\t}", "code_tokens": ["public", "static", "Geometry", "convexHull", "(", "Geometry", "geometry", ")", "{", "OperatorConvexHull", "op", "=", "(", "OperatorConvexHull", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ConvexHull", ")", ";", "return", "op", ".", "execute", "(", "geometry", ",", "null", ")", ";", "}"], "docstring": "Calculates the convex hull geometry.\n\nSee OperatorConvexHull.\n\n@param geometry The input geometry.\n@return Returns the convex hull.\n\nFor a Point - returns the same point. For an Envelope -\nreturns the same envelope. For a MultiPoint - If the point\ncount is one, returns the same multipoint. If the point count\nis two, returns a polyline of the points. Otherwise computes\nand returns the convex hull polygon. For a Segment - returns a\npolyline consisting of the segment. For a Polyline - If\nconsists of only one segment, returns the same polyline.\nOtherwise computes and returns the convex hull polygon. For a\nPolygon - If more than one path, or if the path isn't already\nconvex, computes and returns the convex hull polygon.\nOtherwise returns the same polygon.", "docstring_tokens": ["Calculates", "the", "convex", "hull", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L749-L753", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.convexHull", "original_string": "public static Geometry[] convexHull(Geometry[] geometries, boolean b_merge) {\n\t\tOperatorConvexHull op = (OperatorConvexHull) factory\n\t\t\t\t.getOperator(Operator.Type.ConvexHull);\n\t\tSimpleGeometryCursor simple_cursor = new SimpleGeometryCursor(\n\t\t\t\tgeometries);\n\t\tGeometryCursor cursor = op.execute(simple_cursor, b_merge, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = cursor.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] output = new Geometry[resultGeoms.size()];\n\n\t\tfor (int i = 0; i < resultGeoms.size(); i++)\n\t\t\toutput[i] = resultGeoms.get(i);\n\n\t\treturn output;\n\t}", "language": "java", "code": "public static Geometry[] convexHull(Geometry[] geometries, boolean b_merge) {\n\t\tOperatorConvexHull op = (OperatorConvexHull) factory\n\t\t\t\t.getOperator(Operator.Type.ConvexHull);\n\t\tSimpleGeometryCursor simple_cursor = new SimpleGeometryCursor(\n\t\t\t\tgeometries);\n\t\tGeometryCursor cursor = op.execute(simple_cursor, b_merge, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = cursor.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] output = new Geometry[resultGeoms.size()];\n\n\t\tfor (int i = 0; i < resultGeoms.size(); i++)\n\t\t\toutput[i] = resultGeoms.get(i);\n\n\t\treturn output;\n\t}", "code_tokens": ["public", "static", "Geometry", "[", "]", "convexHull", "(", "Geometry", "[", "]", "geometries", ",", "boolean", "b_merge", ")", "{", "OperatorConvexHull", "op", "=", "(", "OperatorConvexHull", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "ConvexHull", ")", ";", "SimpleGeometryCursor", "simple_cursor", "=", "new", "SimpleGeometryCursor", "(", "geometries", ")", ";", "GeometryCursor", "cursor", "=", "op", ".", "execute", "(", "simple_cursor", ",", "b_merge", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "resultGeoms", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "g", ";", "while", "(", "(", "g", "=", "cursor", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "resultGeoms", ".", "add", "(", "g", ")", ";", "}", "Geometry", "[", "]", "output", "=", "new", "Geometry", "[", "resultGeoms", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "resultGeoms", ".", "size", "(", ")", ";", "i", "++", ")", "output", "[", "i", "]", "=", "resultGeoms", ".", "get", "(", "i", ")", ";", "return", "output", ";", "}"], "docstring": "Calculates the convex hull.\n\nSee OperatorConvexHull\n\n@param geometries\nThe input geometry array.\n@param b_merge\nPut true if you want the convex hull of all the geometries in\nthe array combined. Put false if you want the convex hull of\neach geometry in the array individually.\n@return Returns an array of convex hulls. If b_merge is true, the result\nwill be a one element array consisting of the merged convex hull.", "docstring_tokens": ["Calculates", "the", "convex", "hull", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L769-L788", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.getNearestCoordinate", "original_string": "public static Proximity2DResult getNearestCoordinate(Geometry geometry,\n\t\t\tPoint inputPoint, boolean bTestPolygonInterior) {\n\n\t\tOperatorProximity2D proximity = (OperatorProximity2D) factory\n\t\t\t\t.getOperator(com.esri.core.geometry.Operator.Type.Proximity2D);\n\t\tProximity2DResult result = proximity.getNearestCoordinate(geometry,\n\t\t\t\tinputPoint, bTestPolygonInterior);\n\t\treturn result;\n\t}", "language": "java", "code": "public static Proximity2DResult getNearestCoordinate(Geometry geometry,\n\t\t\tPoint inputPoint, boolean bTestPolygonInterior) {\n\n\t\tOperatorProximity2D proximity = (OperatorProximity2D) factory\n\t\t\t\t.getOperator(com.esri.core.geometry.Operator.Type.Proximity2D);\n\t\tProximity2DResult result = proximity.getNearestCoordinate(geometry,\n\t\t\t\tinputPoint, bTestPolygonInterior);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "Proximity2DResult", "getNearestCoordinate", "(", "Geometry", "geometry", ",", "Point", "inputPoint", ",", "boolean", "bTestPolygonInterior", ")", "{", "OperatorProximity2D", "proximity", "=", "(", "OperatorProximity2D", ")", "factory", ".", "getOperator", "(", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Operator", ".", "Type", ".", "Proximity2D", ")", ";", "Proximity2DResult", "result", "=", "proximity", ".", "getNearestCoordinate", "(", "geometry", ",", "inputPoint", ",", "bTestPolygonInterior", ")", ";", "return", "result", ";", "}"], "docstring": "Finds the coordinate of the geometry which is closest to the specified\npoint.\n\nSee OperatorProximity2D.\n\n@param inputPoint\nThe point to find the nearest coordinate in the geometry for.\n@param geometry\nThe geometry to consider.\n@return Proximity2DResult containing the nearest coordinate.", "docstring_tokens": ["Finds", "the", "coordinate", "of", "the", "geometry", "which", "is", "closest", "to", "the", "specified", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L802-L810", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.getNearestVertices", "original_string": "public static Proximity2DResult[] getNearestVertices(Geometry geometry,\n\t\t\tPoint inputPoint, double searchRadius, int maxVertexCountToReturn) {\n\t\tOperatorProximity2D proximity = (OperatorProximity2D) factory\n\t\t\t\t.getOperator(com.esri.core.geometry.Operator.Type.Proximity2D);\n\n\t\tProximity2DResult[] results = proximity.getNearestVertices(geometry,\n\t\t\t\tinputPoint, searchRadius, maxVertexCountToReturn);\n\n\t\treturn results;\n\t}", "language": "java", "code": "public static Proximity2DResult[] getNearestVertices(Geometry geometry,\n\t\t\tPoint inputPoint, double searchRadius, int maxVertexCountToReturn) {\n\t\tOperatorProximity2D proximity = (OperatorProximity2D) factory\n\t\t\t\t.getOperator(com.esri.core.geometry.Operator.Type.Proximity2D);\n\n\t\tProximity2DResult[] results = proximity.getNearestVertices(geometry,\n\t\t\t\tinputPoint, searchRadius, maxVertexCountToReturn);\n\n\t\treturn results;\n\t}", "code_tokens": ["public", "static", "Proximity2DResult", "[", "]", "getNearestVertices", "(", "Geometry", "geometry", ",", "Point", "inputPoint", ",", "double", "searchRadius", ",", "int", "maxVertexCountToReturn", ")", "{", "OperatorProximity2D", "proximity", "=", "(", "OperatorProximity2D", ")", "factory", ".", "getOperator", "(", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Operator", ".", "Type", ".", "Proximity2D", ")", ";", "Proximity2DResult", "[", "]", "results", "=", "proximity", ".", "getNearestVertices", "(", "geometry", ",", "inputPoint", ",", "searchRadius", ",", "maxVertexCountToReturn", ")", ";", "return", "results", ";", "}"], "docstring": "Finds all vertices in the given distance from the specified point, sorted\nfrom the closest to the furthest.\n\nSee OperatorProximity2D.\n\n@param inputPoint\nThe point to start from.\n@param geometry\nThe geometry to consider.\n@param searchRadius\nThe search radius.\n@param maxVertexCountToReturn\nThe maximum number number of vertices to return.\n@return Proximity2DResult containing the array of nearest vertices.", "docstring_tokens": ["Finds", "all", "vertices", "in", "the", "given", "distance", "from", "the", "specified", "point", "sorted", "from", "the", "closest", "to", "the", "furthest", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L849-L858", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.simplify", "original_string": "public static Geometry simplify(Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorSimplify op = (OperatorSimplify) factory\n\t\t\t\t.getOperator(Operator.Type.Simplify);\n\t\tGeometry result = op.execute(geometry, spatialReference, false, null);\n\t\treturn result;\n\t}", "language": "java", "code": "public static Geometry simplify(Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorSimplify op = (OperatorSimplify) factory\n\t\t\t\t.getOperator(Operator.Type.Simplify);\n\t\tGeometry result = op.execute(geometry, spatialReference, false, null);\n\t\treturn result;\n\t}", "code_tokens": ["public", "static", "Geometry", "simplify", "(", "Geometry", "geometry", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorSimplify", "op", "=", "(", "OperatorSimplify", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Simplify", ")", ";", "Geometry", "result", "=", "op", ".", "execute", "(", "geometry", ",", "spatialReference", ",", "false", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Performs the simplify operation on the geometry.\n\nSee OperatorSimplify and See OperatorSimplifyOGC.\n\n@param geometry\nThe geometry to be simplified.\n@param spatialReference\nThe spatial reference of the geometry to be simplified.\n@return The simplified geometry.", "docstring_tokens": ["Performs", "the", "simplify", "operation", "on", "the", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L871-L877", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.isSimple", "original_string": "static boolean isSimple(Geometry geometry, SpatialReference spatialReference) {\n\t\tOperatorSimplify op = (OperatorSimplify) factory\n\t\t\t\t.getOperator(Operator.Type.Simplify);\n\t\tboolean result = op.isSimpleAsFeature(geometry, spatialReference, null);\n\t\treturn result;\n\t}", "language": "java", "code": "static boolean isSimple(Geometry geometry, SpatialReference spatialReference) {\n\t\tOperatorSimplify op = (OperatorSimplify) factory\n\t\t\t\t.getOperator(Operator.Type.Simplify);\n\t\tboolean result = op.isSimpleAsFeature(geometry, spatialReference, null);\n\t\treturn result;\n\t}", "code_tokens": ["static", "boolean", "isSimple", "(", "Geometry", "geometry", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorSimplify", "op", "=", "(", "OperatorSimplify", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Simplify", ")", ";", "boolean", "result", "=", "op", ".", "isSimpleAsFeature", "(", "geometry", ",", "spatialReference", ",", "null", ")", ";", "return", "result", ";", "}"], "docstring": "Checks if the Geometry is simple.\n\nSee OperatorSimplify.\n\n@param geometry\nThe geometry to be checked.\n@param spatialReference\nThe spatial reference of the geometry.\n@return TRUE if the geometry is simple.", "docstring_tokens": ["Checks", "if", "the", "Geometry", "is", "simple", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L890-L895", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Proximity2DResult.java", "func_name": "Proximity2DResult.setRightSide", "original_string": "public void setRightSide(boolean bRight) {\n\t\tif (bRight)\n\t\t\tm_info |= (int) OperatorProximity2D.ProxResultInfo.rightSide;\n\t\telse\n\t\t\tm_info &= ~(int) OperatorProximity2D.ProxResultInfo.rightSide;\n\t}", "language": "java", "code": "public void setRightSide(boolean bRight) {\n\t\tif (bRight)\n\t\t\tm_info |= (int) OperatorProximity2D.ProxResultInfo.rightSide;\n\t\telse\n\t\t\tm_info &= ~(int) OperatorProximity2D.ProxResultInfo.rightSide;\n\t}", "code_tokens": ["public", "void", "setRightSide", "(", "boolean", "bRight", ")", "{", "if", "(", "bRight", ")", "m_info", "|=", "(", "int", ")", "OperatorProximity2D", ".", "ProxResultInfo", ".", "rightSide", ";", "else", "m_info", "&=", "~", "(", "int", ")", "OperatorProximity2D", ".", "ProxResultInfo", ".", "rightSide", ";", "}"], "docstring": "Sets the right_side info to true or false.\n\n@param bRight\nWhether the nearest coordinate is to the right or left of the\ngeometry.", "docstring_tokens": ["Sets", "the", "right_side", "info", "to", "true", "or", "false", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Proximity2DResult.java#L44-L49", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java", "func_name": "SegmentIteratorImpl.nextSegment", "original_string": "public Segment nextSegment() {\n\t\tif (m_currentSegmentIndex != m_nextSegmentIndex)\n\t\t\t_updateSegment();\n\n\t\tif (m_bCirculator) {\n\t\t\tm_nextSegmentIndex = (m_nextSegmentIndex + 1) % m_segmentCount;\n\t\t} else {\n\t\t\tif (m_nextSegmentIndex == m_segmentCount)\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t\tm_nextSegmentIndex++;\n\t\t}\n\n\t\treturn m_currentSegment;\n\t}", "language": "java", "code": "public Segment nextSegment() {\n\t\tif (m_currentSegmentIndex != m_nextSegmentIndex)\n\t\t\t_updateSegment();\n\n\t\tif (m_bCirculator) {\n\t\t\tm_nextSegmentIndex = (m_nextSegmentIndex + 1) % m_segmentCount;\n\t\t} else {\n\t\t\tif (m_nextSegmentIndex == m_segmentCount)\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t\tm_nextSegmentIndex++;\n\t\t}\n\n\t\treturn m_currentSegment;\n\t}", "code_tokens": ["public", "Segment", "nextSegment", "(", ")", "{", "if", "(", "m_currentSegmentIndex", "!=", "m_nextSegmentIndex", ")", "_updateSegment", "(", ")", ";", "if", "(", "m_bCirculator", ")", "{", "m_nextSegmentIndex", "=", "(", "m_nextSegmentIndex", "+", "1", ")", "%", "m_segmentCount", ";", "}", "else", "{", "if", "(", "m_nextSegmentIndex", "==", "m_segmentCount", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "m_nextSegmentIndex", "++", ";", "}", "return", "m_currentSegment", ";", "}"], "docstring": "Moves the iterator to next segment and returns the segment.\n\nThe Segment is returned by value and is owned by the iterator.", "docstring_tokens": ["Moves", "the", "iterator", "to", "next", "segment", "and", "returns", "the", "segment", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java#L148-L162", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java", "func_name": "SegmentIteratorImpl.nextPath", "original_string": "public boolean nextPath() {\n\t\t// post-increment\n\t\tm_currentPathIndex = m_nextPathIndex;\n\t\tif (m_currentPathIndex >= m_parent.getPathCount())\n\t\t\treturn false;\n\n\t\tm_currentSegmentIndex = -1;\n\t\tm_nextSegmentIndex = 0;\n\t\tm_segmentCount = _getSegmentCount(m_currentPathIndex);\n\t\tm_pathBegin = m_parent.getPathStart(m_currentPathIndex);\n\t\tm_nextPathIndex++;\n\t\treturn true;\n\t}", "language": "java", "code": "public boolean nextPath() {\n\t\t// post-increment\n\t\tm_currentPathIndex = m_nextPathIndex;\n\t\tif (m_currentPathIndex >= m_parent.getPathCount())\n\t\t\treturn false;\n\n\t\tm_currentSegmentIndex = -1;\n\t\tm_nextSegmentIndex = 0;\n\t\tm_segmentCount = _getSegmentCount(m_currentPathIndex);\n\t\tm_pathBegin = m_parent.getPathStart(m_currentPathIndex);\n\t\tm_nextPathIndex++;\n\t\treturn true;\n\t}", "code_tokens": ["public", "boolean", "nextPath", "(", ")", "{", "// post-increment", "m_currentPathIndex", "=", "m_nextPathIndex", ";", "if", "(", "m_currentPathIndex", ">=", "m_parent", ".", "getPathCount", "(", ")", ")", "return", "false", ";", "m_currentSegmentIndex", "=", "-", "1", ";", "m_nextSegmentIndex", "=", "0", ";", "m_segmentCount", "=", "_getSegmentCount", "(", "m_currentPathIndex", ")", ";", "m_pathBegin", "=", "m_parent", ".", "getPathStart", "(", "m_currentPathIndex", ")", ";", "m_nextPathIndex", "++", ";", "return", "true", ";", "}"], "docstring": "Moves the iterator to next path and returns true if successful.", "docstring_tokens": ["Moves", "the", "iterator", "to", "next", "path", "and", "returns", "true", "if", "successful", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java#L244-L256", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java", "func_name": "SegmentIteratorImpl.previousPath", "original_string": "public boolean previousPath() {\n\t\t// pre-decrement\n\t\tif (m_nextPathIndex == 0)\n\t\t\treturn false;\n\n\t\tm_nextPathIndex--;\n\t\tm_currentSegmentIndex = -1;\n\t\tm_nextSegmentIndex = 0;\n\t\tm_segmentCount = _getSegmentCount(m_nextPathIndex);\n\t\tm_currentPathIndex = m_nextPathIndex;\n\t\tm_pathBegin = m_parent.getPathStart(m_currentPathIndex);\n\t\tresetToLastSegment();\n\t\treturn true;\n\t}", "language": "java", "code": "public boolean previousPath() {\n\t\t// pre-decrement\n\t\tif (m_nextPathIndex == 0)\n\t\t\treturn false;\n\n\t\tm_nextPathIndex--;\n\t\tm_currentSegmentIndex = -1;\n\t\tm_nextSegmentIndex = 0;\n\t\tm_segmentCount = _getSegmentCount(m_nextPathIndex);\n\t\tm_currentPathIndex = m_nextPathIndex;\n\t\tm_pathBegin = m_parent.getPathStart(m_currentPathIndex);\n\t\tresetToLastSegment();\n\t\treturn true;\n\t}", "code_tokens": ["public", "boolean", "previousPath", "(", ")", "{", "// pre-decrement", "if", "(", "m_nextPathIndex", "==", "0", ")", "return", "false", ";", "m_nextPathIndex", "--", ";", "m_currentSegmentIndex", "=", "-", "1", ";", "m_nextSegmentIndex", "=", "0", ";", "m_segmentCount", "=", "_getSegmentCount", "(", "m_nextPathIndex", ")", ";", "m_currentPathIndex", "=", "m_nextPathIndex", ";", "m_pathBegin", "=", "m_parent", ".", "getPathStart", "(", "m_currentPathIndex", ")", ";", "resetToLastSegment", "(", ")", ";", "return", "true", ";", "}"], "docstring": "Moves the iterator to next path and returns true if successful.", "docstring_tokens": ["Moves", "the", "iterator", "to", "next", "path", "and", "returns", "true", "if", "successful", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java#L262-L275", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java", "func_name": "SegmentIteratorImpl.resetToPath", "original_string": "public void resetToPath(int pathIndex) {\n\t\tif (pathIndex < 0)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tm_nextPathIndex = pathIndex;\n\t\tm_currentPathIndex = -1;\n\t\tm_currentSegmentIndex = -1;\n\t\tm_nextSegmentIndex = -1;\n\t\tm_segmentCount = -1;\n\t\tm_pathBegin = -1;\n\t}", "language": "java", "code": "public void resetToPath(int pathIndex) {\n\t\tif (pathIndex < 0)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tm_nextPathIndex = pathIndex;\n\t\tm_currentPathIndex = -1;\n\t\tm_currentSegmentIndex = -1;\n\t\tm_nextSegmentIndex = -1;\n\t\tm_segmentCount = -1;\n\t\tm_pathBegin = -1;\n\t}", "code_tokens": ["public", "void", "resetToPath", "(", "int", "pathIndex", ")", "{", "if", "(", "pathIndex", "<", "0", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "m_nextPathIndex", "=", "pathIndex", ";", "m_currentPathIndex", "=", "-", "1", ";", "m_currentSegmentIndex", "=", "-", "1", ";", "m_nextSegmentIndex", "=", "-", "1", ";", "m_segmentCount", "=", "-", "1", ";", "m_pathBegin", "=", "-", "1", ";", "}"], "docstring": "Resets the iterator such that the subsequent call to the NextPath will\nset the iterator to the first segment of the given path. The call to\nPreviousPath will reset the iterator to the last segment of path\npathIndex - 1.", "docstring_tokens": ["Resets", "the", "iterator", "such", "that", "the", "subsequent", "call", "to", "the", "NextPath", "will", "set", "the", "iterator", "to", "the", "first", "segment", "of", "the", "given", "path", ".", "The", "call", "to", "PreviousPath", "will", "reset", "the", "iterator", "to", "the", "last", "segment", "of", "path", "pathIndex", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SegmentIteratorImpl.java#L310-L320", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCPolygon.java", "func_name": "OGCPolygon.exteriorRing", "original_string": "public OGCLineString exteriorRing() {\n\t\tif (polygon.isEmpty())\n\t\t\treturn new OGCLinearRing((Polygon) polygon.createInstance(), 0,\n\t\t\t\t\tesriSR, true);\n\t\treturn new OGCLinearRing(polygon, 0, esriSR, true);\n\t}", "language": "java", "code": "public OGCLineString exteriorRing() {\n\t\tif (polygon.isEmpty())\n\t\t\treturn new OGCLinearRing((Polygon) polygon.createInstance(), 0,\n\t\t\t\t\tesriSR, true);\n\t\treturn new OGCLinearRing(polygon, 0, esriSR, true);\n\t}", "code_tokens": ["public", "OGCLineString", "exteriorRing", "(", ")", "{", "if", "(", "polygon", ".", "isEmpty", "(", ")", ")", "return", "new", "OGCLinearRing", "(", "(", "Polygon", ")", "polygon", ".", "createInstance", "(", ")", ",", "0", ",", "esriSR", ",", "true", ")", ";", "return", "new", "OGCLinearRing", "(", "polygon", ",", "0", ",", "esriSR", ",", "true", ")", ";", "}"], "docstring": "Returns the exterior ring of this Polygon.\n@return OGCLinearRing instance.", "docstring_tokens": ["Returns", "the", "exterior", "ring", "of", "this", "Polygon", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCPolygon.java#L81-L86", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorDistanceLocal.java", "func_name": "OperatorDistanceLocal.execute", "original_string": "@Override\n\tpublic double execute(Geometry geom1, Geometry geom2,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (null == geom1 || null == geom2) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tGeometry geometryA = geom1;\n\t\tGeometry geometryB = geom2;\n\n\t\tif (geometryA.isEmpty() || geometryB.isEmpty())\n\t\t\treturn NumberUtils.TheNaN;\t\t\n\n\t\tPolygon polygonA;\n\t\tPolygon polygonB;\n\t\tMultiPoint multiPointA;\n\t\tMultiPoint multiPointB;\n\n\t\t// if geometryA is an envelope use a polygon instead (if geom1 was\n\t\t// folded, then geometryA will already be a polygon)\n\t\t// if geometryA is a point use a multipoint instead\n\t\tGeometry.Type gtA = geometryA.getType();\n\t\tGeometry.Type gtB = geometryB.getType();\n\t\tif (gtA == Geometry.Type.Point) {\n\t\t\tif (gtB == Geometry.Type.Point) {\n\t\t\t\treturn Point2D.distance(((Point)geometryA).getXY(), ((Point)geometryB).getXY());\n\t\t\t}\n\t\t\telse if (gtB == Geometry.Type.Envelope) {\n\t\t\t\tEnvelope2D envB = new Envelope2D();\n\t\t\t\tgeometryB.queryEnvelope2D(envB);\n\t\t\t\treturn envB.distance(((Point)geometryA).getXY());\n\t\t\t}\n\t\t\t\n\t\t\tmultiPointA = new MultiPoint();\n\t\t\tmultiPointA.add((Point) geometryA);\n\t\t\tgeometryA = multiPointA;\n\t\t} else if (gtA == Geometry.Type.Envelope) {\n\t\t\tif (gtB == Geometry.Type.Envelope) {\n\t\t\t\tEnvelope2D envA = new Envelope2D();\n\t\t\t\tgeometryA.queryEnvelope2D(envA);\n\t\t\t\tEnvelope2D envB = new Envelope2D();\n\t\t\t\tgeometryB.queryEnvelope2D(envB);\n\t\t\t\treturn envB.distance(envA);\n\t\t\t}\n\t\t\tpolygonA = new Polygon();\n\t\t\tpolygonA.addEnvelope((Envelope) geometryA, false);\n\t\t\tgeometryA = polygonA;\n\t\t}\n\n\t\t// if geom_2 is an envelope use a polygon instead\n\t\t// if geom_2 is a point use a multipoint instead\n\t\tif (gtB == Geometry.Type.Point) {\n\t\t\tmultiPointB = new MultiPoint();\n\t\t\tmultiPointB.add((Point) geometryB);\n\t\t\tgeometryB = multiPointB;\n\t\t} else if (gtB == Geometry.Type.Envelope) {\n\t\t\tpolygonB = new Polygon();\n\t\t\tpolygonB.addEnvelope((Envelope) geometryB, false);\n\t\t\tgeometryB = polygonB;\n\t\t}\n\n\t\tDistanceCalculator distanceCalculator = new DistanceCalculator(\n\t\t\t\tprogressTracker);\n\t\tdouble distance = distanceCalculator.calculate(geometryA, geometryB);\n\t\treturn distance;\n\t}", "language": "java", "code": "@Override\n\tpublic double execute(Geometry geom1, Geometry geom2,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (null == geom1 || null == geom2) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tGeometry geometryA = geom1;\n\t\tGeometry geometryB = geom2;\n\n\t\tif (geometryA.isEmpty() || geometryB.isEmpty())\n\t\t\treturn NumberUtils.TheNaN;\t\t\n\n\t\tPolygon polygonA;\n\t\tPolygon polygonB;\n\t\tMultiPoint multiPointA;\n\t\tMultiPoint multiPointB;\n\n\t\t// if geometryA is an envelope use a polygon instead (if geom1 was\n\t\t// folded, then geometryA will already be a polygon)\n\t\t// if geometryA is a point use a multipoint instead\n\t\tGeometry.Type gtA = geometryA.getType();\n\t\tGeometry.Type gtB = geometryB.getType();\n\t\tif (gtA == Geometry.Type.Point) {\n\t\t\tif (gtB == Geometry.Type.Point) {\n\t\t\t\treturn Point2D.distance(((Point)geometryA).getXY(), ((Point)geometryB).getXY());\n\t\t\t}\n\t\t\telse if (gtB == Geometry.Type.Envelope) {\n\t\t\t\tEnvelope2D envB = new Envelope2D();\n\t\t\t\tgeometryB.queryEnvelope2D(envB);\n\t\t\t\treturn envB.distance(((Point)geometryA).getXY());\n\t\t\t}\n\t\t\t\n\t\t\tmultiPointA = new MultiPoint();\n\t\t\tmultiPointA.add((Point) geometryA);\n\t\t\tgeometryA = multiPointA;\n\t\t} else if (gtA == Geometry.Type.Envelope) {\n\t\t\tif (gtB == Geometry.Type.Envelope) {\n\t\t\t\tEnvelope2D envA = new Envelope2D();\n\t\t\t\tgeometryA.queryEnvelope2D(envA);\n\t\t\t\tEnvelope2D envB = new Envelope2D();\n\t\t\t\tgeometryB.queryEnvelope2D(envB);\n\t\t\t\treturn envB.distance(envA);\n\t\t\t}\n\t\t\tpolygonA = new Polygon();\n\t\t\tpolygonA.addEnvelope((Envelope) geometryA, false);\n\t\t\tgeometryA = polygonA;\n\t\t}\n\n\t\t// if geom_2 is an envelope use a polygon instead\n\t\t// if geom_2 is a point use a multipoint instead\n\t\tif (gtB == Geometry.Type.Point) {\n\t\t\tmultiPointB = new MultiPoint();\n\t\t\tmultiPointB.add((Point) geometryB);\n\t\t\tgeometryB = multiPointB;\n\t\t} else if (gtB == Geometry.Type.Envelope) {\n\t\t\tpolygonB = new Polygon();\n\t\t\tpolygonB.addEnvelope((Envelope) geometryB, false);\n\t\t\tgeometryB = polygonB;\n\t\t}\n\n\t\tDistanceCalculator distanceCalculator = new DistanceCalculator(\n\t\t\t\tprogressTracker);\n\t\tdouble distance = distanceCalculator.calculate(geometryA, geometryB);\n\t\treturn distance;\n\t}", "code_tokens": ["@", "Override", "public", "double", "execute", "(", "Geometry", "geom1", ",", "Geometry", "geom2", ",", "ProgressTracker", "progressTracker", ")", "{", "if", "(", "null", "==", "geom1", "||", "null", "==", "geom2", ")", "{", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "Geometry", "geometryA", "=", "geom1", ";", "Geometry", "geometryB", "=", "geom2", ";", "if", "(", "geometryA", ".", "isEmpty", "(", ")", "||", "geometryB", ".", "isEmpty", "(", ")", ")", "return", "NumberUtils", ".", "TheNaN", ";", "Polygon", "polygonA", ";", "Polygon", "polygonB", ";", "MultiPoint", "multiPointA", ";", "MultiPoint", "multiPointB", ";", "// if geometryA is an envelope use a polygon instead (if geom1 was", "// folded, then geometryA will already be a polygon)", "// if geometryA is a point use a multipoint instead", "Geometry", ".", "Type", "gtA", "=", "geometryA", ".", "getType", "(", ")", ";", "Geometry", ".", "Type", "gtB", "=", "geometryB", ".", "getType", "(", ")", ";", "if", "(", "gtA", "==", "Geometry", ".", "Type", ".", "Point", ")", "{", "if", "(", "gtB", "==", "Geometry", ".", "Type", ".", "Point", ")", "{", "return", "Point2D", ".", "distance", "(", "(", "(", "Point", ")", "geometryA", ")", ".", "getXY", "(", ")", ",", "(", "(", "Point", ")", "geometryB", ")", ".", "getXY", "(", ")", ")", ";", "}", "else", "if", "(", "gtB", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "Envelope2D", "envB", "=", "new", "Envelope2D", "(", ")", ";", "geometryB", ".", "queryEnvelope2D", "(", "envB", ")", ";", "return", "envB", ".", "distance", "(", "(", "(", "Point", ")", "geometryA", ")", ".", "getXY", "(", ")", ")", ";", "}", "multiPointA", "=", "new", "MultiPoint", "(", ")", ";", "multiPointA", ".", "add", "(", "(", "Point", ")", "geometryA", ")", ";", "geometryA", "=", "multiPointA", ";", "}", "else", "if", "(", "gtA", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "if", "(", "gtB", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "Envelope2D", "envA", "=", "new", "Envelope2D", "(", ")", ";", "geometryA", ".", "queryEnvelope2D", "(", "envA", ")", ";", "Envelope2D", "envB", "=", "new", "Envelope2D", "(", ")", ";", "geometryB", ".", "queryEnvelope2D", "(", "envB", ")", ";", "return", "envB", ".", "distance", "(", "envA", ")", ";", "}", "polygonA", "=", "new", "Polygon", "(", ")", ";", "polygonA", ".", "addEnvelope", "(", "(", "Envelope", ")", "geometryA", ",", "false", ")", ";", "geometryA", "=", "polygonA", ";", "}", "// if geom_2 is an envelope use a polygon instead", "// if geom_2 is a point use a multipoint instead", "if", "(", "gtB", "==", "Geometry", ".", "Type", ".", "Point", ")", "{", "multiPointB", "=", "new", "MultiPoint", "(", ")", ";", "multiPointB", ".", "add", "(", "(", "Point", ")", "geometryB", ")", ";", "geometryB", "=", "multiPointB", ";", "}", "else", "if", "(", "gtB", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "polygonB", "=", "new", "Polygon", "(", ")", ";", "polygonB", ".", "addEnvelope", "(", "(", "Envelope", ")", "geometryB", ",", "false", ")", ";", "geometryB", "=", "polygonB", ";", "}", "DistanceCalculator", "distanceCalculator", "=", "new", "DistanceCalculator", "(", "progressTracker", ")", ";", "double", "distance", "=", "distanceCalculator", ".", "calculate", "(", "geometryA", ",", "geometryB", ")", ";", "return", "distance", ";", "}"], "docstring": "Performs the Distance operation on two geometries\n\n@return Returns a double.", "docstring_tokens": ["Performs", "the", "Distance", "operation", "on", "two", "geometries"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorDistanceLocal.java#L34-L99", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCLineString.java", "func_name": "OGCLineString.pointN", "original_string": "public OGCPoint pointN(int n) {\n\t\tint nn;\n\t\tif (multiPath.isClosedPath(0) && n == multiPath.getPathSize(0)) {\n\t\t\tnn = multiPath.getPathStart(0);\n\t\t} else\n\t\t\tnn = n + multiPath.getPathStart(0);\n\n\t\treturn (OGCPoint) OGCGeometry.createFromEsriGeometry(\n\t\t\t\tmultiPath.getPoint(nn), esriSR);\n\t}", "language": "java", "code": "public OGCPoint pointN(int n) {\n\t\tint nn;\n\t\tif (multiPath.isClosedPath(0) && n == multiPath.getPathSize(0)) {\n\t\t\tnn = multiPath.getPathStart(0);\n\t\t} else\n\t\t\tnn = n + multiPath.getPathStart(0);\n\n\t\treturn (OGCPoint) OGCGeometry.createFromEsriGeometry(\n\t\t\t\tmultiPath.getPoint(nn), esriSR);\n\t}", "code_tokens": ["public", "OGCPoint", "pointN", "(", "int", "n", ")", "{", "int", "nn", ";", "if", "(", "multiPath", ".", "isClosedPath", "(", "0", ")", "&&", "n", "==", "multiPath", ".", "getPathSize", "(", "0", ")", ")", "{", "nn", "=", "multiPath", ".", "getPathStart", "(", "0", ")", ";", "}", "else", "nn", "=", "n", "+", "multiPath", ".", "getPathStart", "(", "0", ")", ";", "return", "(", "OGCPoint", ")", "OGCGeometry", ".", "createFromEsriGeometry", "(", "multiPath", ".", "getPoint", "(", "nn", ")", ",", "esriSR", ")", ";", "}"], "docstring": "Returns the specified Point N in this LineString.\n@param n The 0 based index of the Point.", "docstring_tokens": ["Returns", "the", "specified", "Point", "N", "in", "this", "LineString", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCLineString.java#L73-L82", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/NumberUtils.java", "func_name": "NumberUtils.hash", "original_string": "static int hash(int n) {\n\t\tint hash = 5381;\n\t\thash = ((hash << 5) + hash) + (n & 0xFF); /* hash * 33 + c */\n\t\thash = ((hash << 5) + hash) + ((n >> 8) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 16) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 24) & 0xFF);\n\t\thash &= 0x7FFFFFFF;\n\t\treturn hash;\n\t}", "language": "java", "code": "static int hash(int n) {\n\t\tint hash = 5381;\n\t\thash = ((hash << 5) + hash) + (n & 0xFF); /* hash * 33 + c */\n\t\thash = ((hash << 5) + hash) + ((n >> 8) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 16) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 24) & 0xFF);\n\t\thash &= 0x7FFFFFFF;\n\t\treturn hash;\n\t}", "code_tokens": ["static", "int", "hash", "(", "int", "n", ")", "{", "int", "hash", "=", "5381", ";", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "n", "&", "0xFF", ")", ";", "/* hash * 33 + c */", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "(", "n", ">>", "8", ")", "&", "0xFF", ")", ";", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "(", "n", ">>", "16", ")", "&", "0xFF", ")", ";", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "(", "n", ">>", "24", ")", "&", "0xFF", ")", ";", "hash", "&=", "0x7FFFFFFF", ";", "return", "hash", ";", "}"], "docstring": "makes a hash out of an int", "docstring_tokens": ["makes", "a", "hash", "out", "of", "an", "int"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/NumberUtils.java#L77-L85", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/NumberUtils.java", "func_name": "NumberUtils.hash", "original_string": "static int hash(double d) {\n\t\tlong bits = Double.doubleToLongBits(d);\n\t\tint hc = (int) (bits ^ (bits >>> 32));\n\t\treturn hash(hc);\n\t}", "language": "java", "code": "static int hash(double d) {\n\t\tlong bits = Double.doubleToLongBits(d);\n\t\tint hc = (int) (bits ^ (bits >>> 32));\n\t\treturn hash(hc);\n\t}", "code_tokens": ["static", "int", "hash", "(", "double", "d", ")", "{", "long", "bits", "=", "Double", ".", "doubleToLongBits", "(", "d", ")", ";", "int", "hc", "=", "(", "int", ")", "(", "bits", "^", "(", "bits", ">>>", "32", ")", ")", ";", "return", "hash", "(", "hc", ")", ";", "}"], "docstring": "//makes a hash out of an double", "docstring_tokens": ["//", "makes", "a", "hash", "out", "of", "an", "double"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/NumberUtils.java#L88-L92", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/NumberUtils.java", "func_name": "NumberUtils.hash", "original_string": "static int hash(int hashIn, int n) {\n\t\tint hash = ((hashIn << 5) + hashIn) + (n & 0xFF); /* hash * 33 + c */\n\t\thash = ((hash << 5) + hash) + ((n >> 8) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 16) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 24) & 0xFF);\n\t\thash &= 0x7FFFFFFF;\n\t\treturn hash;\n\t}", "language": "java", "code": "static int hash(int hashIn, int n) {\n\t\tint hash = ((hashIn << 5) + hashIn) + (n & 0xFF); /* hash * 33 + c */\n\t\thash = ((hash << 5) + hash) + ((n >> 8) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 16) & 0xFF);\n\t\thash = ((hash << 5) + hash) + ((n >> 24) & 0xFF);\n\t\thash &= 0x7FFFFFFF;\n\t\treturn hash;\n\t}", "code_tokens": ["static", "int", "hash", "(", "int", "hashIn", ",", "int", "n", ")", "{", "int", "hash", "=", "(", "(", "hashIn", "<<", "5", ")", "+", "hashIn", ")", "+", "(", "n", "&", "0xFF", ")", ";", "/* hash * 33 + c */", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "(", "n", ">>", "8", ")", "&", "0xFF", ")", ";", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "(", "n", ">>", "16", ")", "&", "0xFF", ")", ";", "hash", "=", "(", "(", "hash", "<<", "5", ")", "+", "hash", ")", "+", "(", "(", "n", ">>", "24", ")", "&", "0xFF", ")", ";", "hash", "&=", "0x7FFFFFFF", ";", "return", "hash", ";", "}"], "docstring": "adds an int to a hash value", "docstring_tokens": ["adds", "an", "int", "to", "a", "hash", "value"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/NumberUtils.java#L95-L102", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyCursor.java", "func_name": "OperatorSimplifyCursor.next", "original_string": "@Override\n\tpublic Geometry next() {\n\t\tGeometry geometry;\n\t\tif ((geometry = m_inputGeometryCursor.next()) != null)// if (geometry =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m_inputGeometryCursor->Next())\n\t\t{\n\t\t\tm_index = m_inputGeometryCursor.getGeometryID();\n\t\t\tif ((m_progressTracker != null)\n\t\t\t\t\t&& !(m_progressTracker.progress(-1, -1)))\n\t\t\t\tthrow new RuntimeException(\"user_canceled\");\n\t\t\treturn simplify(geometry);\n\t\t}\n\t\treturn null;\n\t}", "language": "java", "code": "@Override\n\tpublic Geometry next() {\n\t\tGeometry geometry;\n\t\tif ((geometry = m_inputGeometryCursor.next()) != null)// if (geometry =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m_inputGeometryCursor->Next())\n\t\t{\n\t\t\tm_index = m_inputGeometryCursor.getGeometryID();\n\t\t\tif ((m_progressTracker != null)\n\t\t\t\t\t&& !(m_progressTracker.progress(-1, -1)))\n\t\t\t\tthrow new RuntimeException(\"user_canceled\");\n\t\t\treturn simplify(geometry);\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["@", "Override", "public", "Geometry", "next", "(", ")", "{", "Geometry", "geometry", ";", "if", "(", "(", "geometry", "=", "m_inputGeometryCursor", ".", "next", "(", ")", ")", "!=", "null", ")", "// if (geometry =", "// m_inputGeometryCursor->Next())", "{", "m_index", "=", "m_inputGeometryCursor", ".", "getGeometryID", "(", ")", ";", "if", "(", "(", "m_progressTracker", "!=", "null", ")", "&&", "!", "(", "m_progressTracker", ".", "progress", "(", "-", "1", ",", "-", "1", ")", ")", ")", "throw", "new", "RuntimeException", "(", "\"user_canceled\"", ")", ";", "return", "simplify", "(", "geometry", ")", ";", "}", "return", "null", ";", "}"], "docstring": "Reviewed vs. Feb 8 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Feb", "8", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyCursor.java#L50-L63", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPointImpl.java", "func_name": "MultiPointImpl.add", "original_string": "public void add(double x, double y) {\n\t\tresize(m_pointCount + 1);\n\t\tPoint2D pt = new Point2D();\n\t\tpt.setCoords(x, y);\n\t\tsetXY(m_pointCount - 1, pt);\n\t}", "language": "java", "code": "public void add(double x, double y) {\n\t\tresize(m_pointCount + 1);\n\t\tPoint2D pt = new Point2D();\n\t\tpt.setCoords(x, y);\n\t\tsetXY(m_pointCount - 1, pt);\n\t}", "code_tokens": ["public", "void", "add", "(", "double", "x", ",", "double", "y", ")", "{", "resize", "(", "m_pointCount", "+", "1", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "pt", ".", "setCoords", "(", "x", ",", "y", ")", ";", "setXY", "(", "m_pointCount", "-", "1", ",", "pt", ")", ";", "}"], "docstring": "Adds a Point to this MultiPoint with given x, y coordinates.", "docstring_tokens": ["Adds", "a", "Point", "to", "this", "MultiPoint", "with", "given", "x", "y", "coordinates", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPointImpl.java#L66-L71", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPointImpl.java", "func_name": "MultiPointImpl.add", "original_string": "public void add(double x, double y, double z) {\n\t\tresize(m_pointCount + 1);\n\t\tPoint3D pt = new Point3D();\n\t\tpt.setCoords(x, y, z);\n\t\tsetXYZ(m_pointCount - 1, pt);\n\t}", "language": "java", "code": "public void add(double x, double y, double z) {\n\t\tresize(m_pointCount + 1);\n\t\tPoint3D pt = new Point3D();\n\t\tpt.setCoords(x, y, z);\n\t\tsetXYZ(m_pointCount - 1, pt);\n\t}", "code_tokens": ["public", "void", "add", "(", "double", "x", ",", "double", "y", ",", "double", "z", ")", "{", "resize", "(", "m_pointCount", "+", "1", ")", ";", "Point3D", "pt", "=", "new", "Point3D", "(", ")", ";", "pt", ".", "setCoords", "(", "x", ",", "y", ",", "z", ")", ";", "setXYZ", "(", "m_pointCount", "-", "1", ",", "pt", ")", ";", "}"], "docstring": "Adds a Point to this MultiPoint with given x, y, z coordinates.", "docstring_tokens": ["Adds", "a", "Point", "to", "this", "MultiPoint", "with", "given", "x", "y", "z", "coordinates", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPointImpl.java#L76-L81", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPointImpl.java", "func_name": "MultiPointImpl.add", "original_string": "public void add(MultiVertexGeometryImpl src, int beginIndex, int endIndex) {\n\t\tint endIndexC = endIndex < 0 ? src.getPointCount() : endIndex;\n\t\tif (beginIndex < 0 || beginIndex > src.getPointCount()\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (beginIndex == endIndexC)\n\t\t\treturn;\n\n\t\tmergeVertexDescription(src.getDescription());\n\t\tint count = endIndexC - beginIndex;\n\t\tint oldPointCount = m_pointCount;\n\t\tresize(m_pointCount + count);\n\t\t_verifyAllStreams();\n\t\tfor (int iattrib = 0, nattrib = src.getDescription()\n\t\t\t\t.getAttributeCount(); iattrib < nattrib; iattrib++) {\n\t\t\tint semantics = src.getDescription()._getSemanticsImpl(iattrib);\n\t\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\t\tAttributeStreamBase stream = getAttributeStreamRef(semantics);\n\t\t\tAttributeStreamBase srcStream = src\n\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\tstream.insertRange(oldPointCount * ncomps, srcStream, beginIndex\n\t\t\t\t\t* ncomps, count * ncomps, true, 1, oldPointCount * ncomps);\n\t\t}\n\t}", "language": "java", "code": "public void add(MultiVertexGeometryImpl src, int beginIndex, int endIndex) {\n\t\tint endIndexC = endIndex < 0 ? src.getPointCount() : endIndex;\n\t\tif (beginIndex < 0 || beginIndex > src.getPointCount()\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (beginIndex == endIndexC)\n\t\t\treturn;\n\n\t\tmergeVertexDescription(src.getDescription());\n\t\tint count = endIndexC - beginIndex;\n\t\tint oldPointCount = m_pointCount;\n\t\tresize(m_pointCount + count);\n\t\t_verifyAllStreams();\n\t\tfor (int iattrib = 0, nattrib = src.getDescription()\n\t\t\t\t.getAttributeCount(); iattrib < nattrib; iattrib++) {\n\t\t\tint semantics = src.getDescription()._getSemanticsImpl(iattrib);\n\t\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\t\tAttributeStreamBase stream = getAttributeStreamRef(semantics);\n\t\t\tAttributeStreamBase srcStream = src\n\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\tstream.insertRange(oldPointCount * ncomps, srcStream, beginIndex\n\t\t\t\t\t* ncomps, count * ncomps, true, 1, oldPointCount * ncomps);\n\t\t}\n\t}", "code_tokens": ["public", "void", "add", "(", "MultiVertexGeometryImpl", "src", ",", "int", "beginIndex", ",", "int", "endIndex", ")", "{", "int", "endIndexC", "=", "endIndex", "<", "0", "?", "src", ".", "getPointCount", "(", ")", ":", "endIndex", ";", "if", "(", "beginIndex", "<", "0", "||", "beginIndex", ">", "src", ".", "getPointCount", "(", ")", "||", "endIndexC", "<", "beginIndex", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "beginIndex", "==", "endIndexC", ")", "return", ";", "mergeVertexDescription", "(", "src", ".", "getDescription", "(", ")", ")", ";", "int", "count", "=", "endIndexC", "-", "beginIndex", ";", "int", "oldPointCount", "=", "m_pointCount", ";", "resize", "(", "m_pointCount", "+", "count", ")", ";", "_verifyAllStreams", "(", ")", ";", "for", "(", "int", "iattrib", "=", "0", ",", "nattrib", "=", "src", ".", "getDescription", "(", ")", ".", "getAttributeCount", "(", ")", ";", "iattrib", "<", "nattrib", ";", "iattrib", "++", ")", "{", "int", "semantics", "=", "src", ".", "getDescription", "(", ")", ".", "_getSemanticsImpl", "(", "iattrib", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "AttributeStreamBase", "stream", "=", "getAttributeStreamRef", "(", "semantics", ")", ";", "AttributeStreamBase", "srcStream", "=", "src", ".", "getAttributeStreamRef", "(", "semantics", ")", ";", "stream", ".", "insertRange", "(", "oldPointCount", "*", "ncomps", ",", "srcStream", ",", "beginIndex", "*", "ncomps", ",", "count", "*", "ncomps", ",", "true", ",", "1", ",", "oldPointCount", "*", "ncomps", ")", ";", "}", "}"], "docstring": "Appends points from another MultiVertexGeometryImpl at the end of this\none.\n\n@param src\nThe source MultiVertexGeometryImpl", "docstring_tokens": ["Appends", "points", "from", "another", "MultiVertexGeometryImpl", "at", "the", "end", "of", "this", "one", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPointImpl.java#L90-L114", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RasterizedGeometry2D.java", "func_name": "RasterizedGeometry2D.create", "original_string": "public static RasterizedGeometry2D create(Geometry geom,\n\t\t\tdouble toleranceXY, int rasterSizeBytes) {\n\t\tif (!canUseAccelerator(geom))\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tRasterizedGeometry2DImpl gc = RasterizedGeometry2DImpl.createImpl(geom,\n\t\t\t\ttoleranceXY, rasterSizeBytes);\n\t\treturn (RasterizedGeometry2D) gc;\n\t}", "language": "java", "code": "public static RasterizedGeometry2D create(Geometry geom,\n\t\t\tdouble toleranceXY, int rasterSizeBytes) {\n\t\tif (!canUseAccelerator(geom))\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tRasterizedGeometry2DImpl gc = RasterizedGeometry2DImpl.createImpl(geom,\n\t\t\t\ttoleranceXY, rasterSizeBytes);\n\t\treturn (RasterizedGeometry2D) gc;\n\t}", "code_tokens": ["public", "static", "RasterizedGeometry2D", "create", "(", "Geometry", "geom", ",", "double", "toleranceXY", ",", "int", "rasterSizeBytes", ")", "{", "if", "(", "!", "canUseAccelerator", "(", "geom", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "RasterizedGeometry2DImpl", "gc", "=", "RasterizedGeometry2DImpl", ".", "createImpl", "(", "geom", ",", "toleranceXY", ",", "rasterSizeBytes", ")", ";", "return", "(", "RasterizedGeometry2D", ")", "gc", ";", "}"], "docstring": "Creates a rasterized geometry from a given Geometry.\n\n@param geom\nThe input geometry to rasterize. It has to be a MultiVertexGeometry instance.\n@param toleranceXY\nThe tolerance of the rasterization. Raster pixels that are\ncloser than given tolerance to the Geometry will be set.\n@param rasterSizeBytes\nThe max size of the raster in bytes. The raster has size of\nrasterSize x rasterSize. Polygons are rasterized into 2 bpp\n(bits per pixel) rasters while other geometries are rasterized\ninto 1 bpp rasters. 32x32 pixel raster for a polygon would\ntake 256 bytes of memory", "docstring_tokens": ["Creates", "a", "rasterized", "geometry", "from", "a", "given", "Geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RasterizedGeometry2D.java#L68-L76", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SegmentIntersector.java", "func_name": "SegmentIntersector.pushSegment", "original_string": "public int pushSegment(Segment seg) {\n\t\tassert (m_input_segments.size() < 2);\n\t\tm_input_segments.add(newIntersectionPart_(seg));\n\t\t// m_param_1.resize(15);\n\t\t// m_param_2.resize(15);\n\t\treturn (int) m_input_segments.size() - 1;\n\t}", "language": "java", "code": "public int pushSegment(Segment seg) {\n\t\tassert (m_input_segments.size() < 2);\n\t\tm_input_segments.add(newIntersectionPart_(seg));\n\t\t// m_param_1.resize(15);\n\t\t// m_param_2.resize(15);\n\t\treturn (int) m_input_segments.size() - 1;\n\t}", "code_tokens": ["public", "int", "pushSegment", "(", "Segment", "seg", ")", "{", "assert", "(", "m_input_segments", ".", "size", "(", ")", "<", "2", ")", ";", "m_input_segments", ".", "add", "(", "newIntersectionPart_", "(", "seg", ")", ")", ";", "// m_param_1.resize(15);", "// m_param_2.resize(15);", "return", "(", "int", ")", "m_input_segments", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "Two segments has to be pushed for the intersect method to succeed.", "docstring_tokens": ["Two", "segments", "has", "to", "be", "pushed", "for", "the", "intersect", "method", "to", "succeed", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SegmentIntersector.java#L143-L149", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SegmentIntersector.java", "func_name": "SegmentIntersector.intersect", "original_string": "public boolean intersect(double tolerance, boolean b_intersecting) {\n\t\tif (m_input_segments.size() != 2)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tm_tolerance = tolerance;\n\t\tdouble small_tolerance_sqr = MathUtils.sqr(tolerance * 0.01);\n\t\tboolean bigmove = false;\n\t\t\n\t\tIntersectionPart part1 = m_input_segments.get(0);\n\t\tIntersectionPart part2 = m_input_segments.get(1);\n\t\tif (b_intersecting\n\t\t\t\t|| (part1.seg._isIntersecting(part2.seg, tolerance, true) & 5) != 0) {\n\t\t\tif (part1.seg.getType().value() == Geometry.GeometryType.Line) {\n\t\t\t\tLine line_1 = (Line) part1.seg;\n\t\t\t\tif (part2.seg.getType().value() == Geometry.GeometryType.Line) {\n\t\t\t\t\tLine line_2 = (Line) part2.seg;\n\t\t\t\t\tint count = Line._intersectLineLine(line_1, line_2, null,\n\t\t\t\t\t\t\tm_param_1, m_param_2, tolerance);\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tassert (count > 0);\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t\t\t}\n\t\t\t\t\tPoint2D[] points = new Point2D[9];\n\t\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\t\t// For each point of intersection, we calculate a\n\t\t\t\t\t\t// weighted point\n\t\t\t\t\t\t// based on the ranks and weights of the endpoints and\n\t\t\t\t\t\t// the interior.\n\t\t\t\t\t\tdouble t1 = m_param_1[i];\n\t\t\t\t\t\tdouble t2 = m_param_2[i];\n\t\t\t\t\t\tint rank1 = part1.rank_interior;\n\t\t\t\t\t\tdouble weight1 = 1.0;\n\n\t\t\t\t\t\tif (t1 == 0) {\n\t\t\t\t\t\t\trank1 = part1.rank_start;\n\t\t\t\t\t\t\tweight1 = part1.weight_start;\n\t\t\t\t\t\t} else if (t1 == 1.0) {\n\t\t\t\t\t\t\trank1 = part1.rank_end;\n\t\t\t\t\t\t\tweight1 = part1.weight_end;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint rank2 = part2.rank_interior;\n\t\t\t\t\t\tdouble weight2 = 1.0;\n\t\t\t\t\t\tif (t2 == 0) {\n\t\t\t\t\t\t\trank2 = part2.rank_start;\n\t\t\t\t\t\t\tweight2 = part2.weight_start;\n\t\t\t\t\t\t} else if (t2 == 1.0) {\n\t\t\t\t\t\t\trank2 = part2.rank_end;\n\t\t\t\t\t\t\tweight2 = part2.weight_end;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdouble ptWeight;\n\n\t\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\t\tif (rank1 == rank2) {// for equal ranks use weighted sum\n\t\t\t\t\t\t\tPoint2D pt_1 = new Point2D();\n\t\t\t\t\t\t\tline_1.getCoord2D(t1, pt_1);\n\t\t\t\t\t\t\tPoint2D pt_2 = new Point2D();\n\t\t\t\t\t\t\tline_2.getCoord2D(t2, pt_2);\n\t\t\t\t\t\t\tptWeight = weight1 + weight2;\n\t\t\t\t\t\t\tdouble t = weight2 / ptWeight;\n\t\t\t\t\t\t\tMathUtils.lerp(pt_1, pt_2, t, pt);\n\t\t\t\t\t\t\tif (Point2D.sqrDistance(pt, pt_1)\n\t\t\t\t\t\t\t\t\t+ Point2D.sqrDistance(pt, pt_2) > small_tolerance_sqr)\n\t\t\t\t\t\t\t\tbigmove = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {// for non-equal ranks, the higher rank wins\n\t\t\t\t\t\t\tif (rank1 > rank2) {\n\t\t\t\t\t\t\t\tline_1.getCoord2D(t1, pt);\n\t\t\t\t\t\t\t\tptWeight = weight1;\n\t\t\t\t\t\t\t\tPoint2D pt_2 = new Point2D();\n\t\t\t\t\t\t\t\tline_2.getCoord2D(t2, pt_2);\n\t\t\t\t\t\t\t\tif (Point2D.sqrDistance(pt, pt_2) > small_tolerance_sqr)\n\t\t\t\t\t\t\t\t\tbigmove = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tline_2.getCoord2D(t2, pt);\n\t\t\t\t\t\t\t\tptWeight = weight2;\n\t\t\t\t\t\t\t\tPoint2D pt_1 = new Point2D();\n\t\t\t\t\t\t\t\tline_1.getCoord2D(t1, pt_1);\n\t\t\t\t\t\t\t\tif (Point2D.sqrDistance(pt, pt_1) > small_tolerance_sqr)\n\t\t\t\t\t\t\t\t\tbigmove = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpoints[i] = pt;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Split the line_1, making sure the endpoints are adusted\n\t\t\t\t\t// to the weighted\n\t\t\t\t\tdouble t0 = 0;\n\t\t\t\t\tint i0 = -1;\n\t\t\t\t\tfor (int i = 0; i <= count; i++) {\n\t\t\t\t\t\tdouble t = i < count ? m_param_1[i] : 1.0;\n\t\t\t\t\t\tif (t != t0) {\n\t\t\t\t\t\t\tSegmentBuffer seg_buffer = newSegmentBuffer_();\n\t\t\t\t\t\t\tline_1.cut(t0, t, seg_buffer);\n\t\t\t\t\t\t\tif (i0 != -1)\n\t\t\t\t\t\t\t\tseg_buffer.get().setStartXY(points[i0]);\n\t\t\t\t\t\t\tif (i != count)\n\t\t\t\t\t\t\t\tseg_buffer.get().setEndXY(points[i]);\n\n\t\t\t\t\t\t\tt0 = t;\n\t\t\t\t\t\t\tm_result_segments_1\n\t\t\t\t\t\t\t\t\t.add(newIntersectionPart_(seg_buffer.get()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tint[] indices = new int[9];\n\t\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t\t\tindices[i] = i;\n\n\t\t\t\t\tif (count > 1) {\n\t\t\t\t\t\tif (m_param_2[0] > m_param_2[1]) {\n\t\t\t\t\t\t\tdouble t = m_param_2[0];\n\t\t\t\t\t\t\tm_param_2[0] = m_param_2[1];\n\t\t\t\t\t\t\tm_param_2[1] = t;\n\t\t\t\t\t\t\tint i = indices[0];\n\t\t\t\t\t\t\tindices[0] = indices[1];\n\t\t\t\t\t\t\tindices[1] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Split the line_2\n\t\t\t\t\tt0 = 0;\n\t\t\t\t\ti0 = -1;\n\t\t\t\t\tfor (int i = 0; i <= count; i++) {\n\t\t\t\t\t\tdouble t = i < count ? m_param_2[i] : 1.0;\n\t\t\t\t\t\tif (t != t0) {\n\t\t\t\t\t\t\tSegmentBuffer seg_buffer = newSegmentBuffer_();\n\t\t\t\t\t\t\tline_2.cut(t0, t, seg_buffer);\n\t\t\t\t\t\t\tif (i0 != -1) {\n\t\t\t\t\t\t\t\tint ind = indices[i0];\n\t\t\t\t\t\t\t\tseg_buffer.get().setStartXY(points[ind]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i != count) {\n\t\t\t\t\t\t\t\tint ind = indices[i];\n\t\t\t\t\t\t\t\tseg_buffer.get().setEndXY(points[ind]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tt0 = t;\n\t\t\t\t\t\t\tm_result_segments_2\n\t\t\t\t\t\t\t\t\t.add(newIntersectionPart_(seg_buffer.get()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn bigmove;\n\t\t\t\t}\n\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t}\n\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\t\t\n\t\treturn false;\n\t}", "language": "java", "code": "public boolean intersect(double tolerance, boolean b_intersecting) {\n\t\tif (m_input_segments.size() != 2)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tm_tolerance = tolerance;\n\t\tdouble small_tolerance_sqr = MathUtils.sqr(tolerance * 0.01);\n\t\tboolean bigmove = false;\n\t\t\n\t\tIntersectionPart part1 = m_input_segments.get(0);\n\t\tIntersectionPart part2 = m_input_segments.get(1);\n\t\tif (b_intersecting\n\t\t\t\t|| (part1.seg._isIntersecting(part2.seg, tolerance, true) & 5) != 0) {\n\t\t\tif (part1.seg.getType().value() == Geometry.GeometryType.Line) {\n\t\t\t\tLine line_1 = (Line) part1.seg;\n\t\t\t\tif (part2.seg.getType().value() == Geometry.GeometryType.Line) {\n\t\t\t\t\tLine line_2 = (Line) part2.seg;\n\t\t\t\t\tint count = Line._intersectLineLine(line_1, line_2, null,\n\t\t\t\t\t\t\tm_param_1, m_param_2, tolerance);\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tassert (count > 0);\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t\t\t}\n\t\t\t\t\tPoint2D[] points = new Point2D[9];\n\t\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\t\t// For each point of intersection, we calculate a\n\t\t\t\t\t\t// weighted point\n\t\t\t\t\t\t// based on the ranks and weights of the endpoints and\n\t\t\t\t\t\t// the interior.\n\t\t\t\t\t\tdouble t1 = m_param_1[i];\n\t\t\t\t\t\tdouble t2 = m_param_2[i];\n\t\t\t\t\t\tint rank1 = part1.rank_interior;\n\t\t\t\t\t\tdouble weight1 = 1.0;\n\n\t\t\t\t\t\tif (t1 == 0) {\n\t\t\t\t\t\t\trank1 = part1.rank_start;\n\t\t\t\t\t\t\tweight1 = part1.weight_start;\n\t\t\t\t\t\t} else if (t1 == 1.0) {\n\t\t\t\t\t\t\trank1 = part1.rank_end;\n\t\t\t\t\t\t\tweight1 = part1.weight_end;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint rank2 = part2.rank_interior;\n\t\t\t\t\t\tdouble weight2 = 1.0;\n\t\t\t\t\t\tif (t2 == 0) {\n\t\t\t\t\t\t\trank2 = part2.rank_start;\n\t\t\t\t\t\t\tweight2 = part2.weight_start;\n\t\t\t\t\t\t} else if (t2 == 1.0) {\n\t\t\t\t\t\t\trank2 = part2.rank_end;\n\t\t\t\t\t\t\tweight2 = part2.weight_end;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdouble ptWeight;\n\n\t\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\t\tif (rank1 == rank2) {// for equal ranks use weighted sum\n\t\t\t\t\t\t\tPoint2D pt_1 = new Point2D();\n\t\t\t\t\t\t\tline_1.getCoord2D(t1, pt_1);\n\t\t\t\t\t\t\tPoint2D pt_2 = new Point2D();\n\t\t\t\t\t\t\tline_2.getCoord2D(t2, pt_2);\n\t\t\t\t\t\t\tptWeight = weight1 + weight2;\n\t\t\t\t\t\t\tdouble t = weight2 / ptWeight;\n\t\t\t\t\t\t\tMathUtils.lerp(pt_1, pt_2, t, pt);\n\t\t\t\t\t\t\tif (Point2D.sqrDistance(pt, pt_1)\n\t\t\t\t\t\t\t\t\t+ Point2D.sqrDistance(pt, pt_2) > small_tolerance_sqr)\n\t\t\t\t\t\t\t\tbigmove = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {// for non-equal ranks, the higher rank wins\n\t\t\t\t\t\t\tif (rank1 > rank2) {\n\t\t\t\t\t\t\t\tline_1.getCoord2D(t1, pt);\n\t\t\t\t\t\t\t\tptWeight = weight1;\n\t\t\t\t\t\t\t\tPoint2D pt_2 = new Point2D();\n\t\t\t\t\t\t\t\tline_2.getCoord2D(t2, pt_2);\n\t\t\t\t\t\t\t\tif (Point2D.sqrDistance(pt, pt_2) > small_tolerance_sqr)\n\t\t\t\t\t\t\t\t\tbigmove = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tline_2.getCoord2D(t2, pt);\n\t\t\t\t\t\t\t\tptWeight = weight2;\n\t\t\t\t\t\t\t\tPoint2D pt_1 = new Point2D();\n\t\t\t\t\t\t\t\tline_1.getCoord2D(t1, pt_1);\n\t\t\t\t\t\t\t\tif (Point2D.sqrDistance(pt, pt_1) > small_tolerance_sqr)\n\t\t\t\t\t\t\t\t\tbigmove = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpoints[i] = pt;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Split the line_1, making sure the endpoints are adusted\n\t\t\t\t\t// to the weighted\n\t\t\t\t\tdouble t0 = 0;\n\t\t\t\t\tint i0 = -1;\n\t\t\t\t\tfor (int i = 0; i <= count; i++) {\n\t\t\t\t\t\tdouble t = i < count ? m_param_1[i] : 1.0;\n\t\t\t\t\t\tif (t != t0) {\n\t\t\t\t\t\t\tSegmentBuffer seg_buffer = newSegmentBuffer_();\n\t\t\t\t\t\t\tline_1.cut(t0, t, seg_buffer);\n\t\t\t\t\t\t\tif (i0 != -1)\n\t\t\t\t\t\t\t\tseg_buffer.get().setStartXY(points[i0]);\n\t\t\t\t\t\t\tif (i != count)\n\t\t\t\t\t\t\t\tseg_buffer.get().setEndXY(points[i]);\n\n\t\t\t\t\t\t\tt0 = t;\n\t\t\t\t\t\t\tm_result_segments_1\n\t\t\t\t\t\t\t\t\t.add(newIntersectionPart_(seg_buffer.get()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tint[] indices = new int[9];\n\t\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t\t\tindices[i] = i;\n\n\t\t\t\t\tif (count > 1) {\n\t\t\t\t\t\tif (m_param_2[0] > m_param_2[1]) {\n\t\t\t\t\t\t\tdouble t = m_param_2[0];\n\t\t\t\t\t\t\tm_param_2[0] = m_param_2[1];\n\t\t\t\t\t\t\tm_param_2[1] = t;\n\t\t\t\t\t\t\tint i = indices[0];\n\t\t\t\t\t\t\tindices[0] = indices[1];\n\t\t\t\t\t\t\tindices[1] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Split the line_2\n\t\t\t\t\tt0 = 0;\n\t\t\t\t\ti0 = -1;\n\t\t\t\t\tfor (int i = 0; i <= count; i++) {\n\t\t\t\t\t\tdouble t = i < count ? m_param_2[i] : 1.0;\n\t\t\t\t\t\tif (t != t0) {\n\t\t\t\t\t\t\tSegmentBuffer seg_buffer = newSegmentBuffer_();\n\t\t\t\t\t\t\tline_2.cut(t0, t, seg_buffer);\n\t\t\t\t\t\t\tif (i0 != -1) {\n\t\t\t\t\t\t\t\tint ind = indices[i0];\n\t\t\t\t\t\t\t\tseg_buffer.get().setStartXY(points[ind]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i != count) {\n\t\t\t\t\t\t\t\tint ind = indices[i];\n\t\t\t\t\t\t\t\tseg_buffer.get().setEndXY(points[ind]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tt0 = t;\n\t\t\t\t\t\t\tm_result_segments_2\n\t\t\t\t\t\t\t\t\t.add(newIntersectionPart_(seg_buffer.get()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn bigmove;\n\t\t\t\t}\n\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t}\n\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\t\t\n\t\treturn false;\n\t}", "code_tokens": ["public", "boolean", "intersect", "(", "double", "tolerance", ",", "boolean", "b_intersecting", ")", "{", "if", "(", "m_input_segments", ".", "size", "(", ")", "!=", "2", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "m_tolerance", "=", "tolerance", ";", "double", "small_tolerance_sqr", "=", "MathUtils", ".", "sqr", "(", "tolerance", "*", "0.01", ")", ";", "boolean", "bigmove", "=", "false", ";", "IntersectionPart", "part1", "=", "m_input_segments", ".", "get", "(", "0", ")", ";", "IntersectionPart", "part2", "=", "m_input_segments", ".", "get", "(", "1", ")", ";", "if", "(", "b_intersecting", "||", "(", "part1", ".", "seg", ".", "_isIntersecting", "(", "part2", ".", "seg", ",", "tolerance", ",", "true", ")", "&", "5", ")", "!=", "0", ")", "{", "if", "(", "part1", ".", "seg", ".", "getType", "(", ")", ".", "value", "(", ")", "==", "Geometry", ".", "GeometryType", ".", "Line", ")", "{", "Line", "line_1", "=", "(", "Line", ")", "part1", ".", "seg", ";", "if", "(", "part2", ".", "seg", ".", "getType", "(", ")", ".", "value", "(", ")", "==", "Geometry", ".", "GeometryType", ".", "Line", ")", "{", "Line", "line_2", "=", "(", "Line", ")", "part2", ".", "seg", ";", "int", "count", "=", "Line", ".", "_intersectLineLine", "(", "line_1", ",", "line_2", ",", "null", ",", "m_param_1", ",", "m_param_2", ",", "tolerance", ")", ";", "if", "(", "count", "==", "0", ")", "{", "assert", "(", "count", ">", "0", ")", ";", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "Point2D", "[", "]", "points", "=", "new", "Point2D", "[", "9", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "// For each point of intersection, we calculate a", "// weighted point", "// based on the ranks and weights of the endpoints and", "// the interior.", "double", "t1", "=", "m_param_1", "[", "i", "]", ";", "double", "t2", "=", "m_param_2", "[", "i", "]", ";", "int", "rank1", "=", "part1", ".", "rank_interior", ";", "double", "weight1", "=", "1.0", ";", "if", "(", "t1", "==", "0", ")", "{", "rank1", "=", "part1", ".", "rank_start", ";", "weight1", "=", "part1", ".", "weight_start", ";", "}", "else", "if", "(", "t1", "==", "1.0", ")", "{", "rank1", "=", "part1", ".", "rank_end", ";", "weight1", "=", "part1", ".", "weight_end", ";", "}", "int", "rank2", "=", "part2", ".", "rank_interior", ";", "double", "weight2", "=", "1.0", ";", "if", "(", "t2", "==", "0", ")", "{", "rank2", "=", "part2", ".", "rank_start", ";", "weight2", "=", "part2", ".", "weight_start", ";", "}", "else", "if", "(", "t2", "==", "1.0", ")", "{", "rank2", "=", "part2", ".", "rank_end", ";", "weight2", "=", "part2", ".", "weight_end", ";", "}", "double", "ptWeight", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "if", "(", "rank1", "==", "rank2", ")", "{", "// for equal ranks use weighted sum", "Point2D", "pt_1", "=", "new", "Point2D", "(", ")", ";", "line_1", ".", "getCoord2D", "(", "t1", ",", "pt_1", ")", ";", "Point2D", "pt_2", "=", "new", "Point2D", "(", ")", ";", "line_2", ".", "getCoord2D", "(", "t2", ",", "pt_2", ")", ";", "ptWeight", "=", "weight1", "+", "weight2", ";", "double", "t", "=", "weight2", "/", "ptWeight", ";", "MathUtils", ".", "lerp", "(", "pt_1", ",", "pt_2", ",", "t", ",", "pt", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt", ",", "pt_1", ")", "+", "Point2D", ".", "sqrDistance", "(", "pt", ",", "pt_2", ")", ">", "small_tolerance_sqr", ")", "bigmove", "=", "true", ";", "}", "else", "{", "// for non-equal ranks, the higher rank wins", "if", "(", "rank1", ">", "rank2", ")", "{", "line_1", ".", "getCoord2D", "(", "t1", ",", "pt", ")", ";", "ptWeight", "=", "weight1", ";", "Point2D", "pt_2", "=", "new", "Point2D", "(", ")", ";", "line_2", ".", "getCoord2D", "(", "t2", ",", "pt_2", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt", ",", "pt_2", ")", ">", "small_tolerance_sqr", ")", "bigmove", "=", "true", ";", "}", "else", "{", "line_2", ".", "getCoord2D", "(", "t2", ",", "pt", ")", ";", "ptWeight", "=", "weight2", ";", "Point2D", "pt_1", "=", "new", "Point2D", "(", ")", ";", "line_1", ".", "getCoord2D", "(", "t1", ",", "pt_1", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt", ",", "pt_1", ")", ">", "small_tolerance_sqr", ")", "bigmove", "=", "true", ";", "}", "}", "points", "[", "i", "]", "=", "pt", ";", "}", "// Split the line_1, making sure the endpoints are adusted", "// to the weighted", "double", "t0", "=", "0", ";", "int", "i0", "=", "-", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<=", "count", ";", "i", "++", ")", "{", "double", "t", "=", "i", "<", "count", "?", "m_param_1", "[", "i", "]", ":", "1.0", ";", "if", "(", "t", "!=", "t0", ")", "{", "SegmentBuffer", "seg_buffer", "=", "newSegmentBuffer_", "(", ")", ";", "line_1", ".", "cut", "(", "t0", ",", "t", ",", "seg_buffer", ")", ";", "if", "(", "i0", "!=", "-", "1", ")", "seg_buffer", ".", "get", "(", ")", ".", "setStartXY", "(", "points", "[", "i0", "]", ")", ";", "if", "(", "i", "!=", "count", ")", "seg_buffer", ".", "get", "(", ")", ".", "setEndXY", "(", "points", "[", "i", "]", ")", ";", "t0", "=", "t", ";", "m_result_segments_1", ".", "add", "(", "newIntersectionPart_", "(", "seg_buffer", ".", "get", "(", ")", ")", ")", ";", "}", "i0", "=", "i", ";", "}", "int", "[", "]", "indices", "=", "new", "int", "[", "9", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "indices", "[", "i", "]", "=", "i", ";", "if", "(", "count", ">", "1", ")", "{", "if", "(", "m_param_2", "[", "0", "]", ">", "m_param_2", "[", "1", "]", ")", "{", "double", "t", "=", "m_param_2", "[", "0", "]", ";", "m_param_2", "[", "0", "]", "=", "m_param_2", "[", "1", "]", ";", "m_param_2", "[", "1", "]", "=", "t", ";", "int", "i", "=", "indices", "[", "0", "]", ";", "indices", "[", "0", "]", "=", "indices", "[", "1", "]", ";", "indices", "[", "1", "]", "=", "i", ";", "}", "}", "// Split the line_2", "t0", "=", "0", ";", "i0", "=", "-", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<=", "count", ";", "i", "++", ")", "{", "double", "t", "=", "i", "<", "count", "?", "m_param_2", "[", "i", "]", ":", "1.0", ";", "if", "(", "t", "!=", "t0", ")", "{", "SegmentBuffer", "seg_buffer", "=", "newSegmentBuffer_", "(", ")", ";", "line_2", ".", "cut", "(", "t0", ",", "t", ",", "seg_buffer", ")", ";", "if", "(", "i0", "!=", "-", "1", ")", "{", "int", "ind", "=", "indices", "[", "i0", "]", ";", "seg_buffer", ".", "get", "(", ")", ".", "setStartXY", "(", "points", "[", "ind", "]", ")", ";", "}", "if", "(", "i", "!=", "count", ")", "{", "int", "ind", "=", "indices", "[", "i", "]", ";", "seg_buffer", ".", "get", "(", ")", ".", "setEndXY", "(", "points", "[", "ind", "]", ")", ";", "}", "t0", "=", "t", ";", "m_result_segments_2", ".", "add", "(", "newIntersectionPart_", "(", "seg_buffer", ".", "get", "(", ")", ")", ")", ";", "}", "i0", "=", "i", ";", "}", "return", "bigmove", ";", "}", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "return", "false", ";", "}"], "docstring": "Performs the intersection", "docstring_tokens": ["Performs", "the", "intersection"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SegmentIntersector.java#L196-L352", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepMonkierComparator.java", "func_name": "SweepMonkierComparator.compare", "original_string": "@Override\n\tint compare(Treap treap, int node) {\n\t\tint vertex = treap.getElement(node);\n\t\treturn compareVertex_(treap, node, vertex);\n\t}", "language": "java", "code": "@Override\n\tint compare(Treap treap, int node) {\n\t\tint vertex = treap.getElement(node);\n\t\treturn compareVertex_(treap, node, vertex);\n\t}", "code_tokens": ["@", "Override", "int", "compare", "(", "Treap", "treap", ",", "int", "node", ")", "{", "int", "vertex", "=", "treap", ".", "getElement", "(", "node", ")", ";", "return", "compareVertex_", "(", "treap", ",", "node", ",", "vertex", ")", ";", "}"], "docstring": "element contained in the given node.", "docstring_tokens": ["element", "contained", "in", "the", "given", "node", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepMonkierComparator.java#L78-L82", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiDCList.java", "func_name": "IndexMultiDCList.createList", "original_string": "int createList(int listData) {\n\t\tint list = newList_();\n\t\t// m_lists.set_field(list, 0, null_node());//head\n\t\t// m_lists.set_field(list, 1, null_node());//tail\n\t\t// m_lists.set_field(list, 2, null_node());//prev list\n\t\tm_lists.setField(list, 3, m_list_of_lists); // next list\n\t\tm_lists.setField(list, 4, 0);// node count in the list\n\t\tm_lists.setField(list, 5, listData);\n\t\tif (m_list_of_lists != nullNode())\n\t\t\tsetPrevList_(m_list_of_lists, list);\n\n\t\tm_list_of_lists = list;\n\t\treturn list;\n\t}", "language": "java", "code": "int createList(int listData) {\n\t\tint list = newList_();\n\t\t// m_lists.set_field(list, 0, null_node());//head\n\t\t// m_lists.set_field(list, 1, null_node());//tail\n\t\t// m_lists.set_field(list, 2, null_node());//prev list\n\t\tm_lists.setField(list, 3, m_list_of_lists); // next list\n\t\tm_lists.setField(list, 4, 0);// node count in the list\n\t\tm_lists.setField(list, 5, listData);\n\t\tif (m_list_of_lists != nullNode())\n\t\t\tsetPrevList_(m_list_of_lists, list);\n\n\t\tm_list_of_lists = list;\n\t\treturn list;\n\t}", "code_tokens": ["int", "createList", "(", "int", "listData", ")", "{", "int", "list", "=", "newList_", "(", ")", ";", "// m_lists.set_field(list, 0, null_node());//head", "// m_lists.set_field(list, 1, null_node());//tail", "// m_lists.set_field(list, 2, null_node());//prev list", "m_lists", ".", "setField", "(", "list", ",", "3", ",", "m_list_of_lists", ")", ";", "// next list", "m_lists", ".", "setField", "(", "list", ",", "4", ",", "0", ")", ";", "// node count in the list", "m_lists", ".", "setField", "(", "list", ",", "5", ",", "listData", ")", ";", "if", "(", "m_list_of_lists", "!=", "nullNode", "(", ")", ")", "setPrevList_", "(", "m_list_of_lists", ",", "list", ")", ";", "m_list_of_lists", "=", "list", ";", "return", "list", ";", "}"], "docstring": "listData is user's info associated with the list", "docstring_tokens": ["listData", "is", "user", "s", "info", "associated", "with", "the", "list"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiDCList.java#L103-L116", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiDCList.java", "func_name": "IndexMultiDCList.deleteList", "original_string": "int deleteList(int list) {\n\t\tclear(list);\n\t\tint prevList = m_lists.getField(list, 2);\n\t\tint nextList = m_lists.getField(list, 3);\n\t\tif (prevList != nullNode())\n\t\t\tsetNextList_(prevList, nextList);\n\t\telse\n\t\t\tm_list_of_lists = nextList;\n\n\t\tif (nextList != nullNode())\n\t\t\tsetPrevList_(nextList, prevList);\n\n\t\tfreeList_(list);\n\t\treturn nextList;\n\t}", "language": "java", "code": "int deleteList(int list) {\n\t\tclear(list);\n\t\tint prevList = m_lists.getField(list, 2);\n\t\tint nextList = m_lists.getField(list, 3);\n\t\tif (prevList != nullNode())\n\t\t\tsetNextList_(prevList, nextList);\n\t\telse\n\t\t\tm_list_of_lists = nextList;\n\n\t\tif (nextList != nullNode())\n\t\t\tsetPrevList_(nextList, prevList);\n\n\t\tfreeList_(list);\n\t\treturn nextList;\n\t}", "code_tokens": ["int", "deleteList", "(", "int", "list", ")", "{", "clear", "(", "list", ")", ";", "int", "prevList", "=", "m_lists", ".", "getField", "(", "list", ",", "2", ")", ";", "int", "nextList", "=", "m_lists", ".", "getField", "(", "list", ",", "3", ")", ";", "if", "(", "prevList", "!=", "nullNode", "(", ")", ")", "setNextList_", "(", "prevList", ",", "nextList", ")", ";", "else", "m_list_of_lists", "=", "nextList", ";", "if", "(", "nextList", "!=", "nullNode", "(", ")", ")", "setPrevList_", "(", "nextList", ",", "prevList", ")", ";", "freeList_", "(", "list", ")", ";", "return", "nextList", ";", "}"], "docstring": "Deletes a list and returns the index of the next list.", "docstring_tokens": ["Deletes", "a", "list", "and", "returns", "the", "index", "of", "the", "next", "list", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiDCList.java#L119-L133", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiDCList.java", "func_name": "IndexMultiDCList.insertElement", "original_string": "int insertElement(int list, int beforeNode, int data) {\n\t\tint node = newNode_();\n\t\tint prev = -1;\n\t\tif (beforeNode != nullNode()) {\n\t\t\tprev = getPrev(beforeNode);\n\t\t\tsetPrev_(beforeNode, node);\n\t\t}\n\n\t\tsetNext_(node, beforeNode);\n\t\tif (prev != nullNode())\n\t\t\tsetNext_(prev, node);\n\n\t\tint head = m_lists.getField(list, 0);\n\n\t\tif (beforeNode == head)\n\t\t\tm_lists.setField(list, 0, node);\n\t\tif (beforeNode == nullNode()) {\n\t\t\tint tail = m_lists.getField(list, 1);\n\t\t\tsetPrev_(node, tail);\n\t\t\tif (tail != -1)\n\t\t\t\tsetNext_(tail, node);\n\n\t\t\tm_lists.setField(list, 1, node);\n\t\t}\n\n\t\tsetData(node, data);\n\t\tsetListSize_(list, getListSize(list) + 1);\n\n\t\tif (m_b_store_list_index_with_node)\n\t\t\tsetList_(node, list);\n\n\t\treturn node;\n\t}", "language": "java", "code": "int insertElement(int list, int beforeNode, int data) {\n\t\tint node = newNode_();\n\t\tint prev = -1;\n\t\tif (beforeNode != nullNode()) {\n\t\t\tprev = getPrev(beforeNode);\n\t\t\tsetPrev_(beforeNode, node);\n\t\t}\n\n\t\tsetNext_(node, beforeNode);\n\t\tif (prev != nullNode())\n\t\t\tsetNext_(prev, node);\n\n\t\tint head = m_lists.getField(list, 0);\n\n\t\tif (beforeNode == head)\n\t\t\tm_lists.setField(list, 0, node);\n\t\tif (beforeNode == nullNode()) {\n\t\t\tint tail = m_lists.getField(list, 1);\n\t\t\tsetPrev_(node, tail);\n\t\t\tif (tail != -1)\n\t\t\t\tsetNext_(tail, node);\n\n\t\t\tm_lists.setField(list, 1, node);\n\t\t}\n\n\t\tsetData(node, data);\n\t\tsetListSize_(list, getListSize(list) + 1);\n\n\t\tif (m_b_store_list_index_with_node)\n\t\t\tsetList_(node, list);\n\n\t\treturn node;\n\t}", "code_tokens": ["int", "insertElement", "(", "int", "list", ",", "int", "beforeNode", ",", "int", "data", ")", "{", "int", "node", "=", "newNode_", "(", ")", ";", "int", "prev", "=", "-", "1", ";", "if", "(", "beforeNode", "!=", "nullNode", "(", ")", ")", "{", "prev", "=", "getPrev", "(", "beforeNode", ")", ";", "setPrev_", "(", "beforeNode", ",", "node", ")", ";", "}", "setNext_", "(", "node", ",", "beforeNode", ")", ";", "if", "(", "prev", "!=", "nullNode", "(", ")", ")", "setNext_", "(", "prev", ",", "node", ")", ";", "int", "head", "=", "m_lists", ".", "getField", "(", "list", ",", "0", ")", ";", "if", "(", "beforeNode", "==", "head", ")", "m_lists", ".", "setField", "(", "list", ",", "0", ",", "node", ")", ";", "if", "(", "beforeNode", "==", "nullNode", "(", ")", ")", "{", "int", "tail", "=", "m_lists", ".", "getField", "(", "list", ",", "1", ")", ";", "setPrev_", "(", "node", ",", "tail", ")", ";", "if", "(", "tail", "!=", "-", "1", ")", "setNext_", "(", "tail", ",", "node", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "node", ")", ";", "}", "setData", "(", "node", ",", "data", ")", ";", "setListSize_", "(", "list", ",", "getListSize", "(", "list", ")", "+", "1", ")", ";", "if", "(", "m_b_store_list_index_with_node", ")", "setList_", "(", "node", ",", "list", ")", ";", "return", "node", ";", "}"], "docstring": "Inserts a new node before the given one .", "docstring_tokens": ["Inserts", "a", "new", "node", "before", "the", "given", "one", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiDCList.java#L164-L196", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiDCList.java", "func_name": "IndexMultiDCList.deleteElement", "original_string": "int deleteElement(int list, int node) {\n\t\tint prev = getPrev(node);\n\t\tint next = getNext(node);\n\t\tif (prev != nullNode())\n\t\t\tsetNext_(prev, next);\n\t\telse\n\t\t\tm_lists.setField(list, 0, next);// change head\n\t\tif (next != nullNode())\n\t\t\tsetPrev_(next, prev);\n\t\telse\n\t\t\tm_lists.setField(list, 1, prev);// change tail\n\n\t\tfreeNode_(node);\n\t\tsetListSize_(list, getListSize(list) - 1);\n\t\treturn next;\n\t}", "language": "java", "code": "int deleteElement(int list, int node) {\n\t\tint prev = getPrev(node);\n\t\tint next = getNext(node);\n\t\tif (prev != nullNode())\n\t\t\tsetNext_(prev, next);\n\t\telse\n\t\t\tm_lists.setField(list, 0, next);// change head\n\t\tif (next != nullNode())\n\t\t\tsetPrev_(next, prev);\n\t\telse\n\t\t\tm_lists.setField(list, 1, prev);// change tail\n\n\t\tfreeNode_(node);\n\t\tsetListSize_(list, getListSize(list) - 1);\n\t\treturn next;\n\t}", "code_tokens": ["int", "deleteElement", "(", "int", "list", ",", "int", "node", ")", "{", "int", "prev", "=", "getPrev", "(", "node", ")", ";", "int", "next", "=", "getNext", "(", "node", ")", ";", "if", "(", "prev", "!=", "nullNode", "(", ")", ")", "setNext_", "(", "prev", ",", "next", ")", ";", "else", "m_lists", ".", "setField", "(", "list", ",", "0", ",", "next", ")", ";", "// change head", "if", "(", "next", "!=", "nullNode", "(", ")", ")", "setPrev_", "(", "next", ",", "prev", ")", ";", "else", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "prev", ")", ";", "// change tail", "freeNode_", "(", "node", ")", ";", "setListSize_", "(", "list", ",", "getListSize", "(", "list", ")", "-", "1", ")", ";", "return", "next", ";", "}"], "docstring": "Deletes a node from a list. Returns the next node after the deleted one.", "docstring_tokens": ["Deletes", "a", "node", "from", "a", "list", ".", "Returns", "the", "next", "node", "after", "the", "deleted", "one", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiDCList.java#L199-L214", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiDCList.java", "func_name": "IndexMultiDCList.clear", "original_string": "void clear(int list) {\n\t\tint last = getLast(list);\n\t\twhile (last != nullNode()) {\n\t\t\tint n = last;\n\t\t\tlast = getPrev(n);\n\t\t\tfreeNode_(n);\n\t\t}\n\t\tm_lists.setField(list, 0, -1);\n\t\tm_lists.setField(list, 1, -1);\n\t\tsetListSize_(list, 0);\n\t}", "language": "java", "code": "void clear(int list) {\n\t\tint last = getLast(list);\n\t\twhile (last != nullNode()) {\n\t\t\tint n = last;\n\t\t\tlast = getPrev(n);\n\t\t\tfreeNode_(n);\n\t\t}\n\t\tm_lists.setField(list, 0, -1);\n\t\tm_lists.setField(list, 1, -1);\n\t\tsetListSize_(list, 0);\n\t}", "code_tokens": ["void", "clear", "(", "int", "list", ")", "{", "int", "last", "=", "getLast", "(", "list", ")", ";", "while", "(", "last", "!=", "nullNode", "(", ")", ")", "{", "int", "n", "=", "last", ";", "last", "=", "getPrev", "(", "n", ")", ";", "freeNode_", "(", "n", ")", ";", "}", "m_lists", ".", "setField", "(", "list", ",", "0", ",", "-", "1", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "-", "1", ")", ";", "setListSize_", "(", "list", ",", "0", ")", ";", "}"], "docstring": "Clears all nodes from the list.", "docstring_tokens": ["Clears", "all", "nodes", "from", "the", "list", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiDCList.java#L264-L274", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation3D.java", "func_name": "Transformation3D.setZero", "original_string": "public void setZero() {\n\t\txx = 0.0;\n\t\tyx = 0.0;\n\t\tzx = 0.0;\n\t\txy = 0.0;\n\t\tyy = 0.0;\n\t\tzy = 0.0;\n\t\txz = 0.0;\n\t\tyz = 0.0;\n\t\tzz = 0.0;\n\t\txd = 0.0;\n\t\tyd = 0.0;\n\t\tzd = 0.0;\n\t}", "language": "java", "code": "public void setZero() {\n\t\txx = 0.0;\n\t\tyx = 0.0;\n\t\tzx = 0.0;\n\t\txy = 0.0;\n\t\tyy = 0.0;\n\t\tzy = 0.0;\n\t\txz = 0.0;\n\t\tyz = 0.0;\n\t\tzz = 0.0;\n\t\txd = 0.0;\n\t\tyd = 0.0;\n\t\tzd = 0.0;\n\t}", "code_tokens": ["public", "void", "setZero", "(", ")", "{", "xx", "=", "0.0", ";", "yx", "=", "0.0", ";", "zx", "=", "0.0", ";", "xy", "=", "0.0", ";", "yy", "=", "0.0", ";", "zy", "=", "0.0", ";", "xz", "=", "0.0", ";", "yz", "=", "0.0", ";", "zz", "=", "0.0", ";", "xd", "=", "0.0", ";", "yd", "=", "0.0", ";", "zd", "=", "0.0", ";", "}"], "docstring": "Sets all elements to 0, thus producing and invalid transformation.", "docstring_tokens": ["Sets", "all", "elements", "to", "0", "thus", "producing", "and", "invalid", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation3D.java#L47-L60", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation3D.java", "func_name": "Transformation3D.transform", "original_string": "public Envelope3D transform(Envelope3D env) {\n\n\t\tif (env.isEmpty())\n\t\t\treturn env;\n\n\t\tPoint3D[] buf = new Point3D[8];\n\t\tenv.queryCorners(buf);\n\n\t\ttransform(buf, 8, buf);\n\t\tenv.setFromPoints(buf);\n\t\treturn env;\n\t}", "language": "java", "code": "public Envelope3D transform(Envelope3D env) {\n\n\t\tif (env.isEmpty())\n\t\t\treturn env;\n\n\t\tPoint3D[] buf = new Point3D[8];\n\t\tenv.queryCorners(buf);\n\n\t\ttransform(buf, 8, buf);\n\t\tenv.setFromPoints(buf);\n\t\treturn env;\n\t}", "code_tokens": ["public", "Envelope3D", "transform", "(", "Envelope3D", "env", ")", "{", "if", "(", "env", ".", "isEmpty", "(", ")", ")", "return", "env", ";", "Point3D", "[", "]", "buf", "=", "new", "Point3D", "[", "8", "]", ";", "env", ".", "queryCorners", "(", "buf", ")", ";", "transform", "(", "buf", ",", "8", ",", "buf", ")", ";", "env", ".", "setFromPoints", "(", "buf", ")", ";", "return", "env", ";", "}"], "docstring": "Transforms an envelope. The result is the bounding box of the transformed\nenvelope.", "docstring_tokens": ["Transforms", "an", "envelope", ".", "The", "result", "is", "the", "bounding", "box", "of", "the", "transformed", "envelope", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation3D.java#L102-L113", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation3D.java", "func_name": "Transformation3D.multiply", "original_string": "public static void multiply(Transformation3D a, Transformation3D b,\n\t\t\tTransformation3D result) {\n\t\tdouble xx, yx, zx;\n\t\tdouble xy, yy, zy;\n\t\tdouble xz, yz, zz;\n\t\tdouble xd, yd, zd;\n\n\t\txx = a.xx * b.xx + a.yx * b.xy + a.zx * b.xz;\n\t\tyx = a.xx * b.yx + a.yx * b.yy + a.zx * b.yz;\n\t\tzx = a.xx * b.zx + a.yx * b.zy + a.zx * b.zz;\n\t\txy = a.xy * b.xx + a.yy * b.xy + a.zy * b.xz;\n\t\tyy = a.xy * b.yx + a.yy * b.yy + a.zy * b.yz;\n\t\tzy = a.xy * b.zx + a.yy * b.zy + a.zy * b.zz;\n\t\txz = a.xz * b.xx + a.yz * b.xy + a.zz * b.xz;\n\t\tyz = a.xz * b.yx + a.yz * b.yy + a.zz * b.yz;\n\t\tzz = a.xz * b.zx + a.yz * b.zy + a.zz * b.zz;\n\t\txd = a.xd * b.xx + a.yd * b.xy + a.zd * b.xz + b.xd;\n\t\tyd = a.xd * b.yx + a.yd * b.yy + a.zd * b.yz + b.yd;\n\t\tzd = a.xd * b.zx + a.yd * b.zy + a.zd * b.zz + b.zd;\n\n\t\tresult.xx = xx;\n\t\tresult.yx = yx;\n\t\tresult.zx = zx;\n\t\tresult.xy = xy;\n\t\tresult.yy = yy;\n\t\tresult.zy = zy;\n\t\tresult.xz = xz;\n\t\tresult.yz = yz;\n\t\tresult.zz = zz;\n\t\tresult.xd = xd;\n\t\tresult.yd = yd;\n\t\tresult.zd = zd;\n\t}", "language": "java", "code": "public static void multiply(Transformation3D a, Transformation3D b,\n\t\t\tTransformation3D result) {\n\t\tdouble xx, yx, zx;\n\t\tdouble xy, yy, zy;\n\t\tdouble xz, yz, zz;\n\t\tdouble xd, yd, zd;\n\n\t\txx = a.xx * b.xx + a.yx * b.xy + a.zx * b.xz;\n\t\tyx = a.xx * b.yx + a.yx * b.yy + a.zx * b.yz;\n\t\tzx = a.xx * b.zx + a.yx * b.zy + a.zx * b.zz;\n\t\txy = a.xy * b.xx + a.yy * b.xy + a.zy * b.xz;\n\t\tyy = a.xy * b.yx + a.yy * b.yy + a.zy * b.yz;\n\t\tzy = a.xy * b.zx + a.yy * b.zy + a.zy * b.zz;\n\t\txz = a.xz * b.xx + a.yz * b.xy + a.zz * b.xz;\n\t\tyz = a.xz * b.yx + a.yz * b.yy + a.zz * b.yz;\n\t\tzz = a.xz * b.zx + a.yz * b.zy + a.zz * b.zz;\n\t\txd = a.xd * b.xx + a.yd * b.xy + a.zd * b.xz + b.xd;\n\t\tyd = a.xd * b.yx + a.yd * b.yy + a.zd * b.yz + b.yd;\n\t\tzd = a.xd * b.zx + a.yd * b.zy + a.zd * b.zz + b.zd;\n\n\t\tresult.xx = xx;\n\t\tresult.yx = yx;\n\t\tresult.zx = zx;\n\t\tresult.xy = xy;\n\t\tresult.yy = yy;\n\t\tresult.zy = zy;\n\t\tresult.xz = xz;\n\t\tresult.yz = yz;\n\t\tresult.zz = zz;\n\t\tresult.xd = xd;\n\t\tresult.yd = yd;\n\t\tresult.zd = zd;\n\t}", "code_tokens": ["public", "static", "void", "multiply", "(", "Transformation3D", "a", ",", "Transformation3D", "b", ",", "Transformation3D", "result", ")", "{", "double", "xx", ",", "yx", ",", "zx", ";", "double", "xy", ",", "yy", ",", "zy", ";", "double", "xz", ",", "yz", ",", "zz", ";", "double", "xd", ",", "yd", ",", "zd", ";", "xx", "=", "a", ".", "xx", "*", "b", ".", "xx", "+", "a", ".", "yx", "*", "b", ".", "xy", "+", "a", ".", "zx", "*", "b", ".", "xz", ";", "yx", "=", "a", ".", "xx", "*", "b", ".", "yx", "+", "a", ".", "yx", "*", "b", ".", "yy", "+", "a", ".", "zx", "*", "b", ".", "yz", ";", "zx", "=", "a", ".", "xx", "*", "b", ".", "zx", "+", "a", ".", "yx", "*", "b", ".", "zy", "+", "a", ".", "zx", "*", "b", ".", "zz", ";", "xy", "=", "a", ".", "xy", "*", "b", ".", "xx", "+", "a", ".", "yy", "*", "b", ".", "xy", "+", "a", ".", "zy", "*", "b", ".", "xz", ";", "yy", "=", "a", ".", "xy", "*", "b", ".", "yx", "+", "a", ".", "yy", "*", "b", ".", "yy", "+", "a", ".", "zy", "*", "b", ".", "yz", ";", "zy", "=", "a", ".", "xy", "*", "b", ".", "zx", "+", "a", ".", "yy", "*", "b", ".", "zy", "+", "a", ".", "zy", "*", "b", ".", "zz", ";", "xz", "=", "a", ".", "xz", "*", "b", ".", "xx", "+", "a", ".", "yz", "*", "b", ".", "xy", "+", "a", ".", "zz", "*", "b", ".", "xz", ";", "yz", "=", "a", ".", "xz", "*", "b", ".", "yx", "+", "a", ".", "yz", "*", "b", ".", "yy", "+", "a", ".", "zz", "*", "b", ".", "yz", ";", "zz", "=", "a", ".", "xz", "*", "b", ".", "zx", "+", "a", ".", "yz", "*", "b", ".", "zy", "+", "a", ".", "zz", "*", "b", ".", "zz", ";", "xd", "=", "a", ".", "xd", "*", "b", ".", "xx", "+", "a", ".", "yd", "*", "b", ".", "xy", "+", "a", ".", "zd", "*", "b", ".", "xz", "+", "b", ".", "xd", ";", "yd", "=", "a", ".", "xd", "*", "b", ".", "yx", "+", "a", ".", "yd", "*", "b", ".", "yy", "+", "a", ".", "zd", "*", "b", ".", "yz", "+", "b", ".", "yd", ";", "zd", "=", "a", ".", "xd", "*", "b", ".", "zx", "+", "a", ".", "yd", "*", "b", ".", "zy", "+", "a", ".", "zd", "*", "b", ".", "zz", "+", "b", ".", "zd", ";", "result", ".", "xx", "=", "xx", ";", "result", ".", "yx", "=", "yx", ";", "result", ".", "zx", "=", "zx", ";", "result", ".", "xy", "=", "xy", ";", "result", ".", "yy", "=", "yy", ";", "result", ".", "zy", "=", "zy", ";", "result", ".", "xz", "=", "xz", ";", "result", ".", "yz", "=", "yz", ";", "result", ".", "zz", "=", "zz", ";", "result", ".", "xd", "=", "xd", ";", "result", ".", "yd", "=", "yd", ";", "result", ".", "zd", "=", "zd", ";", "}"], "docstring": "static", "docstring_tokens": ["static"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation3D.java#L160-L192", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation3D.java", "func_name": "Transformation3D.inverse", "original_string": "public static void inverse(Transformation3D src, Transformation3D result) {\n\t\tdouble det = src.xx * (src.yy * src.zz - src.zy * src.yz) - src.yx\n\t\t\t\t* (src.xy * src.zz - src.zy * src.xz) + src.zx\n\t\t\t\t* (src.xy * src.yz - src.yy * src.xz);\n\t\tif (det != 0) {\n\t\t\tdouble xx, yx, zx;\n\t\t\tdouble xy, yy, zy;\n\t\t\tdouble xz, yz, zz;\n\t\t\tdouble xd, yd, zd;\n\n\t\t\tdouble det_1 = 1.0 / det;\n\t\t\txx = (src.yy * src.zz - src.zy * src.yz) * det_1;\n\t\t\txy = -(src.xy * src.zz - src.zy * src.xz) * det_1;\n\t\t\txz = (src.xy * src.yz - src.yy * src.xz) * det_1;\n\n\t\t\tyx = -(src.yx * src.zz - src.yz * src.zx) * det_1;\n\t\t\tyy = (src.xx * src.zz - src.zx * src.xz) * det_1;\n\t\t\tyz = -(src.xx * src.yz - src.yx * src.xz) * det_1;\n\n\t\t\tzx = (src.yx * src.zy - src.zx * src.yy) * det_1;\n\t\t\tzy = -(src.xx * src.zy - src.zx * src.xy) * det_1;\n\t\t\tzz = (src.xx * src.yy - src.yx * src.xy) * det_1;\n\n\t\t\txd = -(src.xd * xx + src.yd * xy + src.zd * xz);\n\t\t\tyd = -(src.xd * yx + src.yd * yy + src.zd * yz);\n\t\t\tzd = -(src.xd * zx + src.yd * zy + src.zd * zz);\n\n\t\t\tresult.xx = xx;\n\t\t\tresult.yx = yx;\n\t\t\tresult.zx = zx;\n\t\t\tresult.xy = xy;\n\t\t\tresult.yy = yy;\n\t\t\tresult.zy = zy;\n\t\t\tresult.xz = xz;\n\t\t\tresult.yz = yz;\n\t\t\tresult.zz = zz;\n\t\t\tresult.xd = xd;\n\t\t\tresult.yd = yd;\n\t\t\tresult.zd = zd;\n\t\t} else {\n\t\t\tthrow new GeometryException(\"math singularity\");\n\t\t}\n\t}", "language": "java", "code": "public static void inverse(Transformation3D src, Transformation3D result) {\n\t\tdouble det = src.xx * (src.yy * src.zz - src.zy * src.yz) - src.yx\n\t\t\t\t* (src.xy * src.zz - src.zy * src.xz) + src.zx\n\t\t\t\t* (src.xy * src.yz - src.yy * src.xz);\n\t\tif (det != 0) {\n\t\t\tdouble xx, yx, zx;\n\t\t\tdouble xy, yy, zy;\n\t\t\tdouble xz, yz, zz;\n\t\t\tdouble xd, yd, zd;\n\n\t\t\tdouble det_1 = 1.0 / det;\n\t\t\txx = (src.yy * src.zz - src.zy * src.yz) * det_1;\n\t\t\txy = -(src.xy * src.zz - src.zy * src.xz) * det_1;\n\t\t\txz = (src.xy * src.yz - src.yy * src.xz) * det_1;\n\n\t\t\tyx = -(src.yx * src.zz - src.yz * src.zx) * det_1;\n\t\t\tyy = (src.xx * src.zz - src.zx * src.xz) * det_1;\n\t\t\tyz = -(src.xx * src.yz - src.yx * src.xz) * det_1;\n\n\t\t\tzx = (src.yx * src.zy - src.zx * src.yy) * det_1;\n\t\t\tzy = -(src.xx * src.zy - src.zx * src.xy) * det_1;\n\t\t\tzz = (src.xx * src.yy - src.yx * src.xy) * det_1;\n\n\t\t\txd = -(src.xd * xx + src.yd * xy + src.zd * xz);\n\t\t\tyd = -(src.xd * yx + src.yd * yy + src.zd * yz);\n\t\t\tzd = -(src.xd * zx + src.yd * zy + src.zd * zz);\n\n\t\t\tresult.xx = xx;\n\t\t\tresult.yx = yx;\n\t\t\tresult.zx = zx;\n\t\t\tresult.xy = xy;\n\t\t\tresult.yy = yy;\n\t\t\tresult.zy = zy;\n\t\t\tresult.xz = xz;\n\t\t\tresult.yz = yz;\n\t\t\tresult.zz = zz;\n\t\t\tresult.xd = xd;\n\t\t\tresult.yd = yd;\n\t\t\tresult.zd = zd;\n\t\t} else {\n\t\t\tthrow new GeometryException(\"math singularity\");\n\t\t}\n\t}", "code_tokens": ["public", "static", "void", "inverse", "(", "Transformation3D", "src", ",", "Transformation3D", "result", ")", "{", "double", "det", "=", "src", ".", "xx", "*", "(", "src", ".", "yy", "*", "src", ".", "zz", "-", "src", ".", "zy", "*", "src", ".", "yz", ")", "-", "src", ".", "yx", "*", "(", "src", ".", "xy", "*", "src", ".", "zz", "-", "src", ".", "zy", "*", "src", ".", "xz", ")", "+", "src", ".", "zx", "*", "(", "src", ".", "xy", "*", "src", ".", "yz", "-", "src", ".", "yy", "*", "src", ".", "xz", ")", ";", "if", "(", "det", "!=", "0", ")", "{", "double", "xx", ",", "yx", ",", "zx", ";", "double", "xy", ",", "yy", ",", "zy", ";", "double", "xz", ",", "yz", ",", "zz", ";", "double", "xd", ",", "yd", ",", "zd", ";", "double", "det_1", "=", "1.0", "/", "det", ";", "xx", "=", "(", "src", ".", "yy", "*", "src", ".", "zz", "-", "src", ".", "zy", "*", "src", ".", "yz", ")", "*", "det_1", ";", "xy", "=", "-", "(", "src", ".", "xy", "*", "src", ".", "zz", "-", "src", ".", "zy", "*", "src", ".", "xz", ")", "*", "det_1", ";", "xz", "=", "(", "src", ".", "xy", "*", "src", ".", "yz", "-", "src", ".", "yy", "*", "src", ".", "xz", ")", "*", "det_1", ";", "yx", "=", "-", "(", "src", ".", "yx", "*", "src", ".", "zz", "-", "src", ".", "yz", "*", "src", ".", "zx", ")", "*", "det_1", ";", "yy", "=", "(", "src", ".", "xx", "*", "src", ".", "zz", "-", "src", ".", "zx", "*", "src", ".", "xz", ")", "*", "det_1", ";", "yz", "=", "-", "(", "src", ".", "xx", "*", "src", ".", "yz", "-", "src", ".", "yx", "*", "src", ".", "xz", ")", "*", "det_1", ";", "zx", "=", "(", "src", ".", "yx", "*", "src", ".", "zy", "-", "src", ".", "zx", "*", "src", ".", "yy", ")", "*", "det_1", ";", "zy", "=", "-", "(", "src", ".", "xx", "*", "src", ".", "zy", "-", "src", ".", "zx", "*", "src", ".", "xy", ")", "*", "det_1", ";", "zz", "=", "(", "src", ".", "xx", "*", "src", ".", "yy", "-", "src", ".", "yx", "*", "src", ".", "xy", ")", "*", "det_1", ";", "xd", "=", "-", "(", "src", ".", "xd", "*", "xx", "+", "src", ".", "yd", "*", "xy", "+", "src", ".", "zd", "*", "xz", ")", ";", "yd", "=", "-", "(", "src", ".", "xd", "*", "yx", "+", "src", ".", "yd", "*", "yy", "+", "src", ".", "zd", "*", "yz", ")", ";", "zd", "=", "-", "(", "src", ".", "xd", "*", "zx", "+", "src", ".", "yd", "*", "zy", "+", "src", ".", "zd", "*", "zz", ")", ";", "result", ".", "xx", "=", "xx", ";", "result", ".", "yx", "=", "yx", ";", "result", ".", "zx", "=", "zx", ";", "result", ".", "xy", "=", "xy", ";", "result", ".", "yy", "=", "yy", ";", "result", ".", "zy", "=", "zy", ";", "result", ".", "xz", "=", "xz", ";", "result", ".", "yz", "=", "yz", ";", "result", ".", "zz", "=", "zz", ";", "result", ".", "xd", "=", "xd", ";", "result", ".", "yd", "=", "yd", ";", "result", ".", "zd", "=", "zd", ";", "}", "else", "{", "throw", "new", "GeometryException", "(", "\"math singularity\"", ")", ";", "}", "}"], "docstring": "Calculates the Inverse transformation.\n\n@param src\nThe input transformation.\n@param result\nThe inverse of the input transformation. Throws the\nGeometryException(\"math singularity\") exception if the Inverse\ncan not be calculated.", "docstring_tokens": ["Calculates", "the", "Inverse", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation3D.java#L204-L246", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.relate", "original_string": "static boolean relate(Geometry geometry_a, Geometry geometry_b,\n\t\t\tSpatialReference sr, String scl, ProgressTracker progress_tracker) {\n\n        if (scl.length() != 9)\n            throw new GeometryException(\"relation string length has to be 9 characters\");\n\n        for (int i = 0; i < 9; i++)\n        {\n            char c = scl.charAt(i);\n\n            if (c != '*' && c != 'T' && c != 'F' && c != '0' && c != '1' && c != '2')\n                throw new GeometryException(\"relation string\");\n        }\n\n        int relation = getPredefinedRelation_(scl, geometry_a.getDimension(),\n\t\t\t\tgeometry_b.getDimension());\n\n\t\tif (relation != RelationalOperations.Relation.unknown)\n\t\t\treturn RelationalOperations.relate(geometry_a, geometry_b, sr,\n\t\t\t\t\trelation, progress_tracker);\n\n\t\tEnvelope2D env1 = new Envelope2D();\n\t\tgeometry_a.queryEnvelope2D(env1);\n\t\tEnvelope2D env2 = new Envelope2D();\n\t\tgeometry_b.queryEnvelope2D(env2);\n\n\t\tEnvelope2D envMerged = new Envelope2D();\n\t\tenvMerged.setCoords(env1);\n\t\tenvMerged.merge(env2);\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenvMerged, false);\n\n\t\tGeometry _geometryA = convertGeometry_(geometry_a, tolerance);\n\t\tGeometry _geometryB = convertGeometry_(geometry_b, tolerance);\n\n        if (_geometryA.isEmpty() || _geometryB.isEmpty())\n            return relateEmptyGeometries_(_geometryA, _geometryB, scl);\n\n\t\tint typeA = _geometryA.getType().value();\n\t\tint typeB = _geometryB.getType().value();\n\n\t\tboolean bRelation = false;\n\n\t\tswitch (typeA) {\n\t\tcase Geometry.GeometryType.Polygon:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelatePolygon_((Polygon) (_geometryA),\n\t\t\t\t\t\t(Polygon) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polygonRelatePolyline_((Polygon) (_geometryA),\n\t\t\t\t\t\t(Polyline) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = polygonRelatePoint_((Polygon) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = polygonRelateMultiPoint_((Polygon) (_geometryA),\n\t\t\t\t\t\t(MultiPoint) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Geometry.GeometryType.Polyline:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelatePolyline_((Polygon) (_geometryB),\n\t\t\t\t\t\t(Polyline) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polylineRelatePolyline_((Polyline) (_geometryA),\n\t\t\t\t\t\t(Polyline) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = polylineRelatePoint_((Polyline) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = polylineRelateMultiPoint_((Polyline) (_geometryA),\n\t\t\t\t\t\t(MultiPoint) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Geometry.GeometryType.Point:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelatePoint_((Polygon) (_geometryB),\n\t\t\t\t\t\t(Point) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polylineRelatePoint_((Polyline) (_geometryB),\n\t\t\t\t\t\t(Point) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = pointRelatePoint_((Point) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = multiPointRelatePoint_((MultiPoint) (_geometryB),\n\t\t\t\t\t\t(Point) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelateMultiPoint_((Polygon) (_geometryB),\n\t\t\t\t\t\t(MultiPoint) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polylineRelateMultiPoint_((Polyline) (_geometryB),\n\t\t\t\t\t\t(MultiPoint) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = multiPointRelateMultiPoint_(\n\t\t\t\t\t\t(MultiPoint) (_geometryA), (MultiPoint) (_geometryB),\n\t\t\t\t\t\ttolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = multiPointRelatePoint_((MultiPoint) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbRelation = false;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean relate(Geometry geometry_a, Geometry geometry_b,\n\t\t\tSpatialReference sr, String scl, ProgressTracker progress_tracker) {\n\n        if (scl.length() != 9)\n            throw new GeometryException(\"relation string length has to be 9 characters\");\n\n        for (int i = 0; i < 9; i++)\n        {\n            char c = scl.charAt(i);\n\n            if (c != '*' && c != 'T' && c != 'F' && c != '0' && c != '1' && c != '2')\n                throw new GeometryException(\"relation string\");\n        }\n\n        int relation = getPredefinedRelation_(scl, geometry_a.getDimension(),\n\t\t\t\tgeometry_b.getDimension());\n\n\t\tif (relation != RelationalOperations.Relation.unknown)\n\t\t\treturn RelationalOperations.relate(geometry_a, geometry_b, sr,\n\t\t\t\t\trelation, progress_tracker);\n\n\t\tEnvelope2D env1 = new Envelope2D();\n\t\tgeometry_a.queryEnvelope2D(env1);\n\t\tEnvelope2D env2 = new Envelope2D();\n\t\tgeometry_b.queryEnvelope2D(env2);\n\n\t\tEnvelope2D envMerged = new Envelope2D();\n\t\tenvMerged.setCoords(env1);\n\t\tenvMerged.merge(env2);\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenvMerged, false);\n\n\t\tGeometry _geometryA = convertGeometry_(geometry_a, tolerance);\n\t\tGeometry _geometryB = convertGeometry_(geometry_b, tolerance);\n\n        if (_geometryA.isEmpty() || _geometryB.isEmpty())\n            return relateEmptyGeometries_(_geometryA, _geometryB, scl);\n\n\t\tint typeA = _geometryA.getType().value();\n\t\tint typeB = _geometryB.getType().value();\n\n\t\tboolean bRelation = false;\n\n\t\tswitch (typeA) {\n\t\tcase Geometry.GeometryType.Polygon:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelatePolygon_((Polygon) (_geometryA),\n\t\t\t\t\t\t(Polygon) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polygonRelatePolyline_((Polygon) (_geometryA),\n\t\t\t\t\t\t(Polyline) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = polygonRelatePoint_((Polygon) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = polygonRelateMultiPoint_((Polygon) (_geometryA),\n\t\t\t\t\t\t(MultiPoint) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Geometry.GeometryType.Polyline:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelatePolyline_((Polygon) (_geometryB),\n\t\t\t\t\t\t(Polyline) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polylineRelatePolyline_((Polyline) (_geometryA),\n\t\t\t\t\t\t(Polyline) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = polylineRelatePoint_((Polyline) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = polylineRelateMultiPoint_((Polyline) (_geometryA),\n\t\t\t\t\t\t(MultiPoint) (_geometryB), tolerance, scl,\n\t\t\t\t\t\tprogress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Geometry.GeometryType.Point:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelatePoint_((Polygon) (_geometryB),\n\t\t\t\t\t\t(Point) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polylineRelatePoint_((Polyline) (_geometryB),\n\t\t\t\t\t\t(Point) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = pointRelatePoint_((Point) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = multiPointRelatePoint_((MultiPoint) (_geometryB),\n\t\t\t\t\t\t(Point) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\tswitch (typeB) {\n\t\t\tcase Geometry.GeometryType.Polygon:\n\t\t\t\tbRelation = polygonRelateMultiPoint_((Polygon) (_geometryB),\n\t\t\t\t\t\t(MultiPoint) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Polyline:\n\t\t\t\tbRelation = polylineRelateMultiPoint_((Polyline) (_geometryB),\n\t\t\t\t\t\t(MultiPoint) (_geometryA), tolerance,\n\t\t\t\t\t\tgetTransposeMatrix_(scl), progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.MultiPoint:\n\t\t\t\tbRelation = multiPointRelateMultiPoint_(\n\t\t\t\t\t\t(MultiPoint) (_geometryA), (MultiPoint) (_geometryB),\n\t\t\t\t\t\ttolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tcase Geometry.GeometryType.Point:\n\t\t\t\tbRelation = multiPointRelatePoint_((MultiPoint) (_geometryA),\n\t\t\t\t\t\t(Point) (_geometryB), tolerance, scl, progress_tracker);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak; // warning fix\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbRelation = false;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "relate", "(", "Geometry", "geometry_a", ",", "Geometry", "geometry_b", ",", "SpatialReference", "sr", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "scl", ".", "length", "(", ")", "!=", "9", ")", "throw", "new", "GeometryException", "(", "\"relation string length has to be 9 characters\"", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "{", "char", "c", "=", "scl", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "!=", "'", "'", "&&", "c", "!=", "'", "'", "&&", "c", "!=", "'", "'", "&&", "c", "!=", "'", "'", "&&", "c", "!=", "'", "'", "&&", "c", "!=", "'", "'", ")", "throw", "new", "GeometryException", "(", "\"relation string\"", ")", ";", "}", "int", "relation", "=", "getPredefinedRelation_", "(", "scl", ",", "geometry_a", ".", "getDimension", "(", ")", ",", "geometry_b", ".", "getDimension", "(", ")", ")", ";", "if", "(", "relation", "!=", "RelationalOperations", ".", "Relation", ".", "unknown", ")", "return", "RelationalOperations", ".", "relate", "(", "geometry_a", ",", "geometry_b", ",", "sr", ",", "relation", ",", "progress_tracker", ")", ";", "Envelope2D", "env1", "=", "new", "Envelope2D", "(", ")", ";", "geometry_a", ".", "queryEnvelope2D", "(", "env1", ")", ";", "Envelope2D", "env2", "=", "new", "Envelope2D", "(", ")", ";", "geometry_b", ".", "queryEnvelope2D", "(", "env2", ")", ";", "Envelope2D", "envMerged", "=", "new", "Envelope2D", "(", ")", ";", "envMerged", ".", "setCoords", "(", "env1", ")", ";", "envMerged", ".", "merge", "(", "env2", ")", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "sr", ",", "envMerged", ",", "false", ")", ";", "Geometry", "_geometryA", "=", "convertGeometry_", "(", "geometry_a", ",", "tolerance", ")", ";", "Geometry", "_geometryB", "=", "convertGeometry_", "(", "geometry_b", ",", "tolerance", ")", ";", "if", "(", "_geometryA", ".", "isEmpty", "(", ")", "||", "_geometryB", ".", "isEmpty", "(", ")", ")", "return", "relateEmptyGeometries_", "(", "_geometryA", ",", "_geometryB", ",", "scl", ")", ";", "int", "typeA", "=", "_geometryA", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "int", "typeB", "=", "_geometryB", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "boolean", "bRelation", "=", "false", ";", "switch", "(", "typeA", ")", "{", "case", "Geometry", ".", "GeometryType", ".", "Polygon", ":", "switch", "(", "typeB", ")", "{", "case", "Geometry", ".", "GeometryType", ".", "Polygon", ":", "bRelation", "=", "polygonRelatePolygon_", "(", "(", "Polygon", ")", "(", "_geometryA", ")", ",", "(", "Polygon", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Polyline", ":", "bRelation", "=", "polygonRelatePolyline_", "(", "(", "Polygon", ")", "(", "_geometryA", ")", ",", "(", "Polyline", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Point", ":", "bRelation", "=", "polygonRelatePoint_", "(", "(", "Polygon", ")", "(", "_geometryA", ")", ",", "(", "Point", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "MultiPoint", ":", "bRelation", "=", "polygonRelateMultiPoint_", "(", "(", "Polygon", ")", "(", "_geometryA", ")", ",", "(", "MultiPoint", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "default", ":", "break", ";", "// warning fix", "}", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Polyline", ":", "switch", "(", "typeB", ")", "{", "case", "Geometry", ".", "GeometryType", ".", "Polygon", ":", "bRelation", "=", "polygonRelatePolyline_", "(", "(", "Polygon", ")", "(", "_geometryB", ")", ",", "(", "Polyline", ")", "(", "_geometryA", ")", ",", "tolerance", ",", "getTransposeMatrix_", "(", "scl", ")", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Polyline", ":", "bRelation", "=", "polylineRelatePolyline_", "(", "(", "Polyline", ")", "(", "_geometryA", ")", ",", "(", "Polyline", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Point", ":", "bRelation", "=", "polylineRelatePoint_", "(", "(", "Polyline", ")", "(", "_geometryA", ")", ",", "(", "Point", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "MultiPoint", ":", "bRelation", "=", "polylineRelateMultiPoint_", "(", "(", "Polyline", ")", "(", "_geometryA", ")", ",", "(", "MultiPoint", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "default", ":", "break", ";", "// warning fix", "}", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Point", ":", "switch", "(", "typeB", ")", "{", "case", "Geometry", ".", "GeometryType", ".", "Polygon", ":", "bRelation", "=", "polygonRelatePoint_", "(", "(", "Polygon", ")", "(", "_geometryB", ")", ",", "(", "Point", ")", "(", "_geometryA", ")", ",", "tolerance", ",", "getTransposeMatrix_", "(", "scl", ")", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Polyline", ":", "bRelation", "=", "polylineRelatePoint_", "(", "(", "Polyline", ")", "(", "_geometryB", ")", ",", "(", "Point", ")", "(", "_geometryA", ")", ",", "tolerance", ",", "getTransposeMatrix_", "(", "scl", ")", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Point", ":", "bRelation", "=", "pointRelatePoint_", "(", "(", "Point", ")", "(", "_geometryA", ")", ",", "(", "Point", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "MultiPoint", ":", "bRelation", "=", "multiPointRelatePoint_", "(", "(", "MultiPoint", ")", "(", "_geometryB", ")", ",", "(", "Point", ")", "(", "_geometryA", ")", ",", "tolerance", ",", "getTransposeMatrix_", "(", "scl", ")", ",", "progress_tracker", ")", ";", "break", ";", "default", ":", "break", ";", "// warning fix", "}", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "MultiPoint", ":", "switch", "(", "typeB", ")", "{", "case", "Geometry", ".", "GeometryType", ".", "Polygon", ":", "bRelation", "=", "polygonRelateMultiPoint_", "(", "(", "Polygon", ")", "(", "_geometryB", ")", ",", "(", "MultiPoint", ")", "(", "_geometryA", ")", ",", "tolerance", ",", "getTransposeMatrix_", "(", "scl", ")", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Polyline", ":", "bRelation", "=", "polylineRelateMultiPoint_", "(", "(", "Polyline", ")", "(", "_geometryB", ")", ",", "(", "MultiPoint", ")", "(", "_geometryA", ")", ",", "tolerance", ",", "getTransposeMatrix_", "(", "scl", ")", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "MultiPoint", ":", "bRelation", "=", "multiPointRelateMultiPoint_", "(", "(", "MultiPoint", ")", "(", "_geometryA", ")", ",", "(", "MultiPoint", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "case", "Geometry", ".", "GeometryType", ".", "Point", ":", "bRelation", "=", "multiPointRelatePoint_", "(", "(", "MultiPoint", ")", "(", "_geometryA", ")", ",", "(", "Point", ")", "(", "_geometryB", ")", ",", "tolerance", ",", "scl", ",", "progress_tracker", ")", ";", "break", ";", "default", ":", "break", ";", "// warning fix", "}", "break", ";", "default", ":", "bRelation", "=", "false", ";", "break", ";", "}", "return", "bRelation", ";", "}"], "docstring": "string.", "docstring_tokens": ["string", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L63-L232", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polygonRelatePolygon_", "original_string": "static boolean polygonRelatePolygon_(Polygon polygon_a, Polygon polygon_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setAreaAreaPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolygon_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.contains) {\n\t\t\t\trelOps.areaAreaContainsPredicates_(polygon_b);\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.within) {\n\t\t\t\trelOps.areaAreaWithinPredicates_(polygon_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polygon_a);\n\t\t\tint geom_b = edit_shape.addGeometry(polygon_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean polygonRelatePolygon_(Polygon polygon_a, Polygon polygon_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setAreaAreaPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolygon_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.contains) {\n\t\t\t\trelOps.areaAreaContainsPredicates_(polygon_b);\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.within) {\n\t\t\t\trelOps.areaAreaWithinPredicates_(polygon_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polygon_a);\n\t\t\tint geom_b = edit_shape.addGeometry(polygon_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "polygonRelatePolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setAreaAreaPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polygon_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "areaAreaDisjointPredicates_", "(", "polygon_a", ",", "polygon_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "// Quick rasterize test to see whether the the geometries are", "// disjoint, or if one is contained in the other.", "int", "relation", "=", "RelationalOperations", ".", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "disjoint", ")", "{", "relOps", ".", "areaAreaDisjointPredicates_", "(", "polygon_a", ",", "polygon_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "else", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "contains", ")", "{", "relOps", ".", "areaAreaContainsPredicates_", "(", "polygon_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "else", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "within", ")", "{", "relOps", ".", "areaAreaWithinPredicates_", "(", "polygon_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polygon_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "polygon_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "computeMatrixTopoGraphHalfEdges_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L245-L296", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polygonContainsPolygon_", "original_string": "static boolean polygonContainsPolygon_(Polygon polygon_a, Polygon polygon_b, double tolerance, ProgressTracker progress_tracker)\n    {\n        assert(!polygon_a.isEmpty());\n        assert(!polygon_b.isEmpty());\n\n        RelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n        relOps.resetMatrix_();\n        relOps.setPredicates_(\"T*****F**\");\n        relOps.setAreaAreaPredicates_();\n\n        Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n        polygon_a.queryEnvelope2D(env_a);\n        polygon_b.queryEnvelope2D(env_b);\n\n        boolean bRelationKnown = false;\n        boolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(env_a, env_b, tolerance, progress_tracker);\n\n        if (b_disjoint)\n        {\n            relOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n            bRelationKnown = true;\n        }\n\n        if (!bRelationKnown)\n        {\n            // Quick rasterize test to see whether the the geometries are disjoint, or if one is contained in the other.\n            int relation = RelationalOperations.tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b, tolerance, false);\n\n            if (relation == RelationalOperations.Relation.disjoint)\n            {\n                relOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n                bRelationKnown = true;\n            }\n            else if (relation == RelationalOperations.Relation.contains)\n            {\n                relOps.areaAreaContainsPredicates_(polygon_b);\n                bRelationKnown = true;\n            }\n            else if (relation == RelationalOperations.Relation.within)\n            {\n                relOps.areaAreaWithinPredicates_(polygon_a);\n                bRelationKnown = true;\n            }\n        }\n\n        if (bRelationKnown)\n        {\n            boolean bContains = relationCompare_(relOps.m_matrix, relOps.m_scl);\n            return bContains;\n        }\n\n        EditShape edit_shape = new EditShape();\n        int geom_a = edit_shape.addGeometry(polygon_a);\n        int geom_b = edit_shape.addGeometry(polygon_b);\n\n        CrackAndCluster.execute(edit_shape, tolerance, progress_tracker, false);\n        Polyline boundary_b = (Polyline)edit_shape.getGeometry(geom_b).getBoundary();\n        edit_shape.filterClosePoints(0, true, true);\n        Simplificator.execute(edit_shape, geom_a, -1, false, progress_tracker);\n\n        // Make sure Polygon A has exterior\n        // If the simplified Polygon A does not have interior, then it cannot contain anything.\n        if (edit_shape.getPointCount(geom_a) == 0)\n            return false;\n\n        Simplificator.execute(edit_shape, geom_b, -1, false, progress_tracker);\n\n        relOps.setEditShape_(edit_shape, progress_tracker);\n\n        // We see if the simplified Polygon A contains the simplified Polygon B.\n\n        boolean b_empty = edit_shape.getPointCount(geom_b) == 0;\n\n        if (!b_empty)\n        {//geom_b has interior\n            relOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n            relOps.m_topo_graph.removeShape();\n            boolean bContains = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\n            if (!bContains)\n                return bContains;\n        }\n\n        Polygon polygon_simple_a = (Polygon)edit_shape.getGeometry(geom_a);\n        edit_shape = new EditShape();\n        geom_a = edit_shape.addGeometry(polygon_simple_a);\n        geom_b = edit_shape.addGeometry(boundary_b);\n        relOps.setEditShape_(edit_shape, progress_tracker);\n\n        // Check no interior lines of the boundary intersect the exterior\n        relOps.m_predicate_count = 0;\n        relOps.resetMatrix_();\n        relOps.setPredicates_(b_empty ? \"T*****F**\" : \"******F**\");\n        relOps.setAreaLinePredicates_();\n\n        relOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n        relOps.m_topo_graph.removeShape();\n        boolean bContains = relationCompare_(relOps.m_matrix, relOps.m_scl);\n        return bContains;\n    }", "language": "java", "code": "static boolean polygonContainsPolygon_(Polygon polygon_a, Polygon polygon_b, double tolerance, ProgressTracker progress_tracker)\n    {\n        assert(!polygon_a.isEmpty());\n        assert(!polygon_b.isEmpty());\n\n        RelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n        relOps.resetMatrix_();\n        relOps.setPredicates_(\"T*****F**\");\n        relOps.setAreaAreaPredicates_();\n\n        Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n        polygon_a.queryEnvelope2D(env_a);\n        polygon_b.queryEnvelope2D(env_b);\n\n        boolean bRelationKnown = false;\n        boolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(env_a, env_b, tolerance, progress_tracker);\n\n        if (b_disjoint)\n        {\n            relOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n            bRelationKnown = true;\n        }\n\n        if (!bRelationKnown)\n        {\n            // Quick rasterize test to see whether the the geometries are disjoint, or if one is contained in the other.\n            int relation = RelationalOperations.tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b, tolerance, false);\n\n            if (relation == RelationalOperations.Relation.disjoint)\n            {\n                relOps.areaAreaDisjointPredicates_(polygon_a, polygon_b);\n                bRelationKnown = true;\n            }\n            else if (relation == RelationalOperations.Relation.contains)\n            {\n                relOps.areaAreaContainsPredicates_(polygon_b);\n                bRelationKnown = true;\n            }\n            else if (relation == RelationalOperations.Relation.within)\n            {\n                relOps.areaAreaWithinPredicates_(polygon_a);\n                bRelationKnown = true;\n            }\n        }\n\n        if (bRelationKnown)\n        {\n            boolean bContains = relationCompare_(relOps.m_matrix, relOps.m_scl);\n            return bContains;\n        }\n\n        EditShape edit_shape = new EditShape();\n        int geom_a = edit_shape.addGeometry(polygon_a);\n        int geom_b = edit_shape.addGeometry(polygon_b);\n\n        CrackAndCluster.execute(edit_shape, tolerance, progress_tracker, false);\n        Polyline boundary_b = (Polyline)edit_shape.getGeometry(geom_b).getBoundary();\n        edit_shape.filterClosePoints(0, true, true);\n        Simplificator.execute(edit_shape, geom_a, -1, false, progress_tracker);\n\n        // Make sure Polygon A has exterior\n        // If the simplified Polygon A does not have interior, then it cannot contain anything.\n        if (edit_shape.getPointCount(geom_a) == 0)\n            return false;\n\n        Simplificator.execute(edit_shape, geom_b, -1, false, progress_tracker);\n\n        relOps.setEditShape_(edit_shape, progress_tracker);\n\n        // We see if the simplified Polygon A contains the simplified Polygon B.\n\n        boolean b_empty = edit_shape.getPointCount(geom_b) == 0;\n\n        if (!b_empty)\n        {//geom_b has interior\n            relOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n            relOps.m_topo_graph.removeShape();\n            boolean bContains = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\n            if (!bContains)\n                return bContains;\n        }\n\n        Polygon polygon_simple_a = (Polygon)edit_shape.getGeometry(geom_a);\n        edit_shape = new EditShape();\n        geom_a = edit_shape.addGeometry(polygon_simple_a);\n        geom_b = edit_shape.addGeometry(boundary_b);\n        relOps.setEditShape_(edit_shape, progress_tracker);\n\n        // Check no interior lines of the boundary intersect the exterior\n        relOps.m_predicate_count = 0;\n        relOps.resetMatrix_();\n        relOps.setPredicates_(b_empty ? \"T*****F**\" : \"******F**\");\n        relOps.setAreaLinePredicates_();\n\n        relOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n        relOps.m_topo_graph.removeShape();\n        boolean bContains = relationCompare_(relOps.m_matrix, relOps.m_scl);\n        return bContains;\n    }", "code_tokens": ["static", "boolean", "polygonContainsPolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "assert", "(", "!", "polygon_a", ".", "isEmpty", "(", ")", ")", ";", "assert", "(", "!", "polygon_b", ".", "isEmpty", "(", ")", ")", ";", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "\"T*****F**\"", ")", ";", "relOps", ".", "setAreaAreaPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polygon_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "areaAreaDisjointPredicates_", "(", "polygon_a", ",", "polygon_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint, or if one is contained in the other.", "int", "relation", "=", "RelationalOperations", ".", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "disjoint", ")", "{", "relOps", ".", "areaAreaDisjointPredicates_", "(", "polygon_a", ",", "polygon_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "else", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "contains", ")", "{", "relOps", ".", "areaAreaContainsPredicates_", "(", "polygon_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "else", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "within", ")", "{", "relOps", ".", "areaAreaWithinPredicates_", "(", "polygon_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "}", "if", "(", "bRelationKnown", ")", "{", "boolean", "bContains", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bContains", ";", "}", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polygon_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "polygon_b", ")", ";", "CrackAndCluster", ".", "execute", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ",", "false", ")", ";", "Polyline", "boundary_b", "=", "(", "Polyline", ")", "edit_shape", ".", "getGeometry", "(", "geom_b", ")", ".", "getBoundary", "(", ")", ";", "edit_shape", ".", "filterClosePoints", "(", "0", ",", "true", ",", "true", ")", ";", "Simplificator", ".", "execute", "(", "edit_shape", ",", "geom_a", ",", "-", "1", ",", "false", ",", "progress_tracker", ")", ";", "// Make sure Polygon A has exterior", "// If the simplified Polygon A does not have interior, then it cannot contain anything.", "if", "(", "edit_shape", ".", "getPointCount", "(", "geom_a", ")", "==", "0", ")", "return", "false", ";", "Simplificator", ".", "execute", "(", "edit_shape", ",", "geom_b", ",", "-", "1", ",", "false", ",", "progress_tracker", ")", ";", "relOps", ".", "setEditShape_", "(", "edit_shape", ",", "progress_tracker", ")", ";", "// We see if the simplified Polygon A contains the simplified Polygon B.", "boolean", "b_empty", "=", "edit_shape", ".", "getPointCount", "(", "geom_b", ")", "==", "0", ";", "if", "(", "!", "b_empty", ")", "{", "//geom_b has interior", "relOps", ".", "computeMatrixTopoGraphHalfEdges_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "boolean", "bContains", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "if", "(", "!", "bContains", ")", "return", "bContains", ";", "}", "Polygon", "polygon_simple_a", "=", "(", "Polygon", ")", "edit_shape", ".", "getGeometry", "(", "geom_a", ")", ";", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polygon_simple_a", ")", ";", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "boundary_b", ")", ";", "relOps", ".", "setEditShape_", "(", "edit_shape", ",", "progress_tracker", ")", ";", "// Check no interior lines of the boundary intersect the exterior", "relOps", ".", "m_predicate_count", "=", "0", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "b_empty", "?", "\"T*****F**\"", ":", "\"******F**\"", ")", ";", "relOps", ".", "setAreaLinePredicates_", "(", ")", ";", "relOps", ".", "computeMatrixTopoGraphHalfEdges_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "boolean", "bContains", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bContains", ";", "}"], "docstring": "The relation is based on the simplified-Polygon A containing Polygon B, which may be non-simple.", "docstring_tokens": ["The", "relation", "is", "based", "on", "the", "simplified", "-", "Polygon", "A", "containing", "Polygon", "B", "which", "may", "be", "non", "-", "simple", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L299-L398", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polygonRelatePolyline_", "original_string": "static boolean polygonRelatePolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setAreaLinePredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.areaLineDisjointPredicates_(polygon_a, polyline_b); // passing polyline\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to get boundary\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// information\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.areaLineDisjointPredicates_(polygon_a, polyline_b); // passing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// get boundary\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// information\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.contains) {\n\t\t\t\trelOps.areaLineContainsPredicates_(polygon_a, polyline_b); // passing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// get boundary\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// information\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polygon_a);\n\t\t\tint geom_b = edit_shape.addGeometry(polyline_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.m_cluster_index_b = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\tmarkClusterEndPoints_(geom_b, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_b);\n\t\t\trelOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean polygonRelatePolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setAreaLinePredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.areaLineDisjointPredicates_(polygon_a, polyline_b); // passing polyline\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to get boundary\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// information\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.areaLineDisjointPredicates_(polygon_a, polyline_b); // passing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// get boundary\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// information\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.contains) {\n\t\t\t\trelOps.areaLineContainsPredicates_(polygon_a, polyline_b); // passing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// get boundary\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// information\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polygon_a);\n\t\t\tint geom_b = edit_shape.addGeometry(polyline_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.m_cluster_index_b = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\tmarkClusterEndPoints_(geom_b, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_b);\n\t\t\trelOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "polygonRelatePolyline_", "(", "Polygon", "polygon_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setAreaLinePredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polyline_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "areaLineDisjointPredicates_", "(", "polygon_a", ",", "polyline_b", ")", ";", "// passing polyline", "// to get boundary", "// information", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "// Quick rasterize test to see whether the the geometries are", "// disjoint, or if one is contained in the other.", "int", "relation", "=", "RelationalOperations", ".", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "disjoint", ")", "{", "relOps", ".", "areaLineDisjointPredicates_", "(", "polygon_a", ",", "polyline_b", ")", ";", "// passing", "// polyline to", "// get boundary", "// information", "bRelationKnown", "=", "true", ";", "}", "else", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "contains", ")", "{", "relOps", ".", "areaLineContainsPredicates_", "(", "polygon_a", ",", "polyline_b", ")", ";", "// passing", "// polyline to", "// get boundary", "// information", "bRelationKnown", "=", "true", ";", "}", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polygon_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "polyline_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "m_cluster_index_b", "=", "relOps", ".", "m_topo_graph", ".", "createUserIndexForClusters", "(", ")", ";", "markClusterEndPoints_", "(", "geom_b", ",", "relOps", ".", "m_topo_graph", ",", "relOps", ".", "m_cluster_index_b", ")", ";", "relOps", ".", "computeMatrixTopoGraphHalfEdges_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "deleteUserIndexForClusters", "(", "relOps", ".", "m_cluster_index_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L401-L464", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polygonRelateMultiPoint_", "original_string": "static boolean polygonRelateMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setAreaPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.areaPointDisjointPredicates_(polygon_a);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polygon_a, multipoint_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.areaPointDisjointPredicates_(polygon_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.contains) {\n\t\t\t\trelOps.areaPointContainsPredicates_(polygon_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polygon_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean polygonRelateMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setAreaPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.areaPointDisjointPredicates_(polygon_a);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polygon_a, multipoint_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.areaPointDisjointPredicates_(polygon_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t} else if (relation == RelationalOperations.Relation.contains) {\n\t\t\t\trelOps.areaPointContainsPredicates_(polygon_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polygon_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "polygonRelateMultiPoint_", "(", "Polygon", "polygon_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setAreaPointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "areaPointDisjointPredicates_", "(", "polygon_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "// Quick rasterize test to see whether the the geometries are", "// disjoint, or if one is contained in the other.", "int", "relation", "=", "RelationalOperations", ".", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "disjoint", ")", "{", "relOps", ".", "areaPointDisjointPredicates_", "(", "polygon_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "else", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "contains", ")", "{", "relOps", ".", "areaPointContainsPredicates_", "(", "polygon_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polygon_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "computeMatrixTopoGraphClusters_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L527-L576", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polylineRelatePolyline_", "original_string": "static boolean polylineRelatePolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setLineLinePredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.lineLineDisjointPredicates_(polyline_a, polyline_b);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.lineLineDisjointPredicates_(polyline_a, polyline_b);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polyline_a);\n\t\t\tint geom_b = edit_shape.addGeometry(polyline_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.m_cluster_index_a = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\trelOps.m_cluster_index_b = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\tmarkClusterEndPoints_(geom_a, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_a);\n\t\t\tmarkClusterEndPoints_(geom_b, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_b);\n\t\t\trelOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_a);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean polylineRelatePolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setLineLinePredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.lineLineDisjointPredicates_(polyline_a, polyline_b);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.lineLineDisjointPredicates_(polyline_a, polyline_b);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polyline_a);\n\t\t\tint geom_b = edit_shape.addGeometry(polyline_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.m_cluster_index_a = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\trelOps.m_cluster_index_b = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\tmarkClusterEndPoints_(geom_a, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_a);\n\t\t\tmarkClusterEndPoints_(geom_b, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_b);\n\t\t\trelOps.computeMatrixTopoGraphHalfEdges_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_a);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "polylineRelatePolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setLineLinePredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polyline_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "lineLineDisjointPredicates_", "(", "polyline_a", ",", "polyline_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "// Quick rasterize test to see whether the the geometries are", "// disjoint, or if one is contained in the other.", "int", "relation", "=", "RelationalOperations", ".", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "disjoint", ")", "{", "relOps", ".", "lineLineDisjointPredicates_", "(", "polyline_a", ",", "polyline_b", ")", ";", "bRelationKnown", "=", "true", ";", "}", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polyline_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "polyline_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "m_cluster_index_a", "=", "relOps", ".", "m_topo_graph", ".", "createUserIndexForClusters", "(", ")", ";", "relOps", ".", "m_cluster_index_b", "=", "relOps", ".", "m_topo_graph", ".", "createUserIndexForClusters", "(", ")", ";", "markClusterEndPoints_", "(", "geom_a", ",", "relOps", ".", "m_topo_graph", ",", "relOps", ".", "m_cluster_index_a", ")", ";", "markClusterEndPoints_", "(", "geom_b", ",", "relOps", ".", "m_topo_graph", ",", "relOps", ".", "m_cluster_index_b", ")", ";", "relOps", ".", "computeMatrixTopoGraphHalfEdges_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "deleteUserIndexForClusters", "(", "relOps", ".", "m_cluster_index_a", ")", ";", "relOps", ".", "m_topo_graph", ".", "deleteUserIndexForClusters", "(", "relOps", ".", "m_cluster_index_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L579-L637", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polylineRelateMultiPoint_", "original_string": "static boolean polylineRelateMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setLinePointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.linePointDisjointPredicates_(polyline_a);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.linePointDisjointPredicates_(polyline_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polyline_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.m_cluster_index_a = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\tmarkClusterEndPoints_(geom_a, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_a);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_a);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean polylineRelateMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setLinePointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.linePointDisjointPredicates_(polyline_a);\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\t// Quick rasterize test to see whether the the geometries are\n\t\t\t// disjoint, or if one is contained in the other.\n\t\t\tint relation = RelationalOperations\n\t\t\t\t\t.tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\t\t\t\ttolerance, false);\n\n\t\t\tif (relation == RelationalOperations.Relation.disjoint) {\n\t\t\t\trelOps.linePointDisjointPredicates_(polyline_a);\n\t\t\t\tbRelationKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(polyline_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.m_cluster_index_a = relOps.m_topo_graph\n\t\t\t\t\t.createUserIndexForClusters();\n\t\t\tmarkClusterEndPoints_(geom_a, relOps.m_topo_graph,\n\t\t\t\t\trelOps.m_cluster_index_a);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph\n\t\t\t\t\t.deleteUserIndexForClusters(relOps.m_cluster_index_a);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "polylineRelateMultiPoint_", "(", "Polyline", "polyline_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setLinePointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "linePointDisjointPredicates_", "(", "polyline_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "// Quick rasterize test to see whether the the geometries are", "// disjoint, or if one is contained in the other.", "int", "relation", "=", "RelationalOperations", ".", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "RelationalOperations", ".", "Relation", ".", "disjoint", ")", "{", "relOps", ".", "linePointDisjointPredicates_", "(", "polyline_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "polyline_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "m_cluster_index_a", "=", "relOps", ".", "m_topo_graph", ".", "createUserIndexForClusters", "(", ")", ";", "markClusterEndPoints_", "(", "geom_a", ",", "relOps", ".", "m_topo_graph", ",", "relOps", ".", "m_cluster_index_a", ")", ";", "relOps", ".", "computeMatrixTopoGraphClusters_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "deleteUserIndexForClusters", "(", "relOps", ".", "m_cluster_index_a", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L640-L692", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.multiPointRelateMultiPoint_", "original_string": "static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(multipoint_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(multipoint_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "multiPointRelateMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setPointPointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "pointPointDisjointPredicates_", "(", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "computeMatrixTopoGraphClusters_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L695-L728", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polygonRelatePoint_", "original_string": "static boolean polygonRelatePoint_(Polygon polygon_a, Point point_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n        RelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n        relOps.resetMatrix_();\n        relOps.setPredicates_(scl);\n        relOps.setAreaPointPredicates_();\n\n        Envelope2D env_a = new Envelope2D();\n        polygon_a.queryEnvelope2D(env_a);\n        Point2D pt_b = point_b.getXY();\n\n        boolean bRelationKnown = false;\n        boolean b_disjoint = RelationalOperations.pointDisjointEnvelope_(pt_b, env_a, tolerance, progress_tracker);\n\n        if (b_disjoint)\n        {\n            relOps.areaPointDisjointPredicates_(polygon_a);\n            bRelationKnown = true;\n        }\n\n        if (!bRelationKnown)\n        {\n            PolygonUtils.PiPResult res = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance); // uses accelerator\n\n            if (res == PolygonUtils.PiPResult.PiPInside)\n            {// polygon must have area\n                relOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n                relOps.m_matrix[MatrixPredicate.InteriorExterior] = 2;\n                relOps.m_matrix[MatrixPredicate.BoundaryInterior] = -1;\n                relOps.m_matrix[MatrixPredicate.BoundaryExterior] = 1;\n                relOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n            }\n            else if (res == PolygonUtils.PiPResult.PiPBoundary)\n            {\n                relOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n\n                double area = polygon_a.calculateArea2D();\n\n                if (area != 0)\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = 0;\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = 2;\n                    relOps.m_matrix[MatrixPredicate.BoundaryExterior] = 1;\n                }\n                else\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = -1;\n                    relOps.m_matrix[MatrixPredicate.BoundaryExterior] = -1;\n\n                    Envelope2D env = new Envelope2D();\n                    polygon_a.queryEnvelope2D(env);\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = (env.getHeight() == 0.0 && env.getWidth() == 0.0 ? -1 : 1);\n                }\n            }\n            else\n            {\n                relOps.areaPointDisjointPredicates_(polygon_a);\n            }\n        }\n\n        boolean bRelation = relationCompare_(relOps.m_matrix, scl);\n        return bRelation;\n\t}", "language": "java", "code": "static boolean polygonRelatePoint_(Polygon polygon_a, Point point_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n        RelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n        relOps.resetMatrix_();\n        relOps.setPredicates_(scl);\n        relOps.setAreaPointPredicates_();\n\n        Envelope2D env_a = new Envelope2D();\n        polygon_a.queryEnvelope2D(env_a);\n        Point2D pt_b = point_b.getXY();\n\n        boolean bRelationKnown = false;\n        boolean b_disjoint = RelationalOperations.pointDisjointEnvelope_(pt_b, env_a, tolerance, progress_tracker);\n\n        if (b_disjoint)\n        {\n            relOps.areaPointDisjointPredicates_(polygon_a);\n            bRelationKnown = true;\n        }\n\n        if (!bRelationKnown)\n        {\n            PolygonUtils.PiPResult res = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance); // uses accelerator\n\n            if (res == PolygonUtils.PiPResult.PiPInside)\n            {// polygon must have area\n                relOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n                relOps.m_matrix[MatrixPredicate.InteriorExterior] = 2;\n                relOps.m_matrix[MatrixPredicate.BoundaryInterior] = -1;\n                relOps.m_matrix[MatrixPredicate.BoundaryExterior] = 1;\n                relOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n            }\n            else if (res == PolygonUtils.PiPResult.PiPBoundary)\n            {\n                relOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n\n                double area = polygon_a.calculateArea2D();\n\n                if (area != 0)\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = 0;\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = 2;\n                    relOps.m_matrix[MatrixPredicate.BoundaryExterior] = 1;\n                }\n                else\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = -1;\n                    relOps.m_matrix[MatrixPredicate.BoundaryExterior] = -1;\n\n                    Envelope2D env = new Envelope2D();\n                    polygon_a.queryEnvelope2D(env);\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = (env.getHeight() == 0.0 && env.getWidth() == 0.0 ? -1 : 1);\n                }\n            }\n            else\n            {\n                relOps.areaPointDisjointPredicates_(polygon_a);\n            }\n        }\n\n        boolean bRelation = relationCompare_(relOps.m_matrix, scl);\n        return bRelation;\n\t}", "code_tokens": ["static", "boolean", "polygonRelatePoint_", "(", "Polygon", "polygon_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setAreaPointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "pointDisjointEnvelope_", "(", "pt_b", ",", "env_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "areaPointDisjointPredicates_", "(", "polygon_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "PolygonUtils", ".", "PiPResult", "res", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ")", ";", "// uses accelerator", "if", "(", "res", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPInside", ")", "{", "// polygon must have area", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "2", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "-", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "-", "1", ";", "}", "else", "if", "(", "res", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPBoundary", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "-", "1", ";", "double", "area", "=", "polygon_a", ".", "calculateArea2D", "(", ")", ";", "if", "(", "area", "!=", "0", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "-", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "0", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "2", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "1", ";", "}", "else", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "-", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "-", "1", ";", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env", ")", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "(", "env", ".", "getHeight", "(", ")", "==", "0.0", "&&", "env", ".", "getWidth", "(", ")", "==", "0.0", "?", "-", "1", ":", "1", ")", ";", "}", "}", "else", "{", "relOps", ".", "areaPointDisjointPredicates_", "(", "polygon_a", ")", ";", "}", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L731-L795", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.polylineRelatePoint_", "original_string": "static boolean polylineRelatePoint_(Polyline polyline_a, Point point_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n        RelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n        relOps.resetMatrix_();\n        relOps.setPredicates_(scl);\n        relOps.setLinePointPredicates_();\n\n        Envelope2D env_a = new Envelope2D();\n        polyline_a.queryEnvelope2D(env_a);\n        Point2D pt_b = point_b.getXY();\n\n        boolean bRelationKnown = false;\n        boolean b_disjoint = RelationalOperations.pointDisjointEnvelope_(pt_b, env_a, tolerance, progress_tracker);\n\n        if (b_disjoint)\n        {\n            relOps.linePointDisjointPredicates_(polyline_a);\n            bRelationKnown = true;\n        }\n\n        if (!bRelationKnown)\n        {\n            MultiPoint boundary_a = null;\n            boolean b_boundary_contains_point_known = false;\n            boolean b_boundary_contains_point = false;\n\n            if (relOps.m_perform_predicates[MatrixPredicate.InteriorInterior] || relOps.m_perform_predicates[MatrixPredicate.ExteriorInterior])\n            {\n                boolean b_intersects = RelationalOperations.linearPathIntersectsPoint_(polyline_a, pt_b, tolerance);\n\n                if (b_intersects)\n                {\n                    if (relOps.m_perform_predicates[MatrixPredicate.InteriorInterior])\n                    {\n                        boundary_a = (MultiPoint)Boundary.calculate(polyline_a, progress_tracker);\n                        b_boundary_contains_point = !RelationalOperations.multiPointDisjointPointImpl_(boundary_a, pt_b, tolerance, progress_tracker);\n                        b_boundary_contains_point_known = true;\n\n                        if (b_boundary_contains_point)\n                            relOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n                        else\n                            relOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n                    }\n\n                    relOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n                }\n                else\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n                    relOps.m_matrix[MatrixPredicate.ExteriorInterior] = 0;\n                }\n            }\n\n            if (relOps.m_perform_predicates[MatrixPredicate.BoundaryInterior])\n            {\n                if (boundary_a != null && boundary_a.isEmpty())\n                {\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = -1;\n                }\n                else\n                {\n                    if (!b_boundary_contains_point_known)\n                    {\n                        if (boundary_a == null)\n                            boundary_a = (MultiPoint)Boundary.calculate(polyline_a, progress_tracker);\n\n                        b_boundary_contains_point = !RelationalOperations.multiPointDisjointPointImpl_(boundary_a, pt_b, tolerance, progress_tracker);\n                        b_boundary_contains_point_known = true;\n                    }\n\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = (b_boundary_contains_point ? 0 : -1);\n                }\n            }\n\n            if (relOps.m_perform_predicates[MatrixPredicate.BoundaryExterior])\n            {\n                if (boundary_a != null && boundary_a.isEmpty())\n                {\n                    relOps.m_matrix[MatrixPredicate.BoundaryExterior] = -1;\n                }\n                else\n                {\n                    if (b_boundary_contains_point_known && !b_boundary_contains_point)\n                    {\n                        relOps.m_matrix[MatrixPredicate.BoundaryExterior] = 0;\n                    }\n                    else\n                    {\n                        if (boundary_a == null)\n                            boundary_a = (MultiPoint)Boundary.calculate(polyline_a, progress_tracker);\n\n                        boolean b_boundary_equals_point = RelationalOperations.multiPointEqualsPoint_(boundary_a, point_b, tolerance, progress_tracker);\n                        relOps.m_matrix[MatrixPredicate.BoundaryExterior] = (b_boundary_equals_point ? -1 : 0);\n                    }\n                }\n            }\n\n            if (relOps.m_perform_predicates[MatrixPredicate.InteriorExterior])\n            {\n                boolean b_has_length = polyline_a.calculateLength2D() != 0;\n\n                if (b_has_length)\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = 1;\n                }\n                else\n                {\n                    // all points are interior\n                    MultiPoint interior_a = new MultiPoint(polyline_a.getDescription());\n                    interior_a.add(polyline_a, 0, polyline_a.getPointCount());\n                    boolean b_interior_equals_point = RelationalOperations.multiPointEqualsPoint_(interior_a, point_b, tolerance, progress_tracker);\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = (b_interior_equals_point ? -1 : 0);\n                }\n            }\n        }\n\n        boolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n        return bRelation;\n\t}", "language": "java", "code": "static boolean polylineRelatePoint_(Polyline polyline_a, Point point_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n        RelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n        relOps.resetMatrix_();\n        relOps.setPredicates_(scl);\n        relOps.setLinePointPredicates_();\n\n        Envelope2D env_a = new Envelope2D();\n        polyline_a.queryEnvelope2D(env_a);\n        Point2D pt_b = point_b.getXY();\n\n        boolean bRelationKnown = false;\n        boolean b_disjoint = RelationalOperations.pointDisjointEnvelope_(pt_b, env_a, tolerance, progress_tracker);\n\n        if (b_disjoint)\n        {\n            relOps.linePointDisjointPredicates_(polyline_a);\n            bRelationKnown = true;\n        }\n\n        if (!bRelationKnown)\n        {\n            MultiPoint boundary_a = null;\n            boolean b_boundary_contains_point_known = false;\n            boolean b_boundary_contains_point = false;\n\n            if (relOps.m_perform_predicates[MatrixPredicate.InteriorInterior] || relOps.m_perform_predicates[MatrixPredicate.ExteriorInterior])\n            {\n                boolean b_intersects = RelationalOperations.linearPathIntersectsPoint_(polyline_a, pt_b, tolerance);\n\n                if (b_intersects)\n                {\n                    if (relOps.m_perform_predicates[MatrixPredicate.InteriorInterior])\n                    {\n                        boundary_a = (MultiPoint)Boundary.calculate(polyline_a, progress_tracker);\n                        b_boundary_contains_point = !RelationalOperations.multiPointDisjointPointImpl_(boundary_a, pt_b, tolerance, progress_tracker);\n                        b_boundary_contains_point_known = true;\n\n                        if (b_boundary_contains_point)\n                            relOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n                        else\n                            relOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n                    }\n\n                    relOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n                }\n                else\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n                    relOps.m_matrix[MatrixPredicate.ExteriorInterior] = 0;\n                }\n            }\n\n            if (relOps.m_perform_predicates[MatrixPredicate.BoundaryInterior])\n            {\n                if (boundary_a != null && boundary_a.isEmpty())\n                {\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = -1;\n                }\n                else\n                {\n                    if (!b_boundary_contains_point_known)\n                    {\n                        if (boundary_a == null)\n                            boundary_a = (MultiPoint)Boundary.calculate(polyline_a, progress_tracker);\n\n                        b_boundary_contains_point = !RelationalOperations.multiPointDisjointPointImpl_(boundary_a, pt_b, tolerance, progress_tracker);\n                        b_boundary_contains_point_known = true;\n                    }\n\n                    relOps.m_matrix[MatrixPredicate.BoundaryInterior] = (b_boundary_contains_point ? 0 : -1);\n                }\n            }\n\n            if (relOps.m_perform_predicates[MatrixPredicate.BoundaryExterior])\n            {\n                if (boundary_a != null && boundary_a.isEmpty())\n                {\n                    relOps.m_matrix[MatrixPredicate.BoundaryExterior] = -1;\n                }\n                else\n                {\n                    if (b_boundary_contains_point_known && !b_boundary_contains_point)\n                    {\n                        relOps.m_matrix[MatrixPredicate.BoundaryExterior] = 0;\n                    }\n                    else\n                    {\n                        if (boundary_a == null)\n                            boundary_a = (MultiPoint)Boundary.calculate(polyline_a, progress_tracker);\n\n                        boolean b_boundary_equals_point = RelationalOperations.multiPointEqualsPoint_(boundary_a, point_b, tolerance, progress_tracker);\n                        relOps.m_matrix[MatrixPredicate.BoundaryExterior] = (b_boundary_equals_point ? -1 : 0);\n                    }\n                }\n            }\n\n            if (relOps.m_perform_predicates[MatrixPredicate.InteriorExterior])\n            {\n                boolean b_has_length = polyline_a.calculateLength2D() != 0;\n\n                if (b_has_length)\n                {\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = 1;\n                }\n                else\n                {\n                    // all points are interior\n                    MultiPoint interior_a = new MultiPoint(polyline_a.getDescription());\n                    interior_a.add(polyline_a, 0, polyline_a.getPointCount());\n                    boolean b_interior_equals_point = RelationalOperations.multiPointEqualsPoint_(interior_a, point_b, tolerance, progress_tracker);\n                    relOps.m_matrix[MatrixPredicate.InteriorExterior] = (b_interior_equals_point ? -1 : 0);\n                }\n            }\n        }\n\n        boolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n        return bRelation;\n\t}", "code_tokens": ["static", "boolean", "polylineRelatePoint_", "(", "Polyline", "polyline_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setLinePointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "pointDisjointEnvelope_", "(", "pt_b", ",", "env_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "linePointDisjointPredicates_", "(", "polyline_a", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "MultiPoint", "boundary_a", "=", "null", ";", "boolean", "b_boundary_contains_point_known", "=", "false", ";", "boolean", "b_boundary_contains_point", "=", "false", ";", "if", "(", "relOps", ".", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "||", "relOps", ".", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "boolean", "b_intersects", "=", "RelationalOperations", ".", "linearPathIntersectsPoint_", "(", "polyline_a", ",", "pt_b", ",", "tolerance", ")", ";", "if", "(", "b_intersects", ")", "{", "if", "(", "relOps", ".", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "boundary_a", "=", "(", "MultiPoint", ")", "Boundary", ".", "calculate", "(", "polyline_a", ",", "progress_tracker", ")", ";", "b_boundary_contains_point", "=", "!", "RelationalOperations", ".", "multiPointDisjointPointImpl_", "(", "boundary_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "b_boundary_contains_point_known", "=", "true", ";", "if", "(", "b_boundary_contains_point", ")", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "-", "1", ";", "else", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "}", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "-", "1", ";", "}", "else", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "-", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "0", ";", "}", "}", "if", "(", "relOps", ".", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "if", "(", "boundary_a", "!=", "null", "&&", "boundary_a", ".", "isEmpty", "(", ")", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "-", "1", ";", "}", "else", "{", "if", "(", "!", "b_boundary_contains_point_known", ")", "{", "if", "(", "boundary_a", "==", "null", ")", "boundary_a", "=", "(", "MultiPoint", ")", "Boundary", ".", "calculate", "(", "polyline_a", ",", "progress_tracker", ")", ";", "b_boundary_contains_point", "=", "!", "RelationalOperations", ".", "multiPointDisjointPointImpl_", "(", "boundary_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "b_boundary_contains_point_known", "=", "true", ";", "}", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "(", "b_boundary_contains_point", "?", "0", ":", "-", "1", ")", ";", "}", "}", "if", "(", "relOps", ".", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "if", "(", "boundary_a", "!=", "null", "&&", "boundary_a", ".", "isEmpty", "(", ")", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "-", "1", ";", "}", "else", "{", "if", "(", "b_boundary_contains_point_known", "&&", "!", "b_boundary_contains_point", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "0", ";", "}", "else", "{", "if", "(", "boundary_a", "==", "null", ")", "boundary_a", "=", "(", "MultiPoint", ")", "Boundary", ".", "calculate", "(", "polyline_a", ",", "progress_tracker", ")", ";", "boolean", "b_boundary_equals_point", "=", "RelationalOperations", ".", "multiPointEqualsPoint_", "(", "boundary_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "(", "b_boundary_equals_point", "?", "-", "1", ":", "0", ")", ";", "}", "}", "}", "if", "(", "relOps", ".", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "boolean", "b_has_length", "=", "polyline_a", ".", "calculateLength2D", "(", ")", "!=", "0", ";", "if", "(", "b_has_length", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "1", ";", "}", "else", "{", "// all points are interior", "MultiPoint", "interior_a", "=", "new", "MultiPoint", "(", "polyline_a", ".", "getDescription", "(", ")", ")", ";", "interior_a", ".", "add", "(", "polyline_a", ",", "0", ",", "polyline_a", ".", "getPointCount", "(", ")", ")", ";", "boolean", "b_interior_equals_point", "=", "RelationalOperations", ".", "multiPointEqualsPoint_", "(", "interior_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "(", "b_interior_equals_point", "?", "-", "1", ":", "0", ")", ";", "}", "}", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L798-L916", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.multiPointRelatePoint_", "original_string": "static boolean multiPointRelatePoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tPoint2D pt_b = point_b.getXY();\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.pointDisjointEnvelope_(pt_b,\n\t\t\t\tenv_a, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tboolean b_intersects = false;\n\t\t\tboolean b_multipoint_contained = true;\n\t\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\t\tPoint2D pt_a = multipoint_a.getXY(i);\n\n\t\t\t\tif (Point2D.sqrDistance(pt_a, pt_b) <= tolerance_sq)\n\t\t\t\t\tb_intersects = true;\n\t\t\t\telse\n\t\t\t\t\tb_multipoint_contained = false;\n\n\t\t\t\tif (b_intersects && !b_multipoint_contained)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (b_intersects) {\n\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n\n\t\t\t\tif (!b_multipoint_contained)\n\t\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorExterior] = 0;\n\t\t\t\telse\n\t\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorExterior] = -1;\n\n\t\t\t\trelOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n\t\t\t} else {\n\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorExterior] = 0;\n\t\t\t\trelOps.m_matrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean multiPointRelatePoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tPoint2D pt_b = point_b.getXY();\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.pointDisjointEnvelope_(pt_b,\n\t\t\t\tenv_a, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tboolean b_intersects = false;\n\t\t\tboolean b_multipoint_contained = true;\n\t\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\t\tPoint2D pt_a = multipoint_a.getXY(i);\n\n\t\t\t\tif (Point2D.sqrDistance(pt_a, pt_b) <= tolerance_sq)\n\t\t\t\t\tb_intersects = true;\n\t\t\t\telse\n\t\t\t\t\tb_multipoint_contained = false;\n\n\t\t\t\tif (b_intersects && !b_multipoint_contained)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (b_intersects) {\n\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorInterior] = 0;\n\n\t\t\t\tif (!b_multipoint_contained)\n\t\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorExterior] = 0;\n\t\t\t\telse\n\t\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorExterior] = -1;\n\n\t\t\t\trelOps.m_matrix[MatrixPredicate.ExteriorInterior] = -1;\n\t\t\t} else {\n\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorInterior] = -1;\n\t\t\t\trelOps.m_matrix[MatrixPredicate.InteriorExterior] = 0;\n\t\t\t\trelOps.m_matrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "multiPointRelatePoint_", "(", "MultiPoint", "multipoint_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setPointPointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "pointDisjointEnvelope_", "(", "pt_b", ",", "env_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "pointPointDisjointPredicates_", "(", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "boolean", "b_intersects", "=", "false", ";", "boolean", "b_multipoint_contained", "=", "true", ";", "double", "tolerance_sq", "=", "tolerance", "*", "tolerance", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "Point2D", "pt_a", "=", "multipoint_a", ".", "getXY", "(", "i", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt_a", ",", "pt_b", ")", "<=", "tolerance_sq", ")", "b_intersects", "=", "true", ";", "else", "b_multipoint_contained", "=", "false", ";", "if", "(", "b_intersects", "&&", "!", "b_multipoint_contained", ")", "break", ";", "}", "if", "(", "b_intersects", ")", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "if", "(", "!", "b_multipoint_contained", ")", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "0", ";", "else", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "-", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "-", "1", ";", "}", "else", "{", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "-", "1", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "0", ";", "relOps", ".", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "0", ";", "}", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L919-L975", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.pointRelatePoint_", "original_string": "static boolean pointRelatePoint_(Point point_a, Point point_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_a = point_a.getXY();\n\t\tPoint2D pt_b = point_b.getXY();\n\t\tint[] matrix = new int[9];\n\n\t\tfor (int i = 0; i < 9; i++)\n\t\t\tmatrix[i] = -1;\n\n\t\tif (Point2D.sqrDistance(pt_a, pt_b) <= tolerance * tolerance) {\n\t\t\tmatrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t} else {\n\t\t\tmatrix[MatrixPredicate.InteriorExterior] = 0;\n\t\t\tmatrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t}\n\n\t\tmatrix[MatrixPredicate.ExteriorExterior] = 2;\n\n\t\tboolean bRelation = relationCompare_(matrix, scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean pointRelatePoint_(Point point_a, Point point_b,\n\t\t\tdouble tolerance, String scl, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_a = point_a.getXY();\n\t\tPoint2D pt_b = point_b.getXY();\n\t\tint[] matrix = new int[9];\n\n\t\tfor (int i = 0; i < 9; i++)\n\t\t\tmatrix[i] = -1;\n\n\t\tif (Point2D.sqrDistance(pt_a, pt_b) <= tolerance * tolerance) {\n\t\t\tmatrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t} else {\n\t\t\tmatrix[MatrixPredicate.InteriorExterior] = 0;\n\t\t\tmatrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t}\n\n\t\tmatrix[MatrixPredicate.ExteriorExterior] = 2;\n\n\t\tboolean bRelation = relationCompare_(matrix, scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "pointRelatePoint_", "(", "Point", "point_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "Point2D", "pt_a", "=", "point_a", ".", "getXY", "(", ")", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "int", "[", "]", "matrix", "=", "new", "int", "[", "9", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "matrix", "[", "i", "]", "=", "-", "1", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt_a", ",", "pt_b", ")", "<=", "tolerance", "*", "tolerance", ")", "{", "matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "}", "else", "{", "matrix", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "0", ";", "matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "0", ";", "}", "matrix", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "boolean", "bRelation", "=", "relationCompare_", "(", "matrix", ",", "scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L978-L998", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.relationCompare_", "original_string": "private static boolean relationCompare_(int[] matrix, String scl) {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tswitch (scl.charAt(i)) {\n\t\t\tcase 'T':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] == -1)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != -1)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase '0':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != 0)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase '1':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != 1)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase '2':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != 2)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean relationCompare_(int[] matrix, String scl) {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tswitch (scl.charAt(i)) {\n\t\t\tcase 'T':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] == -1)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != -1)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase '0':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != 0)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase '1':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != 1)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase '2':\n\t\t\t\tassert (matrix[i] != -2);\n\t\t\t\tif (matrix[i] != 2)\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "relationCompare_", "(", "int", "[", "]", "matrix", ",", "String", "scl", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "{", "switch", "(", "scl", ".", "charAt", "(", "i", ")", ")", "{", "case", "'", "'", ":", "assert", "(", "matrix", "[", "i", "]", "!=", "-", "2", ")", ";", "if", "(", "matrix", "[", "i", "]", "==", "-", "1", ")", "return", "false", ";", "break", ";", "case", "'", "'", ":", "assert", "(", "matrix", "[", "i", "]", "!=", "-", "2", ")", ";", "if", "(", "matrix", "[", "i", "]", "!=", "-", "1", ")", "return", "false", ";", "break", ";", "case", "'", "'", ":", "assert", "(", "matrix", "[", "i", "]", "!=", "-", "2", ")", ";", "if", "(", "matrix", "[", "i", "]", "!=", "0", ")", "return", "false", ";", "break", ";", "case", "'", "'", ":", "assert", "(", "matrix", "[", "i", "]", "!=", "-", "2", ")", ";", "if", "(", "matrix", "[", "i", "]", "!=", "1", ")", "return", "false", ";", "break", ";", "case", "'", "'", ":", "assert", "(", "matrix", "[", "i", "]", "!=", "-", "2", ")", ";", "if", "(", "matrix", "[", "i", "]", "!=", "2", ")", "return", "false", ";", "break", ";", "default", ":", "break", ";", "}", "}", "return", "true", ";", "}"], "docstring": "Compares the DE-9I matrix against the scl string.", "docstring_tokens": ["Compares", "the", "DE", "-", "9I", "matrix", "against", "the", "scl", "string", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1001-L1040", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.getPredefinedRelation_", "original_string": "private static int getPredefinedRelation_(String scl, int dim_a, int dim_b) {\n\t\tif (equals_(scl))\n\t\t\treturn RelationalOperations.Relation.equals;\n\n\t\tif (disjoint_(scl))\n\t\t\treturn RelationalOperations.Relation.disjoint;\n\n\t\tif (touches_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.touches;\n\n\t\tif (crosses_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.crosses;\n\n\t\tif (contains_(scl))\n\t\t\treturn RelationalOperations.Relation.contains;\n\n\t\tif (overlaps_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.overlaps;\n\n\t\treturn RelationalOperations.Relation.unknown;\n\t}", "language": "java", "code": "private static int getPredefinedRelation_(String scl, int dim_a, int dim_b) {\n\t\tif (equals_(scl))\n\t\t\treturn RelationalOperations.Relation.equals;\n\n\t\tif (disjoint_(scl))\n\t\t\treturn RelationalOperations.Relation.disjoint;\n\n\t\tif (touches_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.touches;\n\n\t\tif (crosses_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.crosses;\n\n\t\tif (contains_(scl))\n\t\t\treturn RelationalOperations.Relation.contains;\n\n\t\tif (overlaps_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.overlaps;\n\n\t\treturn RelationalOperations.Relation.unknown;\n\t}", "code_tokens": ["private", "static", "int", "getPredefinedRelation_", "(", "String", "scl", ",", "int", "dim_a", ",", "int", "dim_b", ")", "{", "if", "(", "equals_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "equals", ";", "if", "(", "disjoint_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "disjoint", ";", "if", "(", "touches_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "touches", ";", "if", "(", "crosses_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "crosses", ";", "if", "(", "contains_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "contains", ";", "if", "(", "overlaps_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "overlaps", ";", "return", "RelationalOperations", ".", "Relation", ".", "unknown", ";", "}"], "docstring": "Checks whether scl string is a predefined relation.", "docstring_tokens": ["Checks", "whether", "scl", "string", "is", "a", "predefined", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1122-L1142", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.equals_", "original_string": "private static boolean equals_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == 'F' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == 'F'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean equals_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == 'F' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == 'F'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "equals_", "(", "String", "scl", ")", "{", "// Valid for all", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the equals relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "equals", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1145-L1155", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.disjoint_", "original_string": "private static boolean disjoint_(String scl) {\n\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == 'F'\n\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == 'F'\n\t\t\t\t&& scl.charAt(4) == 'F' && scl.charAt(5) == '*'\n\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean disjoint_(String scl) {\n\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == 'F'\n\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == 'F'\n\t\t\t\t&& scl.charAt(4) == 'F' && scl.charAt(5) == '*'\n\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "disjoint_", "(", "String", "scl", ")", "{", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the disjoint relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "disjoint", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1158-L1167", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.touches_", "original_string": "private static boolean touches_(String scl, int dim_a, int dim_b) {\n\t\t// Points cant touch\n\t\tif (dim_a == 0 && dim_b == 0)\n\t\t\treturn false;\n\n\t\tif (!(dim_a == 2 && dim_b == 2)) {\n\t\t\t// Valid for area-Line, Line-Line, area-Point, and Line-Point\n\t\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == 'T'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\n\t\t\tif (dim_a == 1 && dim_b == 1) {\n\t\t\t\t// Valid for Line-Line\n\t\t\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == 'T'\n\t\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Valid for area-area, area-Line, Line-Line\n\n\t\tif (dim_b != 0) {\n\t\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == 'T' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean touches_(String scl, int dim_a, int dim_b) {\n\t\t// Points cant touch\n\t\tif (dim_a == 0 && dim_b == 0)\n\t\t\treturn false;\n\n\t\tif (!(dim_a == 2 && dim_b == 2)) {\n\t\t\t// Valid for area-Line, Line-Line, area-Point, and Line-Point\n\t\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == 'T'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\n\t\t\tif (dim_a == 1 && dim_b == 1) {\n\t\t\t\t// Valid for Line-Line\n\t\t\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == 'T'\n\t\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Valid for area-area, area-Line, Line-Line\n\n\t\tif (dim_b != 0) {\n\t\t\tif (scl.charAt(0) == 'F' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == 'T' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "touches_", "(", "String", "scl", ",", "int", "dim_a", ",", "int", "dim_b", ")", "{", "// Points cant touch", "if", "(", "dim_a", "==", "0", "&&", "dim_b", "==", "0", ")", "return", "false", ";", "if", "(", "!", "(", "dim_a", "==", "2", "&&", "dim_b", "==", "2", ")", ")", "{", "// Valid for area-Line, Line-Line, area-Point, and Line-Point", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "if", "(", "dim_a", "==", "1", "&&", "dim_b", "==", "1", ")", "{", "// Valid for Line-Line", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "}", "}", "// Valid for area-area, area-Line, Line-Line", "if", "(", "dim_b", "!=", "0", ")", "{", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the touches relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "touches", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1170-L1207", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.crosses_", "original_string": "private static boolean crosses_(String scl, int dim_a, int dim_b) {\n\t\tif (dim_a > dim_b) {\n\t\t\t// Valid for area-Line, area-Point, Line-Point\n\t\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == 'T' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (dim_a == 1 && dim_b == 1) {\n\t\t\t// Valid for Line-Line\n\t\t\tif (scl.charAt(0) == '0' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean crosses_(String scl, int dim_a, int dim_b) {\n\t\tif (dim_a > dim_b) {\n\t\t\t// Valid for area-Line, area-Point, Line-Point\n\t\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == 'T' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (dim_a == 1 && dim_b == 1) {\n\t\t\t// Valid for Line-Line\n\t\t\tif (scl.charAt(0) == '0' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == '*' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "crosses_", "(", "String", "scl", ",", "int", "dim_a", ",", "int", "dim_b", ")", "{", "if", "(", "dim_a", ">", "dim_b", ")", "{", "// Valid for area-Line, area-Point, Line-Point", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}", "if", "(", "dim_a", "==", "1", "&&", "dim_b", "==", "1", ")", "{", "// Valid for Line-Line", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the crosses relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "crosses", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1210-L1234", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.contains_", "original_string": "private static boolean contains_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean contains_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == '*' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "contains_", "(", "String", "scl", ")", "{", "// Valid for all", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the contains relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "contains", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1237-L1247", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.overlaps_", "original_string": "private static boolean overlaps_(String scl, int dim_a, int dim_b) {\n\t\tif (dim_a == dim_b) {\n\t\t\tif (dim_a != 1) {\n\t\t\t\t// Valid for area-area, Point-Point\n\t\t\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t\t\t&& scl.charAt(2) == 'T' && scl.charAt(3) == '*'\n\t\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t\t&& scl.charAt(6) == 'T' && scl.charAt(7) == '*'\n\t\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\t\treturn true;\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Valid for Line-Line\n\t\t\tif (scl.charAt(0) == '1' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == 'T' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == 'T' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean overlaps_(String scl, int dim_a, int dim_b) {\n\t\tif (dim_a == dim_b) {\n\t\t\tif (dim_a != 1) {\n\t\t\t\t// Valid for area-area, Point-Point\n\t\t\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t\t\t&& scl.charAt(2) == 'T' && scl.charAt(3) == '*'\n\t\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t\t&& scl.charAt(6) == 'T' && scl.charAt(7) == '*'\n\t\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\t\treturn true;\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Valid for Line-Line\n\t\t\tif (scl.charAt(0) == '1' && scl.charAt(1) == '*'\n\t\t\t\t\t&& scl.charAt(2) == 'T' && scl.charAt(3) == '*'\n\t\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == '*'\n\t\t\t\t\t&& scl.charAt(6) == 'T' && scl.charAt(7) == '*'\n\t\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "overlaps_", "(", "String", "scl", ",", "int", "dim_a", ",", "int", "dim_b", ")", "{", "if", "(", "dim_a", "==", "dim_b", ")", "{", "if", "(", "dim_a", "!=", "1", ")", "{", "// Valid for area-area, Point-Point", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}", "// Valid for Line-Line", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the overlaps relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "overlaps", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1250-L1274", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.markClusterEndPoints_", "original_string": "private static void markClusterEndPoints_(int geometry,\n\t\t\tTopoGraph topoGraph, int clusterIndex) {\n        int id = topoGraph.getGeometryID(geometry);\n\n        for (int cluster = topoGraph.getFirstCluster(); cluster != -1; cluster = topoGraph.getNextCluster(cluster))\n        {\n            int cluster_parentage = topoGraph.getClusterParentage(cluster);\n\n            if ((cluster_parentage & id) == 0)\n                continue;\n\n            int first_half_edge = topoGraph.getClusterHalfEdge(cluster);\n            if (first_half_edge == -1)\n            {\n                topoGraph.setClusterUserIndex(cluster, clusterIndex, 0);\n                continue;\n            }\n\n            int next_half_edge = first_half_edge;\n            int index = 0;\n\n            do\n            {\n                int half_edge = next_half_edge;\n                int half_edge_parentage = topoGraph.getHalfEdgeParentage(half_edge);\n\n                if ((half_edge_parentage & id) != 0)\n                    index++;\n\n                next_half_edge = topoGraph.getHalfEdgeNext(topoGraph.getHalfEdgeTwin(half_edge));\n\n            } while (next_half_edge != first_half_edge);\n\n            topoGraph.setClusterUserIndex(cluster, clusterIndex, index);\n        }\n\n        return;\n\t}", "language": "java", "code": "private static void markClusterEndPoints_(int geometry,\n\t\t\tTopoGraph topoGraph, int clusterIndex) {\n        int id = topoGraph.getGeometryID(geometry);\n\n        for (int cluster = topoGraph.getFirstCluster(); cluster != -1; cluster = topoGraph.getNextCluster(cluster))\n        {\n            int cluster_parentage = topoGraph.getClusterParentage(cluster);\n\n            if ((cluster_parentage & id) == 0)\n                continue;\n\n            int first_half_edge = topoGraph.getClusterHalfEdge(cluster);\n            if (first_half_edge == -1)\n            {\n                topoGraph.setClusterUserIndex(cluster, clusterIndex, 0);\n                continue;\n            }\n\n            int next_half_edge = first_half_edge;\n            int index = 0;\n\n            do\n            {\n                int half_edge = next_half_edge;\n                int half_edge_parentage = topoGraph.getHalfEdgeParentage(half_edge);\n\n                if ((half_edge_parentage & id) != 0)\n                    index++;\n\n                next_half_edge = topoGraph.getHalfEdgeNext(topoGraph.getHalfEdgeTwin(half_edge));\n\n            } while (next_half_edge != first_half_edge);\n\n            topoGraph.setClusterUserIndex(cluster, clusterIndex, index);\n        }\n\n        return;\n\t}", "code_tokens": ["private", "static", "void", "markClusterEndPoints_", "(", "int", "geometry", ",", "TopoGraph", "topoGraph", ",", "int", "clusterIndex", ")", "{", "int", "id", "=", "topoGraph", ".", "getGeometryID", "(", "geometry", ")", ";", "for", "(", "int", "cluster", "=", "topoGraph", ".", "getFirstCluster", "(", ")", ";", "cluster", "!=", "-", "1", ";", "cluster", "=", "topoGraph", ".", "getNextCluster", "(", "cluster", ")", ")", "{", "int", "cluster_parentage", "=", "topoGraph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "cluster_parentage", "&", "id", ")", "==", "0", ")", "continue", ";", "int", "first_half_edge", "=", "topoGraph", ".", "getClusterHalfEdge", "(", "cluster", ")", ";", "if", "(", "first_half_edge", "==", "-", "1", ")", "{", "topoGraph", ".", "setClusterUserIndex", "(", "cluster", ",", "clusterIndex", ",", "0", ")", ";", "continue", ";", "}", "int", "next_half_edge", "=", "first_half_edge", ";", "int", "index", "=", "0", ";", "do", "{", "int", "half_edge", "=", "next_half_edge", ";", "int", "half_edge_parentage", "=", "topoGraph", ".", "getHalfEdgeParentage", "(", "half_edge", ")", ";", "if", "(", "(", "half_edge_parentage", "&", "id", ")", "!=", "0", ")", "index", "++", ";", "next_half_edge", "=", "topoGraph", ".", "getHalfEdgeNext", "(", "topoGraph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "}", "while", "(", "next_half_edge", "!=", "first_half_edge", ")", ";", "topoGraph", ".", "setClusterUserIndex", "(", "cluster", ",", "clusterIndex", ",", "index", ")", ";", "}", "return", ";", "}"], "docstring": "the geometry and/or a boundary index of the geometry.", "docstring_tokens": ["the", "geometry", "and", "/", "or", "a", "boundary", "index", "of", "the", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1278-L1315", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setPredicates_", "original_string": "private void setPredicates_(String scl) {\n\t\tm_scl = scl;\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_scl.charAt(i) != '*') {\n\t\t\t\tm_perform_predicates[i] = true;\n\t\t\t\tm_predicate_count++;\n\t\t\t} else\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t}\n\t}", "language": "java", "code": "private void setPredicates_(String scl) {\n\t\tm_scl = scl;\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_scl.charAt(i) != '*') {\n\t\t\t\tm_perform_predicates[i] = true;\n\t\t\t\tm_predicate_count++;\n\t\t\t} else\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t}\n\t}", "code_tokens": ["private", "void", "setPredicates_", "(", "String", "scl", ")", "{", "m_scl", "=", "scl", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "{", "if", "(", "m_scl", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "m_perform_predicates", "[", "i", "]", "=", "true", ";", "m_predicate_count", "++", ";", "}", "else", "m_perform_predicates", "[", "i", "]", "=", "false", ";", "}", "}"], "docstring": "Sets the relation predicates from the scl string.", "docstring_tokens": ["Sets", "the", "relation", "predicates", "from", "the", "scl", "string", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1360-L1370", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setRemainingPredicatesToFalse_", "original_string": "private void setRemainingPredicatesToFalse_() {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_perform_predicates[i] && m_matrix[i] == -2) {\n\t\t\t\tm_matrix[i] = -1;\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void setRemainingPredicatesToFalse_() {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_perform_predicates[i] && m_matrix[i] == -2) {\n\t\t\t\tm_matrix[i] = -1;\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "setRemainingPredicatesToFalse_", "(", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "{", "if", "(", "m_perform_predicates", "[", "i", "]", "&&", "m_matrix", "[", "i", "]", "==", "-", "2", ")", "{", "m_matrix", "[", "i", "]", "=", "-", "1", ";", "m_perform_predicates", "[", "i", "]", "=", "false", ";", "}", "}", "}"], "docstring": "Sets the remaining predicates to false", "docstring_tokens": ["Sets", "the", "remaining", "predicates", "to", "false"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1373-L1380", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.isPredicateKnown_", "original_string": "private boolean isPredicateKnown_(int predicate) {\n        assert(m_scl.charAt(predicate) != '*');\n\n        if (m_matrix[predicate] == -2)\n            return false;\n\n        if (m_matrix[predicate] == -1)\n        {\n            m_perform_predicates[predicate] = false;\n            m_predicate_count--;\n            return true;\n        }\n\n        if (m_scl.charAt(predicate) != 'T' && m_scl.charAt(predicate) != 'F')\n        {\n            if (m_matrix[predicate] < m_max_dim[predicate])\n            {\n                return false;\n            }\n            else\n            {\n                m_perform_predicates[predicate] = false;\n                m_predicate_count--;\n                return true;\n            }\n        }\n        else\n        {\n            m_perform_predicates[predicate] = false;\n            m_predicate_count--;\n            return true;\n        }\n\t}", "language": "java", "code": "private boolean isPredicateKnown_(int predicate) {\n        assert(m_scl.charAt(predicate) != '*');\n\n        if (m_matrix[predicate] == -2)\n            return false;\n\n        if (m_matrix[predicate] == -1)\n        {\n            m_perform_predicates[predicate] = false;\n            m_predicate_count--;\n            return true;\n        }\n\n        if (m_scl.charAt(predicate) != 'T' && m_scl.charAt(predicate) != 'F')\n        {\n            if (m_matrix[predicate] < m_max_dim[predicate])\n            {\n                return false;\n            }\n            else\n            {\n                m_perform_predicates[predicate] = false;\n                m_predicate_count--;\n                return true;\n            }\n        }\n        else\n        {\n            m_perform_predicates[predicate] = false;\n            m_predicate_count--;\n            return true;\n        }\n\t}", "code_tokens": ["private", "boolean", "isPredicateKnown_", "(", "int", "predicate", ")", "{", "assert", "(", "m_scl", ".", "charAt", "(", "predicate", ")", "!=", "'", "'", ")", ";", "if", "(", "m_matrix", "[", "predicate", "]", "==", "-", "2", ")", "return", "false", ";", "if", "(", "m_matrix", "[", "predicate", "]", "==", "-", "1", ")", "{", "m_perform_predicates", "[", "predicate", "]", "=", "false", ";", "m_predicate_count", "--", ";", "return", "true", ";", "}", "if", "(", "m_scl", ".", "charAt", "(", "predicate", ")", "!=", "'", "'", "&&", "m_scl", ".", "charAt", "(", "predicate", ")", "!=", "'", "'", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "<", "m_max_dim", "[", "predicate", "]", ")", "{", "return", "false", ";", "}", "else", "{", "m_perform_predicates", "[", "predicate", "]", "=", "false", ";", "m_predicate_count", "--", ";", "return", "true", ";", "}", "}", "else", "{", "m_perform_predicates", "[", "predicate", "]", "=", "false", ";", "m_predicate_count", "--", ";", "return", "true", ";", "}", "}"], "docstring": "Checks whether the predicate is known.", "docstring_tokens": ["Checks", "whether", "the", "predicate", "is", "known", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1383-L1415", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setAreaAreaPredicates_", "original_string": "private void setAreaAreaPredicates_() {\n        m_predicates_half_edge = Predicates.AreaAreaPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 2;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = 1;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 2;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 1;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = 1;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 2;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = 1;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        // set predicates that are always true/false\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "language": "java", "code": "private void setAreaAreaPredicates_() {\n        m_predicates_half_edge = Predicates.AreaAreaPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 2;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = 1;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 2;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 1;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = 1;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 2;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = 1;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        // set predicates that are always true/false\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "code_tokens": ["private", "void", "setAreaAreaPredicates_", "(", ")", "{", "m_predicates_half_edge", "=", "Predicates", ".", "AreaAreaPredicates", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "2", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "2", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "2", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// set predicates that are always true/false", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// Always true", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "}"], "docstring": "Sets the area-area predicates function.", "docstring_tokens": ["Sets", "the", "area", "-", "area", "predicates", "function", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1418-L1438", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setAreaLinePredicates_", "original_string": "private void setAreaLinePredicates_() {\n        m_predicates_half_edge = Predicates.AreaLinePredicates;\n        m_predicates_cluster = Predicates.AreaPointPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 2;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 1;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = 0;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "language": "java", "code": "private void setAreaLinePredicates_() {\n        m_predicates_half_edge = Predicates.AreaLinePredicates;\n        m_predicates_cluster = Predicates.AreaPointPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 2;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 1;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = 0;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "code_tokens": ["private", "void", "setAreaLinePredicates_", "(", ")", "{", "m_predicates_half_edge", "=", "Predicates", ".", "AreaLinePredicates", ";", "m_predicates_cluster", "=", "Predicates", ".", "AreaPointPredicates", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "2", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// Always true", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "}"], "docstring": "Sets the area-line predicate function.", "docstring_tokens": ["Sets", "the", "area", "-", "line", "predicate", "function", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1441-L1461", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setLineLinePredicates_", "original_string": "private void setLineLinePredicates_() {\n        m_predicates_half_edge = Predicates.LineLinePredicates;\n        m_predicates_cluster = Predicates.LinePointPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 1;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 0;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = 0;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 0;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        // set predicates that are always true/false\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "language": "java", "code": "private void setLineLinePredicates_() {\n        m_predicates_half_edge = Predicates.LineLinePredicates;\n        m_predicates_cluster = Predicates.LinePointPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 1;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 0;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = 0;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 0;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = 0;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        // set predicates that are always true/false\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "code_tokens": ["private", "void", "setLineLinePredicates_", "(", ")", "{", "m_predicates_half_edge", "=", "Predicates", ".", "LineLinePredicates", ";", "m_predicates_cluster", "=", "Predicates", ".", "LinePointPredicates", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// set predicates that are always true/false", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// Always true", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "}"], "docstring": "Sets the line-line predicates function.", "docstring_tokens": ["Sets", "the", "line", "-", "line", "predicates", "function", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1464-L1485", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setAreaPointPredicates_", "original_string": "private void setAreaPointPredicates_() {\n        m_predicates_cluster = Predicates.AreaPointPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 0;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = -1;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 2;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 0;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = -1;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 0;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = -1;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        // set predicates that are always true/false\n        if (m_perform_predicates[MatrixPredicate.InteriorBoundary])\n        {\n            m_matrix[MatrixPredicate.InteriorBoundary] = -1; // Always false\n            m_perform_predicates[MatrixPredicate.InteriorBoundary] = false;\n            m_predicate_count--;\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryBoundary])\n        {\n            m_matrix[MatrixPredicate.BoundaryBoundary] = -1; // Always false\n            m_perform_predicates[MatrixPredicate.BoundaryBoundary] = false;\n            m_predicate_count--;\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorBoundary])\n        {\n            m_matrix[MatrixPredicate.ExteriorBoundary] = -1; // Always false\n            m_perform_predicates[MatrixPredicate.ExteriorBoundary] = false;\n            m_predicate_count--;\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "language": "java", "code": "private void setAreaPointPredicates_() {\n        m_predicates_cluster = Predicates.AreaPointPredicates;\n\n        m_max_dim[MatrixPredicate.InteriorInterior] = 0;\n        m_max_dim[MatrixPredicate.InteriorBoundary] = -1;\n        m_max_dim[MatrixPredicate.InteriorExterior] = 2;\n        m_max_dim[MatrixPredicate.BoundaryInterior] = 0;\n        m_max_dim[MatrixPredicate.BoundaryBoundary] = -1;\n        m_max_dim[MatrixPredicate.BoundaryExterior] = 1;\n        m_max_dim[MatrixPredicate.ExteriorInterior] = 0;\n        m_max_dim[MatrixPredicate.ExteriorBoundary] = -1;\n        m_max_dim[MatrixPredicate.ExteriorExterior] = 2;\n\n        // set predicates that are always true/false\n        if (m_perform_predicates[MatrixPredicate.InteriorBoundary])\n        {\n            m_matrix[MatrixPredicate.InteriorBoundary] = -1; // Always false\n            m_perform_predicates[MatrixPredicate.InteriorBoundary] = false;\n            m_predicate_count--;\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryBoundary])\n        {\n            m_matrix[MatrixPredicate.BoundaryBoundary] = -1; // Always false\n            m_perform_predicates[MatrixPredicate.BoundaryBoundary] = false;\n            m_predicate_count--;\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorBoundary])\n        {\n            m_matrix[MatrixPredicate.ExteriorBoundary] = -1; // Always false\n            m_perform_predicates[MatrixPredicate.ExteriorBoundary] = false;\n            m_predicate_count--;\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorExterior])\n        {\n            m_matrix[MatrixPredicate.ExteriorExterior] = 2; // Always true\n            m_perform_predicates[MatrixPredicate.ExteriorExterior] = false;\n            m_predicate_count--;\n        }\n\t}", "code_tokens": ["private", "void", "setAreaPointPredicates_", "(", ")", "{", "m_predicates_cluster", "=", "Predicates", ".", "AreaPointPredicates", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "-", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "InteriorExterior", "]", "=", "2", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "-", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "0", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "-", "1", ";", "m_max_dim", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// set predicates that are always true/false", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "-", "1", ";", "// Always false", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "-", "1", ";", "// Always false", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "-", "1", ";", "// Always false", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "2", ";", "// Always true", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorExterior", "]", "=", "false", ";", "m_predicate_count", "--", ";", "}", "}"], "docstring": "Sets the area-point predicate function.", "docstring_tokens": ["Sets", "the", "area", "-", "point", "predicate", "function", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1488-L1529", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.areaAreaPredicates_", "original_string": "private boolean areaAreaPredicates_(int half_edge, int id_a, int id_b) {\n\t\tboolean bRelationKnown = true;\n\n\t\tif (m_perform_predicates[MatrixPredicate.InteriorInterior]) {\n\t\t\tinteriorAreaInteriorArea_(half_edge, id_a, id_b);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.InteriorInterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.InteriorBoundary]) {\n\t\t\tinteriorAreaBoundaryArea_(half_edge, id_a,\n\t\t\t\t\tMatrixPredicate.InteriorBoundary);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.InteriorBoundary);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.InteriorExterior]) {\n\t\t\tinteriorAreaExteriorArea_(half_edge, id_a, id_b,\n\t\t\t\t\tMatrixPredicate.InteriorExterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.InteriorExterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.BoundaryInterior]) {\n\t\t\tinteriorAreaBoundaryArea_(half_edge, id_b,\n\t\t\t\t\tMatrixPredicate.BoundaryInterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.BoundaryInterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.BoundaryBoundary]) {\n\t\t\tboundaryAreaBoundaryArea_(half_edge, id_a, id_b);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.BoundaryBoundary);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.BoundaryExterior]) {\n\t\t\tboundaryAreaExteriorArea_(half_edge, id_a, id_b,\n\t\t\t\t\tMatrixPredicate.BoundaryExterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.BoundaryExterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.ExteriorInterior]) {\n\t\t\tinteriorAreaExteriorArea_(half_edge, id_b, id_a,\n\t\t\t\t\tMatrixPredicate.ExteriorInterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.ExteriorInterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.ExteriorBoundary]) {\n\t\t\tboundaryAreaExteriorArea_(half_edge, id_b, id_a,\n\t\t\t\t\tMatrixPredicate.ExteriorBoundary);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.ExteriorBoundary);\n\t\t}\n\n\t\treturn bRelationKnown;\n\t}", "language": "java", "code": "private boolean areaAreaPredicates_(int half_edge, int id_a, int id_b) {\n\t\tboolean bRelationKnown = true;\n\n\t\tif (m_perform_predicates[MatrixPredicate.InteriorInterior]) {\n\t\t\tinteriorAreaInteriorArea_(half_edge, id_a, id_b);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.InteriorInterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.InteriorBoundary]) {\n\t\t\tinteriorAreaBoundaryArea_(half_edge, id_a,\n\t\t\t\t\tMatrixPredicate.InteriorBoundary);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.InteriorBoundary);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.InteriorExterior]) {\n\t\t\tinteriorAreaExteriorArea_(half_edge, id_a, id_b,\n\t\t\t\t\tMatrixPredicate.InteriorExterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.InteriorExterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.BoundaryInterior]) {\n\t\t\tinteriorAreaBoundaryArea_(half_edge, id_b,\n\t\t\t\t\tMatrixPredicate.BoundaryInterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.BoundaryInterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.BoundaryBoundary]) {\n\t\t\tboundaryAreaBoundaryArea_(half_edge, id_a, id_b);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.BoundaryBoundary);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.BoundaryExterior]) {\n\t\t\tboundaryAreaExteriorArea_(half_edge, id_a, id_b,\n\t\t\t\t\tMatrixPredicate.BoundaryExterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.BoundaryExterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.ExteriorInterior]) {\n\t\t\tinteriorAreaExteriorArea_(half_edge, id_b, id_a,\n\t\t\t\t\tMatrixPredicate.ExteriorInterior);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.ExteriorInterior);\n\t\t}\n\n\t\tif (m_perform_predicates[MatrixPredicate.ExteriorBoundary]) {\n\t\t\tboundaryAreaExteriorArea_(half_edge, id_b, id_a,\n\t\t\t\t\tMatrixPredicate.ExteriorBoundary);\n\t\t\tbRelationKnown &= isPredicateKnown_(\n\t\t\t\t\tMatrixPredicate.ExteriorBoundary);\n\t\t}\n\n\t\treturn bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "areaAreaPredicates_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorAreaInteriorArea_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", ")", "{", "interiorAreaBoundaryArea_", "(", "half_edge", ",", "id_a", ",", "MatrixPredicate", ".", "InteriorBoundary", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorBoundary", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorAreaExteriorArea_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "interiorAreaBoundaryArea_", "(", "half_edge", ",", "id_b", ",", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", ")", "{", "boundaryAreaBoundaryArea_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryBoundary", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryAreaExteriorArea_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "interiorAreaExteriorArea_", "(", "half_edge", ",", "id_b", ",", "id_a", ",", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", ")", "{", "boundaryAreaExteriorArea_", "(", "half_edge", ",", "id_b", ",", "id_a", ",", "MatrixPredicate", ".", "ExteriorBoundary", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorBoundary", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of area vs area.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "area", "vs", "area", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1634-L1692", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.areaLinePredicates_", "original_string": "private boolean areaLinePredicates_(int half_edge, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorLine_(half_edge, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorBoundary])\n        {\n            interiorAreaBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorLine_(half_edge, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryBoundary])\n        {\n            boundaryAreaBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorLine_(half_edge, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorLine_(half_edge, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorBoundary])\n        {\n            exteriorAreaBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorBoundary);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean areaLinePredicates_(int half_edge, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorLine_(half_edge, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorBoundary])\n        {\n            interiorAreaBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorLine_(half_edge, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryBoundary])\n        {\n            boundaryAreaBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorLine_(half_edge, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorLine_(half_edge, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorBoundary])\n        {\n            exteriorAreaBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorBoundary);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "areaLinePredicates_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorAreaInteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", ")", "{", "interiorAreaBoundaryLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorBoundary", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorAreaExteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "boundaryAreaInteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", ")", "{", "boundaryAreaBoundaryLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryBoundary", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryAreaExteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "exteriorAreaInteriorLine_", "(", "half_edge", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", ")", "{", "exteriorAreaBoundaryLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorBoundary", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of area vs Line.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "area", "vs", "Line", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1871-L1923", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.lineLinePredicates_", "original_string": "private boolean lineLinePredicates_(int half_edge, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorLineInteriorLine_(half_edge, id_a, id_b, m_cluster_index_a, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorBoundary])\n        {\n            interiorLineBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_a, m_cluster_index_b, MatrixPredicate.InteriorBoundary);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorLineExteriorLine_(half_edge, id_a, id_b, MatrixPredicate.InteriorExterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            interiorLineBoundaryLine_(half_edge, id_b, id_a, m_cluster_index_b, m_cluster_index_a, MatrixPredicate.BoundaryInterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryBoundary])\n        {\n            boundaryLineBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_a, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryLineExteriorLine_(half_edge, id_a, id_b, m_cluster_index_a, MatrixPredicate.BoundaryExterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            interiorLineExteriorLine_(half_edge, id_b, id_a, MatrixPredicate.ExteriorInterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorBoundary])\n        {\n            boundaryLineExteriorLine_(half_edge, id_b, id_a, m_cluster_index_b, MatrixPredicate.ExteriorBoundary);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorBoundary);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean lineLinePredicates_(int half_edge, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorLineInteriorLine_(half_edge, id_a, id_b, m_cluster_index_a, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorBoundary])\n        {\n            interiorLineBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_a, m_cluster_index_b, MatrixPredicate.InteriorBoundary);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorLineExteriorLine_(half_edge, id_a, id_b, MatrixPredicate.InteriorExterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            interiorLineBoundaryLine_(half_edge, id_b, id_a, m_cluster_index_b, m_cluster_index_a, MatrixPredicate.BoundaryInterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryBoundary])\n        {\n            boundaryLineBoundaryLine_(half_edge, id_a, id_b, m_cluster_index_a, m_cluster_index_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryBoundary);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryLineExteriorLine_(half_edge, id_a, id_b, m_cluster_index_a, MatrixPredicate.BoundaryExterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            interiorLineExteriorLine_(half_edge, id_b, id_a, MatrixPredicate.ExteriorInterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorBoundary])\n        {\n            boundaryLineExteriorLine_(half_edge, id_b, id_a, m_cluster_index_b, MatrixPredicate.ExteriorBoundary);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorBoundary);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "lineLinePredicates_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorLineInteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ",", "m_cluster_index_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", ")", "{", "interiorLineBoundaryLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ",", "m_cluster_index_b", ",", "MatrixPredicate", ".", "InteriorBoundary", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorBoundary", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorLineExteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "interiorLineBoundaryLine_", "(", "half_edge", ",", "id_b", ",", "id_a", ",", "m_cluster_index_b", ",", "m_cluster_index_a", ",", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", ")", "{", "boundaryLineBoundaryLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ",", "m_cluster_index_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryBoundary", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryLineExteriorLine_", "(", "half_edge", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ",", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "interiorLineExteriorLine_", "(", "half_edge", ",", "id_b", ",", "id_a", ",", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", ")", "{", "boundaryLineExteriorLine_", "(", "half_edge", ",", "id_b", ",", "id_a", ",", "m_cluster_index_b", ",", "MatrixPredicate", ".", "ExteriorBoundary", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorBoundary", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of Line vs Line.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "Line", "vs", "Line", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1926-L1978", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.areaPointPredicates_", "original_string": "private boolean areaPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean areaPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "areaPointPredicates_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorAreaInteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorAreaExteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "boundaryAreaInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryAreaExteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "exteriorAreaInteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of area vs Point.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "area", "vs", "Point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1981-L2015", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.linePointPredicates_", "original_string": "private boolean linePointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorLineInteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorLineExteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryLineInteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryLineExteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorLineInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean linePointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorLineInteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorLineExteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryLineInteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryLineExteriorPoint_(cluster, id_a, id_b, m_cluster_index_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorLineInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "linePointPredicates_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorLineInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorLineExteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "boundaryLineInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryLineExteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ",", "m_cluster_index_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "exteriorLineInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of Line vs Point.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "Line", "vs", "Point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2018-L2052", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.pointPointPredicates_", "original_string": "private boolean pointPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorPointInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorPointExteriorPoint_(cluster, id_a, id_b, MatrixPredicate.InteriorExterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            interiorPointExteriorPoint_(cluster, id_b, id_a, MatrixPredicate.ExteriorInterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean pointPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorPointInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorPointExteriorPoint_(cluster, id_a, id_b, MatrixPredicate.InteriorExterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            interiorPointExteriorPoint_(cluster, id_b, id_a, MatrixPredicate.ExteriorInterior);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "pointPointPredicates_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorPointInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorPointExteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ",", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "interiorPointExteriorPoint_", "(", "cluster", ",", "id_b", ",", "id_a", ",", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of Point vs Point.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "Point", "vs", "Point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2055-L2077", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorAreaInteriorArea_", "original_string": "private void interiorAreaInteriorArea_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 2)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\n\t\tif ((faceParentage & id_a) != 0 && (faceParentage & id_b) != 0)\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 2;\n\t}", "language": "java", "code": "private void interiorAreaInteriorArea_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 2)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\n\t\tif ((faceParentage & id_a) != 0 && (faceParentage & id_b) != 0)\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 2;\n\t}", "code_tokens": ["private", "void", "interiorAreaInteriorArea_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "==", "2", ")", "return", ";", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "faceParentage", "&", "id_b", ")", "!=", "0", ")", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "2", ";", "}"], "docstring": "with the interior of area B.", "docstring_tokens": ["with", "the", "interior", "of", "area", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2081-L2089", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorAreaBoundaryArea_", "original_string": "private void interiorAreaBoundaryArea_(int half_edge, int id_a,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_a) != 0 && (twinFaceParentage & id_a) != 0)\n\t\t\tm_matrix[predicate] = 1;\n\t}", "language": "java", "code": "private void interiorAreaBoundaryArea_(int half_edge, int id_a,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_a) != 0 && (twinFaceParentage & id_a) != 0)\n\t\t\tm_matrix[predicate] = 1;\n\t}", "code_tokens": ["private", "void", "interiorAreaBoundaryArea_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "1", ")", "return", ";", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "int", "twinFaceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "twinFaceParentage", "&", "id_a", ")", "!=", "0", ")", "m_matrix", "[", "predicate", "]", "=", "1", ";", "}"], "docstring": "with the boundary of area B.", "docstring_tokens": ["with", "the", "boundary", "of", "area", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2093-L2105", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorAreaExteriorArea_", "original_string": "private void interiorAreaExteriorArea_(int half_edge, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 2)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\n\t\tif ((faceParentage & id_a) != 0 && (faceParentage & id_b) == 0)\n\t\t\tm_matrix[predicate] = 2;\n\n\t}", "language": "java", "code": "private void interiorAreaExteriorArea_(int half_edge, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 2)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\n\t\tif ((faceParentage & id_a) != 0 && (faceParentage & id_b) == 0)\n\t\t\tm_matrix[predicate] = 2;\n\n\t}", "code_tokens": ["private", "void", "interiorAreaExteriorArea_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "2", ")", "return", ";", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "faceParentage", "&", "id_b", ")", "==", "0", ")", "m_matrix", "[", "predicate", "]", "=", "2", ";", "}"], "docstring": "with the exterior of area B.", "docstring_tokens": ["with", "the", "exterior", "of", "area", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2109-L2119", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryAreaBoundaryArea_", "original_string": "private void boundaryAreaBoundaryArea_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] != 0) {\n\t\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\t\tm_visited_index) != 1) {\n\t\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\t\tint clusterParentage = m_topo_graph\n\t\t\t\t\t\t.getClusterParentage(cluster);\n\n\t\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryAreaBoundaryArea_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] != 0) {\n\t\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\t\tm_visited_index) != 1) {\n\t\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\t\tint clusterParentage = m_topo_graph\n\t\t\t\t\t\t.getClusterParentage(cluster);\n\n\t\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryAreaBoundaryArea_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "==", "1", ")", "return", ";", "int", "parentage", "=", "m_topo_graph", ".", "getHalfEdgeParentage", "(", "half_edge", ")", ";", "if", "(", "(", "parentage", "&", "id_a", ")", "!=", "0", "&&", "(", "parentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "1", ";", "return", ";", "}", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "!=", "0", ")", "{", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "0", ";", "}", "}", "}", "}"], "docstring": "with the boundary of area B.", "docstring_tokens": ["with", "the", "boundary", "of", "area", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2123-L2148", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryAreaExteriorArea_", "original_string": "private void boundaryAreaExteriorArea_(int half_edge, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_b) == 0 && (twinFaceParentage & id_b) == 0)\n\t\t\tm_matrix[predicate] = 1;\n\t}", "language": "java", "code": "private void boundaryAreaExteriorArea_(int half_edge, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_b) == 0 && (twinFaceParentage & id_b) == 0)\n\t\t\tm_matrix[predicate] = 1;\n\t}", "code_tokens": ["private", "void", "boundaryAreaExteriorArea_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "1", ")", "return", ";", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "int", "twinFaceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "if", "(", "(", "faceParentage", "&", "id_b", ")", "==", "0", "&&", "(", "twinFaceParentage", "&", "id_b", ")", "==", "0", ")", "m_matrix", "[", "predicate", "]", "=", "1", ";", "}"], "docstring": "with the exterior of area B.", "docstring_tokens": ["with", "the", "exterior", "of", "area", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2152-L2164", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorAreaInteriorLine_", "original_string": "private void interiorAreaInteriorLine_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_a) != 0 && (twinFaceParentage & id_a) != 0)\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 1;\n\t}", "language": "java", "code": "private void interiorAreaInteriorLine_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_a) != 0 && (twinFaceParentage & id_a) != 0)\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 1;\n\t}", "code_tokens": ["private", "void", "interiorAreaInteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "==", "1", ")", "return", ";", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "int", "twinFaceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "twinFaceParentage", "&", "id_a", ")", "!=", "0", ")", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "1", ";", "}"], "docstring": "with the interior of Line B.", "docstring_tokens": ["with", "the", "interior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2168-L2179", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorAreaBoundaryLine_", "original_string": "private void interiorAreaBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\t\tint faceParentage = m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeFaceParentage(half_edge);\n\n\t\t\t\tif ((faceParentage & id_a) != 0) {\n\t\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 != 0)) {\n\t\t\t\t\t\tassert (index != -1);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.InteriorBoundary] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void interiorAreaBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\t\tint faceParentage = m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeFaceParentage(half_edge);\n\n\t\t\t\tif ((faceParentage & id_a) != 0) {\n\t\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 != 0)) {\n\t\t\t\t\t\tassert (index != -1);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.InteriorBoundary] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorAreaBoundaryLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "==", "0", ")", "return", ";", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "==", "0", ")", "{", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "!=", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", "&&", "(", "index", "%", "2", "!=", "0", ")", ")", "{", "assert", "(", "index", "!=", "-", "1", ")", ";", "m_matrix", "[", "MatrixPredicate", ".", "InteriorBoundary", "]", "=", "0", ";", "}", "}", "}", "}", "}"], "docstring": "with the boundary of Line B.", "docstring_tokens": ["with", "the", "boundary", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2183-L2209", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryAreaInteriorLine_", "original_string": "private void boundaryAreaInteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] != 0) {\n\t\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\t\tm_visited_index) != 1) {\n\t\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\t\tint clusterParentage = m_topo_graph\n\t\t\t\t\t\t.getClusterParentage(cluster);\n\n\t\t\t\tif ((clusterParentage & id_a) != 0) {\n\t\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 == 0)) {\n\t\t\t\t\t\tassert (index != -1);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryAreaInteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] != 0) {\n\t\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\t\tm_visited_index) != 1) {\n\t\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\t\tint clusterParentage = m_topo_graph\n\t\t\t\t\t\t.getClusterParentage(cluster);\n\n\t\t\t\tif ((clusterParentage & id_a) != 0) {\n\t\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 == 0)) {\n\t\t\t\t\t\tassert (index != -1);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryAreaInteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "==", "1", ")", "return", ";", "int", "parentage", "=", "m_topo_graph", ".", "getHalfEdgeParentage", "(", "half_edge", ")", ";", "if", "(", "(", "parentage", "&", "id_a", ")", "!=", "0", "&&", "(", "parentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "1", ";", "return", ";", "}", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "!=", "0", ")", "{", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", "&&", "(", "index", "%", "2", "==", "0", ")", ")", "{", "assert", "(", "index", "!=", "-", "1", ")", ";", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "0", ";", "}", "}", "}", "}", "}"], "docstring": "with the interior of Line B.", "docstring_tokens": ["with", "the", "interior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2226-L2257", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryAreaBoundaryLine_", "original_string": "private void boundaryAreaBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) != 0) {\n\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 != 0)) {\n\t\t\t\t\tassert (index != -1);\n\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryAreaBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) != 0) {\n\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 != 0)) {\n\t\t\t\t\tassert (index != -1);\n\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryAreaBoundaryLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "==", "0", ")", "return", ";", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", "&&", "(", "index", "%", "2", "!=", "0", ")", ")", "{", "assert", "(", "index", "!=", "-", "1", ")", ";", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "0", ";", "}", "}", "}", "}"], "docstring": "with the boundary of Line B.", "docstring_tokens": ["with", "the", "boundary", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2261-L2282", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryAreaExteriorLine_", "original_string": "private void boundaryAreaExteriorLine_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryExterior] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) == 0)\n\t\t\tm_matrix[MatrixPredicate.BoundaryExterior] = 1;\n\n\t}", "language": "java", "code": "private void boundaryAreaExteriorLine_(int half_edge, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryExterior] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) == 0)\n\t\t\tm_matrix[MatrixPredicate.BoundaryExterior] = 1;\n\n\t}", "code_tokens": ["private", "void", "boundaryAreaExteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "==", "1", ")", "return", ";", "int", "parentage", "=", "m_topo_graph", ".", "getHalfEdgeParentage", "(", "half_edge", ")", ";", "if", "(", "(", "parentage", "&", "id_a", ")", "!=", "0", "&&", "(", "parentage", "&", "id_b", ")", "==", "0", ")", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "1", ";", "}"], "docstring": "with the exterior of Line B.", "docstring_tokens": ["with", "the", "exterior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2286-L2295", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.exteriorAreaInteriorLine_", "original_string": "private void exteriorAreaInteriorLine_(int half_edge, int id_a) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorInterior] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_a) == 0 && (twinFaceParentage & id_a) == 0)\n\t\t\tm_matrix[MatrixPredicate.ExteriorInterior] = 1;\n\t}", "language": "java", "code": "private void exteriorAreaInteriorLine_(int half_edge, int id_a) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorInterior] == 1)\n\t\t\treturn;\n\n\t\tint faceParentage = m_topo_graph.getHalfEdgeFaceParentage(half_edge);\n\t\tint twinFaceParentage = m_topo_graph\n\t\t\t\t.getHalfEdgeFaceParentage(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\n\t\tif ((faceParentage & id_a) == 0 && (twinFaceParentage & id_a) == 0)\n\t\t\tm_matrix[MatrixPredicate.ExteriorInterior] = 1;\n\t}", "code_tokens": ["private", "void", "exteriorAreaInteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "==", "1", ")", "return", ";", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "int", "twinFaceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "==", "0", "&&", "(", "twinFaceParentage", "&", "id_a", ")", "==", "0", ")", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "1", ";", "}"], "docstring": "with the interior of Line B.", "docstring_tokens": ["with", "the", "interior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2299-L2310", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.exteriorAreaBoundaryLine_", "original_string": "private void exteriorAreaBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\t\tint faceParentage = m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeFaceParentage(half_edge);\n\n\t\t\t\tif ((faceParentage & id_a) == 0) {\n\t\t\t\t\tassert ((m_topo_graph.getHalfEdgeParentage(m_topo_graph\n\t\t\t\t\t\t\t.getHalfEdgeTwin(half_edge)) & id_a) == 0);\n\n\t\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 != 0)) {\n\t\t\t\t\t\tassert (index != -1);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.ExteriorBoundary] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void exteriorAreaBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\t\tint faceParentage = m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeFaceParentage(half_edge);\n\n\t\t\t\tif ((faceParentage & id_a) == 0) {\n\t\t\t\t\tassert ((m_topo_graph.getHalfEdgeParentage(m_topo_graph\n\t\t\t\t\t\t\t.getHalfEdgeTwin(half_edge)) & id_a) == 0);\n\n\t\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\n\t\t\t\t\tif ((clusterParentage & id_b) != 0 && (index % 2 != 0)) {\n\t\t\t\t\t\tassert (index != -1);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.ExteriorBoundary] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "exteriorAreaBoundaryLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "==", "0", ")", "return", ";", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "==", "0", ")", "{", "int", "faceParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "if", "(", "(", "faceParentage", "&", "id_a", ")", "==", "0", ")", "{", "assert", "(", "(", "m_topo_graph", ".", "getHalfEdgeParentage", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", "&", "id_a", ")", "==", "0", ")", ";", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", "&&", "(", "index", "%", "2", "!=", "0", ")", ")", "{", "assert", "(", "index", "!=", "-", "1", ")", ";", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorBoundary", "]", "=", "0", ";", "}", "}", "}", "}", "}"], "docstring": "with the boundary of Line B.", "docstring_tokens": ["with", "the", "boundary", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2314-L2343", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorLineInteriorLine_", "original_string": "private void interiorLineInteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] != 0) {\n\t\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\t\tm_visited_index) != 1) {\n\t\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\t\tint clusterParentage = m_topo_graph\n\t\t\t\t\t\t.getClusterParentage(cluster);\n\n\t\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\t\tint index_a = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_a);\n\t\t\t\t\tint index_b = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\t\t\t\t\tassert (index_a != -1);\n\t\t\t\t\tassert (index_b != -1);\n\n\t\t\t\t\tif ((index_a % 2 == 0) && (index_b % 2 == 0)) {\n\t\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0 && (m_topo_graph\n\t\t\t\t\t\t\t\t.getClusterParentage(cluster) & id_b) != 0);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void interiorLineInteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] != 0) {\n\t\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\t\tm_visited_index) != 1) {\n\t\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\t\tint clusterParentage = m_topo_graph\n\t\t\t\t\t\t.getClusterParentage(cluster);\n\n\t\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\t\tint index_a = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_a);\n\t\t\t\t\tint index_b = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\t\tcluster_index_b);\n\t\t\t\t\tassert (index_a != -1);\n\t\t\t\t\tassert (index_b != -1);\n\n\t\t\t\t\tif ((index_a % 2 == 0) && (index_b % 2 == 0)) {\n\t\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0 && (m_topo_graph\n\t\t\t\t\t\t\t\t.getClusterParentage(cluster) & id_b) != 0);\n\t\t\t\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorLineInteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ",", "int", "cluster_index_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "==", "1", ")", "return", ";", "int", "parentage", "=", "m_topo_graph", ".", "getHalfEdgeParentage", "(", "half_edge", ")", ";", "if", "(", "(", "parentage", "&", "id_a", ")", "!=", "0", "&&", "(", "parentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "1", ";", "return", ";", "}", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "!=", "0", ")", "{", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "int", "index_a", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "int", "index_b", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "assert", "(", "index_a", "!=", "-", "1", ")", ";", "assert", "(", "index_b", "!=", "-", "1", ")", ";", "if", "(", "(", "index_a", "%", "2", "==", "0", ")", "&&", "(", "index_b", "%", "2", "==", "0", ")", ")", "{", "assert", "(", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_a", ")", "!=", "0", "&&", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_b", ")", "!=", "0", ")", ";", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "}", "}", "}", "}", "}"], "docstring": "with the interior of Line B.", "docstring_tokens": ["with", "the", "interior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2347-L2384", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorLineBoundaryLine_", "original_string": "private void interiorLineBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int cluster_index_b, int predicate) {\n\t\tif (m_matrix[predicate] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\tint index_a = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_a);\n\t\t\t\tint index_b = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_b);\n\t\t\t\tassert (index_a != -1);\n\t\t\t\tassert (index_b != -1);\n\n\t\t\t\tif ((index_a % 2 == 0) && (index_b % 2 != 0)) {\n\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0 && (m_topo_graph\n\t\t\t\t\t\t\t.getClusterParentage(cluster) & id_b) != 0);\n\t\t\t\t\tm_matrix[predicate] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void interiorLineBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int cluster_index_b, int predicate) {\n\t\tif (m_matrix[predicate] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\tint index_a = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_a);\n\t\t\t\tint index_b = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_b);\n\t\t\t\tassert (index_a != -1);\n\t\t\t\tassert (index_b != -1);\n\n\t\t\t\tif ((index_a % 2 == 0) && (index_b % 2 != 0)) {\n\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0 && (m_topo_graph\n\t\t\t\t\t\t\t.getClusterParentage(cluster) & id_b) != 0);\n\t\t\t\t\tm_matrix[predicate] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorLineBoundaryLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ",", "int", "cluster_index_b", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "0", ")", "return", ";", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "int", "index_a", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "int", "index_b", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "assert", "(", "index_a", "!=", "-", "1", ")", ";", "assert", "(", "index_b", "!=", "-", "1", ")", ";", "if", "(", "(", "index_a", "%", "2", "==", "0", ")", "&&", "(", "index_b", "%", "2", "!=", "0", ")", ")", "{", "assert", "(", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_a", ")", "!=", "0", "&&", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_b", ")", "!=", "0", ")", ";", "m_matrix", "[", "predicate", "]", "=", "0", ";", "}", "}", "}", "}"], "docstring": "with the boundary of Line B.", "docstring_tokens": ["with", "the", "boundary", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2388-L2415", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorLineExteriorLine_", "original_string": "private void interiorLineExteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) == 0)\n\t\t\tm_matrix[predicate] = 1;\n\t}", "language": "java", "code": "private void interiorLineExteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 1)\n\t\t\treturn;\n\n\t\tint parentage = m_topo_graph.getHalfEdgeParentage(half_edge);\n\n\t\tif ((parentage & id_a) != 0 && (parentage & id_b) == 0)\n\t\t\tm_matrix[predicate] = 1;\n\t}", "code_tokens": ["private", "void", "interiorLineExteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "1", ")", "return", ";", "int", "parentage", "=", "m_topo_graph", ".", "getHalfEdgeParentage", "(", "half_edge", ")", ";", "if", "(", "(", "parentage", "&", "id_a", ")", "!=", "0", "&&", "(", "parentage", "&", "id_b", ")", "==", "0", ")", "m_matrix", "[", "predicate", "]", "=", "1", ";", "}"], "docstring": "with the exterior of Line B.", "docstring_tokens": ["with", "the", "exterior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2419-L2428", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryLineBoundaryLine_", "original_string": "private void boundaryLineBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\tint index_a = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_a);\n\t\t\t\tint index_b = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_b);\n\t\t\t\tassert (index_a != -1);\n\t\t\t\tassert (index_b != -1);\n\n\t\t\t\tif ((index_a % 2 != 0) && (index_b % 2 != 0)) {\n\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0 && (m_topo_graph\n\t\t\t\t\t\t\t.getClusterParentage(cluster) & id_b) != 0);\n\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryLineBoundaryLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int cluster_index_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryBoundary] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_a) != 0\n\t\t\t\t\t&& (clusterParentage & id_b) != 0) {\n\t\t\t\tint index_a = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_a);\n\t\t\t\tint index_b = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_b);\n\t\t\t\tassert (index_a != -1);\n\t\t\t\tassert (index_b != -1);\n\n\t\t\t\tif ((index_a % 2 != 0) && (index_b % 2 != 0)) {\n\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0 && (m_topo_graph\n\t\t\t\t\t\t\t.getClusterParentage(cluster) & id_b) != 0);\n\t\t\t\t\tm_matrix[MatrixPredicate.BoundaryBoundary] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryLineBoundaryLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ",", "int", "cluster_index_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "==", "0", ")", "return", ";", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "int", "index_a", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "int", "index_b", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_b", ")", ";", "assert", "(", "index_a", "!=", "-", "1", ")", ";", "assert", "(", "index_b", "!=", "-", "1", ")", ";", "if", "(", "(", "index_a", "%", "2", "!=", "0", ")", "&&", "(", "index_b", "%", "2", "!=", "0", ")", ")", "{", "assert", "(", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_a", ")", "!=", "0", "&&", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_b", ")", "!=", "0", ")", ";", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryBoundary", "]", "=", "0", ";", "}", "}", "}", "}"], "docstring": "with the boundary of Line B.", "docstring_tokens": ["with", "the", "boundary", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2432-L2459", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryLineExteriorLine_", "original_string": "private void boundaryLineExteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int predicate) {\n\t\tif (m_matrix[predicate] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_b) == 0) {\n\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_a);\n\t\t\t\tassert (index != -1);\n\n\t\t\t\tif (index % 2 != 0) {\n\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0);\n\t\t\t\t\tm_matrix[predicate] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryLineExteriorLine_(int half_edge, int id_a, int id_b,\n\t\t\tint cluster_index_a, int predicate) {\n\t\tif (m_matrix[predicate] == 0)\n\t\t\treturn;\n\n\t\tif (m_topo_graph.getHalfEdgeUserIndex(m_topo_graph\n\t\t\t\t.getHalfEdgePrev(m_topo_graph.getHalfEdgeTwin(half_edge)),\n\t\t\t\tm_visited_index) != 1) {\n\t\t\tint cluster = m_topo_graph.getHalfEdgeTo(half_edge);\n\t\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\t\tif ((clusterParentage & id_b) == 0) {\n\t\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\t\tcluster_index_a);\n\t\t\t\tassert (index != -1);\n\n\t\t\t\tif (index % 2 != 0) {\n\t\t\t\t\tassert ((m_topo_graph.getClusterParentage(cluster) & id_a) != 0);\n\t\t\t\t\tm_matrix[predicate] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryLineExteriorLine_", "(", "int", "half_edge", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "0", ")", "return", ";", "if", "(", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "m_topo_graph", ".", "getHalfEdgePrev", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ",", "m_visited_index", ")", "!=", "1", ")", "{", "int", "cluster", "=", "m_topo_graph", ".", "getHalfEdgeTo", "(", "half_edge", ")", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_b", ")", "==", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "assert", "(", "index", "!=", "-", "1", ")", ";", "if", "(", "index", "%", "2", "!=", "0", ")", "{", "assert", "(", "(", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", "&", "id_a", ")", "!=", "0", ")", ";", "m_matrix", "[", "predicate", "]", "=", "0", ";", "}", "}", "}", "}"], "docstring": "with the exterior of Line B.", "docstring_tokens": ["with", "the", "exterior", "of", "Line", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2463-L2485", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorAreaInteriorPoint_", "original_string": "private void interiorAreaInteriorPoint_(int cluster, int id_a) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\tint chain = m_topo_graph.getClusterChain(cluster);\n\t\t\tint chainParentage = m_topo_graph.getChainParentage(chain);\n\n\t\t\tif ((chainParentage & id_a) != 0) {\n\t\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void interiorAreaInteriorPoint_(int cluster, int id_a) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\tint chain = m_topo_graph.getClusterChain(cluster);\n\t\t\tint chainParentage = m_topo_graph.getChainParentage(chain);\n\n\t\t\tif ((chainParentage & id_a) != 0) {\n\t\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorAreaInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "==", "0", ")", "{", "int", "chain", "=", "m_topo_graph", ".", "getClusterChain", "(", "cluster", ")", ";", "int", "chainParentage", "=", "m_topo_graph", ".", "getChainParentage", "(", "chain", ")", ";", "if", "(", "(", "chainParentage", "&", "id_a", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "}", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2489-L2503", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryAreaInteriorPoint_", "original_string": "private void boundaryAreaInteriorPoint_(int cluster, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 0;\n\t\t}\n\t}", "language": "java", "code": "private void boundaryAreaInteriorPoint_(int cluster, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 0;\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryAreaInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "0", ";", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2520-L2529", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.exteriorAreaInteriorPoint_", "original_string": "private void exteriorAreaInteriorPoint_(int cluster, int id_a) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\tint chain = m_topo_graph.getClusterChain(cluster);\n\t\t\tint chainParentage = m_topo_graph.getChainParentage(chain);\n\n\t\t\tif ((chainParentage & id_a) == 0) {\n\t\t\t\tm_matrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void exteriorAreaInteriorPoint_(int cluster, int id_a) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) == 0) {\n\t\t\tint chain = m_topo_graph.getClusterChain(cluster);\n\t\t\tint chainParentage = m_topo_graph.getChainParentage(chain);\n\n\t\t\tif ((chainParentage & id_a) == 0) {\n\t\t\t\tm_matrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "exteriorAreaInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "==", "0", ")", "{", "int", "chain", "=", "m_topo_graph", ".", "getClusterChain", "(", "cluster", ")", ";", "int", "chainParentage", "=", "m_topo_graph", ".", "getChainParentage", "(", "chain", ")", ";", "if", "(", "(", "chainParentage", "&", "id_a", ")", "==", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "0", ";", "}", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2546-L2560", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorLineInteriorPoint_", "original_string": "private void interiorLineInteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint cluster_index_a) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\tcluster_index_a);\n\n\t\t\tif (index % 2 == 0) {\n\t\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void interiorLineInteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint cluster_index_a) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\tcluster_index_a);\n\n\t\t\tif (index % 2 == 0) {\n\t\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorLineInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "if", "(", "index", "%", "2", "==", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "}", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2564-L2579", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryLineInteriorPoint_", "original_string": "private void boundaryLineInteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint cluster_index_a) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\tcluster_index_a);\n\n\t\t\tif (index % 2 != 0) {\n\t\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryLineInteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint cluster_index_a) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\tcluster_index_a);\n\n\t\t\tif (index % 2 != 0) {\n\t\t\t\tm_matrix[MatrixPredicate.BoundaryInterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryLineInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "if", "(", "index", "%", "2", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", "=", "0", ";", "}", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2611-L2626", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.boundaryLineExteriorPoint_", "original_string": "private void boundaryLineExteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint cluster_index_a) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryExterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) == 0) {\n\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\tcluster_index_a);\n\n\t\t\tif (index % 2 != 0) {\n\t\t\t\tm_matrix[MatrixPredicate.BoundaryExterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void boundaryLineExteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint cluster_index_a) {\n\t\tif (m_matrix[MatrixPredicate.BoundaryExterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) == 0) {\n\t\t\tint index = m_topo_graph.getClusterUserIndex(cluster,\n\t\t\t\t\tcluster_index_a);\n\n\t\t\tif (index % 2 != 0) {\n\t\t\t\tm_matrix[MatrixPredicate.BoundaryExterior] = 0;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "boundaryLineExteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "cluster_index_a", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "==", "0", ")", "{", "int", "index", "=", "m_topo_graph", ".", "getClusterUserIndex", "(", "cluster", ",", "cluster_index_a", ")", ";", "if", "(", "index", "%", "2", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", "=", "0", ";", "}", "}", "}"], "docstring": "with the exterior of Point B.", "docstring_tokens": ["with", "the", "exterior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2630-L2645", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.exteriorLineInteriorPoint_", "original_string": "private void exteriorLineInteriorPoint_(int cluster, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) == 0 && (clusterParentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t}\n\t}", "language": "java", "code": "private void exteriorLineInteriorPoint_(int cluster, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.ExteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) == 0 && (clusterParentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.ExteriorInterior] = 0;\n\t\t}\n\t}", "code_tokens": ["private", "void", "exteriorLineInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "==", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", "=", "0", ";", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2649-L2658", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorPointInteriorPoint_", "original_string": "private void interiorPointInteriorPoint_(int cluster, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t}\n\t}", "language": "java", "code": "private void interiorPointInteriorPoint_(int cluster, int id_a, int id_b) {\n\t\tif (m_matrix[MatrixPredicate.InteriorInterior] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) != 0) {\n\t\t\tm_matrix[MatrixPredicate.InteriorInterior] = 0;\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorPointInteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "if", "(", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "!=", "0", ")", "{", "m_matrix", "[", "MatrixPredicate", ".", "InteriorInterior", "]", "=", "0", ";", "}", "}"], "docstring": "with the interior of Point B.", "docstring_tokens": ["with", "the", "interior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2662-L2671", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.interiorPointExteriorPoint_", "original_string": "private void interiorPointExteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) == 0) {\n\t\t\tm_matrix[predicate] = 0;\n\t\t}\n\t}", "language": "java", "code": "private void interiorPointExteriorPoint_(int cluster, int id_a, int id_b,\n\t\t\tint predicate) {\n\t\tif (m_matrix[predicate] == 0)\n\t\t\treturn;\n\n\t\tint clusterParentage = m_topo_graph.getClusterParentage(cluster);\n\n\t\tif ((clusterParentage & id_a) != 0 && (clusterParentage & id_b) == 0) {\n\t\t\tm_matrix[predicate] = 0;\n\t\t}\n\t}", "code_tokens": ["private", "void", "interiorPointExteriorPoint_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ",", "int", "predicate", ")", "{", "if", "(", "m_matrix", "[", "predicate", "]", "==", "0", ")", "return", ";", "int", "clusterParentage", "=", "m_topo_graph", ".", "getClusterParentage", "(", "cluster", ")", ";", "if", "(", "(", "clusterParentage", "&", "id_a", ")", "!=", "0", "&&", "(", "clusterParentage", "&", "id_b", ")", "==", "0", ")", "{", "m_matrix", "[", "predicate", "]", "=", "0", ";", "}", "}"], "docstring": "with the exterior of Point B.", "docstring_tokens": ["with", "the", "exterior", "of", "Point", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2675-L2685", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.computeMatrixTopoGraphHalfEdges_", "original_string": "private void computeMatrixTopoGraphHalfEdges_(int geometry_a, int geometry_b) {\n\t\tboolean bRelationKnown = false;\n\n\t\tint id_a = m_topo_graph.getGeometryID(geometry_a);\n\t\tint id_b = m_topo_graph.getGeometryID(geometry_b);\n\n\t\tm_visited_index = m_topo_graph.createUserIndexForHalfEdges();\n\n\t\tfor (int cluster = m_topo_graph.getFirstCluster(); cluster != -1; cluster = m_topo_graph\n\t\t\t\t.getNextCluster(cluster)) {\n\t\t\tint first_half_edge = m_topo_graph.getClusterHalfEdge(cluster);\n            if (first_half_edge == -1)\n            {\n                if (m_predicates_cluster != -1)\n                {\n                    // Treat cluster as an interior point\n                    switch (m_predicates_cluster)\n                    {\n                        case Predicates.AreaPointPredicates:\n                            bRelationKnown = areaPointPredicates_(cluster, id_a, id_b);\n                            break;\n                        case Predicates.LinePointPredicates:\n                            bRelationKnown = linePointPredicates_(cluster, id_a, id_b);\n                            break;\n                        default:\n                            throw GeometryException.GeometryInternalError();\n                    }\n                }\n\n                continue;\n            }\n\n\t\t\tint next_half_edge = first_half_edge;\n\n\t\t\tdo {\n\t\t\t\tint half_edge = next_half_edge;\n\t\t\t\tint visited = m_topo_graph.getHalfEdgeUserIndex(half_edge,\n\t\t\t\t\t\tm_visited_index);\n\n\t\t\t\tif (visited != 1) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// Invoke relational predicates\n\t\t\t\t\t\tswitch (m_predicates_half_edge) {\n\t\t\t\t\t\tcase Predicates.AreaAreaPredicates:\n\t\t\t\t\t\t\tbRelationKnown = areaAreaPredicates_(half_edge,\n\t\t\t\t\t\t\t\t\tid_a, id_b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Predicates.AreaLinePredicates:\n\t\t\t\t\t\t\tbRelationKnown = areaLinePredicates_(half_edge,\n\t\t\t\t\t\t\t\t\tid_a, id_b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Predicates.LineLinePredicates:\n\t\t\t\t\t\t\tbRelationKnown = lineLinePredicates_(half_edge,\n\t\t\t\t\t\t\t\t\tid_a, id_b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bRelationKnown)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tm_topo_graph.setHalfEdgeUserIndex(half_edge,\n\t\t\t\t\t\t\t\tm_visited_index, 1);\n\t\t\t\t\t\thalf_edge = m_topo_graph.getHalfEdgeNext(half_edge);\n\t\t\t\t\t} while (half_edge != next_half_edge && !bRelationKnown);\n\t\t\t\t}\n\n\t\t\t\tif (bRelationKnown)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnext_half_edge = m_topo_graph.getHalfEdgeNext(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\t\t\t} while (next_half_edge != first_half_edge);\n\n\t\t\tif (bRelationKnown)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bRelationKnown)\n\t\t\tsetRemainingPredicatesToFalse_();\n\n\t\tm_topo_graph.deleteUserIndexForHalfEdges(m_visited_index);\n\t}", "language": "java", "code": "private void computeMatrixTopoGraphHalfEdges_(int geometry_a, int geometry_b) {\n\t\tboolean bRelationKnown = false;\n\n\t\tint id_a = m_topo_graph.getGeometryID(geometry_a);\n\t\tint id_b = m_topo_graph.getGeometryID(geometry_b);\n\n\t\tm_visited_index = m_topo_graph.createUserIndexForHalfEdges();\n\n\t\tfor (int cluster = m_topo_graph.getFirstCluster(); cluster != -1; cluster = m_topo_graph\n\t\t\t\t.getNextCluster(cluster)) {\n\t\t\tint first_half_edge = m_topo_graph.getClusterHalfEdge(cluster);\n            if (first_half_edge == -1)\n            {\n                if (m_predicates_cluster != -1)\n                {\n                    // Treat cluster as an interior point\n                    switch (m_predicates_cluster)\n                    {\n                        case Predicates.AreaPointPredicates:\n                            bRelationKnown = areaPointPredicates_(cluster, id_a, id_b);\n                            break;\n                        case Predicates.LinePointPredicates:\n                            bRelationKnown = linePointPredicates_(cluster, id_a, id_b);\n                            break;\n                        default:\n                            throw GeometryException.GeometryInternalError();\n                    }\n                }\n\n                continue;\n            }\n\n\t\t\tint next_half_edge = first_half_edge;\n\n\t\t\tdo {\n\t\t\t\tint half_edge = next_half_edge;\n\t\t\t\tint visited = m_topo_graph.getHalfEdgeUserIndex(half_edge,\n\t\t\t\t\t\tm_visited_index);\n\n\t\t\t\tif (visited != 1) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// Invoke relational predicates\n\t\t\t\t\t\tswitch (m_predicates_half_edge) {\n\t\t\t\t\t\tcase Predicates.AreaAreaPredicates:\n\t\t\t\t\t\t\tbRelationKnown = areaAreaPredicates_(half_edge,\n\t\t\t\t\t\t\t\t\tid_a, id_b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Predicates.AreaLinePredicates:\n\t\t\t\t\t\t\tbRelationKnown = areaLinePredicates_(half_edge,\n\t\t\t\t\t\t\t\t\tid_a, id_b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Predicates.LineLinePredicates:\n\t\t\t\t\t\t\tbRelationKnown = lineLinePredicates_(half_edge,\n\t\t\t\t\t\t\t\t\tid_a, id_b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bRelationKnown)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tm_topo_graph.setHalfEdgeUserIndex(half_edge,\n\t\t\t\t\t\t\t\tm_visited_index, 1);\n\t\t\t\t\t\thalf_edge = m_topo_graph.getHalfEdgeNext(half_edge);\n\t\t\t\t\t} while (half_edge != next_half_edge && !bRelationKnown);\n\t\t\t\t}\n\n\t\t\t\tif (bRelationKnown)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnext_half_edge = m_topo_graph.getHalfEdgeNext(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\t\t\t} while (next_half_edge != first_half_edge);\n\n\t\t\tif (bRelationKnown)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bRelationKnown)\n\t\t\tsetRemainingPredicatesToFalse_();\n\n\t\tm_topo_graph.deleteUserIndexForHalfEdges(m_visited_index);\n\t}", "code_tokens": ["private", "void", "computeMatrixTopoGraphHalfEdges_", "(", "int", "geometry_a", ",", "int", "geometry_b", ")", "{", "boolean", "bRelationKnown", "=", "false", ";", "int", "id_a", "=", "m_topo_graph", ".", "getGeometryID", "(", "geometry_a", ")", ";", "int", "id_b", "=", "m_topo_graph", ".", "getGeometryID", "(", "geometry_b", ")", ";", "m_visited_index", "=", "m_topo_graph", ".", "createUserIndexForHalfEdges", "(", ")", ";", "for", "(", "int", "cluster", "=", "m_topo_graph", ".", "getFirstCluster", "(", ")", ";", "cluster", "!=", "-", "1", ";", "cluster", "=", "m_topo_graph", ".", "getNextCluster", "(", "cluster", ")", ")", "{", "int", "first_half_edge", "=", "m_topo_graph", ".", "getClusterHalfEdge", "(", "cluster", ")", ";", "if", "(", "first_half_edge", "==", "-", "1", ")", "{", "if", "(", "m_predicates_cluster", "!=", "-", "1", ")", "{", "// Treat cluster as an interior point", "switch", "(", "m_predicates_cluster", ")", "{", "case", "Predicates", ".", "AreaPointPredicates", ":", "bRelationKnown", "=", "areaPointPredicates_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "case", "Predicates", ".", "LinePointPredicates", ":", "bRelationKnown", "=", "linePointPredicates_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "default", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "}", "continue", ";", "}", "int", "next_half_edge", "=", "first_half_edge", ";", "do", "{", "int", "half_edge", "=", "next_half_edge", ";", "int", "visited", "=", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "half_edge", ",", "m_visited_index", ")", ";", "if", "(", "visited", "!=", "1", ")", "{", "do", "{", "// Invoke relational predicates", "switch", "(", "m_predicates_half_edge", ")", "{", "case", "Predicates", ".", "AreaAreaPredicates", ":", "bRelationKnown", "=", "areaAreaPredicates_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "case", "Predicates", ".", "AreaLinePredicates", ":", "bRelationKnown", "=", "areaLinePredicates_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "case", "Predicates", ".", "LineLinePredicates", ":", "bRelationKnown", "=", "lineLinePredicates_", "(", "half_edge", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "default", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "if", "(", "bRelationKnown", ")", "break", ";", "m_topo_graph", ".", "setHalfEdgeUserIndex", "(", "half_edge", ",", "m_visited_index", ",", "1", ")", ";", "half_edge", "=", "m_topo_graph", ".", "getHalfEdgeNext", "(", "half_edge", ")", ";", "}", "while", "(", "half_edge", "!=", "next_half_edge", "&&", "!", "bRelationKnown", ")", ";", "}", "if", "(", "bRelationKnown", ")", "break", ";", "next_half_edge", "=", "m_topo_graph", ".", "getHalfEdgeNext", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "}", "while", "(", "next_half_edge", "!=", "first_half_edge", ")", ";", "if", "(", "bRelationKnown", ")", "break", ";", "}", "if", "(", "!", "bRelationKnown", ")", "setRemainingPredicatesToFalse_", "(", ")", ";", "m_topo_graph", ".", "deleteUserIndexForHalfEdges", "(", "m_visited_index", ")", ";", "}"], "docstring": "area/Line, and Line/Line relations", "docstring_tokens": ["area", "/", "Line", "and", "Line", "/", "Line", "relations"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2690-L2773", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.computeMatrixTopoGraphClusters_", "original_string": "private void computeMatrixTopoGraphClusters_(int geometry_a, int geometry_b) {\n\t\tboolean bRelationKnown = false;\n\n\t\tint id_a = m_topo_graph.getGeometryID(geometry_a);\n\t\tint id_b = m_topo_graph.getGeometryID(geometry_b);\n\n\t\tfor (int cluster = m_topo_graph.getFirstCluster(); cluster != -1; cluster = m_topo_graph\n\t\t\t\t.getNextCluster(cluster)) {\n\t\t\t// Invoke relational predicates\n\t\t\tswitch (m_predicates_cluster) {\n\t\t\tcase Predicates.AreaPointPredicates:\n\t\t\t\tbRelationKnown = areaPointPredicates_(cluster, id_a, id_b);\n\t\t\t\tbreak;\n\t\t\tcase Predicates.LinePointPredicates:\n\t\t\t\tbRelationKnown = linePointPredicates_(cluster, id_a, id_b);\n\t\t\t\tbreak;\n\t\t\tcase Predicates.PointPointPredicates:\n\t\t\t\tbRelationKnown = pointPointPredicates_(cluster, id_a, id_b);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t}\n\n\t\t\tif (bRelationKnown)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bRelationKnown)\n\t\t\tsetRemainingPredicatesToFalse_();\n\t}", "language": "java", "code": "private void computeMatrixTopoGraphClusters_(int geometry_a, int geometry_b) {\n\t\tboolean bRelationKnown = false;\n\n\t\tint id_a = m_topo_graph.getGeometryID(geometry_a);\n\t\tint id_b = m_topo_graph.getGeometryID(geometry_b);\n\n\t\tfor (int cluster = m_topo_graph.getFirstCluster(); cluster != -1; cluster = m_topo_graph\n\t\t\t\t.getNextCluster(cluster)) {\n\t\t\t// Invoke relational predicates\n\t\t\tswitch (m_predicates_cluster) {\n\t\t\tcase Predicates.AreaPointPredicates:\n\t\t\t\tbRelationKnown = areaPointPredicates_(cluster, id_a, id_b);\n\t\t\t\tbreak;\n\t\t\tcase Predicates.LinePointPredicates:\n\t\t\t\tbRelationKnown = linePointPredicates_(cluster, id_a, id_b);\n\t\t\t\tbreak;\n\t\t\tcase Predicates.PointPointPredicates:\n\t\t\t\tbRelationKnown = pointPointPredicates_(cluster, id_a, id_b);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t}\n\n\t\t\tif (bRelationKnown)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bRelationKnown)\n\t\t\tsetRemainingPredicatesToFalse_();\n\t}", "code_tokens": ["private", "void", "computeMatrixTopoGraphClusters_", "(", "int", "geometry_a", ",", "int", "geometry_b", ")", "{", "boolean", "bRelationKnown", "=", "false", ";", "int", "id_a", "=", "m_topo_graph", ".", "getGeometryID", "(", "geometry_a", ")", ";", "int", "id_b", "=", "m_topo_graph", ".", "getGeometryID", "(", "geometry_b", ")", ";", "for", "(", "int", "cluster", "=", "m_topo_graph", ".", "getFirstCluster", "(", ")", ";", "cluster", "!=", "-", "1", ";", "cluster", "=", "m_topo_graph", ".", "getNextCluster", "(", "cluster", ")", ")", "{", "// Invoke relational predicates", "switch", "(", "m_predicates_cluster", ")", "{", "case", "Predicates", ".", "AreaPointPredicates", ":", "bRelationKnown", "=", "areaPointPredicates_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "case", "Predicates", ".", "LinePointPredicates", ":", "bRelationKnown", "=", "linePointPredicates_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "case", "Predicates", ".", "PointPointPredicates", ":", "bRelationKnown", "=", "pointPointPredicates_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "break", ";", "default", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "if", "(", "bRelationKnown", ")", "break", ";", "}", "if", "(", "!", "bRelationKnown", ")", "setRemainingPredicatesToFalse_", "(", ")", ";", "}"], "docstring": "Line/Point, and Point/Point relations", "docstring_tokens": ["Line", "/", "Point", "and", "Point", "/", "Point", "relations"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2778-L2807", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.convertGeometry_", "original_string": "private static Geometry convertGeometry_(Geometry geometry, double tolerance) {\n\t\tint gt = geometry.getType().value();\n\n\t\tif (Geometry.isSegment(gt)) {\n\t\t\tPolyline polyline = new Polyline(geometry.getDescription());\n\t\t\tpolyline.addSegment((Segment) geometry, true);\n\t\t\treturn polyline;\n\t\t}\n\n\t\tif (gt == Geometry.GeometryType.Envelope) {\n\t\t\tEnvelope envelope = (Envelope) (geometry);\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tgeometry.queryEnvelope2D(env);\n\n\t\t\tif (env.getHeight() <= tolerance && env.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\t\tPoint point = new Point(geometry.getDescription());\n\t\t\t\tenvelope.getCenter(point);\n\t\t\t\treturn point;\n\t\t\t}\n\n\t\t\tif (env.getHeight() <= tolerance || env.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\t\t\t\tPolyline polyline = new Polyline(geometry.getDescription());\n\t\t\t\tPoint p = new Point();\n\t\t\t\tenvelope.queryCornerByVal(0, p);\n\t\t\t\tpolyline.startPath(p);\n\t\t\t\tenvelope.queryCornerByVal(2, p);\n\t\t\t\tpolyline.lineTo(p);\n\t\t\t\treturn polyline;\n\t\t\t}\n\n\t\t\t// treat as polygon\n\t\t\tPolygon polygon = new Polygon(geometry.getDescription());\n\t\t\tpolygon.addEnvelope(envelope, false);\n\t\t\treturn polygon;\n\t\t}\n\n\t\treturn geometry;\n\t}", "language": "java", "code": "private static Geometry convertGeometry_(Geometry geometry, double tolerance) {\n\t\tint gt = geometry.getType().value();\n\n\t\tif (Geometry.isSegment(gt)) {\n\t\t\tPolyline polyline = new Polyline(geometry.getDescription());\n\t\t\tpolyline.addSegment((Segment) geometry, true);\n\t\t\treturn polyline;\n\t\t}\n\n\t\tif (gt == Geometry.GeometryType.Envelope) {\n\t\t\tEnvelope envelope = (Envelope) (geometry);\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tgeometry.queryEnvelope2D(env);\n\n\t\t\tif (env.getHeight() <= tolerance && env.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\t\tPoint point = new Point(geometry.getDescription());\n\t\t\t\tenvelope.getCenter(point);\n\t\t\t\treturn point;\n\t\t\t}\n\n\t\t\tif (env.getHeight() <= tolerance || env.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\t\t\t\tPolyline polyline = new Polyline(geometry.getDescription());\n\t\t\t\tPoint p = new Point();\n\t\t\t\tenvelope.queryCornerByVal(0, p);\n\t\t\t\tpolyline.startPath(p);\n\t\t\t\tenvelope.queryCornerByVal(2, p);\n\t\t\t\tpolyline.lineTo(p);\n\t\t\t\treturn polyline;\n\t\t\t}\n\n\t\t\t// treat as polygon\n\t\t\tPolygon polygon = new Polygon(geometry.getDescription());\n\t\t\tpolygon.addEnvelope(envelope, false);\n\t\t\treturn polygon;\n\t\t}\n\n\t\treturn geometry;\n\t}", "code_tokens": ["private", "static", "Geometry", "convertGeometry_", "(", "Geometry", "geometry", ",", "double", "tolerance", ")", "{", "int", "gt", "=", "geometry", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "if", "(", "Geometry", ".", "isSegment", "(", "gt", ")", ")", "{", "Polyline", "polyline", "=", "new", "Polyline", "(", "geometry", ".", "getDescription", "(", ")", ")", ";", "polyline", ".", "addSegment", "(", "(", "Segment", ")", "geometry", ",", "true", ")", ";", "return", "polyline", ";", "}", "if", "(", "gt", "==", "Geometry", ".", "GeometryType", ".", "Envelope", ")", "{", "Envelope", "envelope", "=", "(", "Envelope", ")", "(", "geometry", ")", ";", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "geometry", ".", "queryEnvelope2D", "(", "env", ")", ";", "if", "(", "env", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// point", "Point", "point", "=", "new", "Point", "(", "geometry", ".", "getDescription", "(", ")", ")", ";", "envelope", ".", "getCenter", "(", "point", ")", ";", "return", "point", ";", "}", "if", "(", "env", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// line", "Polyline", "polyline", "=", "new", "Polyline", "(", "geometry", ".", "getDescription", "(", ")", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline", ".", "startPath", "(", "p", ")", ";", "envelope", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline", ".", "lineTo", "(", "p", ")", ";", "return", "polyline", ";", "}", "// treat as polygon", "Polygon", "polygon", "=", "new", "Polygon", "(", "geometry", ".", "getDescription", "(", ")", ")", ";", "polygon", ".", "addEnvelope", "(", "envelope", ",", "false", ")", ";", "return", "polygon", ";", "}", "return", "geometry", ";", "}"], "docstring": "Upgrades the geometry to a feature geometry.", "docstring_tokens": ["Upgrades", "the", "geometry", "to", "a", "feature", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L2834-L2875", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2DIntersectorImpl.java", "func_name": "Envelope2DIntersectorImpl.next", "original_string": "boolean next() {\n\t\tif (m_b_done)\n\t\t\treturn false;\n\n\t\tboolean b_searching = true;\n\t\twhile (b_searching) {\n\t\t\tswitch (m_function) {\n\t\t\tcase State.initialize:\n\t\t\t\tb_searching = initialize_();\n\t\t\t\tbreak;\n\t\t\tcase State.initializeRed:\n\t\t\t\tb_searching = initializeRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.initializeBlue:\n\t\t\t\tb_searching = initializeBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.initializeRedBlue:\n\t\t\t\tb_searching = initializeRedBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweep:\n\t\t\t\tb_searching = sweep_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepBruteForce:\n\t\t\t\tb_searching = sweepBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepRedBlueBruteForce:\n\t\t\t\tb_searching = sweepRedBlueBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepRedBlue:\n\t\t\t\tb_searching = sweepRedBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepRed:\n\t\t\t\tb_searching = sweepRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepBlue:\n\t\t\t\tb_searching = sweepBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterate:\n\t\t\t\tb_searching = iterate_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateRed:\n\t\t\t\tb_searching = iterateRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateBlue:\n\t\t\t\tb_searching = iterateBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateBruteForce:\n\t\t\t\tb_searching = iterateBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateRedBlueBruteForce:\n\t\t\t\tb_searching = iterateRedBlueBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.resetRed:\n\t\t\t\tb_searching = resetRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.resetBlue:\n\t\t\t\tb_searching = resetBlue_();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t}\n\t\t}\n\n\t\tif (m_b_done)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "language": "java", "code": "boolean next() {\n\t\tif (m_b_done)\n\t\t\treturn false;\n\n\t\tboolean b_searching = true;\n\t\twhile (b_searching) {\n\t\t\tswitch (m_function) {\n\t\t\tcase State.initialize:\n\t\t\t\tb_searching = initialize_();\n\t\t\t\tbreak;\n\t\t\tcase State.initializeRed:\n\t\t\t\tb_searching = initializeRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.initializeBlue:\n\t\t\t\tb_searching = initializeBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.initializeRedBlue:\n\t\t\t\tb_searching = initializeRedBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweep:\n\t\t\t\tb_searching = sweep_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepBruteForce:\n\t\t\t\tb_searching = sweepBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepRedBlueBruteForce:\n\t\t\t\tb_searching = sweepRedBlueBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepRedBlue:\n\t\t\t\tb_searching = sweepRedBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepRed:\n\t\t\t\tb_searching = sweepRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.sweepBlue:\n\t\t\t\tb_searching = sweepBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterate:\n\t\t\t\tb_searching = iterate_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateRed:\n\t\t\t\tb_searching = iterateRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateBlue:\n\t\t\t\tb_searching = iterateBlue_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateBruteForce:\n\t\t\t\tb_searching = iterateBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.iterateRedBlueBruteForce:\n\t\t\t\tb_searching = iterateRedBlueBruteForce_();\n\t\t\t\tbreak;\n\t\t\tcase State.resetRed:\n\t\t\t\tb_searching = resetRed_();\n\t\t\t\tbreak;\n\t\t\tcase State.resetBlue:\n\t\t\t\tb_searching = resetBlue_();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t}\n\t\t}\n\n\t\tif (m_b_done)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "code_tokens": ["boolean", "next", "(", ")", "{", "if", "(", "m_b_done", ")", "return", "false", ";", "boolean", "b_searching", "=", "true", ";", "while", "(", "b_searching", ")", "{", "switch", "(", "m_function", ")", "{", "case", "State", ".", "initialize", ":", "b_searching", "=", "initialize_", "(", ")", ";", "break", ";", "case", "State", ".", "initializeRed", ":", "b_searching", "=", "initializeRed_", "(", ")", ";", "break", ";", "case", "State", ".", "initializeBlue", ":", "b_searching", "=", "initializeBlue_", "(", ")", ";", "break", ";", "case", "State", ".", "initializeRedBlue", ":", "b_searching", "=", "initializeRedBlue_", "(", ")", ";", "break", ";", "case", "State", ".", "sweep", ":", "b_searching", "=", "sweep_", "(", ")", ";", "break", ";", "case", "State", ".", "sweepBruteForce", ":", "b_searching", "=", "sweepBruteForce_", "(", ")", ";", "break", ";", "case", "State", ".", "sweepRedBlueBruteForce", ":", "b_searching", "=", "sweepRedBlueBruteForce_", "(", ")", ";", "break", ";", "case", "State", ".", "sweepRedBlue", ":", "b_searching", "=", "sweepRedBlue_", "(", ")", ";", "break", ";", "case", "State", ".", "sweepRed", ":", "b_searching", "=", "sweepRed_", "(", ")", ";", "break", ";", "case", "State", ".", "sweepBlue", ":", "b_searching", "=", "sweepBlue_", "(", ")", ";", "break", ";", "case", "State", ".", "iterate", ":", "b_searching", "=", "iterate_", "(", ")", ";", "break", ";", "case", "State", ".", "iterateRed", ":", "b_searching", "=", "iterateRed_", "(", ")", ";", "break", ";", "case", "State", ".", "iterateBlue", ":", "b_searching", "=", "iterateBlue_", "(", ")", ";", "break", ";", "case", "State", ".", "iterateBruteForce", ":", "b_searching", "=", "iterateBruteForce_", "(", ")", ";", "break", ";", "case", "State", ".", "iterateRedBlueBruteForce", ":", "b_searching", "=", "iterateRedBlueBruteForce_", "(", ")", ";", "break", ";", "case", "State", ".", "resetRed", ":", "b_searching", "=", "resetRed_", "(", ")", ";", "break", ";", "case", "State", ".", "resetBlue", ":", "b_searching", "=", "resetBlue_", "(", ")", ";", "break", ";", "default", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "}", "if", "(", "m_b_done", ")", "return", "false", ";", "return", "true", ";", "}"], "docstring": "/*\nMoves the iterator to the next intersecting pair of envelopes.Returns\ntrue if an intersecting pair is found. You can call get_handle_a() and\nget_handle_b() to get the index of each envelope in the current\nintersection. Otherwise if false is returned, then are no more\nintersections (if at all).", "docstring_tokens": ["/", "*", "Moves", "the", "iterator", "to", "the", "next", "intersecting", "pair", "of", "envelopes", ".", "Returns", "true", "if", "an", "intersecting", "pair", "is", "found", ".", "You", "can", "call", "get_handle_a", "()", "and", "get_handle_b", "()", "to", "get", "the", "index", "of", "each", "envelope", "in", "the", "current", "intersection", ".", "Otherwise", "if", "false", "is", "returned", "then", "are", "no", "more", "intersections", "(", "if", "at", "all", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2DIntersectorImpl.java#L162-L229", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeoDist.java", "func_name": "GeoDist.PE_EQ", "original_string": "static private boolean PE_EQ(double a, double b) {\n\t\treturn (a == b)\n\t\t\t\t|| PE_ABS(a - b) <= PE_EPS * (1 + (PE_ABS(a) + PE_ABS(b)) / 2);\n\t}", "language": "java", "code": "static private boolean PE_EQ(double a, double b) {\n\t\treturn (a == b)\n\t\t\t\t|| PE_ABS(a - b) <= PE_EPS * (1 + (PE_ABS(a) + PE_ABS(b)) / 2);\n\t}", "code_tokens": ["static", "private", "boolean", "PE_EQ", "(", "double", "a", ",", "double", "b", ")", "{", "return", "(", "a", "==", "b", ")", "||", "PE_ABS", "(", "a", "-", "b", ")", "<=", "PE_EPS", "*", "(", "1", "+", "(", "PE_ABS", "(", "a", ")", "+", "PE_ABS", "(", "b", ")", ")", "/", "2", ")", ";", "}"], "docstring": "Determine if two doubles are equal within a default tolerance", "docstring_tokens": ["Determine", "if", "two", "doubles", "are", "equal", "within", "a", "default", "tolerance"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeoDist.java#L46-L49", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConstructOffset.java", "func_name": "ConstructOffset.execute", "original_string": "static Geometry execute(Geometry inputGeometry, double distance,\n\t\t\tOperatorOffset.JoinType joins, double miterLimit, double tolerance,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (inputGeometry == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (inputGeometry.getDimension() < 1)// can offset Polygons and\n\t\t\t\t\t\t\t\t\t\t\t\t// Polylines only\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (distance == 0 || inputGeometry.isEmpty())\n\t\t\treturn inputGeometry;\n\t\tConstructOffset offset = new ConstructOffset(progressTracker);\n\t\toffset.m_inputGeometry = inputGeometry;\n\t\toffset.m_distance = distance;\n\t\toffset.m_tolerance = tolerance;\n\t\toffset.m_joins = joins;\n\t\toffset.m_miterLimit = miterLimit;\n\t\treturn offset._ConstructOffset();\n\t}", "language": "java", "code": "static Geometry execute(Geometry inputGeometry, double distance,\n\t\t\tOperatorOffset.JoinType joins, double miterLimit, double tolerance,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (inputGeometry == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (inputGeometry.getDimension() < 1)// can offset Polygons and\n\t\t\t\t\t\t\t\t\t\t\t\t// Polylines only\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (distance == 0 || inputGeometry.isEmpty())\n\t\t\treturn inputGeometry;\n\t\tConstructOffset offset = new ConstructOffset(progressTracker);\n\t\toffset.m_inputGeometry = inputGeometry;\n\t\toffset.m_distance = distance;\n\t\toffset.m_tolerance = tolerance;\n\t\toffset.m_joins = joins;\n\t\toffset.m_miterLimit = miterLimit;\n\t\treturn offset._ConstructOffset();\n\t}", "code_tokens": ["static", "Geometry", "execute", "(", "Geometry", "inputGeometry", ",", "double", "distance", ",", "OperatorOffset", ".", "JoinType", "joins", ",", "double", "miterLimit", ",", "double", "tolerance", ",", "ProgressTracker", "progressTracker", ")", "{", "if", "(", "inputGeometry", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "inputGeometry", ".", "getDimension", "(", ")", "<", "1", ")", "// can offset Polygons and", "// Polylines only", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "distance", "==", "0", "||", "inputGeometry", ".", "isEmpty", "(", ")", ")", "return", "inputGeometry", ";", "ConstructOffset", "offset", "=", "new", "ConstructOffset", "(", "progressTracker", ")", ";", "offset", ".", "m_inputGeometry", "=", "inputGeometry", ";", "offset", ".", "m_distance", "=", "distance", ";", "offset", ".", "m_tolerance", "=", "tolerance", ";", "offset", ".", "m_joins", "=", "joins", ";", "offset", ".", "m_miterLimit", "=", "miterLimit", ";", "return", "offset", ".", "_ConstructOffset", "(", ")", ";", "}"], "docstring": "static", "docstring_tokens": ["static"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConstructOffset.java#L115-L132", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConstructOffset.java", "func_name": "ConstructOffset.addPoint", "original_string": "void addPoint(GraphicPoint offPt, int i_src) {\n\t\tif (m_offsetPtCount == 0) // TODO: can we have this outside of this\n\t\t\t\t\t\t\t\t\t// method?\n\t\t{\n\t\t\taddPoint(offPt);\n\t\t\treturn;\n\t\t}\n\n\t\tint n_src = m_srcPtCount;\n\t\tGraphicPoint pt1, pt;\n\t\tpt1 = m_srcPts.get(i_src == 0 ? n_src - 1 : i_src - 1);\n\t\tpt = m_srcPts.get(i_src);\n\n\t\t// calculate scalar product to determine if the offset segment goes in\n\t\t// the same/opposite direction compared to the original one\n\t\tdouble s = scal(pt1, pt, m_offsetPts.get(m_offsetPtCount - 1), offPt);\n\t\tif (s > 0)\n\t\t// original segment and offset segment go in the same direction. Just\n\t\t// add the point\n\t\t{\n\t\t\taddPoint(offPt);\n\t\t\treturn;\n\t\t}\n\n\t\tif (s < 0) {\n\t\t\t// we will add a loop. We need to make sure the points we introduce\n\t\t\t// don't generate a \"reversed\" segment\n\t\t\t// let's project the first point of the reversed segment\n\t\t\t// (m_offsetPts + m_offsetPtCount - 1) to check\n\t\t\t// if it falls on the good side of the original segment (scalar\n\t\t\t// product sign again)\n\t\t\tif (scal(pt1, pt, pt, m_offsetPts.get(m_offsetPtCount - 1)) > 0) {\n\t\t\t\tGraphicPoint p;\n\n\t\t\t\t// change value of m_offsetPts + m_offsetPtCount - 1\n\t\t\t\tint k;\n\t\t\t\tif (i_src == 0)\n\t\t\t\t\tk = n_src - 2;\n\t\t\t\telse if (i_src == 1)\n\t\t\t\t\tk = n_src - 1;\n\t\t\t\telse\n\t\t\t\t\tk = i_src - 2;\n\t\t\t\tGraphicPoint pt0 = m_srcPts.get(k);\n\n\t\t\t\tdouble a = Math.atan2(pt1.y - pt0.y, pt1.x - pt0.x);\n\t\t\t\tp = new GraphicPoint(pt1, m_distance, a - half_pi);\n\t\t\t\tm_offsetPts.set(m_offsetPtCount - 1, p);\n\n\t\t\t\tif (m_joins == OperatorOffset.JoinType.Bevel\n\t\t\t\t\t\t|| m_joins == OperatorOffset.JoinType.Miter) {\n\t\t\t\t\t// this block is added as well as the commented BAD_SEG in\n\t\t\t\t\t// the next block\n\t\t\t\t\tp = new GraphicPoint(p, pt1);\n\t\t\t\t\taddPoint(p);\n\n\t\t\t\t\t// \"bad\" segment\n\t\t\t\t\tp = new GraphicPoint(pt1, m_distance, m_a1 + half_pi);\n\n\t\t\t\t\tGraphicPoint p_ = new GraphicPoint(p, pt1);\n\t\t\t\t\tp_.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p_);\n\n\t\t\t\t\taddPoint(p);\n\t\t\t\t} else {\n\t\t\t\t\t// the working stuff for round and square\n\n\t\t\t\t\t// \"bad\" segment\n\t\t\t\t\tp = new GraphicPoint(pt1, m_distance, m_a1 + half_pi);\n\t\t\t\t\tp.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p);\n\t\t\t\t}\n\n\t\t\t\t// add offPt\n\t\t\t\taddPoint(offPt, i_src);\n\t\t\t} else {\n\t\t\t\tGraphicPoint p;\n\n\t\t\t\t// we don't add offPt but the loop containing the \"bad\" segment\n\t\t\t\tp = new GraphicPoint(pt, m_distance, m_a1 + half_pi);\n\t\t\t\taddPoint(p);\n\n\t\t\t\tif (m_joins == OperatorOffset.JoinType.Bevel\n\t\t\t\t\t\t|| m_joins == OperatorOffset.JoinType.Miter) {\n\t\t\t\t\t// this block is added as well as the commented BAD_SEG in\n\t\t\t\t\t// the next block\n\t\t\t\t\tp = new GraphicPoint(p, pt);\n\t\t\t\t\taddPoint(p);\n\n\t\t\t\t\tp = new GraphicPoint(pt, m_distance, m_a2 - half_pi);\n\t\t\t\t\tGraphicPoint p_ = new GraphicPoint(p, pt);\n\t\t\t\t\tp_.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p_);\n\n\t\t\t\t\taddPoint(p);\n\t\t\t\t} else {\n\t\t\t\t\t// the working stuff for round and square\n\t\t\t\t\tp = new GraphicPoint(pt, m_distance, m_a2 - half_pi);\n\t\t\t\t\tp.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "void addPoint(GraphicPoint offPt, int i_src) {\n\t\tif (m_offsetPtCount == 0) // TODO: can we have this outside of this\n\t\t\t\t\t\t\t\t\t// method?\n\t\t{\n\t\t\taddPoint(offPt);\n\t\t\treturn;\n\t\t}\n\n\t\tint n_src = m_srcPtCount;\n\t\tGraphicPoint pt1, pt;\n\t\tpt1 = m_srcPts.get(i_src == 0 ? n_src - 1 : i_src - 1);\n\t\tpt = m_srcPts.get(i_src);\n\n\t\t// calculate scalar product to determine if the offset segment goes in\n\t\t// the same/opposite direction compared to the original one\n\t\tdouble s = scal(pt1, pt, m_offsetPts.get(m_offsetPtCount - 1), offPt);\n\t\tif (s > 0)\n\t\t// original segment and offset segment go in the same direction. Just\n\t\t// add the point\n\t\t{\n\t\t\taddPoint(offPt);\n\t\t\treturn;\n\t\t}\n\n\t\tif (s < 0) {\n\t\t\t// we will add a loop. We need to make sure the points we introduce\n\t\t\t// don't generate a \"reversed\" segment\n\t\t\t// let's project the first point of the reversed segment\n\t\t\t// (m_offsetPts + m_offsetPtCount - 1) to check\n\t\t\t// if it falls on the good side of the original segment (scalar\n\t\t\t// product sign again)\n\t\t\tif (scal(pt1, pt, pt, m_offsetPts.get(m_offsetPtCount - 1)) > 0) {\n\t\t\t\tGraphicPoint p;\n\n\t\t\t\t// change value of m_offsetPts + m_offsetPtCount - 1\n\t\t\t\tint k;\n\t\t\t\tif (i_src == 0)\n\t\t\t\t\tk = n_src - 2;\n\t\t\t\telse if (i_src == 1)\n\t\t\t\t\tk = n_src - 1;\n\t\t\t\telse\n\t\t\t\t\tk = i_src - 2;\n\t\t\t\tGraphicPoint pt0 = m_srcPts.get(k);\n\n\t\t\t\tdouble a = Math.atan2(pt1.y - pt0.y, pt1.x - pt0.x);\n\t\t\t\tp = new GraphicPoint(pt1, m_distance, a - half_pi);\n\t\t\t\tm_offsetPts.set(m_offsetPtCount - 1, p);\n\n\t\t\t\tif (m_joins == OperatorOffset.JoinType.Bevel\n\t\t\t\t\t\t|| m_joins == OperatorOffset.JoinType.Miter) {\n\t\t\t\t\t// this block is added as well as the commented BAD_SEG in\n\t\t\t\t\t// the next block\n\t\t\t\t\tp = new GraphicPoint(p, pt1);\n\t\t\t\t\taddPoint(p);\n\n\t\t\t\t\t// \"bad\" segment\n\t\t\t\t\tp = new GraphicPoint(pt1, m_distance, m_a1 + half_pi);\n\n\t\t\t\t\tGraphicPoint p_ = new GraphicPoint(p, pt1);\n\t\t\t\t\tp_.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p_);\n\n\t\t\t\t\taddPoint(p);\n\t\t\t\t} else {\n\t\t\t\t\t// the working stuff for round and square\n\n\t\t\t\t\t// \"bad\" segment\n\t\t\t\t\tp = new GraphicPoint(pt1, m_distance, m_a1 + half_pi);\n\t\t\t\t\tp.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p);\n\t\t\t\t}\n\n\t\t\t\t// add offPt\n\t\t\t\taddPoint(offPt, i_src);\n\t\t\t} else {\n\t\t\t\tGraphicPoint p;\n\n\t\t\t\t// we don't add offPt but the loop containing the \"bad\" segment\n\t\t\t\tp = new GraphicPoint(pt, m_distance, m_a1 + half_pi);\n\t\t\t\taddPoint(p);\n\n\t\t\t\tif (m_joins == OperatorOffset.JoinType.Bevel\n\t\t\t\t\t\t|| m_joins == OperatorOffset.JoinType.Miter) {\n\t\t\t\t\t// this block is added as well as the commented BAD_SEG in\n\t\t\t\t\t// the next block\n\t\t\t\t\tp = new GraphicPoint(p, pt);\n\t\t\t\t\taddPoint(p);\n\n\t\t\t\t\tp = new GraphicPoint(pt, m_distance, m_a2 - half_pi);\n\t\t\t\t\tGraphicPoint p_ = new GraphicPoint(p, pt);\n\t\t\t\t\tp_.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p_);\n\n\t\t\t\t\taddPoint(p);\n\t\t\t\t} else {\n\t\t\t\t\t// the working stuff for round and square\n\t\t\t\t\tp = new GraphicPoint(pt, m_distance, m_a2 - half_pi);\n\t\t\t\t\tp.type |= BAD_SEG;\n\t\t\t\t\taddPoint(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["void", "addPoint", "(", "GraphicPoint", "offPt", ",", "int", "i_src", ")", "{", "if", "(", "m_offsetPtCount", "==", "0", ")", "// TODO: can we have this outside of this", "// method?", "{", "addPoint", "(", "offPt", ")", ";", "return", ";", "}", "int", "n_src", "=", "m_srcPtCount", ";", "GraphicPoint", "pt1", ",", "pt", ";", "pt1", "=", "m_srcPts", ".", "get", "(", "i_src", "==", "0", "?", "n_src", "-", "1", ":", "i_src", "-", "1", ")", ";", "pt", "=", "m_srcPts", ".", "get", "(", "i_src", ")", ";", "// calculate scalar product to determine if the offset segment goes in", "// the same/opposite direction compared to the original one", "double", "s", "=", "scal", "(", "pt1", ",", "pt", ",", "m_offsetPts", ".", "get", "(", "m_offsetPtCount", "-", "1", ")", ",", "offPt", ")", ";", "if", "(", "s", ">", "0", ")", "// original segment and offset segment go in the same direction. Just", "// add the point", "{", "addPoint", "(", "offPt", ")", ";", "return", ";", "}", "if", "(", "s", "<", "0", ")", "{", "// we will add a loop. We need to make sure the points we introduce", "// don't generate a \"reversed\" segment", "// let's project the first point of the reversed segment", "// (m_offsetPts + m_offsetPtCount - 1) to check", "// if it falls on the good side of the original segment (scalar", "// product sign again)", "if", "(", "scal", "(", "pt1", ",", "pt", ",", "pt", ",", "m_offsetPts", ".", "get", "(", "m_offsetPtCount", "-", "1", ")", ")", ">", "0", ")", "{", "GraphicPoint", "p", ";", "// change value of m_offsetPts + m_offsetPtCount - 1", "int", "k", ";", "if", "(", "i_src", "==", "0", ")", "k", "=", "n_src", "-", "2", ";", "else", "if", "(", "i_src", "==", "1", ")", "k", "=", "n_src", "-", "1", ";", "else", "k", "=", "i_src", "-", "2", ";", "GraphicPoint", "pt0", "=", "m_srcPts", ".", "get", "(", "k", ")", ";", "double", "a", "=", "Math", ".", "atan2", "(", "pt1", ".", "y", "-", "pt0", ".", "y", ",", "pt1", ".", "x", "-", "pt0", ".", "x", ")", ";", "p", "=", "new", "GraphicPoint", "(", "pt1", ",", "m_distance", ",", "a", "-", "half_pi", ")", ";", "m_offsetPts", ".", "set", "(", "m_offsetPtCount", "-", "1", ",", "p", ")", ";", "if", "(", "m_joins", "==", "OperatorOffset", ".", "JoinType", ".", "Bevel", "||", "m_joins", "==", "OperatorOffset", ".", "JoinType", ".", "Miter", ")", "{", "// this block is added as well as the commented BAD_SEG in", "// the next block", "p", "=", "new", "GraphicPoint", "(", "p", ",", "pt1", ")", ";", "addPoint", "(", "p", ")", ";", "// \"bad\" segment", "p", "=", "new", "GraphicPoint", "(", "pt1", ",", "m_distance", ",", "m_a1", "+", "half_pi", ")", ";", "GraphicPoint", "p_", "=", "new", "GraphicPoint", "(", "p", ",", "pt1", ")", ";", "p_", ".", "type", "|=", "BAD_SEG", ";", "addPoint", "(", "p_", ")", ";", "addPoint", "(", "p", ")", ";", "}", "else", "{", "// the working stuff for round and square", "// \"bad\" segment", "p", "=", "new", "GraphicPoint", "(", "pt1", ",", "m_distance", ",", "m_a1", "+", "half_pi", ")", ";", "p", ".", "type", "|=", "BAD_SEG", ";", "addPoint", "(", "p", ")", ";", "}", "// add offPt", "addPoint", "(", "offPt", ",", "i_src", ")", ";", "}", "else", "{", "GraphicPoint", "p", ";", "// we don't add offPt but the loop containing the \"bad\" segment", "p", "=", "new", "GraphicPoint", "(", "pt", ",", "m_distance", ",", "m_a1", "+", "half_pi", ")", ";", "addPoint", "(", "p", ")", ";", "if", "(", "m_joins", "==", "OperatorOffset", ".", "JoinType", ".", "Bevel", "||", "m_joins", "==", "OperatorOffset", ".", "JoinType", ".", "Miter", ")", "{", "// this block is added as well as the commented BAD_SEG in", "// the next block", "p", "=", "new", "GraphicPoint", "(", "p", ",", "pt", ")", ";", "addPoint", "(", "p", ")", ";", "p", "=", "new", "GraphicPoint", "(", "pt", ",", "m_distance", ",", "m_a2", "-", "half_pi", ")", ";", "GraphicPoint", "p_", "=", "new", "GraphicPoint", "(", "p", ",", "pt", ")", ";", "p_", ".", "type", "|=", "BAD_SEG", ";", "addPoint", "(", "p_", ")", ";", "addPoint", "(", "p", ")", ";", "}", "else", "{", "// the working stuff for round and square", "p", "=", "new", "GraphicPoint", "(", "pt", ",", "m_distance", ",", "m_a2", "-", "half_pi", ")", ";", "p", ".", "type", "|=", "BAD_SEG", ";", "addPoint", "(", "p", ")", ";", "}", "}", "}", "}"], "docstring": "this situation is handled here by adding an additional \"bad\" segment", "docstring_tokens": ["this", "situation", "is", "handled", "here", "by", "adding", "an", "additional", "bad", "segment"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConstructOffset.java#L191-L293", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConstructOffset.java", "func_name": "ConstructOffset.compressOffsetArray", "original_string": "void compressOffsetArray(int i0) {\n\t\tint i_ = i0;\n\t\twhile (m_offsetPts.get(i_).m_prev < i_)\n\t\t\ti_ = m_offsetPts.get(i_).m_prev;\n\n\t\tint j = 0, i = i_;\n\n\t\tdo {\n\t\t\tGraphicPoint pt = m_offsetPts.get(i);\n\t\t\tm_offsetPts.set(j, pt);\n\t\t\ti = pt.m_next;\n\t\t\tj++;\n\t\t} while (i != i_);\n\n\t\tm_offsetPts.set(j, m_offsetPts.get(0)); // duplicate closing point\n\n\t\tm_offsetPtCount = j + 1;\n\t}", "language": "java", "code": "void compressOffsetArray(int i0) {\n\t\tint i_ = i0;\n\t\twhile (m_offsetPts.get(i_).m_prev < i_)\n\t\t\ti_ = m_offsetPts.get(i_).m_prev;\n\n\t\tint j = 0, i = i_;\n\n\t\tdo {\n\t\t\tGraphicPoint pt = m_offsetPts.get(i);\n\t\t\tm_offsetPts.set(j, pt);\n\t\t\ti = pt.m_next;\n\t\t\tj++;\n\t\t} while (i != i_);\n\n\t\tm_offsetPts.set(j, m_offsetPts.get(0)); // duplicate closing point\n\n\t\tm_offsetPtCount = j + 1;\n\t}", "code_tokens": ["void", "compressOffsetArray", "(", "int", "i0", ")", "{", "int", "i_", "=", "i0", ";", "while", "(", "m_offsetPts", ".", "get", "(", "i_", ")", ".", "m_prev", "<", "i_", ")", "i_", "=", "m_offsetPts", ".", "get", "(", "i_", ")", ".", "m_prev", ";", "int", "j", "=", "0", ",", "i", "=", "i_", ";", "do", "{", "GraphicPoint", "pt", "=", "m_offsetPts", ".", "get", "(", "i", ")", ";", "m_offsetPts", ".", "set", "(", "j", ",", "pt", ")", ";", "i", "=", "pt", ".", "m_next", ";", "j", "++", ";", "}", "while", "(", "i", "!=", "i_", ")", ";", "m_offsetPts", ".", "set", "(", "j", ",", "m_offsetPts", ".", "get", "(", "0", ")", ")", ";", "// duplicate closing point", "m_offsetPtCount", "=", "j", "+", "1", ";", "}"], "docstring": "is, its the index of a point that isn't part of a deleted loop", "docstring_tokens": ["is", "its", "the", "index", "of", "a", "point", "that", "isn", "t", "part", "of", "a", "deleted", "loop"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConstructOffset.java#L944-L961", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D.scaleAdd", "original_string": "public void scaleAdd(double f, Point2D shift) {\n\t\tx = x * f + shift.x;\n\t\ty = y * f + shift.y;\n\t}", "language": "java", "code": "public void scaleAdd(double f, Point2D shift) {\n\t\tx = x * f + shift.x;\n\t\ty = y * f + shift.y;\n\t}", "code_tokens": ["public", "void", "scaleAdd", "(", "double", "f", ",", "Point2D", "shift", ")", "{", "x", "=", "x", "*", "f", "+", "shift", ".", "x", ";", "y", "=", "y", "*", "f", "+", "shift", ".", "y", ";", "}"], "docstring": "Calculates this = this * f + shift\n@param f\n@param shift", "docstring_tokens": ["Calculates", "this", "=", "this", "*", "f", "+", "shift"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L141-L144", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D.compare", "original_string": "public int compare(Point2D other) {\n\t\treturn y < other.y ? -1 : (y > other.y ? 1 : (x < other.x ? -1\n\t\t\t\t: (x > other.x ? 1 : 0)));\n\t}", "language": "java", "code": "public int compare(Point2D other) {\n\t\treturn y < other.y ? -1 : (y > other.y ? 1 : (x < other.x ? -1\n\t\t\t\t: (x > other.x ? 1 : 0)));\n\t}", "code_tokens": ["public", "int", "compare", "(", "Point2D", "other", ")", "{", "return", "y", "<", "other", ".", "y", "?", "-", "1", ":", "(", "y", ">", "other", ".", "y", "?", "1", ":", "(", "x", "<", "other", ".", "x", "?", "-", "1", ":", "(", "x", ">", "other", ".", "x", "?", "1", ":", "0", ")", ")", ")", ";", "}"], "docstring": "Compares two vertices lexicographically by y.", "docstring_tokens": ["Compares", "two", "vertices", "lexicographically", "by", "y", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L170-L173", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D.compareX", "original_string": "int compareX(Point2D other) {\n\t\treturn x < other.x ? -1 : (x > other.x ? 1 : (y < other.y ? -1\n\t\t\t\t: (y > other.y ? 1 : 0)));\n\t}", "language": "java", "code": "int compareX(Point2D other) {\n\t\treturn x < other.x ? -1 : (x > other.x ? 1 : (y < other.y ? -1\n\t\t\t\t: (y > other.y ? 1 : 0)));\n\t}", "code_tokens": ["int", "compareX", "(", "Point2D", "other", ")", "{", "return", "x", "<", "other", ".", "x", "?", "-", "1", ":", "(", "x", ">", "other", ".", "x", "?", "1", ":", "(", "y", "<", "other", ".", "y", "?", "-", "1", ":", "(", "y", ">", "other", ".", "y", "?", "1", ":", "0", ")", ")", ")", ";", "}"], "docstring": "Compares two vertices lexicographically by x.", "docstring_tokens": ["Compares", "two", "vertices", "lexicographically", "by", "x", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L177-L180", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D._norm", "original_string": "double _norm(int metric) {\n\t\tif (metric < 0 || _isNan())\n\t\t\treturn NumberUtils.NaN();\n\n\t\tswitch (metric) {\n\t\tcase 0: // L-infinite\n\t\t\treturn Math.abs(x) >= Math.abs(y) ? Math.abs(x) : Math.abs(y);\n\n\t\tcase 1: // L1 or Manhattan metric\n\t\t\treturn Math.abs(x) + Math.abs(y);\n\n\t\tcase 2: // L2 or Euclidean metric\n\t\t\treturn Math.sqrt(x * x + y * y);\n\n\t\tdefault:\n\t\t\treturn Math\n\t\t\t\t\t.pow(Math.pow(x, (double) metric)\n\t\t\t\t\t\t\t+ Math.pow(y, (double) metric),\n\t\t\t\t\t\t\t1.0 / (double) metric);\n\t\t}\n\t}", "language": "java", "code": "double _norm(int metric) {\n\t\tif (metric < 0 || _isNan())\n\t\t\treturn NumberUtils.NaN();\n\n\t\tswitch (metric) {\n\t\tcase 0: // L-infinite\n\t\t\treturn Math.abs(x) >= Math.abs(y) ? Math.abs(x) : Math.abs(y);\n\n\t\tcase 1: // L1 or Manhattan metric\n\t\t\treturn Math.abs(x) + Math.abs(y);\n\n\t\tcase 2: // L2 or Euclidean metric\n\t\t\treturn Math.sqrt(x * x + y * y);\n\n\t\tdefault:\n\t\t\treturn Math\n\t\t\t\t\t.pow(Math.pow(x, (double) metric)\n\t\t\t\t\t\t\t+ Math.pow(y, (double) metric),\n\t\t\t\t\t\t\t1.0 / (double) metric);\n\t\t}\n\t}", "code_tokens": ["double", "_norm", "(", "int", "metric", ")", "{", "if", "(", "metric", "<", "0", "||", "_isNan", "(", ")", ")", "return", "NumberUtils", ".", "NaN", "(", ")", ";", "switch", "(", "metric", ")", "{", "case", "0", ":", "// L-infinite", "return", "Math", ".", "abs", "(", "x", ")", ">=", "Math", ".", "abs", "(", "y", ")", "?", "Math", ".", "abs", "(", "x", ")", ":", "Math", ".", "abs", "(", "y", ")", ";", "case", "1", ":", "// L1 or Manhattan metric", "return", "Math", ".", "abs", "(", "x", ")", "+", "Math", ".", "abs", "(", "y", ")", ";", "case", "2", ":", "// L2 or Euclidean metric", "return", "Math", ".", "sqrt", "(", "x", "*", "x", "+", "y", "*", "y", ")", ";", "default", ":", "return", "Math", ".", "pow", "(", "Math", ".", "pow", "(", "x", ",", "(", "double", ")", "metric", ")", "+", "Math", ".", "pow", "(", "y", ",", "(", "double", ")", "metric", ")", ",", "1.0", "/", "(", "double", ")", "metric", ")", ";", "}", "}"], "docstring": "for predefined metrics, use the DistanceMetricEnum defined in WKSPoint.h", "docstring_tokens": ["for", "predefined", "metrics", "use", "the", "DistanceMetricEnum", "defined", "in", "WKSPoint", ".", "h"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L393-L413", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D.offset", "original_string": "double offset(/* const */Point2D pt1, /* const */Point2D pt2) {\n\t\tdouble newDistance = distance(pt1, pt2);\n\t\tPoint2D p = construct(x, y);\n\t\tif (newDistance == 0.0)\n\t\t\treturn distance(p, pt1);\n\n\t\t// get vectors relative to pt_1\n\t\tPoint2D p2 = new Point2D();\n\t\tp2.setCoords(pt2);\n\t\tp2.sub(pt1);\n\t\tp.sub(pt1);\n\n\t\tdouble cross = p.crossProduct(p2);\n\t\treturn cross / newDistance;\n\t}", "language": "java", "code": "double offset(/* const */Point2D pt1, /* const */Point2D pt2) {\n\t\tdouble newDistance = distance(pt1, pt2);\n\t\tPoint2D p = construct(x, y);\n\t\tif (newDistance == 0.0)\n\t\t\treturn distance(p, pt1);\n\n\t\t// get vectors relative to pt_1\n\t\tPoint2D p2 = new Point2D();\n\t\tp2.setCoords(pt2);\n\t\tp2.sub(pt1);\n\t\tp.sub(pt1);\n\n\t\tdouble cross = p.crossProduct(p2);\n\t\treturn cross / newDistance;\n\t}", "code_tokens": ["double", "offset", "(", "/* const */", "Point2D", "pt1", ",", "/* const */", "Point2D", "pt2", ")", "{", "double", "newDistance", "=", "distance", "(", "pt1", ",", "pt2", ")", ";", "Point2D", "p", "=", "construct", "(", "x", ",", "y", ")", ";", "if", "(", "newDistance", "==", "0.0", ")", "return", "distance", "(", "p", ",", "pt1", ")", ";", "// get vectors relative to pt_1", "Point2D", "p2", "=", "new", "Point2D", "(", ")", ";", "p2", ".", "setCoords", "(", "pt2", ")", ";", "p2", ".", "sub", "(", "pt1", ")", ";", "p", ".", "sub", "(", "pt1", ")", ";", "double", "cross", "=", "p", ".", "crossProduct", "(", "p2", ")", ";", "return", "cross", "/", "newDistance", ";", "}"], "docstring": "returns signed distance of point from infinite line represented by\npt_1...pt_2. The returned distance is positive if this point lies on the\nright-hand side of the line, negative otherwise. If the two input points\nare equal, the (positive) distance of this point to p_1 is returned.", "docstring_tokens": ["returns", "signed", "distance", "of", "point", "from", "infinite", "line", "represented", "by", "pt_1", "...", "pt_2", ".", "The", "returned", "distance", "is", "positive", "if", "this", "point", "lies", "on", "the", "right", "-", "hand", "side", "of", "the", "line", "negative", "otherwise", ".", "If", "the", "two", "input", "points", "are", "equal", "the", "(", "positive", ")", "distance", "of", "this", "point", "to", "p_1", "is", "returned", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L421-L435", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D.orientationRobust", "original_string": "public static int orientationRobust(Point2D p, Point2D q, Point2D r) {\n\t\tECoordinate det_ec = new ECoordinate();\n\t\tdet_ec.set(q.x);\n\t\tdet_ec.sub(p.x);\n\n\t\tECoordinate rp_y_ec = new ECoordinate();\n\t\trp_y_ec.set(r.y);\n\t\trp_y_ec.sub(p.y);\n\n\t\tECoordinate qp_y_ec = new ECoordinate();\n\t\tqp_y_ec.set(q.y);\n\t\tqp_y_ec.sub(p.y);\n\n\t\tECoordinate rp_x_ec = new ECoordinate();\n\t\trp_x_ec.set(r.x);\n\t\trp_x_ec.sub(p.x);\n\n\t\tdet_ec.mul(rp_y_ec);\n\t\tqp_y_ec.mul(rp_x_ec);\n\t\tdet_ec.sub(qp_y_ec);\n\n\t\tif (!det_ec.isFuzzyZero()) {\n\t\t\tdouble det_ec_value = det_ec.value();\n\n\t\t\tif (det_ec_value < 0.0)\n\t\t\t\treturn -1;\n\n\t\t\tif (det_ec_value > 0.0)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Need extended precision\n\n\t\tBigDecimal det_mp = new BigDecimal(q.x);\n\t\tBigDecimal px_mp = new BigDecimal(p.x);\n\t\tBigDecimal py_mp = new BigDecimal(p.y);\n\t\tdet_mp = det_mp.subtract(px_mp);\n\n\t\tBigDecimal rp_y_mp = new BigDecimal(r.y);\n\t\trp_y_mp = rp_y_mp.subtract(py_mp);\n\n\t\tBigDecimal qp_y_mp = new BigDecimal(q.y);\n\t\tqp_y_mp = qp_y_mp.subtract(py_mp);\n\n\t\tBigDecimal rp_x_mp = new BigDecimal(r.x);\n\t\trp_x_mp = rp_x_mp.subtract(px_mp);\n\n\t\tdet_mp = det_mp.multiply(rp_y_mp);\n\t\tqp_y_mp = qp_y_mp.multiply(rp_x_mp);\n\t\tdet_mp = det_mp.subtract(qp_y_mp);\n\n\t\treturn det_mp.signum();\n\t}", "language": "java", "code": "public static int orientationRobust(Point2D p, Point2D q, Point2D r) {\n\t\tECoordinate det_ec = new ECoordinate();\n\t\tdet_ec.set(q.x);\n\t\tdet_ec.sub(p.x);\n\n\t\tECoordinate rp_y_ec = new ECoordinate();\n\t\trp_y_ec.set(r.y);\n\t\trp_y_ec.sub(p.y);\n\n\t\tECoordinate qp_y_ec = new ECoordinate();\n\t\tqp_y_ec.set(q.y);\n\t\tqp_y_ec.sub(p.y);\n\n\t\tECoordinate rp_x_ec = new ECoordinate();\n\t\trp_x_ec.set(r.x);\n\t\trp_x_ec.sub(p.x);\n\n\t\tdet_ec.mul(rp_y_ec);\n\t\tqp_y_ec.mul(rp_x_ec);\n\t\tdet_ec.sub(qp_y_ec);\n\n\t\tif (!det_ec.isFuzzyZero()) {\n\t\t\tdouble det_ec_value = det_ec.value();\n\n\t\t\tif (det_ec_value < 0.0)\n\t\t\t\treturn -1;\n\n\t\t\tif (det_ec_value > 0.0)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Need extended precision\n\n\t\tBigDecimal det_mp = new BigDecimal(q.x);\n\t\tBigDecimal px_mp = new BigDecimal(p.x);\n\t\tBigDecimal py_mp = new BigDecimal(p.y);\n\t\tdet_mp = det_mp.subtract(px_mp);\n\n\t\tBigDecimal rp_y_mp = new BigDecimal(r.y);\n\t\trp_y_mp = rp_y_mp.subtract(py_mp);\n\n\t\tBigDecimal qp_y_mp = new BigDecimal(q.y);\n\t\tqp_y_mp = qp_y_mp.subtract(py_mp);\n\n\t\tBigDecimal rp_x_mp = new BigDecimal(r.x);\n\t\trp_x_mp = rp_x_mp.subtract(px_mp);\n\n\t\tdet_mp = det_mp.multiply(rp_y_mp);\n\t\tqp_y_mp = qp_y_mp.multiply(rp_x_mp);\n\t\tdet_mp = det_mp.subtract(qp_y_mp);\n\n\t\treturn det_mp.signum();\n\t}", "code_tokens": ["public", "static", "int", "orientationRobust", "(", "Point2D", "p", ",", "Point2D", "q", ",", "Point2D", "r", ")", "{", "ECoordinate", "det_ec", "=", "new", "ECoordinate", "(", ")", ";", "det_ec", ".", "set", "(", "q", ".", "x", ")", ";", "det_ec", ".", "sub", "(", "p", ".", "x", ")", ";", "ECoordinate", "rp_y_ec", "=", "new", "ECoordinate", "(", ")", ";", "rp_y_ec", ".", "set", "(", "r", ".", "y", ")", ";", "rp_y_ec", ".", "sub", "(", "p", ".", "y", ")", ";", "ECoordinate", "qp_y_ec", "=", "new", "ECoordinate", "(", ")", ";", "qp_y_ec", ".", "set", "(", "q", ".", "y", ")", ";", "qp_y_ec", ".", "sub", "(", "p", ".", "y", ")", ";", "ECoordinate", "rp_x_ec", "=", "new", "ECoordinate", "(", ")", ";", "rp_x_ec", ".", "set", "(", "r", ".", "x", ")", ";", "rp_x_ec", ".", "sub", "(", "p", ".", "x", ")", ";", "det_ec", ".", "mul", "(", "rp_y_ec", ")", ";", "qp_y_ec", ".", "mul", "(", "rp_x_ec", ")", ";", "det_ec", ".", "sub", "(", "qp_y_ec", ")", ";", "if", "(", "!", "det_ec", ".", "isFuzzyZero", "(", ")", ")", "{", "double", "det_ec_value", "=", "det_ec", ".", "value", "(", ")", ";", "if", "(", "det_ec_value", "<", "0.0", ")", "return", "-", "1", ";", "if", "(", "det_ec_value", ">", "0.0", ")", "return", "1", ";", "return", "0", ";", "}", "// Need extended precision", "BigDecimal", "det_mp", "=", "new", "BigDecimal", "(", "q", ".", "x", ")", ";", "BigDecimal", "px_mp", "=", "new", "BigDecimal", "(", "p", ".", "x", ")", ";", "BigDecimal", "py_mp", "=", "new", "BigDecimal", "(", "p", ".", "y", ")", ";", "det_mp", "=", "det_mp", ".", "subtract", "(", "px_mp", ")", ";", "BigDecimal", "rp_y_mp", "=", "new", "BigDecimal", "(", "r", ".", "y", ")", ";", "rp_y_mp", "=", "rp_y_mp", ".", "subtract", "(", "py_mp", ")", ";", "BigDecimal", "qp_y_mp", "=", "new", "BigDecimal", "(", "q", ".", "y", ")", ";", "qp_y_mp", "=", "qp_y_mp", ".", "subtract", "(", "py_mp", ")", ";", "BigDecimal", "rp_x_mp", "=", "new", "BigDecimal", "(", "r", ".", "x", ")", ";", "rp_x_mp", "=", "rp_x_mp", ".", "subtract", "(", "px_mp", ")", ";", "det_mp", "=", "det_mp", ".", "multiply", "(", "rp_y_mp", ")", ";", "qp_y_mp", "=", "qp_y_mp", ".", "multiply", "(", "rp_x_mp", ")", ";", "det_mp", "=", "det_mp", ".", "subtract", "(", "qp_y_mp", ")", ";", "return", "det_mp", ".", "signum", "(", ")", ";", "}"], "docstring": "Calculates the orientation of the triangle formed by p, q, r. Returns 1\nfor counter-clockwise, -1 for clockwise, and 0 for collinear. May use\nhigh precision arithmetics for some special degenerate cases.", "docstring_tokens": ["Calculates", "the", "orientation", "of", "the", "triangle", "formed", "by", "p", "q", "r", ".", "Returns", "1", "for", "counter", "-", "clockwise", "-", "1", "for", "clockwise", "and", "0", "for", "collinear", ".", "May", "use", "high", "precision", "arithmetics", "for", "some", "special", "degenerate", "cases", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L442-L496", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point2D.java", "func_name": "Point2D.inCircleRobust", "original_string": "static int inCircleRobust(Point2D p, Point2D q, Point2D r, Point2D s) {\n\t\tECoordinate psx_ec = new ECoordinate(), psy_ec = new ECoordinate();\n\t\tpsx_ec.set(p.x);\n\t\tpsx_ec.sub(s.x);\n\t\tpsy_ec.set(p.y);\n\t\tpsy_ec.sub(s.y);\n\n\t\tECoordinate qsx_ec = new ECoordinate(), qsy_ec = new ECoordinate();\n\t\tqsx_ec.set(q.x);\n\t\tqsx_ec.sub(s.x);\n\t\tqsy_ec.set(q.y);\n\t\tqsy_ec.sub(s.y);\n\n\t\tECoordinate rsx_ec = new ECoordinate(), rsy_ec = new ECoordinate();\n\t\trsx_ec.set(r.x);\n\t\trsx_ec.sub(s.x);\n\t\trsy_ec.set(r.y);\n\t\trsy_ec.sub(s.y);\n\n\t\tECoordinate psx_ec_qsy_ec = new ECoordinate();\n\t\tpsx_ec_qsy_ec.set(psx_ec);\n\t\tpsx_ec_qsy_ec.mul(qsy_ec);\n\t\tECoordinate psy_ec_qsx_ec = new ECoordinate();\n\t\tpsy_ec_qsx_ec.set(psy_ec);\n\t\tpsy_ec_qsx_ec.mul(qsx_ec);\n\t\tECoordinate qsx_ec_rsy_ec = new ECoordinate();\n\t\tqsx_ec_rsy_ec.set(qsx_ec);\n\t\tqsx_ec_rsy_ec.mul(rsy_ec);\n\t\tECoordinate qsy_ec_rsx_ec = new ECoordinate();\n\t\tqsy_ec_rsx_ec.set(qsy_ec);\n\t\tqsy_ec_rsx_ec.mul(rsx_ec);\n\t\tECoordinate psx_ec_rsy_ec = new ECoordinate();\n\t\tpsx_ec_rsy_ec.set(psx_ec);\n\t\tpsx_ec_rsy_ec.mul(rsy_ec);\n\t\tECoordinate psy_ec_rsx_ec = new ECoordinate();\n\t\tpsy_ec_rsx_ec.set(psy_ec);\n\t\tpsy_ec_rsx_ec.mul(rsx_ec);\n\n\t\tECoordinate pq_det_ec = new ECoordinate();\n\t\tpq_det_ec.set(psx_ec_qsy_ec);\n\t\tpq_det_ec.sub(psy_ec_qsx_ec);\n\t\tECoordinate qr_det_ec = new ECoordinate();\n\t\tqr_det_ec.set(qsx_ec_rsy_ec);\n\t\tqr_det_ec.sub(qsy_ec_rsx_ec);\n\t\tECoordinate pr_det_ec = new ECoordinate();\n\t\tpr_det_ec.set(psx_ec_rsy_ec);\n\t\tpr_det_ec.sub(psy_ec_rsx_ec);\n\n\t\tECoordinate psx_ec_psx_ec = new ECoordinate();\n\t\tpsx_ec_psx_ec.set(psx_ec);\n\t\tpsx_ec_psx_ec.mul(psx_ec);\n\t\tECoordinate psy_ec_psy_ec = new ECoordinate();\n\t\tpsy_ec_psy_ec.set(psy_ec);\n\t\tpsy_ec_psy_ec.mul(psy_ec);\n\t\tECoordinate qsx_ec_qsx_ec = new ECoordinate();\n\t\tqsx_ec_qsx_ec.set(qsx_ec);\n\t\tqsx_ec_qsx_ec.mul(qsx_ec);\n\t\tECoordinate qsy_ec_qsy_ec = new ECoordinate();\n\t\tqsy_ec_qsy_ec.set(qsy_ec);\n\t\tqsy_ec_qsy_ec.mul(qsy_ec);\n\t\tECoordinate rsx_ec_rsx_ec = new ECoordinate();\n\t\trsx_ec_rsx_ec.set(rsx_ec);\n\t\trsx_ec_rsx_ec.mul(rsx_ec);\n\t\tECoordinate rsy_ec_rsy_ec = new ECoordinate();\n\t\trsy_ec_rsy_ec.set(rsy_ec);\n\t\trsy_ec_rsy_ec.mul(rsy_ec);\n\n\t\tECoordinate p_parab_ec = new ECoordinate();\n\t\tp_parab_ec.set(psx_ec_psx_ec);\n\t\tp_parab_ec.add(psy_ec_psy_ec);\n\t\tECoordinate q_parab_ec = new ECoordinate();\n\t\tq_parab_ec.set(qsx_ec_qsx_ec);\n\t\tq_parab_ec.add(qsy_ec_qsy_ec);\n\t\tECoordinate r_parab_ec = new ECoordinate();\n\t\tr_parab_ec.set(rsx_ec_rsx_ec);\n\t\tr_parab_ec.add(rsy_ec_rsy_ec);\n\n\t\tp_parab_ec.mul(qr_det_ec);\n\t\tq_parab_ec.mul(pr_det_ec);\n\t\tr_parab_ec.mul(pq_det_ec);\n\n\t\tECoordinate det_ec = new ECoordinate();\n\t\tdet_ec.set(p_parab_ec);\n\t\tdet_ec.sub(q_parab_ec);\n\t\tdet_ec.add(r_parab_ec);\n\n\t\tif (!det_ec.isFuzzyZero()) {\n\t\t\tdouble det_ec_value = det_ec.value();\n\n\t\t\tif (det_ec_value < 0.0)\n\t\t\t\treturn -1;\n\n\t\t\tif (det_ec_value > 0.0)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn inCircleRobustMP_(p, q, r, s);\n\t}", "language": "java", "code": "static int inCircleRobust(Point2D p, Point2D q, Point2D r, Point2D s) {\n\t\tECoordinate psx_ec = new ECoordinate(), psy_ec = new ECoordinate();\n\t\tpsx_ec.set(p.x);\n\t\tpsx_ec.sub(s.x);\n\t\tpsy_ec.set(p.y);\n\t\tpsy_ec.sub(s.y);\n\n\t\tECoordinate qsx_ec = new ECoordinate(), qsy_ec = new ECoordinate();\n\t\tqsx_ec.set(q.x);\n\t\tqsx_ec.sub(s.x);\n\t\tqsy_ec.set(q.y);\n\t\tqsy_ec.sub(s.y);\n\n\t\tECoordinate rsx_ec = new ECoordinate(), rsy_ec = new ECoordinate();\n\t\trsx_ec.set(r.x);\n\t\trsx_ec.sub(s.x);\n\t\trsy_ec.set(r.y);\n\t\trsy_ec.sub(s.y);\n\n\t\tECoordinate psx_ec_qsy_ec = new ECoordinate();\n\t\tpsx_ec_qsy_ec.set(psx_ec);\n\t\tpsx_ec_qsy_ec.mul(qsy_ec);\n\t\tECoordinate psy_ec_qsx_ec = new ECoordinate();\n\t\tpsy_ec_qsx_ec.set(psy_ec);\n\t\tpsy_ec_qsx_ec.mul(qsx_ec);\n\t\tECoordinate qsx_ec_rsy_ec = new ECoordinate();\n\t\tqsx_ec_rsy_ec.set(qsx_ec);\n\t\tqsx_ec_rsy_ec.mul(rsy_ec);\n\t\tECoordinate qsy_ec_rsx_ec = new ECoordinate();\n\t\tqsy_ec_rsx_ec.set(qsy_ec);\n\t\tqsy_ec_rsx_ec.mul(rsx_ec);\n\t\tECoordinate psx_ec_rsy_ec = new ECoordinate();\n\t\tpsx_ec_rsy_ec.set(psx_ec);\n\t\tpsx_ec_rsy_ec.mul(rsy_ec);\n\t\tECoordinate psy_ec_rsx_ec = new ECoordinate();\n\t\tpsy_ec_rsx_ec.set(psy_ec);\n\t\tpsy_ec_rsx_ec.mul(rsx_ec);\n\n\t\tECoordinate pq_det_ec = new ECoordinate();\n\t\tpq_det_ec.set(psx_ec_qsy_ec);\n\t\tpq_det_ec.sub(psy_ec_qsx_ec);\n\t\tECoordinate qr_det_ec = new ECoordinate();\n\t\tqr_det_ec.set(qsx_ec_rsy_ec);\n\t\tqr_det_ec.sub(qsy_ec_rsx_ec);\n\t\tECoordinate pr_det_ec = new ECoordinate();\n\t\tpr_det_ec.set(psx_ec_rsy_ec);\n\t\tpr_det_ec.sub(psy_ec_rsx_ec);\n\n\t\tECoordinate psx_ec_psx_ec = new ECoordinate();\n\t\tpsx_ec_psx_ec.set(psx_ec);\n\t\tpsx_ec_psx_ec.mul(psx_ec);\n\t\tECoordinate psy_ec_psy_ec = new ECoordinate();\n\t\tpsy_ec_psy_ec.set(psy_ec);\n\t\tpsy_ec_psy_ec.mul(psy_ec);\n\t\tECoordinate qsx_ec_qsx_ec = new ECoordinate();\n\t\tqsx_ec_qsx_ec.set(qsx_ec);\n\t\tqsx_ec_qsx_ec.mul(qsx_ec);\n\t\tECoordinate qsy_ec_qsy_ec = new ECoordinate();\n\t\tqsy_ec_qsy_ec.set(qsy_ec);\n\t\tqsy_ec_qsy_ec.mul(qsy_ec);\n\t\tECoordinate rsx_ec_rsx_ec = new ECoordinate();\n\t\trsx_ec_rsx_ec.set(rsx_ec);\n\t\trsx_ec_rsx_ec.mul(rsx_ec);\n\t\tECoordinate rsy_ec_rsy_ec = new ECoordinate();\n\t\trsy_ec_rsy_ec.set(rsy_ec);\n\t\trsy_ec_rsy_ec.mul(rsy_ec);\n\n\t\tECoordinate p_parab_ec = new ECoordinate();\n\t\tp_parab_ec.set(psx_ec_psx_ec);\n\t\tp_parab_ec.add(psy_ec_psy_ec);\n\t\tECoordinate q_parab_ec = new ECoordinate();\n\t\tq_parab_ec.set(qsx_ec_qsx_ec);\n\t\tq_parab_ec.add(qsy_ec_qsy_ec);\n\t\tECoordinate r_parab_ec = new ECoordinate();\n\t\tr_parab_ec.set(rsx_ec_rsx_ec);\n\t\tr_parab_ec.add(rsy_ec_rsy_ec);\n\n\t\tp_parab_ec.mul(qr_det_ec);\n\t\tq_parab_ec.mul(pr_det_ec);\n\t\tr_parab_ec.mul(pq_det_ec);\n\n\t\tECoordinate det_ec = new ECoordinate();\n\t\tdet_ec.set(p_parab_ec);\n\t\tdet_ec.sub(q_parab_ec);\n\t\tdet_ec.add(r_parab_ec);\n\n\t\tif (!det_ec.isFuzzyZero()) {\n\t\t\tdouble det_ec_value = det_ec.value();\n\n\t\t\tif (det_ec_value < 0.0)\n\t\t\t\treturn -1;\n\n\t\t\tif (det_ec_value > 0.0)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn inCircleRobustMP_(p, q, r, s);\n\t}", "code_tokens": ["static", "int", "inCircleRobust", "(", "Point2D", "p", ",", "Point2D", "q", ",", "Point2D", "r", ",", "Point2D", "s", ")", "{", "ECoordinate", "psx_ec", "=", "new", "ECoordinate", "(", ")", ",", "psy_ec", "=", "new", "ECoordinate", "(", ")", ";", "psx_ec", ".", "set", "(", "p", ".", "x", ")", ";", "psx_ec", ".", "sub", "(", "s", ".", "x", ")", ";", "psy_ec", ".", "set", "(", "p", ".", "y", ")", ";", "psy_ec", ".", "sub", "(", "s", ".", "y", ")", ";", "ECoordinate", "qsx_ec", "=", "new", "ECoordinate", "(", ")", ",", "qsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "qsx_ec", ".", "set", "(", "q", ".", "x", ")", ";", "qsx_ec", ".", "sub", "(", "s", ".", "x", ")", ";", "qsy_ec", ".", "set", "(", "q", ".", "y", ")", ";", "qsy_ec", ".", "sub", "(", "s", ".", "y", ")", ";", "ECoordinate", "rsx_ec", "=", "new", "ECoordinate", "(", ")", ",", "rsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "rsx_ec", ".", "set", "(", "r", ".", "x", ")", ";", "rsx_ec", ".", "sub", "(", "s", ".", "x", ")", ";", "rsy_ec", ".", "set", "(", "r", ".", "y", ")", ";", "rsy_ec", ".", "sub", "(", "s", ".", "y", ")", ";", "ECoordinate", "psx_ec_qsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "psx_ec_qsy_ec", ".", "set", "(", "psx_ec", ")", ";", "psx_ec_qsy_ec", ".", "mul", "(", "qsy_ec", ")", ";", "ECoordinate", "psy_ec_qsx_ec", "=", "new", "ECoordinate", "(", ")", ";", "psy_ec_qsx_ec", ".", "set", "(", "psy_ec", ")", ";", "psy_ec_qsx_ec", ".", "mul", "(", "qsx_ec", ")", ";", "ECoordinate", "qsx_ec_rsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "qsx_ec_rsy_ec", ".", "set", "(", "qsx_ec", ")", ";", "qsx_ec_rsy_ec", ".", "mul", "(", "rsy_ec", ")", ";", "ECoordinate", "qsy_ec_rsx_ec", "=", "new", "ECoordinate", "(", ")", ";", "qsy_ec_rsx_ec", ".", "set", "(", "qsy_ec", ")", ";", "qsy_ec_rsx_ec", ".", "mul", "(", "rsx_ec", ")", ";", "ECoordinate", "psx_ec_rsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "psx_ec_rsy_ec", ".", "set", "(", "psx_ec", ")", ";", "psx_ec_rsy_ec", ".", "mul", "(", "rsy_ec", ")", ";", "ECoordinate", "psy_ec_rsx_ec", "=", "new", "ECoordinate", "(", ")", ";", "psy_ec_rsx_ec", ".", "set", "(", "psy_ec", ")", ";", "psy_ec_rsx_ec", ".", "mul", "(", "rsx_ec", ")", ";", "ECoordinate", "pq_det_ec", "=", "new", "ECoordinate", "(", ")", ";", "pq_det_ec", ".", "set", "(", "psx_ec_qsy_ec", ")", ";", "pq_det_ec", ".", "sub", "(", "psy_ec_qsx_ec", ")", ";", "ECoordinate", "qr_det_ec", "=", "new", "ECoordinate", "(", ")", ";", "qr_det_ec", ".", "set", "(", "qsx_ec_rsy_ec", ")", ";", "qr_det_ec", ".", "sub", "(", "qsy_ec_rsx_ec", ")", ";", "ECoordinate", "pr_det_ec", "=", "new", "ECoordinate", "(", ")", ";", "pr_det_ec", ".", "set", "(", "psx_ec_rsy_ec", ")", ";", "pr_det_ec", ".", "sub", "(", "psy_ec_rsx_ec", ")", ";", "ECoordinate", "psx_ec_psx_ec", "=", "new", "ECoordinate", "(", ")", ";", "psx_ec_psx_ec", ".", "set", "(", "psx_ec", ")", ";", "psx_ec_psx_ec", ".", "mul", "(", "psx_ec", ")", ";", "ECoordinate", "psy_ec_psy_ec", "=", "new", "ECoordinate", "(", ")", ";", "psy_ec_psy_ec", ".", "set", "(", "psy_ec", ")", ";", "psy_ec_psy_ec", ".", "mul", "(", "psy_ec", ")", ";", "ECoordinate", "qsx_ec_qsx_ec", "=", "new", "ECoordinate", "(", ")", ";", "qsx_ec_qsx_ec", ".", "set", "(", "qsx_ec", ")", ";", "qsx_ec_qsx_ec", ".", "mul", "(", "qsx_ec", ")", ";", "ECoordinate", "qsy_ec_qsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "qsy_ec_qsy_ec", ".", "set", "(", "qsy_ec", ")", ";", "qsy_ec_qsy_ec", ".", "mul", "(", "qsy_ec", ")", ";", "ECoordinate", "rsx_ec_rsx_ec", "=", "new", "ECoordinate", "(", ")", ";", "rsx_ec_rsx_ec", ".", "set", "(", "rsx_ec", ")", ";", "rsx_ec_rsx_ec", ".", "mul", "(", "rsx_ec", ")", ";", "ECoordinate", "rsy_ec_rsy_ec", "=", "new", "ECoordinate", "(", ")", ";", "rsy_ec_rsy_ec", ".", "set", "(", "rsy_ec", ")", ";", "rsy_ec_rsy_ec", ".", "mul", "(", "rsy_ec", ")", ";", "ECoordinate", "p_parab_ec", "=", "new", "ECoordinate", "(", ")", ";", "p_parab_ec", ".", "set", "(", "psx_ec_psx_ec", ")", ";", "p_parab_ec", ".", "add", "(", "psy_ec_psy_ec", ")", ";", "ECoordinate", "q_parab_ec", "=", "new", "ECoordinate", "(", ")", ";", "q_parab_ec", ".", "set", "(", "qsx_ec_qsx_ec", ")", ";", "q_parab_ec", ".", "add", "(", "qsy_ec_qsy_ec", ")", ";", "ECoordinate", "r_parab_ec", "=", "new", "ECoordinate", "(", ")", ";", "r_parab_ec", ".", "set", "(", "rsx_ec_rsx_ec", ")", ";", "r_parab_ec", ".", "add", "(", "rsy_ec_rsy_ec", ")", ";", "p_parab_ec", ".", "mul", "(", "qr_det_ec", ")", ";", "q_parab_ec", ".", "mul", "(", "pr_det_ec", ")", ";", "r_parab_ec", ".", "mul", "(", "pq_det_ec", ")", ";", "ECoordinate", "det_ec", "=", "new", "ECoordinate", "(", ")", ";", "det_ec", ".", "set", "(", "p_parab_ec", ")", ";", "det_ec", ".", "sub", "(", "q_parab_ec", ")", ";", "det_ec", ".", "add", "(", "r_parab_ec", ")", ";", "if", "(", "!", "det_ec", ".", "isFuzzyZero", "(", ")", ")", "{", "double", "det_ec_value", "=", "det_ec", ".", "value", "(", ")", ";", "if", "(", "det_ec_value", "<", "0.0", ")", "return", "-", "1", ";", "if", "(", "det_ec_value", ">", "0.0", ")", "return", "1", ";", "return", "0", ";", "}", "return", "inCircleRobustMP_", "(", "p", ",", "q", ",", "r", ",", "s", ")", ";", "}"], "docstring": "Calculates if the point s is inside of the circumcircle inscribed by the clockwise oriented triangle p-q-r.\nReturns 1 for outside, -1 for inside, and 0 for cocircular.\nNote that the convention used here differs from what is commonly found in literature, which can define the relation\nin terms of a counter-clockwise oriented circle, and this flips the sign (think of the signed volume of the tetrahedron).\nMay use high precision arithmetics for some special cases.", "docstring_tokens": ["Calculates", "if", "the", "point", "s", "is", "inside", "of", "the", "circumcircle", "inscribed", "by", "the", "clockwise", "oriented", "triangle", "p", "-", "q", "-", "r", ".", "Returns", "1", "for", "outside", "-", "1", "for", "inside", "and", "0", "for", "cocircular", ".", "Note", "that", "the", "convention", "used", "here", "differs", "from", "what", "is", "commonly", "found", "in", "literature", "which", "can", "define", "the", "relation", "in", "terms", "of", "a", "counter", "-", "clockwise", "oriented", "circle", "and", "this", "flips", "the", "sign", "(", "think", "of", "the", "signed", "volume", "of", "the", "tetrahedron", ")", ".", "May", "use", "high", "precision", "arithmetics", "for", "some", "special", "cases", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point2D.java#L534-L633", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope3D.java", "func_name": "Envelope3D.isIntersecting", "original_string": "public boolean isIntersecting(Envelope3D other) {\n\t\treturn !isEmpty() && !other.isEmpty() && ((xmin <= other.xmin) ? xmax >= other.xmin : other.xmax >= xmin) && // check that x projections overlap\n\t\t\t((ymin <= other.ymin) ? ymax >= other.ymin : other.ymax >= ymin) && // check that y projections overlap\n\t\t\t((zmin <= other.zmin) ? zmax >= other.zmin : other.zmax >= zmin); // check that z projections overlap\n\t}", "language": "java", "code": "public boolean isIntersecting(Envelope3D other) {\n\t\treturn !isEmpty() && !other.isEmpty() && ((xmin <= other.xmin) ? xmax >= other.xmin : other.xmax >= xmin) && // check that x projections overlap\n\t\t\t((ymin <= other.ymin) ? ymax >= other.ymin : other.ymax >= ymin) && // check that y projections overlap\n\t\t\t((zmin <= other.zmin) ? zmax >= other.zmin : other.zmax >= zmin); // check that z projections overlap\n\t}", "code_tokens": ["public", "boolean", "isIntersecting", "(", "Envelope3D", "other", ")", "{", "return", "!", "isEmpty", "(", ")", "&&", "!", "other", ".", "isEmpty", "(", ")", "&&", "(", "(", "xmin", "<=", "other", ".", "xmin", ")", "?", "xmax", ">=", "other", ".", "xmin", ":", "other", ".", "xmax", ">=", "xmin", ")", "&&", "// check that x projections overlap", "(", "(", "ymin", "<=", "other", ".", "ymin", ")", "?", "ymax", ">=", "other", ".", "ymin", ":", "other", ".", "ymax", ">=", "ymin", ")", "&&", "// check that y projections overlap", "(", "(", "zmin", "<=", "other", ".", "zmin", ")", "?", "zmax", ">=", "other", ".", "zmin", ":", "other", ".", "zmax", ">=", "zmin", ")", ";", "// check that z projections overlap", "}"], "docstring": "Checks if this envelope intersects the other.\n\n@return True if this envelope intersects the other.", "docstring_tokens": ["Checks", "if", "this", "envelope", "intersects", "the", "other", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope3D.java#L254-L258", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope3D.java", "func_name": "Envelope3D.intersect", "original_string": "public boolean intersect(Envelope3D other) {\n\t\tif (isEmpty() || other.isEmpty())\n\t\t\treturn false;\n\n\t\tif (other.xmin > xmin)\n\t\t\txmin = other.xmin;\n\n\t\tif (other.xmax < xmax)\n\t\t\txmax = other.xmax;\n\n\t\tif (other.ymin > ymin)\n\t\t\tymin = other.ymin;\n\n\t\tif (other.ymax < ymax)\n\t\t\tymax = other.ymax;\n\n\t\tif (other.zmin > zmin)\n\t\t\tzmin = other.zmin;\n\n\t\tif (other.zmax < zmax)\n\t\t\tzmax = other.zmax;\n\n\t\tboolean bIntersecting = xmin <= xmax && ymin <= ymax && zmin <= zmax;\n\n\t\tif (!bIntersecting)\n\t\t\tsetEmpty();\n\n\t\treturn bIntersecting;\n\t}", "language": "java", "code": "public boolean intersect(Envelope3D other) {\n\t\tif (isEmpty() || other.isEmpty())\n\t\t\treturn false;\n\n\t\tif (other.xmin > xmin)\n\t\t\txmin = other.xmin;\n\n\t\tif (other.xmax < xmax)\n\t\t\txmax = other.xmax;\n\n\t\tif (other.ymin > ymin)\n\t\t\tymin = other.ymin;\n\n\t\tif (other.ymax < ymax)\n\t\t\tymax = other.ymax;\n\n\t\tif (other.zmin > zmin)\n\t\t\tzmin = other.zmin;\n\n\t\tif (other.zmax < zmax)\n\t\t\tzmax = other.zmax;\n\n\t\tboolean bIntersecting = xmin <= xmax && ymin <= ymax && zmin <= zmax;\n\n\t\tif (!bIntersecting)\n\t\t\tsetEmpty();\n\n\t\treturn bIntersecting;\n\t}", "code_tokens": ["public", "boolean", "intersect", "(", "Envelope3D", "other", ")", "{", "if", "(", "isEmpty", "(", ")", "||", "other", ".", "isEmpty", "(", ")", ")", "return", "false", ";", "if", "(", "other", ".", "xmin", ">", "xmin", ")", "xmin", "=", "other", ".", "xmin", ";", "if", "(", "other", ".", "xmax", "<", "xmax", ")", "xmax", "=", "other", ".", "xmax", ";", "if", "(", "other", ".", "ymin", ">", "ymin", ")", "ymin", "=", "other", ".", "ymin", ";", "if", "(", "other", ".", "ymax", "<", "ymax", ")", "ymax", "=", "other", ".", "ymax", ";", "if", "(", "other", ".", "zmin", ">", "zmin", ")", "zmin", "=", "other", ".", "zmin", ";", "if", "(", "other", ".", "zmax", "<", "zmax", ")", "zmax", "=", "other", ".", "zmax", ";", "boolean", "bIntersecting", "=", "xmin", "<=", "xmax", "&&", "ymin", "<=", "ymax", "&&", "zmin", "<=", "zmax", ";", "if", "(", "!", "bIntersecting", ")", "setEmpty", "(", ")", ";", "return", "bIntersecting", ";", "}"], "docstring": "Intersects this envelope with the other and stores result in this\nenvelope.\n\n@return True if this envelope intersects the other, otherwise sets this\nenvelope to empty state and returns False.", "docstring_tokens": ["Intersects", "this", "envelope", "with", "the", "other", "and", "stores", "result", "in", "this", "envelope", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope3D.java#L267-L295", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope3D.java", "func_name": "Envelope3D.contains", "original_string": "public boolean contains(Envelope3D other) {// Note: Will return False, if either envelope is empty.\n\t\treturn other.xmin >= xmin && other.xmax <= xmax && other.ymin >= ymin && other.ymax <= ymax && other.zmin >= zmin && other.zmax <= zmax;\n\t}", "language": "java", "code": "public boolean contains(Envelope3D other) {// Note: Will return False, if either envelope is empty.\n\t\treturn other.xmin >= xmin && other.xmax <= xmax && other.ymin >= ymin && other.ymax <= ymax && other.zmin >= zmin && other.zmax <= zmax;\n\t}", "code_tokens": ["public", "boolean", "contains", "(", "Envelope3D", "other", ")", "{", "// Note: Will return False, if either envelope is empty.", "return", "other", ".", "xmin", ">=", "xmin", "&&", "other", ".", "xmax", "<=", "xmax", "&&", "other", ".", "ymin", ">=", "ymin", "&&", "other", ".", "ymax", "<=", "ymax", "&&", "other", ".", "zmin", ">=", "zmin", "&&", "other", ".", "zmax", "<=", "zmax", ";", "}"], "docstring": "Returns True if the envelope contains the other envelope (boundary\ninclusive).", "docstring_tokens": ["Returns", "True", "if", "the", "envelope", "contains", "the", "other", "envelope", "(", "boundary", "inclusive", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope3D.java#L301-L303", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ECoordinate.java", "func_name": "ECoordinate.sin", "original_string": "void sin(ECoordinate angle) {\n\t\tdouble sinv = Math.sin(angle.m_value);\n\t\tdouble cosv = Math.cos(angle.m_value);\n\t\tm_value = sinv;\n\t\tdouble absv = Math.abs(sinv);\n\t\tm_eps = (Math.abs(cosv) + absv * 0.5 * angle.m_eps) * angle.m_eps\n\t\t\t\t+ epsCoordinate() * absv;\n\t}", "language": "java", "code": "void sin(ECoordinate angle) {\n\t\tdouble sinv = Math.sin(angle.m_value);\n\t\tdouble cosv = Math.cos(angle.m_value);\n\t\tm_value = sinv;\n\t\tdouble absv = Math.abs(sinv);\n\t\tm_eps = (Math.abs(cosv) + absv * 0.5 * angle.m_eps) * angle.m_eps\n\t\t\t\t+ epsCoordinate() * absv;\n\t}", "code_tokens": ["void", "sin", "(", "ECoordinate", "angle", ")", "{", "double", "sinv", "=", "Math", ".", "sin", "(", "angle", ".", "m_value", ")", ";", "double", "cosv", "=", "Math", ".", "cos", "(", "angle", ".", "m_value", ")", ";", "m_value", "=", "sinv", ";", "double", "absv", "=", "Math", ".", "abs", "(", "sinv", ")", ";", "m_eps", "=", "(", "Math", ".", "abs", "(", "cosv", ")", "+", "absv", "*", "0.5", "*", "angle", ".", "m_eps", ")", "*", "angle", ".", "m_eps", "+", "epsCoordinate", "(", ")", "*", "absv", ";", "}"], "docstring": "Assigns sin(angle) to this coordinate.", "docstring_tokens": ["Assigns", "sin", "(", "angle", ")", "to", "this", "coordinate", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ECoordinate.java#L271-L278", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ECoordinate.java", "func_name": "ECoordinate.log", "original_string": "void log(ECoordinate v) {\n\t\tdouble d = v.m_eps / v.m_value;\n\t\tm_value = Math.log(v.m_value);\n\t\tm_eps = d * (1.0 + 0.5 * d) + epsCoordinate() * Math.abs(m_value);\n\t}", "language": "java", "code": "void log(ECoordinate v) {\n\t\tdouble d = v.m_eps / v.m_value;\n\t\tm_value = Math.log(v.m_value);\n\t\tm_eps = d * (1.0 + 0.5 * d) + epsCoordinate() * Math.abs(m_value);\n\t}", "code_tokens": ["void", "log", "(", "ECoordinate", "v", ")", "{", "double", "d", "=", "v", ".", "m_eps", "/", "v", ".", "m_value", ";", "m_value", "=", "Math", ".", "log", "(", "v", ".", "m_value", ")", ";", "m_eps", "=", "d", "*", "(", "1.0", "+", "0.5", "*", "d", ")", "+", "epsCoordinate", "(", ")", "*", "Math", ".", "abs", "(", "m_value", ")", ";", "}"], "docstring": "Calculates natural log of v and assigns to this coordinate", "docstring_tokens": ["Calculates", "natural", "log", "of", "v", "and", "assigns", "to", "this", "coordinate"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ECoordinate.java#L291-L295", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ECoordinate.java", "func_name": "ECoordinate.eq", "original_string": "boolean eq(ECoordinate v) // ==\n\t{\n\t\treturn Math.abs(m_value - v.m_value) <= m_eps + v.m_eps;\n\t}", "language": "java", "code": "boolean eq(ECoordinate v) // ==\n\t{\n\t\treturn Math.abs(m_value - v.m_value) <= m_eps + v.m_eps;\n\t}", "code_tokens": ["boolean", "eq", "(", "ECoordinate", "v", ")", "// ==", "{", "return", "Math", ".", "abs", "(", "m_value", "-", "v", ".", "m_value", ")", "<=", "m_eps", "+", "v", ".", "m_eps", ";", "}"], "docstring": "ECoordinate atan();", "docstring_tokens": ["ECoordinate", "atan", "()", ";"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ECoordinate.java#L304-L307", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ECoordinate.java", "func_name": "ECoordinate.tolEq", "original_string": "boolean tolEq(ECoordinate v, double tolerance) // ! == with tolerance\n\t{\n\t\treturn Math.abs(m_value - v.m_value) <= tolerance || eq(v);\n\t}", "language": "java", "code": "boolean tolEq(ECoordinate v, double tolerance) // ! == with tolerance\n\t{\n\t\treturn Math.abs(m_value - v.m_value) <= tolerance || eq(v);\n\t}", "code_tokens": ["boolean", "tolEq", "(", "ECoordinate", "v", ",", "double", "tolerance", ")", "// ! == with tolerance", "{", "return", "Math", ".", "abs", "(", "m_value", "-", "v", ".", "m_value", ")", "<=", "tolerance", "||", "eq", "(", "v", ")", ";", "}"], "docstring": "user defined tolerance.", "docstring_tokens": ["user", "defined", "tolerance", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ECoordinate.java#L336-L339", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.addGeometry", "original_string": "void addGeometry(Geometry geometry) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn;\n\t\t\n\t\tint type = geometry.getType().value();\n\n\t\tif (MultiVertexGeometry.isMultiVertex(type))\n\t\t\taddMultiVertexGeometry_((MultiVertexGeometry) geometry);\n\t\telse if (MultiPath.isSegment(type))\n\t\t\taddSegment_((Segment) geometry);\n\t\telse if (type == Geometry.GeometryType.Envelope)\n\t\t\taddEnvelope_((Envelope) geometry);\n\t\telse if (type == Geometry.GeometryType.Point)\n\t\t\taddPoint_((Point) geometry);\n\t\telse\n\t\t\tthrow new IllegalArgumentException(\"invalid shape type\");\n\t}", "language": "java", "code": "void addGeometry(Geometry geometry) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn;\n\t\t\n\t\tint type = geometry.getType().value();\n\n\t\tif (MultiVertexGeometry.isMultiVertex(type))\n\t\t\taddMultiVertexGeometry_((MultiVertexGeometry) geometry);\n\t\telse if (MultiPath.isSegment(type))\n\t\t\taddSegment_((Segment) geometry);\n\t\telse if (type == Geometry.GeometryType.Envelope)\n\t\t\taddEnvelope_((Envelope) geometry);\n\t\telse if (type == Geometry.GeometryType.Point)\n\t\t\taddPoint_((Point) geometry);\n\t\telse\n\t\t\tthrow new IllegalArgumentException(\"invalid shape type\");\n\t}", "code_tokens": ["void", "addGeometry", "(", "Geometry", "geometry", ")", "{", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", ";", "int", "type", "=", "geometry", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "if", "(", "MultiVertexGeometry", ".", "isMultiVertex", "(", "type", ")", ")", "addMultiVertexGeometry_", "(", "(", "MultiVertexGeometry", ")", "geometry", ")", ";", "else", "if", "(", "MultiPath", ".", "isSegment", "(", "type", ")", ")", "addSegment_", "(", "(", "Segment", ")", "geometry", ")", ";", "else", "if", "(", "type", "==", "Geometry", ".", "GeometryType", ".", "Envelope", ")", "addEnvelope_", "(", "(", "Envelope", ")", "geometry", ")", ";", "else", "if", "(", "type", "==", "Geometry", ".", "GeometryType", ".", "Point", ")", "addPoint_", "(", "(", "Point", ")", "geometry", ")", ";", "else", "throw", "new", "IllegalArgumentException", "(", "\"invalid shape type\"", ")", ";", "}"], "docstring": "Adds a geometry to the current bounding geometry using an incremental algorithm for dynamic insertion.\n@param geometry The geometry to add to the bounding geometry.", "docstring_tokens": ["Adds", "a", "geometry", "to", "the", "current", "bounding", "geometry", "using", "an", "incremental", "algorithm", "for", "dynamic", "insertion", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L58-L74", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.getBoundingGeometry", "original_string": "Geometry getBoundingGeometry() {\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tPoint point = new Point();\n\t\tint first = m_tree_hull.getFirst(-1);\n\t\tPolygon hull = new Polygon(m_shape.getVertexDescription());\n\t\tif (m_tree_hull.size(-1) == 0)\n\t\t\treturn hull;\n\t\t\n\t\tm_shape.queryPoint(m_tree_hull.getElement(first), point);\n\t\thull.startPath(point);\n\n\t\tfor (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {\n\t\t\tm_shape.queryPoint(m_tree_hull.getElement(i), point);\n\t\t\thull.lineTo(point);\n\t\t}\n\n\t\treturn hull;\n\t}", "language": "java", "code": "Geometry getBoundingGeometry() {\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tPoint point = new Point();\n\t\tint first = m_tree_hull.getFirst(-1);\n\t\tPolygon hull = new Polygon(m_shape.getVertexDescription());\n\t\tif (m_tree_hull.size(-1) == 0)\n\t\t\treturn hull;\n\t\t\n\t\tm_shape.queryPoint(m_tree_hull.getElement(first), point);\n\t\thull.startPath(point);\n\n\t\tfor (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {\n\t\t\tm_shape.queryPoint(m_tree_hull.getElement(i), point);\n\t\t\thull.lineTo(point);\n\t\t}\n\n\t\treturn hull;\n\t}", "code_tokens": ["Geometry", "getBoundingGeometry", "(", ")", "{", "// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.", "Point", "point", "=", "new", "Point", "(", ")", ";", "int", "first", "=", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ";", "Polygon", "hull", "=", "new", "Polygon", "(", "m_shape", ".", "getVertexDescription", "(", ")", ")", ";", "if", "(", "m_tree_hull", ".", "size", "(", "-", "1", ")", "==", "0", ")", "return", "hull", ";", "m_shape", ".", "queryPoint", "(", "m_tree_hull", ".", "getElement", "(", "first", ")", ",", "point", ")", ";", "hull", ".", "startPath", "(", "point", ")", ";", "for", "(", "int", "i", "=", "m_tree_hull", ".", "getNext", "(", "first", ")", ";", "i", "!=", "-", "1", ";", "i", "=", "m_tree_hull", ".", "getNext", "(", "i", ")", ")", "{", "m_shape", ".", "queryPoint", "(", "m_tree_hull", ".", "getElement", "(", "i", ")", ",", "point", ")", ";", "hull", ".", "lineTo", "(", "point", ")", ";", "}", "return", "hull", ";", "}"], "docstring": "Gets the current bounding geometry.\nReturns a Geometry.", "docstring_tokens": ["Gets", "the", "current", "bounding", "geometry", ".", "Returns", "a", "Geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L81-L98", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.construct", "original_string": "static Geometry construct(MultiVertexGeometry mvg) {\n\t\tif (mvg.isEmpty())\n\t\t\treturn new Polygon(mvg.getDescription());\n\n\t\tMultiVertexGeometryImpl mvg_impl = (MultiVertexGeometryImpl) mvg._getImpl();\n\t\tint N = mvg_impl.getPointCount();\n\n\t\tif (N <= 2) {\n\t\t\tif (N == 1 || mvg_impl.getXY(0).equals(mvg_impl.getXY(1))) {\n\t\t\t\tPoint point = new Point(mvg_impl.getDescription());\n\t\t\t\tmvg_impl.getPointByVal(0, point);\n\t\t\t\treturn point;\n\t\t\t} else {\n\t\t\t\tPoint pt = new Point();\n\t\t\t\tPolyline polyline = new Polyline(mvg_impl.getDescription());\n\t\t\t\tmvg_impl.getPointByVal(0, pt);\n\t\t\t\tpolyline.startPath(pt);\n\t\t\t\tmvg_impl.getPointByVal(1, pt);\n\t\t\t\tpolyline.lineTo(pt);\n\t\t\t\treturn polyline;\n\t\t\t}\n\t\t}\n\n\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) mvg_impl.getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tConvexHull convex_hull = new ConvexHull(stream, N);\n\n\t\tint t0 = 0, tm = 1;\n\t\tPoint2D pt_0 = new Point2D();\n\t\tPoint2D pt_m = new Point2D();\n\t\tPoint2D pt_p = new Point2D();\n\n\t\tstream.read(t0 << 1, pt_0);\n\n\t\twhile (true) {\n\t\t\tif (tm >= N)\n\t\t\t\tbreak;\n\n\t\t\tstream.read(tm << 1, pt_m);\n\t\t\tif (!pt_m.isEqual(pt_0, NumberUtils.doubleEps()))\n\t\t\t\tbreak;\n\n\t\t\ttm++; // We don't want to close the gap between t0 and tm.\n\t\t}\n\n\t\tconvex_hull.m_tree_hull.addElement(t0, -1);\n\n\t\tif (tm < N) {\n\t\t\tconvex_hull.m_tree_hull.addBiggestElement(tm, -1);\n\n\t\t\tfor (int tp = tm + 1; tp < mvg_impl.getPointCount(); tp++) {// Dynamically insert into the current convex hull\n\n\t\t\t\tstream.read(tp << 1, pt_p);\n\t\t\t\tint p = convex_hull.treeHull_(pt_p);\n\n\t\t\t\tif (p != -1)\n\t\t\t\t\tconvex_hull.m_tree_hull.setElement(p, tp); // reset the place holder to the point index.\n\t\t\t}\n\t\t}\n\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\n\t\tVertexDescription description = mvg_impl.getDescription();\n\t\tboolean b_has_attributes = (description.getAttributeCount() > 1);\n\t\tint point_count = convex_hull.m_tree_hull.size(-1);\n\n\t\tGeometry hull;\n\n\t\tif (point_count >= 2) {\n\t\t\tif (point_count >= 3)\n\t\t\t\thull = new Polygon(description);\n\t\t\telse\n\t\t\t\thull = new Polyline(description);\n\n\t\t\tMultiPathImpl hull_impl = (MultiPathImpl) hull._getImpl();\n\t\t\thull_impl.addPath((Point2D[]) null, 0, true);\n\n\t\t\tPoint point = null;\n\t\t\tif (b_has_attributes)\n\t\t\t\tpoint = new Point();\n\n\t\t\tfor (int i = convex_hull.m_tree_hull.getFirst(-1); i != -1; i = convex_hull.m_tree_hull.getNext(i)) {\n\t\t\t\tif (b_has_attributes) {\n\t\t\t\t\tmvg_impl.getPointByVal(convex_hull.m_tree_hull.getElement(i), point);\n\t\t\t\t\thull_impl.insertPoint(0, -1, point);\n\t\t\t\t} else {\n\t\t\t\t\tstream.read(convex_hull.m_tree_hull.getElement(i) << 1, pt_p);\n\t\t\t\t\thull_impl.insertPoint(0, -1, pt_p);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert (point_count == 1);\n\n\t\t\tif (b_has_attributes) {\n\t\t\t\tPoint point = new Point(description);\n\t\t\t\tmvg_impl.getPointByVal(convex_hull.m_tree_hull.getElement(convex_hull.m_tree_hull.getFirst(-1)), point);\n\t\t\t\thull = point;\n\t\t\t} else {\n\t\t\t\tstream.read(convex_hull.m_tree_hull.getElement(convex_hull.m_tree_hull.getFirst(-1)) << 1, pt_p);\n\t\t\t\thull = new Point(pt_p);\n\t\t\t}\n\t\t}\n\n\t\treturn hull;\n\t}", "language": "java", "code": "static Geometry construct(MultiVertexGeometry mvg) {\n\t\tif (mvg.isEmpty())\n\t\t\treturn new Polygon(mvg.getDescription());\n\n\t\tMultiVertexGeometryImpl mvg_impl = (MultiVertexGeometryImpl) mvg._getImpl();\n\t\tint N = mvg_impl.getPointCount();\n\n\t\tif (N <= 2) {\n\t\t\tif (N == 1 || mvg_impl.getXY(0).equals(mvg_impl.getXY(1))) {\n\t\t\t\tPoint point = new Point(mvg_impl.getDescription());\n\t\t\t\tmvg_impl.getPointByVal(0, point);\n\t\t\t\treturn point;\n\t\t\t} else {\n\t\t\t\tPoint pt = new Point();\n\t\t\t\tPolyline polyline = new Polyline(mvg_impl.getDescription());\n\t\t\t\tmvg_impl.getPointByVal(0, pt);\n\t\t\t\tpolyline.startPath(pt);\n\t\t\t\tmvg_impl.getPointByVal(1, pt);\n\t\t\t\tpolyline.lineTo(pt);\n\t\t\t\treturn polyline;\n\t\t\t}\n\t\t}\n\n\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) mvg_impl.getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tConvexHull convex_hull = new ConvexHull(stream, N);\n\n\t\tint t0 = 0, tm = 1;\n\t\tPoint2D pt_0 = new Point2D();\n\t\tPoint2D pt_m = new Point2D();\n\t\tPoint2D pt_p = new Point2D();\n\n\t\tstream.read(t0 << 1, pt_0);\n\n\t\twhile (true) {\n\t\t\tif (tm >= N)\n\t\t\t\tbreak;\n\n\t\t\tstream.read(tm << 1, pt_m);\n\t\t\tif (!pt_m.isEqual(pt_0, NumberUtils.doubleEps()))\n\t\t\t\tbreak;\n\n\t\t\ttm++; // We don't want to close the gap between t0 and tm.\n\t\t}\n\n\t\tconvex_hull.m_tree_hull.addElement(t0, -1);\n\n\t\tif (tm < N) {\n\t\t\tconvex_hull.m_tree_hull.addBiggestElement(tm, -1);\n\n\t\t\tfor (int tp = tm + 1; tp < mvg_impl.getPointCount(); tp++) {// Dynamically insert into the current convex hull\n\n\t\t\t\tstream.read(tp << 1, pt_p);\n\t\t\t\tint p = convex_hull.treeHull_(pt_p);\n\n\t\t\t\tif (p != -1)\n\t\t\t\t\tconvex_hull.m_tree_hull.setElement(p, tp); // reset the place holder to the point index.\n\t\t\t}\n\t\t}\n\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\n\t\tVertexDescription description = mvg_impl.getDescription();\n\t\tboolean b_has_attributes = (description.getAttributeCount() > 1);\n\t\tint point_count = convex_hull.m_tree_hull.size(-1);\n\n\t\tGeometry hull;\n\n\t\tif (point_count >= 2) {\n\t\t\tif (point_count >= 3)\n\t\t\t\thull = new Polygon(description);\n\t\t\telse\n\t\t\t\thull = new Polyline(description);\n\n\t\t\tMultiPathImpl hull_impl = (MultiPathImpl) hull._getImpl();\n\t\t\thull_impl.addPath((Point2D[]) null, 0, true);\n\n\t\t\tPoint point = null;\n\t\t\tif (b_has_attributes)\n\t\t\t\tpoint = new Point();\n\n\t\t\tfor (int i = convex_hull.m_tree_hull.getFirst(-1); i != -1; i = convex_hull.m_tree_hull.getNext(i)) {\n\t\t\t\tif (b_has_attributes) {\n\t\t\t\t\tmvg_impl.getPointByVal(convex_hull.m_tree_hull.getElement(i), point);\n\t\t\t\t\thull_impl.insertPoint(0, -1, point);\n\t\t\t\t} else {\n\t\t\t\t\tstream.read(convex_hull.m_tree_hull.getElement(i) << 1, pt_p);\n\t\t\t\t\thull_impl.insertPoint(0, -1, pt_p);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert (point_count == 1);\n\n\t\t\tif (b_has_attributes) {\n\t\t\t\tPoint point = new Point(description);\n\t\t\t\tmvg_impl.getPointByVal(convex_hull.m_tree_hull.getElement(convex_hull.m_tree_hull.getFirst(-1)), point);\n\t\t\t\thull = point;\n\t\t\t} else {\n\t\t\t\tstream.read(convex_hull.m_tree_hull.getElement(convex_hull.m_tree_hull.getFirst(-1)) << 1, pt_p);\n\t\t\t\thull = new Point(pt_p);\n\t\t\t}\n\t\t}\n\n\t\treturn hull;\n\t}", "code_tokens": ["static", "Geometry", "construct", "(", "MultiVertexGeometry", "mvg", ")", "{", "if", "(", "mvg", ".", "isEmpty", "(", ")", ")", "return", "new", "Polygon", "(", "mvg", ".", "getDescription", "(", ")", ")", ";", "MultiVertexGeometryImpl", "mvg_impl", "=", "(", "MultiVertexGeometryImpl", ")", "mvg", ".", "_getImpl", "(", ")", ";", "int", "N", "=", "mvg_impl", ".", "getPointCount", "(", ")", ";", "if", "(", "N", "<=", "2", ")", "{", "if", "(", "N", "==", "1", "||", "mvg_impl", ".", "getXY", "(", "0", ")", ".", "equals", "(", "mvg_impl", ".", "getXY", "(", "1", ")", ")", ")", "{", "Point", "point", "=", "new", "Point", "(", "mvg_impl", ".", "getDescription", "(", ")", ")", ";", "mvg_impl", ".", "getPointByVal", "(", "0", ",", "point", ")", ";", "return", "point", ";", "}", "else", "{", "Point", "pt", "=", "new", "Point", "(", ")", ";", "Polyline", "polyline", "=", "new", "Polyline", "(", "mvg_impl", ".", "getDescription", "(", ")", ")", ";", "mvg_impl", ".", "getPointByVal", "(", "0", ",", "pt", ")", ";", "polyline", ".", "startPath", "(", "pt", ")", ";", "mvg_impl", ".", "getPointByVal", "(", "1", ",", "pt", ")", ";", "polyline", ".", "lineTo", "(", "pt", ")", ";", "return", "polyline", ";", "}", "}", "AttributeStreamOfDbl", "stream", "=", "(", "AttributeStreamOfDbl", ")", "mvg_impl", ".", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "ConvexHull", "convex_hull", "=", "new", "ConvexHull", "(", "stream", ",", "N", ")", ";", "int", "t0", "=", "0", ",", "tm", "=", "1", ";", "Point2D", "pt_0", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt_m", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt_p", "=", "new", "Point2D", "(", ")", ";", "stream", ".", "read", "(", "t0", "<<", "1", ",", "pt_0", ")", ";", "while", "(", "true", ")", "{", "if", "(", "tm", ">=", "N", ")", "break", ";", "stream", ".", "read", "(", "tm", "<<", "1", ",", "pt_m", ")", ";", "if", "(", "!", "pt_m", ".", "isEqual", "(", "pt_0", ",", "NumberUtils", ".", "doubleEps", "(", ")", ")", ")", "break", ";", "tm", "++", ";", "// We don't want to close the gap between t0 and tm.", "}", "convex_hull", ".", "m_tree_hull", ".", "addElement", "(", "t0", ",", "-", "1", ")", ";", "if", "(", "tm", "<", "N", ")", "{", "convex_hull", ".", "m_tree_hull", ".", "addBiggestElement", "(", "tm", ",", "-", "1", ")", ";", "for", "(", "int", "tp", "=", "tm", "+", "1", ";", "tp", "<", "mvg_impl", ".", "getPointCount", "(", ")", ";", "tp", "++", ")", "{", "// Dynamically insert into the current convex hull", "stream", ".", "read", "(", "tp", "<<", "1", ",", "pt_p", ")", ";", "int", "p", "=", "convex_hull", ".", "treeHull_", "(", "pt_p", ")", ";", "if", "(", "p", "!=", "-", "1", ")", "convex_hull", ".", "m_tree_hull", ".", "setElement", "(", "p", ",", "tp", ")", ";", "// reset the place holder to the point index.", "}", "}", "// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.", "VertexDescription", "description", "=", "mvg_impl", ".", "getDescription", "(", ")", ";", "boolean", "b_has_attributes", "=", "(", "description", ".", "getAttributeCount", "(", ")", ">", "1", ")", ";", "int", "point_count", "=", "convex_hull", ".", "m_tree_hull", ".", "size", "(", "-", "1", ")", ";", "Geometry", "hull", ";", "if", "(", "point_count", ">=", "2", ")", "{", "if", "(", "point_count", ">=", "3", ")", "hull", "=", "new", "Polygon", "(", "description", ")", ";", "else", "hull", "=", "new", "Polyline", "(", "description", ")", ";", "MultiPathImpl", "hull_impl", "=", "(", "MultiPathImpl", ")", "hull", ".", "_getImpl", "(", ")", ";", "hull_impl", ".", "addPath", "(", "(", "Point2D", "[", "]", ")", "null", ",", "0", ",", "true", ")", ";", "Point", "point", "=", "null", ";", "if", "(", "b_has_attributes", ")", "point", "=", "new", "Point", "(", ")", ";", "for", "(", "int", "i", "=", "convex_hull", ".", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ";", "i", "!=", "-", "1", ";", "i", "=", "convex_hull", ".", "m_tree_hull", ".", "getNext", "(", "i", ")", ")", "{", "if", "(", "b_has_attributes", ")", "{", "mvg_impl", ".", "getPointByVal", "(", "convex_hull", ".", "m_tree_hull", ".", "getElement", "(", "i", ")", ",", "point", ")", ";", "hull_impl", ".", "insertPoint", "(", "0", ",", "-", "1", ",", "point", ")", ";", "}", "else", "{", "stream", ".", "read", "(", "convex_hull", ".", "m_tree_hull", ".", "getElement", "(", "i", ")", "<<", "1", ",", "pt_p", ")", ";", "hull_impl", ".", "insertPoint", "(", "0", ",", "-", "1", ",", "pt_p", ")", ";", "}", "}", "}", "else", "{", "assert", "(", "point_count", "==", "1", ")", ";", "if", "(", "b_has_attributes", ")", "{", "Point", "point", "=", "new", "Point", "(", "description", ")", ";", "mvg_impl", ".", "getPointByVal", "(", "convex_hull", ".", "m_tree_hull", ".", "getElement", "(", "convex_hull", ".", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ")", ",", "point", ")", ";", "hull", "=", "point", ";", "}", "else", "{", "stream", ".", "read", "(", "convex_hull", ".", "m_tree_hull", ".", "getElement", "(", "convex_hull", ".", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ")", "<<", "1", ",", "pt_p", ")", ";", "hull", "=", "new", "Point", "(", "pt_p", ")", ";", "}", "}", "return", "hull", ";", "}"], "docstring": "Static method to construct the convex hull of a Multi_vertex_geometry.\nReturns a Geometry.\n\\param mvg The geometry used to create the convex hull.", "docstring_tokens": ["Static", "method", "to", "construct", "the", "convex", "hull", "of", "a", "Multi_vertex_geometry", ".", "Returns", "a", "Geometry", ".", "\\", "param", "mvg", "The", "geometry", "used", "to", "create", "the", "convex", "hull", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L106-L209", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.construct", "original_string": "static int construct(Point2D[] points, int count, int[] out_convex_hull) {\n\t\tConvexHull convex_hull = new ConvexHull(points, count);\n\n\t\tint t0 = 0, tm = 1;\n\t\tPoint2D pt_0 = points[t0];\n\n\t\twhile (tm < count && points[tm].isEqual(pt_0, NumberUtils.doubleEps()))\n\t\t\ttm++; // We don't want to close the gap between t0 and tm.\n\n\t\tconvex_hull.m_tree_hull.addElement(t0, -1);\n\n\t\tif (tm < count) {\n\t\t\tconvex_hull.m_tree_hull.addBiggestElement(tm, -1);\n\n\t\t\tfor (int tp = tm + 1; tp < count; tp++) {// Dynamically insert into the current convex hull.\n\n\t\t\t\tPoint2D pt_p = points[tp];\n\t\t\t\tint p = convex_hull.treeHull_(pt_p);\n\n\t\t\t\tif (p != -1)\n\t\t\t\t\tconvex_hull.m_tree_hull.setElement(p, tp); // reset the place holder to the point index.\n\t\t\t}\n\t\t}\n\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tint out_count = 0;\n\t\tfor (int i = convex_hull.m_tree_hull.getFirst(-1); i != -1; i = convex_hull.m_tree_hull.getNext(i))\n\t\t\tout_convex_hull[out_count++] = convex_hull.m_tree_hull.getElement(i);\n\n\t\treturn out_count;\n\t}", "language": "java", "code": "static int construct(Point2D[] points, int count, int[] out_convex_hull) {\n\t\tConvexHull convex_hull = new ConvexHull(points, count);\n\n\t\tint t0 = 0, tm = 1;\n\t\tPoint2D pt_0 = points[t0];\n\n\t\twhile (tm < count && points[tm].isEqual(pt_0, NumberUtils.doubleEps()))\n\t\t\ttm++; // We don't want to close the gap between t0 and tm.\n\n\t\tconvex_hull.m_tree_hull.addElement(t0, -1);\n\n\t\tif (tm < count) {\n\t\t\tconvex_hull.m_tree_hull.addBiggestElement(tm, -1);\n\n\t\t\tfor (int tp = tm + 1; tp < count; tp++) {// Dynamically insert into the current convex hull.\n\n\t\t\t\tPoint2D pt_p = points[tp];\n\t\t\t\tint p = convex_hull.treeHull_(pt_p);\n\n\t\t\t\tif (p != -1)\n\t\t\t\t\tconvex_hull.m_tree_hull.setElement(p, tp); // reset the place holder to the point index.\n\t\t\t}\n\t\t}\n\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tint out_count = 0;\n\t\tfor (int i = convex_hull.m_tree_hull.getFirst(-1); i != -1; i = convex_hull.m_tree_hull.getNext(i))\n\t\t\tout_convex_hull[out_count++] = convex_hull.m_tree_hull.getElement(i);\n\n\t\treturn out_count;\n\t}", "code_tokens": ["static", "int", "construct", "(", "Point2D", "[", "]", "points", ",", "int", "count", ",", "int", "[", "]", "out_convex_hull", ")", "{", "ConvexHull", "convex_hull", "=", "new", "ConvexHull", "(", "points", ",", "count", ")", ";", "int", "t0", "=", "0", ",", "tm", "=", "1", ";", "Point2D", "pt_0", "=", "points", "[", "t0", "]", ";", "while", "(", "tm", "<", "count", "&&", "points", "[", "tm", "]", ".", "isEqual", "(", "pt_0", ",", "NumberUtils", ".", "doubleEps", "(", ")", ")", ")", "tm", "++", ";", "// We don't want to close the gap between t0 and tm.", "convex_hull", ".", "m_tree_hull", ".", "addElement", "(", "t0", ",", "-", "1", ")", ";", "if", "(", "tm", "<", "count", ")", "{", "convex_hull", ".", "m_tree_hull", ".", "addBiggestElement", "(", "tm", ",", "-", "1", ")", ";", "for", "(", "int", "tp", "=", "tm", "+", "1", ";", "tp", "<", "count", ";", "tp", "++", ")", "{", "// Dynamically insert into the current convex hull.", "Point2D", "pt_p", "=", "points", "[", "tp", "]", ";", "int", "p", "=", "convex_hull", ".", "treeHull_", "(", "pt_p", ")", ";", "if", "(", "p", "!=", "-", "1", ")", "convex_hull", ".", "m_tree_hull", ".", "setElement", "(", "p", ",", "tp", ")", ";", "// reset the place holder to the point index.", "}", "}", "// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.", "int", "out_count", "=", "0", ";", "for", "(", "int", "i", "=", "convex_hull", ".", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ";", "i", "!=", "-", "1", ";", "i", "=", "convex_hull", ".", "m_tree_hull", ".", "getNext", "(", "i", ")", ")", "out_convex_hull", "[", "out_count", "++", "]", "=", "convex_hull", ".", "m_tree_hull", ".", "getElement", "(", "i", ")", ";", "return", "out_count", ";", "}"], "docstring": "Static method to construct the convex hull from an array of points. The\nout_convex_hull array will be populated with the subset of index\npositions which contribute to the convex hull.\nReturns the number of points in the convex hull.\n\\param points The points used to create the convex hull.\n\\param count The number of points in the input Point2D array.\n\\param out_convex_hull An index array allocated by the user at least as big as the size of the input points array.", "docstring_tokens": ["Static", "method", "to", "construct", "the", "convex", "hull", "from", "an", "array", "of", "points", ".", "The", "out_convex_hull", "array", "will", "be", "populated", "with", "the", "subset", "of", "index", "positions", "which", "contribute", "to", "the", "convex", "hull", ".", "Returns", "the", "number", "of", "points", "in", "the", "convex", "hull", ".", "\\", "param", "points", "The", "points", "used", "to", "create", "the", "convex", "hull", ".", "\\", "param", "count", "The", "number", "of", "points", "in", "the", "input", "Point2D", "array", ".", "\\", "param", "out_convex_hull", "An", "index", "array", "allocated", "by", "the", "user", "at", "least", "as", "big", "as", "the", "size", "of", "the", "input", "points", "array", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L220-L250", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.isPathConvex", "original_string": "static boolean isPathConvex(MultiPath multi_path, int path_index, ProgressTracker progress_tracker) {\n\t\tMultiPathImpl mimpl = (MultiPathImpl) multi_path._getImpl();\n\t\tint path_start = mimpl.getPathStart(path_index);\n\t\tint path_end = mimpl.getPathEnd(path_index);\n\n\t\tboolean bxyclosed = !mimpl.isClosedPath(path_index) && mimpl.isClosedPathInXYPlane(path_index);\n\n\t\tAttributeStreamOfDbl position = (AttributeStreamOfDbl) (mimpl.getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\t\tint position_start = 2 * path_start;\n\t\tint position_end = 2 * path_end;\n\n\t\tif (bxyclosed)\n\t\t\tposition_end -= 2;\n\n\t\tif (position_end - position_start < 6)\n\t\t\treturn true;\n\n\t\t// This matches the logic for case 1 of the tree hull algorithm. The idea is inductive. We assume we have a convex hull pt_0,...,pt_m, and we see if\n\t\t// a new point (pt_pivot) is among the transitive tournament for pt_0, knowing that pt_pivot comes after pt_m.\n\n\t\t// We check three conditions:\n\t\t// 1) pt_m->pt_pivot->pt_0 is clockwise (closure across the boundary is convex)\n\t\t// 2) pt_1->pt_pivot->pt_0 is clockwise (the first step forward is convex)  (pt_1 is the next point after pt_0)\n\t\t// 3) pt_m->pt_pivot->pt_m_prev is clockwise (the first step backwards is convex)  (pt_m_prev is the previous point before pt_m)\n\n\t\t// If all three of the above conditions are clockwise, then pt_pivot is among the transitive tournament for pt_0, and therefore the polygon pt_0, ..., pt_m, pt_pivot is convex.\n\n\t\tPoint2D pt_0 = new Point2D(), pt_m = new Point2D(), pt_pivot = new Point2D();\n\t\tposition.read(position_start, pt_0);\n\t\tposition.read(position_start + 2, pt_m);\n\t\tposition.read(position_start + 4, pt_pivot);\n\n\t\t// Initial inductive step\n\t\tECoordinate det_ec = determinant_(pt_m, pt_pivot, pt_0);\n\n\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\treturn false;\n\n\t\tPoint2D pt_1 = new Point2D(pt_m.x, pt_m.y);\n\t\tPoint2D pt_m_prev = new Point2D();\n\n\t\t// Assume that pt_0,...,pt_m is convex. Check if the next point, pt_pivot, maintains the convex invariant.\n\t\tfor (int i = position_start + 6; i < position_end; i += 2) {\n\t\t\tpt_m_prev.setCoords(pt_m);\n\t\t\tpt_m.setCoords(pt_pivot);\n\t\t\tposition.read(i, pt_pivot);\n\n\t\t\tdet_ec = determinant_(pt_m, pt_pivot, pt_0);\n\n\t\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\t\treturn false;\n\n\t\t\tdet_ec = determinant_(pt_1, pt_pivot, pt_0);\n\n\t\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\t\treturn false;\n\n\t\t\tdet_ec = determinant_(pt_m, pt_pivot, pt_m_prev);\n\n\t\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "language": "java", "code": "static boolean isPathConvex(MultiPath multi_path, int path_index, ProgressTracker progress_tracker) {\n\t\tMultiPathImpl mimpl = (MultiPathImpl) multi_path._getImpl();\n\t\tint path_start = mimpl.getPathStart(path_index);\n\t\tint path_end = mimpl.getPathEnd(path_index);\n\n\t\tboolean bxyclosed = !mimpl.isClosedPath(path_index) && mimpl.isClosedPathInXYPlane(path_index);\n\n\t\tAttributeStreamOfDbl position = (AttributeStreamOfDbl) (mimpl.getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\t\tint position_start = 2 * path_start;\n\t\tint position_end = 2 * path_end;\n\n\t\tif (bxyclosed)\n\t\t\tposition_end -= 2;\n\n\t\tif (position_end - position_start < 6)\n\t\t\treturn true;\n\n\t\t// This matches the logic for case 1 of the tree hull algorithm. The idea is inductive. We assume we have a convex hull pt_0,...,pt_m, and we see if\n\t\t// a new point (pt_pivot) is among the transitive tournament for pt_0, knowing that pt_pivot comes after pt_m.\n\n\t\t// We check three conditions:\n\t\t// 1) pt_m->pt_pivot->pt_0 is clockwise (closure across the boundary is convex)\n\t\t// 2) pt_1->pt_pivot->pt_0 is clockwise (the first step forward is convex)  (pt_1 is the next point after pt_0)\n\t\t// 3) pt_m->pt_pivot->pt_m_prev is clockwise (the first step backwards is convex)  (pt_m_prev is the previous point before pt_m)\n\n\t\t// If all three of the above conditions are clockwise, then pt_pivot is among the transitive tournament for pt_0, and therefore the polygon pt_0, ..., pt_m, pt_pivot is convex.\n\n\t\tPoint2D pt_0 = new Point2D(), pt_m = new Point2D(), pt_pivot = new Point2D();\n\t\tposition.read(position_start, pt_0);\n\t\tposition.read(position_start + 2, pt_m);\n\t\tposition.read(position_start + 4, pt_pivot);\n\n\t\t// Initial inductive step\n\t\tECoordinate det_ec = determinant_(pt_m, pt_pivot, pt_0);\n\n\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\treturn false;\n\n\t\tPoint2D pt_1 = new Point2D(pt_m.x, pt_m.y);\n\t\tPoint2D pt_m_prev = new Point2D();\n\n\t\t// Assume that pt_0,...,pt_m is convex. Check if the next point, pt_pivot, maintains the convex invariant.\n\t\tfor (int i = position_start + 6; i < position_end; i += 2) {\n\t\t\tpt_m_prev.setCoords(pt_m);\n\t\t\tpt_m.setCoords(pt_pivot);\n\t\t\tposition.read(i, pt_pivot);\n\n\t\t\tdet_ec = determinant_(pt_m, pt_pivot, pt_0);\n\n\t\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\t\treturn false;\n\n\t\t\tdet_ec = determinant_(pt_1, pt_pivot, pt_0);\n\n\t\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\t\treturn false;\n\n\t\t\tdet_ec = determinant_(pt_m, pt_pivot, pt_m_prev);\n\n\t\t\tif (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["static", "boolean", "isPathConvex", "(", "MultiPath", "multi_path", ",", "int", "path_index", ",", "ProgressTracker", "progress_tracker", ")", "{", "MultiPathImpl", "mimpl", "=", "(", "MultiPathImpl", ")", "multi_path", ".", "_getImpl", "(", ")", ";", "int", "path_start", "=", "mimpl", ".", "getPathStart", "(", "path_index", ")", ";", "int", "path_end", "=", "mimpl", ".", "getPathEnd", "(", "path_index", ")", ";", "boolean", "bxyclosed", "=", "!", "mimpl", ".", "isClosedPath", "(", "path_index", ")", "&&", "mimpl", ".", "isClosedPathInXYPlane", "(", "path_index", ")", ";", "AttributeStreamOfDbl", "position", "=", "(", "AttributeStreamOfDbl", ")", "(", "mimpl", ".", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ")", ";", "int", "position_start", "=", "2", "*", "path_start", ";", "int", "position_end", "=", "2", "*", "path_end", ";", "if", "(", "bxyclosed", ")", "position_end", "-=", "2", ";", "if", "(", "position_end", "-", "position_start", "<", "6", ")", "return", "true", ";", "// This matches the logic for case 1 of the tree hull algorithm. The idea is inductive. We assume we have a convex hull pt_0,...,pt_m, and we see if", "// a new point (pt_pivot) is among the transitive tournament for pt_0, knowing that pt_pivot comes after pt_m.", "// We check three conditions:", "// 1) pt_m->pt_pivot->pt_0 is clockwise (closure across the boundary is convex)", "// 2) pt_1->pt_pivot->pt_0 is clockwise (the first step forward is convex)  (pt_1 is the next point after pt_0)", "// 3) pt_m->pt_pivot->pt_m_prev is clockwise (the first step backwards is convex)  (pt_m_prev is the previous point before pt_m)", "// If all three of the above conditions are clockwise, then pt_pivot is among the transitive tournament for pt_0, and therefore the polygon pt_0, ..., pt_m, pt_pivot is convex.", "Point2D", "pt_0", "=", "new", "Point2D", "(", ")", ",", "pt_m", "=", "new", "Point2D", "(", ")", ",", "pt_pivot", "=", "new", "Point2D", "(", ")", ";", "position", ".", "read", "(", "position_start", ",", "pt_0", ")", ";", "position", ".", "read", "(", "position_start", "+", "2", ",", "pt_m", ")", ";", "position", ".", "read", "(", "position_start", "+", "4", ",", "pt_pivot", ")", ";", "// Initial inductive step", "ECoordinate", "det_ec", "=", "determinant_", "(", "pt_m", ",", "pt_pivot", ",", "pt_0", ")", ";", "if", "(", "det_ec", ".", "isFuzzyZero", "(", ")", "||", "!", "isClockwise_", "(", "det_ec", ".", "value", "(", ")", ")", ")", "return", "false", ";", "Point2D", "pt_1", "=", "new", "Point2D", "(", "pt_m", ".", "x", ",", "pt_m", ".", "y", ")", ";", "Point2D", "pt_m_prev", "=", "new", "Point2D", "(", ")", ";", "// Assume that pt_0,...,pt_m is convex. Check if the next point, pt_pivot, maintains the convex invariant.", "for", "(", "int", "i", "=", "position_start", "+", "6", ";", "i", "<", "position_end", ";", "i", "+=", "2", ")", "{", "pt_m_prev", ".", "setCoords", "(", "pt_m", ")", ";", "pt_m", ".", "setCoords", "(", "pt_pivot", ")", ";", "position", ".", "read", "(", "i", ",", "pt_pivot", ")", ";", "det_ec", "=", "determinant_", "(", "pt_m", ",", "pt_pivot", ",", "pt_0", ")", ";", "if", "(", "det_ec", ".", "isFuzzyZero", "(", ")", "||", "!", "isClockwise_", "(", "det_ec", ".", "value", "(", ")", ")", ")", "return", "false", ";", "det_ec", "=", "determinant_", "(", "pt_1", ",", "pt_pivot", ",", "pt_0", ")", ";", "if", "(", "det_ec", ".", "isFuzzyZero", "(", ")", "||", "!", "isClockwise_", "(", "det_ec", ".", "value", "(", ")", ")", ")", "return", "false", ";", "det_ec", "=", "determinant_", "(", "pt_m", ",", "pt_pivot", ",", "pt_m_prev", ")", ";", "if", "(", "det_ec", ".", "isFuzzyZero", "(", ")", "||", "!", "isClockwise_", "(", "det_ec", ".", "value", "(", ")", ")", ")", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Returns true if the given path of the input MultiPath is convex. Returns false otherwise.\n\\param multi_path The MultiPath to check if the path is convex.\n\\param path_index The path of the MultiPath to check if its convex.", "docstring_tokens": ["Returns", "true", "if", "the", "given", "path", "of", "the", "input", "MultiPath", "is", "convex", ".", "Returns", "false", "otherwise", ".", "\\", "param", "multi_path", "The", "MultiPath", "to", "check", "if", "the", "path", "is", "convex", ".", "\\", "param", "path_index", "The", "path", "of", "the", "MultiPath", "to", "check", "if", "its", "convex", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L257-L321", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.addMultiVertexGeometry_", "original_string": "private void addMultiVertexGeometry_(MultiVertexGeometry mvg) {\n\t\tPoint point = new Point();\n\t\tPoint2D pt_p = new Point2D();\n\n\t\tfor (int i = 0; i < mvg.getPointCount(); i++) {\n\t\t\tmvg.getXY(i, pt_p);\n\t\t\tint p = addPoint_(pt_p);\n\n\t\t\tif (p != -1) {\n\t\t\t\tmvg.getPointByVal(i, point);\n\t\t\t\tint tp = m_shape.addPoint(m_path_handle, point);\n\t\t\t\tm_tree_hull.setElement(p, tp); // reset the place holder to tp\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "private void addMultiVertexGeometry_(MultiVertexGeometry mvg) {\n\t\tPoint point = new Point();\n\t\tPoint2D pt_p = new Point2D();\n\n\t\tfor (int i = 0; i < mvg.getPointCount(); i++) {\n\t\t\tmvg.getXY(i, pt_p);\n\t\t\tint p = addPoint_(pt_p);\n\n\t\t\tif (p != -1) {\n\t\t\t\tmvg.getPointByVal(i, point);\n\t\t\t\tint tp = m_shape.addPoint(m_path_handle, point);\n\t\t\t\tm_tree_hull.setElement(p, tp); // reset the place holder to tp\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "addMultiVertexGeometry_", "(", "MultiVertexGeometry", "mvg", ")", "{", "Point", "point", "=", "new", "Point", "(", ")", ";", "Point2D", "pt_p", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "mvg", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "mvg", ".", "getXY", "(", "i", ",", "pt_p", ")", ";", "int", "p", "=", "addPoint_", "(", "pt_p", ")", ";", "if", "(", "p", "!=", "-", "1", ")", "{", "mvg", ".", "getPointByVal", "(", "i", ",", "point", ")", ";", "int", "tp", "=", "m_shape", ".", "addPoint", "(", "m_path_handle", ",", "point", ")", ";", "m_tree_hull", ".", "setElement", "(", "p", ",", "tp", ")", ";", "// reset the place holder to tp", "}", "}", "}"], "docstring": "Dynamically inserts each geometry into the convex hull.", "docstring_tokens": ["Dynamically", "inserts", "each", "geometry", "into", "the", "convex", "hull", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L324-L338", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.treeHull_", "original_string": "private int treeHull_(Point2D pt_pivot) {\n\t\tassert (m_tree_hull.size(-1) >= 2);\n\n\t\tint p = -1;\n\n\t\tdo {\n\t\t\tint first = m_tree_hull.getFirst(-1);\n\t\t\tint last = m_tree_hull.getLast(-1);\n\t\t\tint t0 = m_tree_hull.getElement(first);\n\t\t\tint tm = m_tree_hull.getElement(last);\n\n\t\t\tPoint2D pt_0 = new Point2D(); // should the memory be cached?\n\t\t\tPoint2D pt_m = new Point2D(); // should the memory be cached?\n\t\t\tm_call_back.getXY(t0, pt_0);\n\t\t\tm_call_back.getXY(tm, pt_m);\n\n\t\t\tassert (!pt_0.isEqual(pt_m, NumberUtils.doubleEps())); // assert that the gap is not closed\n\n\t\t\tint orient_m_p_0 = Point2D.orientationRobust(pt_m, pt_pivot, pt_0); // determines case 1, 2, 3\n\n\t\t\tif (isClockwise_(orient_m_p_0)) {// Case 1: tp->t0->tm is clockwise\n\n\t\t\t\tp = m_tree_hull.addBiggestElement(-1, -1); // set place holder to -1 for case 1.\n\t\t\t\tint l = treeHullWalkBackward_(pt_pivot, last, first);\n\n\t\t\t\tif (l != first)\n\t\t\t\t\ttreeHullWalkForward_(pt_pivot, first, m_tree_hull.getPrev(l));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isCounterClockwise_(orient_m_p_0)) {// Case 2: tp->tm->t0 is clockwise\n\t\t\t\tint k = m_tree_hull.getRoot(-1), k_min = m_tree_hull.getFirst(-1), k_max = m_tree_hull.getLast(-1), k_prev;\n\t\t\t\tint tk, tk_prev;\n\t\t\t\tPoint2D pt_k = new Point2D();\n\t\t\t\tPoint2D pt_k_prev = new Point2D();\n\n\t\t\t\twhile (k_min != m_tree_hull.getPrev(k_max)) {// binary search to find k such that t0->tp->tj holds (i.e. clockwise) for j >= k. Hence, tj->tp->t0 is clockwise (or degenerate) for j < k.\n\t\t\t\t\ttk = m_tree_hull.getElement(k);\n\t\t\t\t\tm_call_back.getXY(tk, pt_k);\n\t\t\t\t\tint orient_k_p_0 = Point2D.orientationRobust(pt_k, pt_pivot, pt_0);\n\n\t\t\t\t\tif (isCounterClockwise_(orient_k_p_0)) {\n\t\t\t\t\t\tk_max = k;\n\t\t\t\t\t\tk = m_tree_hull.getLeft(k);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk_min = k;\n\t\t\t\t\t\tk = m_tree_hull.getRight(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk = k_max;\n\t\t\t\tk_prev = k_min;\n\t\t\t\ttk = m_tree_hull.getElement(k);\n\t\t\t\ttk_prev = m_tree_hull.getElement(k_prev);\n\t\t\t\tm_call_back.getXY(tk, pt_k);\n\t\t\t\tm_call_back.getXY(tk_prev, pt_k_prev);\n\t\t\t\tassert (isCounterClockwise_(Point2D.orientationRobust(pt_k, pt_pivot, pt_0)) && !isCounterClockwise_(Point2D.orientationRobust(pt_k_prev, pt_pivot, pt_0)));\n\t\t\t\tassert (k_prev != first || isCounterClockwise_(Point2D.orientationRobust(pt_k, pt_pivot, pt_0)));\n\n\t\t\t\tif (k_prev != first) {\n\t\t\t\t\tint orient_k_prev_p_k = Point2D.orientationRobust(pt_k_prev, pt_pivot, pt_k);\n\n\t\t\t\t\tif (!isClockwise_(orient_k_prev_p_k))\n\t\t\t\t\t\tcontinue; // pt_pivot is inside the hull (or on the boundary)\n\t\t\t\t}\n\n\t\t\t\tp = m_tree_hull.addElementAtPosition(k_prev, k, -2, true, false, -1); // set place holder to -2 for case 2.\n\t\t\t\ttreeHullWalkForward_(pt_pivot, k, last);\n\t\t\t\ttreeHullWalkBackward_(pt_pivot, k_prev, first);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tassert (isDegenerate_(orient_m_p_0));\n\t\t\t{// Case 3: degenerate\n\t\t\t\tint between = isBetween_(pt_pivot, pt_m, pt_0);\n\n\t\t\t\tif (between == -1) {\n\t\t\t\t\tint l = m_tree_hull.getPrev(last);\n\t\t\t\t\tm_tree_hull.deleteNode(last, -1);\n\t\t\t\t\tp = m_tree_hull.addBiggestElement(-3, -1); // set place holder to -3 for case 3.\n\t\t\t\t\ttreeHullWalkBackward_(pt_pivot, l, first);\n\t\t\t\t} else if (between == 1) {\n\t\t\t\t\tint j = m_tree_hull.getNext(first);\n\t\t\t\t\tm_tree_hull.deleteNode(first, -1);\n\t\t\t\t\tp = m_tree_hull.addElementAtPosition(-1, j, -3, true, false, -1); // set place holder to -3 for case 3.\n\t\t\t\t\ttreeHullWalkForward_(pt_pivot, j, last);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t} while (false);\n\n\t\treturn p;\n\t}", "language": "java", "code": "private int treeHull_(Point2D pt_pivot) {\n\t\tassert (m_tree_hull.size(-1) >= 2);\n\n\t\tint p = -1;\n\n\t\tdo {\n\t\t\tint first = m_tree_hull.getFirst(-1);\n\t\t\tint last = m_tree_hull.getLast(-1);\n\t\t\tint t0 = m_tree_hull.getElement(first);\n\t\t\tint tm = m_tree_hull.getElement(last);\n\n\t\t\tPoint2D pt_0 = new Point2D(); // should the memory be cached?\n\t\t\tPoint2D pt_m = new Point2D(); // should the memory be cached?\n\t\t\tm_call_back.getXY(t0, pt_0);\n\t\t\tm_call_back.getXY(tm, pt_m);\n\n\t\t\tassert (!pt_0.isEqual(pt_m, NumberUtils.doubleEps())); // assert that the gap is not closed\n\n\t\t\tint orient_m_p_0 = Point2D.orientationRobust(pt_m, pt_pivot, pt_0); // determines case 1, 2, 3\n\n\t\t\tif (isClockwise_(orient_m_p_0)) {// Case 1: tp->t0->tm is clockwise\n\n\t\t\t\tp = m_tree_hull.addBiggestElement(-1, -1); // set place holder to -1 for case 1.\n\t\t\t\tint l = treeHullWalkBackward_(pt_pivot, last, first);\n\n\t\t\t\tif (l != first)\n\t\t\t\t\ttreeHullWalkForward_(pt_pivot, first, m_tree_hull.getPrev(l));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isCounterClockwise_(orient_m_p_0)) {// Case 2: tp->tm->t0 is clockwise\n\t\t\t\tint k = m_tree_hull.getRoot(-1), k_min = m_tree_hull.getFirst(-1), k_max = m_tree_hull.getLast(-1), k_prev;\n\t\t\t\tint tk, tk_prev;\n\t\t\t\tPoint2D pt_k = new Point2D();\n\t\t\t\tPoint2D pt_k_prev = new Point2D();\n\n\t\t\t\twhile (k_min != m_tree_hull.getPrev(k_max)) {// binary search to find k such that t0->tp->tj holds (i.e. clockwise) for j >= k. Hence, tj->tp->t0 is clockwise (or degenerate) for j < k.\n\t\t\t\t\ttk = m_tree_hull.getElement(k);\n\t\t\t\t\tm_call_back.getXY(tk, pt_k);\n\t\t\t\t\tint orient_k_p_0 = Point2D.orientationRobust(pt_k, pt_pivot, pt_0);\n\n\t\t\t\t\tif (isCounterClockwise_(orient_k_p_0)) {\n\t\t\t\t\t\tk_max = k;\n\t\t\t\t\t\tk = m_tree_hull.getLeft(k);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk_min = k;\n\t\t\t\t\t\tk = m_tree_hull.getRight(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk = k_max;\n\t\t\t\tk_prev = k_min;\n\t\t\t\ttk = m_tree_hull.getElement(k);\n\t\t\t\ttk_prev = m_tree_hull.getElement(k_prev);\n\t\t\t\tm_call_back.getXY(tk, pt_k);\n\t\t\t\tm_call_back.getXY(tk_prev, pt_k_prev);\n\t\t\t\tassert (isCounterClockwise_(Point2D.orientationRobust(pt_k, pt_pivot, pt_0)) && !isCounterClockwise_(Point2D.orientationRobust(pt_k_prev, pt_pivot, pt_0)));\n\t\t\t\tassert (k_prev != first || isCounterClockwise_(Point2D.orientationRobust(pt_k, pt_pivot, pt_0)));\n\n\t\t\t\tif (k_prev != first) {\n\t\t\t\t\tint orient_k_prev_p_k = Point2D.orientationRobust(pt_k_prev, pt_pivot, pt_k);\n\n\t\t\t\t\tif (!isClockwise_(orient_k_prev_p_k))\n\t\t\t\t\t\tcontinue; // pt_pivot is inside the hull (or on the boundary)\n\t\t\t\t}\n\n\t\t\t\tp = m_tree_hull.addElementAtPosition(k_prev, k, -2, true, false, -1); // set place holder to -2 for case 2.\n\t\t\t\ttreeHullWalkForward_(pt_pivot, k, last);\n\t\t\t\ttreeHullWalkBackward_(pt_pivot, k_prev, first);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tassert (isDegenerate_(orient_m_p_0));\n\t\t\t{// Case 3: degenerate\n\t\t\t\tint between = isBetween_(pt_pivot, pt_m, pt_0);\n\n\t\t\t\tif (between == -1) {\n\t\t\t\t\tint l = m_tree_hull.getPrev(last);\n\t\t\t\t\tm_tree_hull.deleteNode(last, -1);\n\t\t\t\t\tp = m_tree_hull.addBiggestElement(-3, -1); // set place holder to -3 for case 3.\n\t\t\t\t\ttreeHullWalkBackward_(pt_pivot, l, first);\n\t\t\t\t} else if (between == 1) {\n\t\t\t\t\tint j = m_tree_hull.getNext(first);\n\t\t\t\t\tm_tree_hull.deleteNode(first, -1);\n\t\t\t\t\tp = m_tree_hull.addElementAtPosition(-1, j, -3, true, false, -1); // set place holder to -3 for case 3.\n\t\t\t\t\ttreeHullWalkForward_(pt_pivot, j, last);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t} while (false);\n\n\t\treturn p;\n\t}", "code_tokens": ["private", "int", "treeHull_", "(", "Point2D", "pt_pivot", ")", "{", "assert", "(", "m_tree_hull", ".", "size", "(", "-", "1", ")", ">=", "2", ")", ";", "int", "p", "=", "-", "1", ";", "do", "{", "int", "first", "=", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ";", "int", "last", "=", "m_tree_hull", ".", "getLast", "(", "-", "1", ")", ";", "int", "t0", "=", "m_tree_hull", ".", "getElement", "(", "first", ")", ";", "int", "tm", "=", "m_tree_hull", ".", "getElement", "(", "last", ")", ";", "Point2D", "pt_0", "=", "new", "Point2D", "(", ")", ";", "// should the memory be cached?", "Point2D", "pt_m", "=", "new", "Point2D", "(", ")", ";", "// should the memory be cached?", "m_call_back", ".", "getXY", "(", "t0", ",", "pt_0", ")", ";", "m_call_back", ".", "getXY", "(", "tm", ",", "pt_m", ")", ";", "assert", "(", "!", "pt_0", ".", "isEqual", "(", "pt_m", ",", "NumberUtils", ".", "doubleEps", "(", ")", ")", ")", ";", "// assert that the gap is not closed", "int", "orient_m_p_0", "=", "Point2D", ".", "orientationRobust", "(", "pt_m", ",", "pt_pivot", ",", "pt_0", ")", ";", "// determines case 1, 2, 3", "if", "(", "isClockwise_", "(", "orient_m_p_0", ")", ")", "{", "// Case 1: tp->t0->tm is clockwise", "p", "=", "m_tree_hull", ".", "addBiggestElement", "(", "-", "1", ",", "-", "1", ")", ";", "// set place holder to -1 for case 1.", "int", "l", "=", "treeHullWalkBackward_", "(", "pt_pivot", ",", "last", ",", "first", ")", ";", "if", "(", "l", "!=", "first", ")", "treeHullWalkForward_", "(", "pt_pivot", ",", "first", ",", "m_tree_hull", ".", "getPrev", "(", "l", ")", ")", ";", "continue", ";", "}", "if", "(", "isCounterClockwise_", "(", "orient_m_p_0", ")", ")", "{", "// Case 2: tp->tm->t0 is clockwise", "int", "k", "=", "m_tree_hull", ".", "getRoot", "(", "-", "1", ")", ",", "k_min", "=", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ",", "k_max", "=", "m_tree_hull", ".", "getLast", "(", "-", "1", ")", ",", "k_prev", ";", "int", "tk", ",", "tk_prev", ";", "Point2D", "pt_k", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt_k_prev", "=", "new", "Point2D", "(", ")", ";", "while", "(", "k_min", "!=", "m_tree_hull", ".", "getPrev", "(", "k_max", ")", ")", "{", "// binary search to find k such that t0->tp->tj holds (i.e. clockwise) for j >= k. Hence, tj->tp->t0 is clockwise (or degenerate) for j < k.", "tk", "=", "m_tree_hull", ".", "getElement", "(", "k", ")", ";", "m_call_back", ".", "getXY", "(", "tk", ",", "pt_k", ")", ";", "int", "orient_k_p_0", "=", "Point2D", ".", "orientationRobust", "(", "pt_k", ",", "pt_pivot", ",", "pt_0", ")", ";", "if", "(", "isCounterClockwise_", "(", "orient_k_p_0", ")", ")", "{", "k_max", "=", "k", ";", "k", "=", "m_tree_hull", ".", "getLeft", "(", "k", ")", ";", "}", "else", "{", "k_min", "=", "k", ";", "k", "=", "m_tree_hull", ".", "getRight", "(", "k", ")", ";", "}", "}", "k", "=", "k_max", ";", "k_prev", "=", "k_min", ";", "tk", "=", "m_tree_hull", ".", "getElement", "(", "k", ")", ";", "tk_prev", "=", "m_tree_hull", ".", "getElement", "(", "k_prev", ")", ";", "m_call_back", ".", "getXY", "(", "tk", ",", "pt_k", ")", ";", "m_call_back", ".", "getXY", "(", "tk_prev", ",", "pt_k_prev", ")", ";", "assert", "(", "isCounterClockwise_", "(", "Point2D", ".", "orientationRobust", "(", "pt_k", ",", "pt_pivot", ",", "pt_0", ")", ")", "&&", "!", "isCounterClockwise_", "(", "Point2D", ".", "orientationRobust", "(", "pt_k_prev", ",", "pt_pivot", ",", "pt_0", ")", ")", ")", ";", "assert", "(", "k_prev", "!=", "first", "||", "isCounterClockwise_", "(", "Point2D", ".", "orientationRobust", "(", "pt_k", ",", "pt_pivot", ",", "pt_0", ")", ")", ")", ";", "if", "(", "k_prev", "!=", "first", ")", "{", "int", "orient_k_prev_p_k", "=", "Point2D", ".", "orientationRobust", "(", "pt_k_prev", ",", "pt_pivot", ",", "pt_k", ")", ";", "if", "(", "!", "isClockwise_", "(", "orient_k_prev_p_k", ")", ")", "continue", ";", "// pt_pivot is inside the hull (or on the boundary)", "}", "p", "=", "m_tree_hull", ".", "addElementAtPosition", "(", "k_prev", ",", "k", ",", "-", "2", ",", "true", ",", "false", ",", "-", "1", ")", ";", "// set place holder to -2 for case 2.", "treeHullWalkForward_", "(", "pt_pivot", ",", "k", ",", "last", ")", ";", "treeHullWalkBackward_", "(", "pt_pivot", ",", "k_prev", ",", "first", ")", ";", "continue", ";", "}", "assert", "(", "isDegenerate_", "(", "orient_m_p_0", ")", ")", ";", "{", "// Case 3: degenerate", "int", "between", "=", "isBetween_", "(", "pt_pivot", ",", "pt_m", ",", "pt_0", ")", ";", "if", "(", "between", "==", "-", "1", ")", "{", "int", "l", "=", "m_tree_hull", ".", "getPrev", "(", "last", ")", ";", "m_tree_hull", ".", "deleteNode", "(", "last", ",", "-", "1", ")", ";", "p", "=", "m_tree_hull", ".", "addBiggestElement", "(", "-", "3", ",", "-", "1", ")", ";", "// set place holder to -3 for case 3.", "treeHullWalkBackward_", "(", "pt_pivot", ",", "l", ",", "first", ")", ";", "}", "else", "if", "(", "between", "==", "1", ")", "{", "int", "j", "=", "m_tree_hull", ".", "getNext", "(", "first", ")", ";", "m_tree_hull", ".", "deleteNode", "(", "first", ",", "-", "1", ")", ";", "p", "=", "m_tree_hull", ".", "addElementAtPosition", "(", "-", "1", ",", "j", ",", "-", "3", ",", "true", ",", "false", ",", "-", "1", ")", ";", "// set place holder to -3 for case 3.", "treeHullWalkForward_", "(", "pt_pivot", ",", "j", ",", "last", ")", ";", "}", "continue", ";", "}", "}", "while", "(", "false", ")", ";", "return", "p", ";", "}"], "docstring": "Algorithm taken from \"Axioms and Hulls\" by D.E. Knuth, Lecture Notes in Computer Science 606, page 47.", "docstring_tokens": ["Algorithm", "taken", "from", "Axioms", "and", "Hulls", "by", "D", ".", "E", ".", "Knuth", "Lecture", "Notes", "in", "Computer", "Science", "606", "page", "47", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L413-L509", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.determinant_", "original_string": "private static ECoordinate determinant_(Point2D p, Point2D q, Point2D r) {\n\t\tECoordinate det_ec = new ECoordinate();\n\t\tdet_ec.set(q.x);\n\t\tdet_ec.sub(p.x);\n\n\t\tECoordinate rp_y_ec = new ECoordinate();\n\t\trp_y_ec.set(r.y);\n\t\trp_y_ec.sub(p.y);\n\n\t\tECoordinate qp_y_ec = new ECoordinate();\n\t\tqp_y_ec.set(q.y);\n\t\tqp_y_ec.sub(p.y);\n\n\t\tECoordinate rp_x_ec = new ECoordinate();\n\t\trp_x_ec.set(r.x);\n\t\trp_x_ec.sub(p.x);\n\n\t\tdet_ec.mul(rp_y_ec);\n\t\tqp_y_ec.mul(rp_x_ec);\n\t\tdet_ec.sub(qp_y_ec);\n\t\treturn det_ec;\n\t}", "language": "java", "code": "private static ECoordinate determinant_(Point2D p, Point2D q, Point2D r) {\n\t\tECoordinate det_ec = new ECoordinate();\n\t\tdet_ec.set(q.x);\n\t\tdet_ec.sub(p.x);\n\n\t\tECoordinate rp_y_ec = new ECoordinate();\n\t\trp_y_ec.set(r.y);\n\t\trp_y_ec.sub(p.y);\n\n\t\tECoordinate qp_y_ec = new ECoordinate();\n\t\tqp_y_ec.set(q.y);\n\t\tqp_y_ec.sub(p.y);\n\n\t\tECoordinate rp_x_ec = new ECoordinate();\n\t\trp_x_ec.set(r.x);\n\t\trp_x_ec.sub(p.x);\n\n\t\tdet_ec.mul(rp_y_ec);\n\t\tqp_y_ec.mul(rp_x_ec);\n\t\tdet_ec.sub(qp_y_ec);\n\t\treturn det_ec;\n\t}", "code_tokens": ["private", "static", "ECoordinate", "determinant_", "(", "Point2D", "p", ",", "Point2D", "q", ",", "Point2D", "r", ")", "{", "ECoordinate", "det_ec", "=", "new", "ECoordinate", "(", ")", ";", "det_ec", ".", "set", "(", "q", ".", "x", ")", ";", "det_ec", ".", "sub", "(", "p", ".", "x", ")", ";", "ECoordinate", "rp_y_ec", "=", "new", "ECoordinate", "(", ")", ";", "rp_y_ec", ".", "set", "(", "r", ".", "y", ")", ";", "rp_y_ec", ".", "sub", "(", "p", ".", "y", ")", ";", "ECoordinate", "qp_y_ec", "=", "new", "ECoordinate", "(", ")", ";", "qp_y_ec", ".", "set", "(", "q", ".", "y", ")", ";", "qp_y_ec", ".", "sub", "(", "p", ".", "y", ")", ";", "ECoordinate", "rp_x_ec", "=", "new", "ECoordinate", "(", ")", ";", "rp_x_ec", ".", "set", "(", "r", ".", "x", ")", ";", "rp_x_ec", ".", "sub", "(", "p", ".", "x", ")", ";", "det_ec", ".", "mul", "(", "rp_y_ec", ")", ";", "qp_y_ec", ".", "mul", "(", "rp_x_ec", ")", ";", "det_ec", ".", "sub", "(", "qp_y_ec", ")", ";", "return", "det_ec", ";", "}"], "docstring": "Orientation predicates", "docstring_tokens": ["Orientation", "predicates"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L576-L597", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point.getXY", "original_string": "public final Point2D getXY() {\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"This operation should not be performed on an empty geometry.\");\n\n\t\tPoint2D pt = new Point2D();\n\t\tpt.setCoords(m_attributes[0], m_attributes[1]);\n\t\treturn pt;\n\t}", "language": "java", "code": "public final Point2D getXY() {\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"This operation should not be performed on an empty geometry.\");\n\n\t\tPoint2D pt = new Point2D();\n\t\tpt.setCoords(m_attributes[0], m_attributes[1]);\n\t\treturn pt;\n\t}", "code_tokens": ["public", "final", "Point2D", "getXY", "(", ")", "{", "if", "(", "isEmptyImpl", "(", ")", ")", "throw", "new", "GeometryException", "(", "\"This operation should not be performed on an empty geometry.\"", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "pt", ".", "setCoords", "(", "m_attributes", "[", "0", "]", ",", "m_attributes", "[", "1", "]", ")", ";", "return", "pt", ";", "}"], "docstring": "Returns XY coordinates of this point.", "docstring_tokens": ["Returns", "XY", "coordinates", "of", "this", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L100-L108", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point.getXYZ", "original_string": "public Point3D getXYZ() {\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"This operation should not be performed on an empty geometry.\");\n\n\t\tPoint3D pt = new Point3D();\n\t\tpt.x = m_attributes[0];\n\t\tpt.y = m_attributes[1];\n\t\tif (m_description.hasZ())\n\t\t\tpt.z = m_attributes[2];\n\t\telse\n\t\t\tpt.z = VertexDescription.getDefaultValue(Semantics.Z);\n\n\t\treturn pt;\n\t}", "language": "java", "code": "public Point3D getXYZ() {\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"This operation should not be performed on an empty geometry.\");\n\n\t\tPoint3D pt = new Point3D();\n\t\tpt.x = m_attributes[0];\n\t\tpt.y = m_attributes[1];\n\t\tif (m_description.hasZ())\n\t\t\tpt.z = m_attributes[2];\n\t\telse\n\t\t\tpt.z = VertexDescription.getDefaultValue(Semantics.Z);\n\n\t\treturn pt;\n\t}", "code_tokens": ["public", "Point3D", "getXYZ", "(", ")", "{", "if", "(", "isEmptyImpl", "(", ")", ")", "throw", "new", "GeometryException", "(", "\"This operation should not be performed on an empty geometry.\"", ")", ";", "Point3D", "pt", "=", "new", "Point3D", "(", ")", ";", "pt", ".", "x", "=", "m_attributes", "[", "0", "]", ";", "pt", ".", "y", "=", "m_attributes", "[", "1", "]", ";", "if", "(", "m_description", ".", "hasZ", "(", ")", ")", "pt", ".", "z", "=", "m_attributes", "[", "2", "]", ";", "else", "pt", ".", "z", "=", "VertexDescription", ".", "getDefaultValue", "(", "Semantics", ".", "Z", ")", ";", "return", "pt", ";", "}"], "docstring": "Returns XYZ coordinates of the point. Z will be set to 0 if Z is missing.", "docstring_tokens": ["Returns", "XYZ", "coordinates", "of", "the", "point", ".", "Z", "will", "be", "set", "to", "0", "if", "Z", "is", "missing", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L133-L147", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point.setXYZ", "original_string": "public void setXYZ(Point3D pt) {\n\t\t_touch();\n\t\tboolean bHasZ = hasAttribute(Semantics.Z);\n\t\tif (!bHasZ && !VertexDescription.isDefaultValue(Semantics.Z, pt.z)) {// add\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Z\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// only\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// pt.z\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// is\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// default\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// value.\n\t\t\taddAttribute(Semantics.Z);\n\t\t\tbHasZ = true;\n\t\t}\n\n\t\tif (m_attributes == null)\n\t\t\t_setToDefault();\n\n\t\tm_attributes[0] = pt.x;\n\t\tm_attributes[1] = pt.y;\n\t\tif (bHasZ)\n\t\t\tm_attributes[2] = pt.z;\n\t}", "language": "java", "code": "public void setXYZ(Point3D pt) {\n\t\t_touch();\n\t\tboolean bHasZ = hasAttribute(Semantics.Z);\n\t\tif (!bHasZ && !VertexDescription.isDefaultValue(Semantics.Z, pt.z)) {// add\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Z\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// only\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// pt.z\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// is\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// default\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// value.\n\t\t\taddAttribute(Semantics.Z);\n\t\t\tbHasZ = true;\n\t\t}\n\n\t\tif (m_attributes == null)\n\t\t\t_setToDefault();\n\n\t\tm_attributes[0] = pt.x;\n\t\tm_attributes[1] = pt.y;\n\t\tif (bHasZ)\n\t\t\tm_attributes[2] = pt.z;\n\t}", "code_tokens": ["public", "void", "setXYZ", "(", "Point3D", "pt", ")", "{", "_touch", "(", ")", ";", "boolean", "bHasZ", "=", "hasAttribute", "(", "Semantics", ".", "Z", ")", ";", "if", "(", "!", "bHasZ", "&&", "!", "VertexDescription", ".", "isDefaultValue", "(", "Semantics", ".", "Z", ",", "pt", ".", "z", ")", ")", "{", "// add", "// Z", "// only", "// if", "// pt.z", "// is", "// not", "// a", "// default", "// value.", "addAttribute", "(", "Semantics", ".", "Z", ")", ";", "bHasZ", "=", "true", ";", "}", "if", "(", "m_attributes", "==", "null", ")", "_setToDefault", "(", ")", ";", "m_attributes", "[", "0", "]", "=", "pt", ".", "x", ";", "m_attributes", "[", "1", "]", "=", "pt", ".", "y", ";", "if", "(", "bHasZ", ")", "m_attributes", "[", "2", "]", "=", "pt", ".", "z", ";", "}"], "docstring": "Sets the XYZ coordinates of this point.\n\n@param pt\nThe point to create the XYZ coordinate from.", "docstring_tokens": ["Sets", "the", "XYZ", "coordinates", "of", "this", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L155-L179", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point.getAttributeAsInt", "original_string": "public int getAttributeAsInt(int semantics, int ordinate) {\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"This operation was performed on an Empty Geometry.\");\n\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ordinate >= ncomps)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tif (attributeIndex >= 0)\n\t\t\treturn (int) m_attributes[m_description\n\t\t\t\t\t._getPointAttributeOffset(attributeIndex) + ordinate];\n\t\telse\n\t\t\treturn (int) VertexDescription.getDefaultValue(semantics);\n\t}", "language": "java", "code": "public int getAttributeAsInt(int semantics, int ordinate) {\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"This operation was performed on an Empty Geometry.\");\n\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ordinate >= ncomps)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tif (attributeIndex >= 0)\n\t\t\treturn (int) m_attributes[m_description\n\t\t\t\t\t._getPointAttributeOffset(attributeIndex) + ordinate];\n\t\telse\n\t\t\treturn (int) VertexDescription.getDefaultValue(semantics);\n\t}", "code_tokens": ["public", "int", "getAttributeAsInt", "(", "int", "semantics", ",", "int", "ordinate", ")", "{", "if", "(", "isEmptyImpl", "(", ")", ")", "throw", "new", "GeometryException", "(", "\"This operation was performed on an Empty Geometry.\"", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "if", "(", "ordinate", ">=", "ncomps", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "int", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "if", "(", "attributeIndex", ">=", "0", ")", "return", "(", "int", ")", "m_attributes", "[", "m_description", ".", "_getPointAttributeOffset", "(", "attributeIndex", ")", "+", "ordinate", "]", ";", "else", "return", "(", "int", ")", "VertexDescription", ".", "getDefaultValue", "(", "semantics", ")", ";", "}"], "docstring": "Returns value of the given vertex attribute's ordinate. The ordinate is\nalways 0 because integer attributes always have one component.\n\n@param semantics\nThe attribute semantics.\n@param ordinate\nThe attribute's ordinate. For example, the y coordinate of the\nNORMAL has ordinate of 1.\n@return The ordinate value truncated to a 32 bit integer value.", "docstring_tokens": ["Returns", "value", "of", "the", "given", "vertex", "attribute", "s", "ordinate", ".", "The", "ordinate", "is", "always", "0", "because", "integer", "attributes", "always", "have", "one", "component", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L312-L327", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point.setAttribute", "original_string": "public void setAttribute(int semantics, int ordinate, double value) {\n\t\t_touch();\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ncomps < ordinate)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tif (attributeIndex < 0) {\n\t\t\taddAttribute(semantics);\n\t\t\tattributeIndex = m_description.getAttributeIndex(semantics);\n\t\t}\n\n\t\tif (m_attributes == null)\n\t\t\t_setToDefault();\n\n\t\tm_attributes[m_description._getPointAttributeOffset(attributeIndex)\n\t\t\t\t+ ordinate] = value;\n\t}", "language": "java", "code": "public void setAttribute(int semantics, int ordinate, double value) {\n\t\t_touch();\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ncomps < ordinate)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tif (attributeIndex < 0) {\n\t\t\taddAttribute(semantics);\n\t\t\tattributeIndex = m_description.getAttributeIndex(semantics);\n\t\t}\n\n\t\tif (m_attributes == null)\n\t\t\t_setToDefault();\n\n\t\tm_attributes[m_description._getPointAttributeOffset(attributeIndex)\n\t\t\t\t+ ordinate] = value;\n\t}", "code_tokens": ["public", "void", "setAttribute", "(", "int", "semantics", ",", "int", "ordinate", ",", "double", "value", ")", "{", "_touch", "(", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "if", "(", "ncomps", "<", "ordinate", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "int", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "if", "(", "attributeIndex", "<", "0", ")", "{", "addAttribute", "(", "semantics", ")", ";", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "}", "if", "(", "m_attributes", "==", "null", ")", "_setToDefault", "(", ")", ";", "m_attributes", "[", "m_description", ".", "_getPointAttributeOffset", "(", "attributeIndex", ")", "+", "ordinate", "]", "=", "value", ";", "}"], "docstring": "Sets the value of the attribute.\n\n@param semantics\nThe attribute semantics.\n@param ordinate\nThe ordinate of the attribute.\n@param value\nIs the array to write values to. The attribute type and the\nnumber of elements must match the persistence type, as well as\nthe number of components of the attribute.", "docstring_tokens": ["Sets", "the", "value", "of", "the", "attribute", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L341-L358", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point._setToDefault", "original_string": "void _setToDefault() {\n\t\tresizeAttributes(m_description.getTotalComponentCount());\n\t\tPoint.attributeCopy(m_description._getDefaultPointAttributes(),\n\t\t\t\tm_attributes, m_description.getTotalComponentCount());\n\t\tm_attributes[0] = NumberUtils.NaN();\n\t\tm_attributes[1] = NumberUtils.NaN();\n\t}", "language": "java", "code": "void _setToDefault() {\n\t\tresizeAttributes(m_description.getTotalComponentCount());\n\t\tPoint.attributeCopy(m_description._getDefaultPointAttributes(),\n\t\t\t\tm_attributes, m_description.getTotalComponentCount());\n\t\tm_attributes[0] = NumberUtils.NaN();\n\t\tm_attributes[1] = NumberUtils.NaN();\n\t}", "code_tokens": ["void", "_setToDefault", "(", ")", "{", "resizeAttributes", "(", "m_description", ".", "getTotalComponentCount", "(", ")", ")", ";", "Point", ".", "attributeCopy", "(", "m_description", ".", "_getDefaultPointAttributes", "(", ")", ",", "m_attributes", ",", "m_description", ".", "getTotalComponentCount", "(", ")", ")", ";", "m_attributes", "[", "0", "]", "=", "NumberUtils", ".", "NaN", "(", ")", ";", "m_attributes", "[", "1", "]", "=", "NumberUtils", ".", "NaN", "(", ")", ";", "}"], "docstring": "Sets the Point to a default, non-empty state.", "docstring_tokens": ["Sets", "the", "Point", "to", "a", "default", "non", "-", "empty", "state", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L433-L439", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Point.java", "func_name": "Point.setXY", "original_string": "public void setXY(double x, double y) {\n\t\t_touch();\n\n\t\tif (m_attributes == null)\n\t\t\t_setToDefault();\n\n\t\tm_attributes[0] = x;\n\t\tm_attributes[1] = y;\n\t}", "language": "java", "code": "public void setXY(double x, double y) {\n\t\t_touch();\n\n\t\tif (m_attributes == null)\n\t\t\t_setToDefault();\n\n\t\tm_attributes[0] = x;\n\t\tm_attributes[1] = y;\n\t}", "code_tokens": ["public", "void", "setXY", "(", "double", "x", ",", "double", "y", ")", "{", "_touch", "(", ")", ";", "if", "(", "m_attributes", "==", "null", ")", "_setToDefault", "(", ")", ";", "m_attributes", "[", "0", "]", "=", "x", ";", "m_attributes", "[", "1", "]", "=", "y", ";", "}"], "docstring": "Set the X and Y coordinate of the point.\n\n@param x\nX coordinate of the point.\n@param y\nY coordinate of the point.", "docstring_tokens": ["Set", "the", "X", "and", "Y", "coordinate", "of", "the", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Point.java#L572-L580", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.setEditShape", "original_string": "void setEditShape(EditShape shape, ProgressTracker progress_tracker) {\n\t\tsetEditShapeImpl_(shape, EnumInputMode.enumInputModeBuildGraph, null,\n\t\t\t\tprogress_tracker, true);\n\t}", "language": "java", "code": "void setEditShape(EditShape shape, ProgressTracker progress_tracker) {\n\t\tsetEditShapeImpl_(shape, EnumInputMode.enumInputModeBuildGraph, null,\n\t\t\t\tprogress_tracker, true);\n\t}", "code_tokens": ["void", "setEditShape", "(", "EditShape", "shape", ",", "ProgressTracker", "progress_tracker", ")", "{", "setEditShapeImpl_", "(", "shape", ",", "EnumInputMode", ".", "enumInputModeBuildGraph", ",", "null", ",", "progress_tracker", ",", "true", ")", ";", "}"], "docstring": "calling this!", "docstring_tokens": ["calling", "this!"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L1877-L1880", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.removeShape", "original_string": "void removeShape() {\n\t\tif (m_shape == null)\n\t\t\treturn;\n\n\t\tif (m_geometryIDIndex != -1) {\n\t\t\tm_shape.removeGeometryUserIndex(m_geometryIDIndex);\n\t\t\tm_geometryIDIndex = -1;\n\t\t}\n\n\t\tif (m_clusterIndex != -1) {\n\t\t\tm_shape.removeUserIndex(m_clusterIndex);\n\t\t\tm_clusterIndex = -1;\n\t\t}\n\n\t\tif (m_halfEdgeIndex != -1) {\n\t\t\tm_shape.removeUserIndex(m_halfEdgeIndex);\n\t\t\tm_halfEdgeIndex = -1;\n\t\t}\n\n\t\tif (m_tmpHalfEdgeParentageIndex != -1) {\n\t\t\tdeleteUserIndexForHalfEdges(m_tmpHalfEdgeParentageIndex);\n\t\t\tm_tmpHalfEdgeParentageIndex = -1;\n\t\t}\n\n\t\tif (m_tmpHalfEdgeWindingNumberIndex != -1) {\n\t\t\tdeleteUserIndexForHalfEdges(m_tmpHalfEdgeWindingNumberIndex);\n\t\t\tm_tmpHalfEdgeWindingNumberIndex = -1;\n\t\t}\n\n\t\tif (m_tmpHalfEdgeOddEvenNumberIndex != -1) {\n\t\t\tdeleteUserIndexForHalfEdges(m_tmpHalfEdgeOddEvenNumberIndex);\n\t\t\tm_tmpHalfEdgeOddEvenNumberIndex = -1;\n\t\t}\n\t\t\n\t\tm_shape = null;\n\t\tm_clusterData.deleteAll(true);\n\t\tm_clusterVertices.deleteAll(true);\n\t\tm_firstCluster = -1;\n\t\tm_lastCluster = -1;\n\n\t\tif (m_halfEdgeData != null)\n\t\t\tm_halfEdgeData.deleteAll(true);\n\t\tif (m_edgeIndices != null)\n\t\t\tm_edgeIndices.clear();\n\t\tif (m_clusterIndices != null)\n\t\t\tm_clusterIndices.clear();\n\t\tif (m_chainIndices != null)\n\t\t\tm_chainIndices.clear();\n\t\tif (m_chainData != null)\n\t\t\tm_chainData.deleteAll(true);\n\t\tm_universeChain = -1;\n\t\tm_chainAreas = null;\n\t}", "language": "java", "code": "void removeShape() {\n\t\tif (m_shape == null)\n\t\t\treturn;\n\n\t\tif (m_geometryIDIndex != -1) {\n\t\t\tm_shape.removeGeometryUserIndex(m_geometryIDIndex);\n\t\t\tm_geometryIDIndex = -1;\n\t\t}\n\n\t\tif (m_clusterIndex != -1) {\n\t\t\tm_shape.removeUserIndex(m_clusterIndex);\n\t\t\tm_clusterIndex = -1;\n\t\t}\n\n\t\tif (m_halfEdgeIndex != -1) {\n\t\t\tm_shape.removeUserIndex(m_halfEdgeIndex);\n\t\t\tm_halfEdgeIndex = -1;\n\t\t}\n\n\t\tif (m_tmpHalfEdgeParentageIndex != -1) {\n\t\t\tdeleteUserIndexForHalfEdges(m_tmpHalfEdgeParentageIndex);\n\t\t\tm_tmpHalfEdgeParentageIndex = -1;\n\t\t}\n\n\t\tif (m_tmpHalfEdgeWindingNumberIndex != -1) {\n\t\t\tdeleteUserIndexForHalfEdges(m_tmpHalfEdgeWindingNumberIndex);\n\t\t\tm_tmpHalfEdgeWindingNumberIndex = -1;\n\t\t}\n\n\t\tif (m_tmpHalfEdgeOddEvenNumberIndex != -1) {\n\t\t\tdeleteUserIndexForHalfEdges(m_tmpHalfEdgeOddEvenNumberIndex);\n\t\t\tm_tmpHalfEdgeOddEvenNumberIndex = -1;\n\t\t}\n\t\t\n\t\tm_shape = null;\n\t\tm_clusterData.deleteAll(true);\n\t\tm_clusterVertices.deleteAll(true);\n\t\tm_firstCluster = -1;\n\t\tm_lastCluster = -1;\n\n\t\tif (m_halfEdgeData != null)\n\t\t\tm_halfEdgeData.deleteAll(true);\n\t\tif (m_edgeIndices != null)\n\t\t\tm_edgeIndices.clear();\n\t\tif (m_clusterIndices != null)\n\t\t\tm_clusterIndices.clear();\n\t\tif (m_chainIndices != null)\n\t\t\tm_chainIndices.clear();\n\t\tif (m_chainData != null)\n\t\t\tm_chainData.deleteAll(true);\n\t\tm_universeChain = -1;\n\t\tm_chainAreas = null;\n\t}", "code_tokens": ["void", "removeShape", "(", ")", "{", "if", "(", "m_shape", "==", "null", ")", "return", ";", "if", "(", "m_geometryIDIndex", "!=", "-", "1", ")", "{", "m_shape", ".", "removeGeometryUserIndex", "(", "m_geometryIDIndex", ")", ";", "m_geometryIDIndex", "=", "-", "1", ";", "}", "if", "(", "m_clusterIndex", "!=", "-", "1", ")", "{", "m_shape", ".", "removeUserIndex", "(", "m_clusterIndex", ")", ";", "m_clusterIndex", "=", "-", "1", ";", "}", "if", "(", "m_halfEdgeIndex", "!=", "-", "1", ")", "{", "m_shape", ".", "removeUserIndex", "(", "m_halfEdgeIndex", ")", ";", "m_halfEdgeIndex", "=", "-", "1", ";", "}", "if", "(", "m_tmpHalfEdgeParentageIndex", "!=", "-", "1", ")", "{", "deleteUserIndexForHalfEdges", "(", "m_tmpHalfEdgeParentageIndex", ")", ";", "m_tmpHalfEdgeParentageIndex", "=", "-", "1", ";", "}", "if", "(", "m_tmpHalfEdgeWindingNumberIndex", "!=", "-", "1", ")", "{", "deleteUserIndexForHalfEdges", "(", "m_tmpHalfEdgeWindingNumberIndex", ")", ";", "m_tmpHalfEdgeWindingNumberIndex", "=", "-", "1", ";", "}", "if", "(", "m_tmpHalfEdgeOddEvenNumberIndex", "!=", "-", "1", ")", "{", "deleteUserIndexForHalfEdges", "(", "m_tmpHalfEdgeOddEvenNumberIndex", ")", ";", "m_tmpHalfEdgeOddEvenNumberIndex", "=", "-", "1", ";", "}", "m_shape", "=", "null", ";", "m_clusterData", ".", "deleteAll", "(", "true", ")", ";", "m_clusterVertices", ".", "deleteAll", "(", "true", ")", ";", "m_firstCluster", "=", "-", "1", ";", "m_lastCluster", "=", "-", "1", ";", "if", "(", "m_halfEdgeData", "!=", "null", ")", "m_halfEdgeData", ".", "deleteAll", "(", "true", ")", ";", "if", "(", "m_edgeIndices", "!=", "null", ")", "m_edgeIndices", ".", "clear", "(", ")", ";", "if", "(", "m_clusterIndices", "!=", "null", ")", "m_clusterIndices", ".", "clear", "(", ")", ";", "if", "(", "m_chainIndices", "!=", "null", ")", "m_chainIndices", ".", "clear", "(", ")", ";", "if", "(", "m_chainData", "!=", "null", ")", "m_chainData", ".", "deleteAll", "(", "true", ")", ";", "m_universeChain", "=", "-", "1", ";", "m_chainAreas", "=", "null", ";", "}"], "docstring": "the edit shape.", "docstring_tokens": ["the", "edit", "shape", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L1903-L1955", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getXY", "original_string": "void getXY(int cluster, Point2D pt) {\n\t\tint vindex = getClusterVertexIndex_(cluster);\n\t\tm_shape.getXYWithIndex(vindex, pt);\n\t}", "language": "java", "code": "void getXY(int cluster, Point2D pt) {\n\t\tint vindex = getClusterVertexIndex_(cluster);\n\t\tm_shape.getXYWithIndex(vindex, pt);\n\t}", "code_tokens": ["void", "getXY", "(", "int", "cluster", ",", "Point2D", "pt", ")", "{", "int", "vindex", "=", "getClusterVertexIndex_", "(", "cluster", ")", ";", "m_shape", ".", "getXYWithIndex", "(", "vindex", ",", "pt", ")", ";", "}"], "docstring": "Returns the coordinates of the cluster", "docstring_tokens": ["Returns", "the", "coordinates", "of", "the", "cluster"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L1968-L1971", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getClusterUserIndex", "original_string": "int getClusterUserIndex(int cluster, int index) {\n\t\tint i = getClusterIndex_(cluster);\n\t\tAttributeStreamOfInt32 stream = m_clusterIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\treturn -1;\n\t\treturn stream.read(i);\n\t}", "language": "java", "code": "int getClusterUserIndex(int cluster, int index) {\n\t\tint i = getClusterIndex_(cluster);\n\t\tAttributeStreamOfInt32 stream = m_clusterIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\treturn -1;\n\t\treturn stream.read(i);\n\t}", "code_tokens": ["int", "getClusterUserIndex", "(", "int", "cluster", ",", "int", "index", ")", "{", "int", "i", "=", "getClusterIndex_", "(", "cluster", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_clusterIndices", ".", "get", "(", "index", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<=", "i", ")", "return", "-", "1", ";", "return", "stream", ".", "read", "(", "i", ")", ";", "}"], "docstring": "Returns a user index value for the cluster.", "docstring_tokens": ["Returns", "a", "user", "index", "value", "for", "the", "cluster", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2018-L2024", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.setClusterUserIndex", "original_string": "void setClusterUserIndex(int cluster, int index, int value) {\n\t\tint i = getClusterIndex_(cluster);\n\t\tAttributeStreamOfInt32 stream = m_clusterIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\tstream.resize(m_clusterData.size(), -1);\n\n\t\tstream.write(i, value);\n\t}", "language": "java", "code": "void setClusterUserIndex(int cluster, int index, int value) {\n\t\tint i = getClusterIndex_(cluster);\n\t\tAttributeStreamOfInt32 stream = m_clusterIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\tstream.resize(m_clusterData.size(), -1);\n\n\t\tstream.write(i, value);\n\t}", "code_tokens": ["void", "setClusterUserIndex", "(", "int", "cluster", ",", "int", "index", ",", "int", "value", ")", "{", "int", "i", "=", "getClusterIndex_", "(", "cluster", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_clusterIndices", ".", "get", "(", "index", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<=", "i", ")", "stream", ".", "resize", "(", "m_clusterData", ".", "size", "(", ")", ",", "-", "1", ")", ";", "stream", ".", "write", "(", "i", ",", "value", ")", ";", "}"], "docstring": "Sets a user index value for the cluster.", "docstring_tokens": ["Sets", "a", "user", "index", "value", "for", "the", "cluster", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2027-L2034", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.createUserIndexForClusters", "original_string": "int createUserIndexForClusters() {\n\t\tif (m_clusterIndices == null) {\n\t\t\tm_clusterIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\t\t}\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_clusterData.capacity(), -1);\n\t\tfor (int i = 0, n = m_clusterIndices.size(); i < n; i++) {\n\t\t\tif (m_clusterIndices.get(i) == null) {\n\t\t\t\tm_clusterIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_clusterIndices.add(new_stream);\n\t\treturn m_clusterIndices.size() - 1;\n\t}", "language": "java", "code": "int createUserIndexForClusters() {\n\t\tif (m_clusterIndices == null) {\n\t\t\tm_clusterIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\t\t}\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_clusterData.capacity(), -1);\n\t\tfor (int i = 0, n = m_clusterIndices.size(); i < n; i++) {\n\t\t\tif (m_clusterIndices.get(i) == null) {\n\t\t\t\tm_clusterIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_clusterIndices.add(new_stream);\n\t\treturn m_clusterIndices.size() - 1;\n\t}", "code_tokens": ["int", "createUserIndexForClusters", "(", ")", "{", "if", "(", "m_clusterIndices", "==", "null", ")", "{", "m_clusterIndices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "3", ")", ";", "}", "AttributeStreamOfInt32", "new_stream", "=", "new", "AttributeStreamOfInt32", "(", "m_clusterData", ".", "capacity", "(", ")", ",", "-", "1", ")", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_clusterIndices", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "m_clusterIndices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_clusterIndices", ".", "set", "(", "i", ",", "new_stream", ")", ";", "return", "i", ";", "}", "}", "m_clusterIndices", ".", "add", "(", "new_stream", ")", ";", "return", "m_clusterIndices", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "Creates a new user index for the cluster. The index values are set to -1.", "docstring_tokens": ["Creates", "a", "new", "user", "index", "for", "the", "cluster", ".", "The", "index", "values", "are", "set", "to", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2037-L2052", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.deleteUserIndexForClusters", "original_string": "void deleteUserIndexForClusters(int userIndex) {\n\t\tassert (m_clusterIndices.get(userIndex) != null);\n\t\tm_clusterIndices.set(userIndex, null);\n\t}", "language": "java", "code": "void deleteUserIndexForClusters(int userIndex) {\n\t\tassert (m_clusterIndices.get(userIndex) != null);\n\t\tm_clusterIndices.set(userIndex, null);\n\t}", "code_tokens": ["void", "deleteUserIndexForClusters", "(", "int", "userIndex", ")", "{", "assert", "(", "m_clusterIndices", ".", "get", "(", "userIndex", ")", "!=", "null", ")", ";", "m_clusterIndices", ".", "set", "(", "userIndex", ",", "null", ")", ";", "}"], "docstring": "Deletes user index", "docstring_tokens": ["Deletes", "user", "index"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2055-L2058", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getHalfEdgeUserIndex", "original_string": "int getHalfEdgeUserIndex(int half_edge, int index) {\n\t\tint i = getHalfEdgeIndex_(half_edge);\n\t\tAttributeStreamOfInt32 stream = m_edgeIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\treturn -1;\n\n\t\treturn stream.read(i);\n\t}", "language": "java", "code": "int getHalfEdgeUserIndex(int half_edge, int index) {\n\t\tint i = getHalfEdgeIndex_(half_edge);\n\t\tAttributeStreamOfInt32 stream = m_edgeIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\treturn -1;\n\n\t\treturn stream.read(i);\n\t}", "code_tokens": ["int", "getHalfEdgeUserIndex", "(", "int", "half_edge", ",", "int", "index", ")", "{", "int", "i", "=", "getHalfEdgeIndex_", "(", "half_edge", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_edgeIndices", ".", "get", "(", "index", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<=", "i", ")", "return", "-", "1", ";", "return", "stream", ".", "read", "(", "i", ")", ";", "}"], "docstring": "Returns a user index value for the half edge", "docstring_tokens": ["Returns", "a", "user", "index", "value", "for", "the", "half", "edge"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2120-L2127", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.setHalfEdgeUserIndex", "original_string": "void setHalfEdgeUserIndex(int half_edge, int index, int value) {\n\t\tint i = getHalfEdgeIndex_(half_edge);\n\t\tAttributeStreamOfInt32 stream = m_edgeIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\tstream.resize(m_halfEdgeData.size(), -1);\n\n\t\tstream.write(i, value);\n\t}", "language": "java", "code": "void setHalfEdgeUserIndex(int half_edge, int index, int value) {\n\t\tint i = getHalfEdgeIndex_(half_edge);\n\t\tAttributeStreamOfInt32 stream = m_edgeIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\tstream.resize(m_halfEdgeData.size(), -1);\n\n\t\tstream.write(i, value);\n\t}", "code_tokens": ["void", "setHalfEdgeUserIndex", "(", "int", "half_edge", ",", "int", "index", ",", "int", "value", ")", "{", "int", "i", "=", "getHalfEdgeIndex_", "(", "half_edge", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_edgeIndices", ".", "get", "(", "index", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<=", "i", ")", "stream", ".", "resize", "(", "m_halfEdgeData", ".", "size", "(", ")", ",", "-", "1", ")", ";", "stream", ".", "write", "(", "i", ",", "value", ")", ";", "}"], "docstring": "Sets a user index value for a half edge", "docstring_tokens": ["Sets", "a", "user", "index", "value", "for", "a", "half", "edge"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2130-L2137", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.createUserIndexForHalfEdges", "original_string": "int createUserIndexForHalfEdges() {\n\t\tif (m_edgeIndices == null)\n\t\t\tm_edgeIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_halfEdgeData.capacity(), -1);\n\t\tfor (int i = 0, n = m_edgeIndices.size(); i < n; i++) {\n\t\t\tif (m_edgeIndices.get(i) == null) {\n\t\t\t\tm_edgeIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_edgeIndices.add(new_stream);\n\t\treturn m_edgeIndices.size() - 1;\n\t}", "language": "java", "code": "int createUserIndexForHalfEdges() {\n\t\tif (m_edgeIndices == null)\n\t\t\tm_edgeIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_halfEdgeData.capacity(), -1);\n\t\tfor (int i = 0, n = m_edgeIndices.size(); i < n; i++) {\n\t\t\tif (m_edgeIndices.get(i) == null) {\n\t\t\t\tm_edgeIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_edgeIndices.add(new_stream);\n\t\treturn m_edgeIndices.size() - 1;\n\t}", "code_tokens": ["int", "createUserIndexForHalfEdges", "(", ")", "{", "if", "(", "m_edgeIndices", "==", "null", ")", "m_edgeIndices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "3", ")", ";", "AttributeStreamOfInt32", "new_stream", "=", "new", "AttributeStreamOfInt32", "(", "m_halfEdgeData", ".", "capacity", "(", ")", ",", "-", "1", ")", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_edgeIndices", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "m_edgeIndices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_edgeIndices", ".", "set", "(", "i", ",", "new_stream", ")", ";", "return", "i", ";", "}", "}", "m_edgeIndices", ".", "add", "(", "new_stream", ")", ";", "return", "m_edgeIndices", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "create a new user index for half edges. The index values are set to -1.", "docstring_tokens": ["create", "a", "new", "user", "index", "for", "half", "edges", ".", "The", "index", "values", "are", "set", "to", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2140-L2154", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.deleteUserIndexForHalfEdges", "original_string": "void deleteUserIndexForHalfEdges(int userIndex) {\n\t\tassert (m_edgeIndices.get(userIndex) != null);\n\t\tm_edgeIndices.set(userIndex, null);\n\t}", "language": "java", "code": "void deleteUserIndexForHalfEdges(int userIndex) {\n\t\tassert (m_edgeIndices.get(userIndex) != null);\n\t\tm_edgeIndices.set(userIndex, null);\n\t}", "code_tokens": ["void", "deleteUserIndexForHalfEdges", "(", "int", "userIndex", ")", "{", "assert", "(", "m_edgeIndices", ".", "get", "(", "userIndex", ")", "!=", "null", ")", ";", "m_edgeIndices", ".", "set", "(", "userIndex", ",", "null", ")", ";", "}"], "docstring": "Deletes the given user index for half edges", "docstring_tokens": ["Deletes", "the", "given", "user", "index", "for", "half", "edges"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2157-L2160", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.deleteEdgeInternal_", "original_string": "int deleteEdgeInternal_(int half_edge) {\n\t\tint chain = getHalfEdgeChain(half_edge);\n\t\tint halfEdgeTwin = getHalfEdgeTwin(half_edge);\n\t\tint chainTwin = getHalfEdgeChain(halfEdgeTwin);\n\t\t// This function only works for spikes. These two asserts check for that\n\t\tassert (chainTwin == chain);\n\t\tassert (half_edge == getHalfEdgeNext(halfEdgeTwin) || halfEdgeTwin == getHalfEdgeNext(half_edge));\n\n\t\tint n = getHalfEdgeNext(half_edge);\n\t\tif (n == halfEdgeTwin) {\n\t\t\tn = getHalfEdgeNext(n);\n\t\t\tif (n == half_edge)\n\t\t\t\tn = -1;\n\t\t}\n\n\t\tif (getChainHalfEdge(chain) == half_edge) {\n\t\t\tsetChainHalfEdge_(chain, n);\n\t\t}\n\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainAreas.read(chainIndex);\n\t\tif (!NumberUtils.isNaN(v)) {\n\t\t\tsetChainArea_(chain, NumberUtils.TheNaN);\n\t\t\tsetChainPerimeter_(chain, NumberUtils.TheNaN);\n\t\t}\n\n\t\tupdateVertexToHalfEdgeConnection_(half_edge, true);\n\n\t\tdeleteEdgeImpl_(half_edge);// does not change chain information\n\t\treturn n;\n\t}", "language": "java", "code": "int deleteEdgeInternal_(int half_edge) {\n\t\tint chain = getHalfEdgeChain(half_edge);\n\t\tint halfEdgeTwin = getHalfEdgeTwin(half_edge);\n\t\tint chainTwin = getHalfEdgeChain(halfEdgeTwin);\n\t\t// This function only works for spikes. These two asserts check for that\n\t\tassert (chainTwin == chain);\n\t\tassert (half_edge == getHalfEdgeNext(halfEdgeTwin) || halfEdgeTwin == getHalfEdgeNext(half_edge));\n\n\t\tint n = getHalfEdgeNext(half_edge);\n\t\tif (n == halfEdgeTwin) {\n\t\t\tn = getHalfEdgeNext(n);\n\t\t\tif (n == half_edge)\n\t\t\t\tn = -1;\n\t\t}\n\n\t\tif (getChainHalfEdge(chain) == half_edge) {\n\t\t\tsetChainHalfEdge_(chain, n);\n\t\t}\n\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainAreas.read(chainIndex);\n\t\tif (!NumberUtils.isNaN(v)) {\n\t\t\tsetChainArea_(chain, NumberUtils.TheNaN);\n\t\t\tsetChainPerimeter_(chain, NumberUtils.TheNaN);\n\t\t}\n\n\t\tupdateVertexToHalfEdgeConnection_(half_edge, true);\n\n\t\tdeleteEdgeImpl_(half_edge);// does not change chain information\n\t\treturn n;\n\t}", "code_tokens": ["int", "deleteEdgeInternal_", "(", "int", "half_edge", ")", "{", "int", "chain", "=", "getHalfEdgeChain", "(", "half_edge", ")", ";", "int", "halfEdgeTwin", "=", "getHalfEdgeTwin", "(", "half_edge", ")", ";", "int", "chainTwin", "=", "getHalfEdgeChain", "(", "halfEdgeTwin", ")", ";", "// This function only works for spikes. These two asserts check for that", "assert", "(", "chainTwin", "==", "chain", ")", ";", "assert", "(", "half_edge", "==", "getHalfEdgeNext", "(", "halfEdgeTwin", ")", "||", "halfEdgeTwin", "==", "getHalfEdgeNext", "(", "half_edge", ")", ")", ";", "int", "n", "=", "getHalfEdgeNext", "(", "half_edge", ")", ";", "if", "(", "n", "==", "halfEdgeTwin", ")", "{", "n", "=", "getHalfEdgeNext", "(", "n", ")", ";", "if", "(", "n", "==", "half_edge", ")", "n", "=", "-", "1", ";", "}", "if", "(", "getChainHalfEdge", "(", "chain", ")", "==", "half_edge", ")", "{", "setChainHalfEdge_", "(", "chain", ",", "n", ")", ";", "}", "int", "chainIndex", "=", "getChainIndex_", "(", "chain", ")", ";", "double", "v", "=", "m_chainAreas", ".", "read", "(", "chainIndex", ")", ";", "if", "(", "!", "NumberUtils", ".", "isNaN", "(", "v", ")", ")", "{", "setChainArea_", "(", "chain", ",", "NumberUtils", ".", "TheNaN", ")", ";", "setChainPerimeter_", "(", "chain", ",", "NumberUtils", ".", "TheNaN", ")", ";", "}", "updateVertexToHalfEdgeConnection_", "(", "half_edge", ",", "true", ")", ";", "deleteEdgeImpl_", "(", "half_edge", ")", ";", "// does not change chain information", "return", "n", ";", "}"], "docstring": "Use with care.", "docstring_tokens": ["Use", "with", "care", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2166-L2196", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.deleteEdgesBreakFaces_", "original_string": "void deleteEdgesBreakFaces_(AttributeStreamOfInt32 edgesToDelete) {\n\t\tfor (int i = 0, n = edgesToDelete.size(); i < n; i++) {\n\t\t\tint half_edge = edgesToDelete.get(i);\n\t\t\tint chain = getHalfEdgeChain(half_edge);\n\t\t\tint halfEdgeTwin = getHalfEdgeTwin(half_edge);\n\t\t\tint chainTwin = getHalfEdgeChain(halfEdgeTwin);\n\t\t\tsetChainHalfEdge_(chain, -1);\n\t\t\tsetChainHalfEdge_(chainTwin, -1);\n\t\t\tupdateVertexToHalfEdgeConnection_(half_edge, true);\n\t\t\tdeleteEdgeImpl_(half_edge);\n\t\t}\n\t}", "language": "java", "code": "void deleteEdgesBreakFaces_(AttributeStreamOfInt32 edgesToDelete) {\n\t\tfor (int i = 0, n = edgesToDelete.size(); i < n; i++) {\n\t\t\tint half_edge = edgesToDelete.get(i);\n\t\t\tint chain = getHalfEdgeChain(half_edge);\n\t\t\tint halfEdgeTwin = getHalfEdgeTwin(half_edge);\n\t\t\tint chainTwin = getHalfEdgeChain(halfEdgeTwin);\n\t\t\tsetChainHalfEdge_(chain, -1);\n\t\t\tsetChainHalfEdge_(chainTwin, -1);\n\t\t\tupdateVertexToHalfEdgeConnection_(half_edge, true);\n\t\t\tdeleteEdgeImpl_(half_edge);\n\t\t}\n\t}", "code_tokens": ["void", "deleteEdgesBreakFaces_", "(", "AttributeStreamOfInt32", "edgesToDelete", ")", "{", "for", "(", "int", "i", "=", "0", ",", "n", "=", "edgesToDelete", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "half_edge", "=", "edgesToDelete", ".", "get", "(", "i", ")", ";", "int", "chain", "=", "getHalfEdgeChain", "(", "half_edge", ")", ";", "int", "halfEdgeTwin", "=", "getHalfEdgeTwin", "(", "half_edge", ")", ";", "int", "chainTwin", "=", "getHalfEdgeChain", "(", "halfEdgeTwin", ")", ";", "setChainHalfEdge_", "(", "chain", ",", "-", "1", ")", ";", "setChainHalfEdge_", "(", "chainTwin", ",", "-", "1", ")", ";", "updateVertexToHalfEdgeConnection_", "(", "half_edge", ",", "true", ")", ";", "deleteEdgeImpl_", "(", "half_edge", ")", ";", "}", "}"], "docstring": "parentage information still.", "docstring_tokens": ["parentage", "information", "still", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2204-L2215", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getChainArea", "original_string": "double getChainArea(int chain) {\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainAreas.read(chainIndex);\n\t\tif (NumberUtils.isNaN(v)) {\n\t\t\tupdateChainAreaAndPerimeter_(chain);\n\t\t\tv = m_chainAreas.read(chainIndex);\n\t\t}\n\n\t\treturn v;\n\t}", "language": "java", "code": "double getChainArea(int chain) {\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainAreas.read(chainIndex);\n\t\tif (NumberUtils.isNaN(v)) {\n\t\t\tupdateChainAreaAndPerimeter_(chain);\n\t\t\tv = m_chainAreas.read(chainIndex);\n\t\t}\n\n\t\treturn v;\n\t}", "code_tokens": ["double", "getChainArea", "(", "int", "chain", ")", "{", "int", "chainIndex", "=", "getChainIndex_", "(", "chain", ")", ";", "double", "v", "=", "m_chainAreas", ".", "read", "(", "chainIndex", ")", ";", "if", "(", "NumberUtils", ".", "isNaN", "(", "v", ")", ")", "{", "updateChainAreaAndPerimeter_", "(", "chain", ")", ";", "v", "=", "m_chainAreas", ".", "read", "(", "chainIndex", ")", ";", "}", "return", "v", ";", "}"], "docstring": "+Inf is returned for the universe chain.", "docstring_tokens": ["+", "Inf", "is", "returned", "for", "the", "universe", "chain", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2369-L2378", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getChainPerimeter", "original_string": "double getChainPerimeter(int chain) {\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainPerimeters.read(chainIndex);\n\t\tif (NumberUtils.isNaN(v)) {\n\t\t\tupdateChainAreaAndPerimeter_(chain);\n\t\t\tv = m_chainPerimeters.read(chainIndex);\n\t\t}\n\n\t\treturn v;\n\t}", "language": "java", "code": "double getChainPerimeter(int chain) {\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainPerimeters.read(chainIndex);\n\t\tif (NumberUtils.isNaN(v)) {\n\t\t\tupdateChainAreaAndPerimeter_(chain);\n\t\t\tv = m_chainPerimeters.read(chainIndex);\n\t\t}\n\n\t\treturn v;\n\t}", "code_tokens": ["double", "getChainPerimeter", "(", "int", "chain", ")", "{", "int", "chainIndex", "=", "getChainIndex_", "(", "chain", ")", ";", "double", "v", "=", "m_chainPerimeters", ".", "read", "(", "chainIndex", ")", ";", "if", "(", "NumberUtils", ".", "isNaN", "(", "v", ")", ")", "{", "updateChainAreaAndPerimeter_", "(", "chain", ")", ";", "v", "=", "m_chainPerimeters", ".", "read", "(", "chainIndex", ")", ";", "}", "return", "v", ";", "}"], "docstring": "universe chain.", "docstring_tokens": ["universe", "chain", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2382-L2391", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getChainUserIndex", "original_string": "int getChainUserIndex(int chain, int index) {\n\t\tint i = getChainIndex_(chain);\n\t\tAttributeStreamOfInt32 stream = m_chainIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\treturn -1;\n\t\treturn stream.read(i);\n\t}", "language": "java", "code": "int getChainUserIndex(int chain, int index) {\n\t\tint i = getChainIndex_(chain);\n\t\tAttributeStreamOfInt32 stream = m_chainIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\treturn -1;\n\t\treturn stream.read(i);\n\t}", "code_tokens": ["int", "getChainUserIndex", "(", "int", "chain", ",", "int", "index", ")", "{", "int", "i", "=", "getChainIndex_", "(", "chain", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_chainIndices", ".", "get", "(", "index", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<=", "i", ")", "return", "-", "1", ";", "return", "stream", ".", "read", "(", "i", ")", ";", "}"], "docstring": "Returns a user index value for the chain.", "docstring_tokens": ["Returns", "a", "user", "index", "value", "for", "the", "chain", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2394-L2400", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.setChainUserIndex", "original_string": "void setChainUserIndex(int chain, int index, int value) {\n\t\tint i = getChainIndex_(chain);\n\t\tAttributeStreamOfInt32 stream = m_chainIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\tstream.resize(m_chainData.size(), -1);\n\n\t\tstream.write(i, value);\n\t}", "language": "java", "code": "void setChainUserIndex(int chain, int index, int value) {\n\t\tint i = getChainIndex_(chain);\n\t\tAttributeStreamOfInt32 stream = m_chainIndices.get(index);\n\t\tif (stream.size() <= i)\n\t\t\tstream.resize(m_chainData.size(), -1);\n\n\t\tstream.write(i, value);\n\t}", "code_tokens": ["void", "setChainUserIndex", "(", "int", "chain", ",", "int", "index", ",", "int", "value", ")", "{", "int", "i", "=", "getChainIndex_", "(", "chain", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_chainIndices", ".", "get", "(", "index", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<=", "i", ")", "stream", ".", "resize", "(", "m_chainData", ".", "size", "(", ")", ",", "-", "1", ")", ";", "stream", ".", "write", "(", "i", ",", "value", ")", ";", "}"], "docstring": "Sets a user index value for the chain.", "docstring_tokens": ["Sets", "a", "user", "index", "value", "for", "the", "chain", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2403-L2410", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.createUserIndexForChains", "original_string": "int createUserIndexForChains() {\n\t\tif (m_chainIndices == null) {\n\t\t\tm_chainIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\t\t}\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_chainData.capacity(), -1);\n\t\tfor (int i = 0, n = m_chainIndices.size(); i < n; i++) {\n\t\t\tif (m_chainIndices.get(i) == null) {\n\t\t\t\tm_chainIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_chainIndices.add(new_stream);\n\t\treturn m_chainIndices.size() - 1;\n\t}", "language": "java", "code": "int createUserIndexForChains() {\n\t\tif (m_chainIndices == null) {\n\t\t\tm_chainIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\t\t}\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_chainData.capacity(), -1);\n\t\tfor (int i = 0, n = m_chainIndices.size(); i < n; i++) {\n\t\t\tif (m_chainIndices.get(i) == null) {\n\t\t\t\tm_chainIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_chainIndices.add(new_stream);\n\t\treturn m_chainIndices.size() - 1;\n\t}", "code_tokens": ["int", "createUserIndexForChains", "(", ")", "{", "if", "(", "m_chainIndices", "==", "null", ")", "{", "m_chainIndices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "3", ")", ";", "}", "AttributeStreamOfInt32", "new_stream", "=", "new", "AttributeStreamOfInt32", "(", "m_chainData", ".", "capacity", "(", ")", ",", "-", "1", ")", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_chainIndices", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "m_chainIndices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_chainIndices", ".", "set", "(", "i", ",", "new_stream", ")", ";", "return", "i", ";", "}", "}", "m_chainIndices", ".", "add", "(", "new_stream", ")", ";", "return", "m_chainIndices", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "Creates a new user index for the chains. The index values are set to -1.", "docstring_tokens": ["Creates", "a", "new", "user", "index", "for", "the", "chains", ".", "The", "index", "values", "are", "set", "to", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2413-L2428", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.deleteUserIndexForChains", "original_string": "void deleteUserIndexForChains(int userIndex) {\n\t\tassert (m_chainIndices.get(userIndex) != null);\n\t\tm_chainIndices.set(userIndex, null);\n\t}", "language": "java", "code": "void deleteUserIndexForChains(int userIndex) {\n\t\tassert (m_chainIndices.get(userIndex) != null);\n\t\tm_chainIndices.set(userIndex, null);\n\t}", "code_tokens": ["void", "deleteUserIndexForChains", "(", "int", "userIndex", ")", "{", "assert", "(", "m_chainIndices", ".", "get", "(", "userIndex", ")", "!=", "null", ")", ";", "m_chainIndices", ".", "set", "(", "userIndex", ",", "null", ")", ";", "}"], "docstring": "Deletes user index", "docstring_tokens": ["Deletes", "user", "index"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2431-L2434", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.getHalfEdgeConnector", "original_string": "int getHalfEdgeConnector(int clusterFrom, int clusterTo) {\n\t\tint first_edge = getClusterHalfEdge(clusterFrom);\n\t\tif (first_edge == -1)\n\t\t\treturn -1;\n\t\tint edge = first_edge;\n\t\tint firstEdgeTo = -1;\n\t\tint eTo = -1;\n\t\t// Doing two loops in parallel - one on the half-edges attached to the\n\t\t// clusterFrom, another - attached to clusterTo.\n\t\tdo {\n\t\t\tif (getHalfEdgeTo(edge) == clusterTo)\n\t\t\t\treturn edge;\n\n\t\t\tif (firstEdgeTo == -1) {\n\t\t\t\tfirstEdgeTo = getClusterHalfEdge(clusterTo);\n\t\t\t\tif (firstEdgeTo == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\teTo = firstEdgeTo;\n\t\t\t}\n\n\t\t\tif (getHalfEdgeTo(eTo) == clusterFrom) {\n\t\t\t\tedge = getHalfEdgeTwin(eTo);\n\t\t\t\tassert (getHalfEdgeTo(edge) == clusterTo && getHalfEdgeOrigin(edge) == clusterFrom);\n\t\t\t\treturn edge;\n\t\t\t}\n\n\t\t\tedge = getHalfEdgeNext(getHalfEdgeTwin(edge));\n\t\t\teTo = getHalfEdgeNext(getHalfEdgeTwin(eTo));\n\t\t} while (edge != first_edge && eTo != firstEdgeTo);\n\n\t\treturn -1;\n\t}", "language": "java", "code": "int getHalfEdgeConnector(int clusterFrom, int clusterTo) {\n\t\tint first_edge = getClusterHalfEdge(clusterFrom);\n\t\tif (first_edge == -1)\n\t\t\treturn -1;\n\t\tint edge = first_edge;\n\t\tint firstEdgeTo = -1;\n\t\tint eTo = -1;\n\t\t// Doing two loops in parallel - one on the half-edges attached to the\n\t\t// clusterFrom, another - attached to clusterTo.\n\t\tdo {\n\t\t\tif (getHalfEdgeTo(edge) == clusterTo)\n\t\t\t\treturn edge;\n\n\t\t\tif (firstEdgeTo == -1) {\n\t\t\t\tfirstEdgeTo = getClusterHalfEdge(clusterTo);\n\t\t\t\tif (firstEdgeTo == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\teTo = firstEdgeTo;\n\t\t\t}\n\n\t\t\tif (getHalfEdgeTo(eTo) == clusterFrom) {\n\t\t\t\tedge = getHalfEdgeTwin(eTo);\n\t\t\t\tassert (getHalfEdgeTo(edge) == clusterTo && getHalfEdgeOrigin(edge) == clusterFrom);\n\t\t\t\treturn edge;\n\t\t\t}\n\n\t\t\tedge = getHalfEdgeNext(getHalfEdgeTwin(edge));\n\t\t\teTo = getHalfEdgeNext(getHalfEdgeTwin(eTo));\n\t\t} while (edge != first_edge && eTo != firstEdgeTo);\n\n\t\treturn -1;\n\t}", "code_tokens": ["int", "getHalfEdgeConnector", "(", "int", "clusterFrom", ",", "int", "clusterTo", ")", "{", "int", "first_edge", "=", "getClusterHalfEdge", "(", "clusterFrom", ")", ";", "if", "(", "first_edge", "==", "-", "1", ")", "return", "-", "1", ";", "int", "edge", "=", "first_edge", ";", "int", "firstEdgeTo", "=", "-", "1", ";", "int", "eTo", "=", "-", "1", ";", "// Doing two loops in parallel - one on the half-edges attached to the", "// clusterFrom, another - attached to clusterTo.", "do", "{", "if", "(", "getHalfEdgeTo", "(", "edge", ")", "==", "clusterTo", ")", "return", "edge", ";", "if", "(", "firstEdgeTo", "==", "-", "1", ")", "{", "firstEdgeTo", "=", "getClusterHalfEdge", "(", "clusterTo", ")", ";", "if", "(", "firstEdgeTo", "==", "-", "1", ")", "return", "-", "1", ";", "eTo", "=", "firstEdgeTo", ";", "}", "if", "(", "getHalfEdgeTo", "(", "eTo", ")", "==", "clusterFrom", ")", "{", "edge", "=", "getHalfEdgeTwin", "(", "eTo", ")", ";", "assert", "(", "getHalfEdgeTo", "(", "edge", ")", "==", "clusterTo", "&&", "getHalfEdgeOrigin", "(", "edge", ")", "==", "clusterFrom", ")", ";", "return", "edge", ";", "}", "edge", "=", "getHalfEdgeNext", "(", "getHalfEdgeTwin", "(", "edge", ")", ")", ";", "eTo", "=", "getHalfEdgeNext", "(", "getHalfEdgeTwin", "(", "eTo", ")", ")", ";", "}", "while", "(", "edge", "!=", "first_edge", "&&", "eTo", "!=", "firstEdgeTo", ")", ";", "return", "-", "1", ";", "}"], "docstring": "Could be a slow operation when valency of each cluster is high.", "docstring_tokens": ["Could", "be", "a", "slow", "operation", "when", "valency", "of", "each", "cluster", "is", "high", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2456-L2487", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.querySegmentXY", "original_string": "void querySegmentXY(int half_edge, SegmentBuffer outBuffer) {\n\t\toutBuffer.createLine();\n\t\tSegment seg = outBuffer.get();\n\t\tPoint2D pt = new Point2D();\n\t\tgetHalfEdgeFromXY(half_edge, pt);\n\t\tseg.setStartXY(pt);\n\t\tgetHalfEdgeToXY(half_edge, pt);\n\t\tseg.setEndXY(pt);\n\t}", "language": "java", "code": "void querySegmentXY(int half_edge, SegmentBuffer outBuffer) {\n\t\toutBuffer.createLine();\n\t\tSegment seg = outBuffer.get();\n\t\tPoint2D pt = new Point2D();\n\t\tgetHalfEdgeFromXY(half_edge, pt);\n\t\tseg.setStartXY(pt);\n\t\tgetHalfEdgeToXY(half_edge, pt);\n\t\tseg.setEndXY(pt);\n\t}", "code_tokens": ["void", "querySegmentXY", "(", "int", "half_edge", ",", "SegmentBuffer", "outBuffer", ")", "{", "outBuffer", ".", "createLine", "(", ")", ";", "Segment", "seg", "=", "outBuffer", ".", "get", "(", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "getHalfEdgeFromXY", "(", "half_edge", ",", "pt", ")", ";", "seg", ".", "setStartXY", "(", "pt", ")", ";", "getHalfEdgeToXY", "(", "half_edge", ",", "pt", ")", ";", "seg", ".", "setEndXY", "(", "pt", ")", ";", "}"], "docstring": "Queries segment for the edge (only xy coordinates, no attributes)", "docstring_tokens": ["Queries", "segment", "for", "the", "edge", "(", "only", "xy", "coordinates", "no", "attributes", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2490-L2498", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.reset", "original_string": "void reset(Envelope2D extent, int height) {\n\t\tm_quad_tree_nodes.deleteAll(false);\n\t\tm_element_nodes.deleteAll(false);\n\t\tm_data.clear();\n\t\tm_free_data.clear(false);\n\t\treset_(extent, height);\n\t}", "language": "java", "code": "void reset(Envelope2D extent, int height) {\n\t\tm_quad_tree_nodes.deleteAll(false);\n\t\tm_element_nodes.deleteAll(false);\n\t\tm_data.clear();\n\t\tm_free_data.clear(false);\n\t\treset_(extent, height);\n\t}", "code_tokens": ["void", "reset", "(", "Envelope2D", "extent", ",", "int", "height", ")", "{", "m_quad_tree_nodes", ".", "deleteAll", "(", "false", ")", ";", "m_element_nodes", ".", "deleteAll", "(", "false", ")", ";", "m_data", ".", "clear", "(", ")", ";", "m_free_data", ".", "clear", "(", "false", ")", ";", "reset_", "(", "extent", ",", "height", ")", ";", "}"], "docstring": "Resets the Quad_tree_impl to the given extent and height.\n\\param extent The extent of the Quad_tree_impl.\n\\param height The max height of the Quad_tree_impl.", "docstring_tokens": ["Resets", "the", "Quad_tree_impl", "to", "the", "given", "extent", "and", "height", ".", "\\", "param", "extent", "The", "extent", "of", "the", "Quad_tree_impl", ".", "\\", "param", "height", "The", "max", "height", "of", "the", "Quad_tree_impl", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L366-L372", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.insert", "original_string": "int insert(int element, Envelope2D bounding_box) {\n\t\tif (m_root == -1)\n\t\t\tcreate_root_();\n\n\t\tif (m_b_store_duplicates) {\n\t\t\tint success = insert_duplicates_(element, bounding_box, 0, m_extent, m_root, false, -1);\n\n\t\t\tif (success != -1) {\n\t\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\t\telse\n\t\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t\t}\n\n\t\t\treturn success;\n\t\t}\n\n\t\tint element_handle = insert_(element, bounding_box, 0, m_extent, m_root, false, -1);\n\n\t\tif (element_handle != -1) {\n\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\telse\n\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t}\n\n\t\treturn element_handle;\n\t}", "language": "java", "code": "int insert(int element, Envelope2D bounding_box) {\n\t\tif (m_root == -1)\n\t\t\tcreate_root_();\n\n\t\tif (m_b_store_duplicates) {\n\t\t\tint success = insert_duplicates_(element, bounding_box, 0, m_extent, m_root, false, -1);\n\n\t\t\tif (success != -1) {\n\t\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\t\telse\n\t\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t\t}\n\n\t\t\treturn success;\n\t\t}\n\n\t\tint element_handle = insert_(element, bounding_box, 0, m_extent, m_root, false, -1);\n\n\t\tif (element_handle != -1) {\n\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\telse\n\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t}\n\n\t\treturn element_handle;\n\t}", "code_tokens": ["int", "insert", "(", "int", "element", ",", "Envelope2D", "bounding_box", ")", "{", "if", "(", "m_root", "==", "-", "1", ")", "create_root_", "(", ")", ";", "if", "(", "m_b_store_duplicates", ")", "{", "int", "success", "=", "insert_duplicates_", "(", "element", ",", "bounding_box", ",", "0", ",", "m_extent", ",", "m_root", ",", "false", ",", "-", "1", ")", ";", "if", "(", "success", "!=", "-", "1", ")", "{", "if", "(", "m_data_extent", ".", "isEmpty", "(", ")", ")", "m_data_extent", ".", "setCoords", "(", "bounding_box", ")", ";", "else", "m_data_extent", ".", "merge", "(", "bounding_box", ")", ";", "}", "return", "success", ";", "}", "int", "element_handle", "=", "insert_", "(", "element", ",", "bounding_box", ",", "0", ",", "m_extent", ",", "m_root", ",", "false", ",", "-", "1", ")", ";", "if", "(", "element_handle", "!=", "-", "1", ")", "{", "if", "(", "m_data_extent", ".", "isEmpty", "(", ")", ")", "m_data_extent", ".", "setCoords", "(", "bounding_box", ")", ";", "else", "m_data_extent", ".", "merge", "(", "bounding_box", ")", ";", "}", "return", "element_handle", ";", "}"], "docstring": "Inserts the element and bounding_box into the Quad_tree_impl.\nNote that this will invalidate any active iterator on the Quad_tree_impl.\nReturns an Element_handle corresponding to the element and bounding_box.\n\\param element The element of the Geometry to be inserted.\n\\param bounding_box The bounding_box of the Geometry to be inserted.", "docstring_tokens": ["Inserts", "the", "element", "and", "bounding_box", "into", "the", "Quad_tree_impl", ".", "Note", "that", "this", "will", "invalidate", "any", "active", "iterator", "on", "the", "Quad_tree_impl", ".", "Returns", "an", "Element_handle", "corresponding", "to", "the", "element", "and", "bounding_box", ".", "\\", "param", "element", "The", "element", "of", "the", "Geometry", "to", "be", "inserted", ".", "\\", "param", "bounding_box", "The", "bounding_box", "of", "the", "Geometry", "to", "be", "inserted", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L381-L408", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.insert", "original_string": "int insert(int element, Envelope2D bounding_box, int hint_index) {\n\t\tif (m_root == -1)\n\t\t\tcreate_root_();\n\n\t\tif (m_b_store_duplicates) {\n\t\t\tint success = insert_duplicates_(element, bounding_box, 0, m_extent, m_root, false, -1);\n\n\t\t\tif (success != -1) {\n\t\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\t\telse\n\t\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\tint quad_handle;\n\n\t\tif (hint_index == -1)\n\t\t\tquad_handle = m_root;\n\t\telse\n\t\t\tquad_handle = get_quad_(hint_index);\n\n\t\tint quad_height = getHeight(quad_handle);\n\t\tEnvelope2D quad_extent = getExtent(quad_handle);\n\n\t\tint element_handle = insert_(element, bounding_box, quad_height, quad_extent, quad_handle, false, -1);\n\n\t\tif (element_handle != -1) {\n\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\telse\n\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t}\n\n\t\treturn element_handle;\n\t}", "language": "java", "code": "int insert(int element, Envelope2D bounding_box, int hint_index) {\n\t\tif (m_root == -1)\n\t\t\tcreate_root_();\n\n\t\tif (m_b_store_duplicates) {\n\t\t\tint success = insert_duplicates_(element, bounding_box, 0, m_extent, m_root, false, -1);\n\n\t\t\tif (success != -1) {\n\t\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\t\telse\n\t\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\tint quad_handle;\n\n\t\tif (hint_index == -1)\n\t\t\tquad_handle = m_root;\n\t\telse\n\t\t\tquad_handle = get_quad_(hint_index);\n\n\t\tint quad_height = getHeight(quad_handle);\n\t\tEnvelope2D quad_extent = getExtent(quad_handle);\n\n\t\tint element_handle = insert_(element, bounding_box, quad_height, quad_extent, quad_handle, false, -1);\n\n\t\tif (element_handle != -1) {\n\t\t\tif (m_data_extent.isEmpty())\n\t\t\t\tm_data_extent.setCoords(bounding_box);\n\t\t\telse\n\t\t\t\tm_data_extent.merge(bounding_box);\n\t\t}\n\n\t\treturn element_handle;\n\t}", "code_tokens": ["int", "insert", "(", "int", "element", ",", "Envelope2D", "bounding_box", ",", "int", "hint_index", ")", "{", "if", "(", "m_root", "==", "-", "1", ")", "create_root_", "(", ")", ";", "if", "(", "m_b_store_duplicates", ")", "{", "int", "success", "=", "insert_duplicates_", "(", "element", ",", "bounding_box", ",", "0", ",", "m_extent", ",", "m_root", ",", "false", ",", "-", "1", ")", ";", "if", "(", "success", "!=", "-", "1", ")", "{", "if", "(", "m_data_extent", ".", "isEmpty", "(", ")", ")", "m_data_extent", ".", "setCoords", "(", "bounding_box", ")", ";", "else", "m_data_extent", ".", "merge", "(", "bounding_box", ")", ";", "}", "return", "success", ";", "}", "int", "quad_handle", ";", "if", "(", "hint_index", "==", "-", "1", ")", "quad_handle", "=", "m_root", ";", "else", "quad_handle", "=", "get_quad_", "(", "hint_index", ")", ";", "int", "quad_height", "=", "getHeight", "(", "quad_handle", ")", ";", "Envelope2D", "quad_extent", "=", "getExtent", "(", "quad_handle", ")", ";", "int", "element_handle", "=", "insert_", "(", "element", ",", "bounding_box", ",", "quad_height", ",", "quad_extent", ",", "quad_handle", ",", "false", ",", "-", "1", ")", ";", "if", "(", "element_handle", "!=", "-", "1", ")", "{", "if", "(", "m_data_extent", ".", "isEmpty", "(", ")", ")", "m_data_extent", ".", "setCoords", "(", "bounding_box", ")", ";", "else", "m_data_extent", ".", "merge", "(", "bounding_box", ")", ";", "}", "return", "element_handle", ";", "}"], "docstring": "Inserts the element and bounding_box into the Quad_tree_impl at the given quad_handle.\nNote that this will invalidate any active iterator on the Quad_tree_impl.\nReturns an Element_handle corresponding to the element and bounding_box.\n\\param element The element of the Geometry to be inserted.\n\\param bounding_box The bounding_box of the Geometry to be inserted.\n\\param hint_index A handle used as a hint where to place the element. This can be a handle obtained from a previous insertion and is useful on data having strong locality such as segments of a Polygon.", "docstring_tokens": ["Inserts", "the", "element", "and", "bounding_box", "into", "the", "Quad_tree_impl", "at", "the", "given", "quad_handle", ".", "Note", "that", "this", "will", "invalidate", "any", "active", "iterator", "on", "the", "Quad_tree_impl", ".", "Returns", "an", "Element_handle", "corresponding", "to", "the", "element", "and", "bounding_box", ".", "\\", "param", "element", "The", "element", "of", "the", "Geometry", "to", "be", "inserted", ".", "\\", "param", "bounding_box", "The", "bounding_box", "of", "the", "Geometry", "to", "be", "inserted", ".", "\\", "param", "hint_index", "A", "handle", "used", "as", "a", "hint", "where", "to", "place", "the", "element", ".", "This", "can", "be", "a", "handle", "obtained", "from", "a", "previous", "insertion", "and", "is", "useful", "on", "data", "having", "strong", "locality", "such", "as", "segments", "of", "a", "Polygon", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L418-L454", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.removeElement", "original_string": "void removeElement(int element_handle) {\n\t\tif (m_b_store_duplicates)\n\t\t\tthrow new GeometryException(\"invalid call\");\n\n\t\tint quad_handle = get_quad_(element_handle);\n\t\tdisconnect_element_handle_(element_handle);\n\t\tfree_element_and_box_node_(element_handle);\n\n\t\tint q = quad_handle;\n\n\t\twhile (q != -1) {\n\t\t\tset_sub_tree_element_count_(q, get_sub_tree_element_count_(q) - 1);\n\t\t\tint parent = get_parent_(q);\n\n\t\t\tif (get_sub_tree_element_count_(q) == 0) {\n\t\t\t\tassert (get_local_element_count_(q) == 0);\n\n\t\t\t\tif (q != m_root) {\n\t\t\t\t\tint quadrant = get_quadrant_(q);\n\t\t\t\t\tm_quad_tree_nodes.deleteElement(q);\n\t\t\t\t\tset_child_(parent, quadrant, -1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq = parent;\n\t\t}\n\t}", "language": "java", "code": "void removeElement(int element_handle) {\n\t\tif (m_b_store_duplicates)\n\t\t\tthrow new GeometryException(\"invalid call\");\n\n\t\tint quad_handle = get_quad_(element_handle);\n\t\tdisconnect_element_handle_(element_handle);\n\t\tfree_element_and_box_node_(element_handle);\n\n\t\tint q = quad_handle;\n\n\t\twhile (q != -1) {\n\t\t\tset_sub_tree_element_count_(q, get_sub_tree_element_count_(q) - 1);\n\t\t\tint parent = get_parent_(q);\n\n\t\t\tif (get_sub_tree_element_count_(q) == 0) {\n\t\t\t\tassert (get_local_element_count_(q) == 0);\n\n\t\t\t\tif (q != m_root) {\n\t\t\t\t\tint quadrant = get_quadrant_(q);\n\t\t\t\t\tm_quad_tree_nodes.deleteElement(q);\n\t\t\t\t\tset_child_(parent, quadrant, -1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq = parent;\n\t\t}\n\t}", "code_tokens": ["void", "removeElement", "(", "int", "element_handle", ")", "{", "if", "(", "m_b_store_duplicates", ")", "throw", "new", "GeometryException", "(", "\"invalid call\"", ")", ";", "int", "quad_handle", "=", "get_quad_", "(", "element_handle", ")", ";", "disconnect_element_handle_", "(", "element_handle", ")", ";", "free_element_and_box_node_", "(", "element_handle", ")", ";", "int", "q", "=", "quad_handle", ";", "while", "(", "q", "!=", "-", "1", ")", "{", "set_sub_tree_element_count_", "(", "q", ",", "get_sub_tree_element_count_", "(", "q", ")", "-", "1", ")", ";", "int", "parent", "=", "get_parent_", "(", "q", ")", ";", "if", "(", "get_sub_tree_element_count_", "(", "q", ")", "==", "0", ")", "{", "assert", "(", "get_local_element_count_", "(", "q", ")", "==", "0", ")", ";", "if", "(", "q", "!=", "m_root", ")", "{", "int", "quadrant", "=", "get_quadrant_", "(", "q", ")", ";", "m_quad_tree_nodes", ".", "deleteElement", "(", "q", ")", ";", "set_child_", "(", "parent", ",", "quadrant", ",", "-", "1", ")", ";", "}", "}", "q", "=", "parent", ";", "}", "}"], "docstring": "Removes the element and bounding_box at the given element_handle.\nNote that this will invalidate any active iterator on the Quad_tree_impl.\n\\param element_handle The handle corresponding to the element and bounding_box to be removed.", "docstring_tokens": ["Removes", "the", "element", "and", "bounding_box", "at", "the", "given", "element_handle", ".", "Note", "that", "this", "will", "invalidate", "any", "active", "iterator", "on", "the", "Quad_tree_impl", ".", "\\", "param", "element_handle", "The", "handle", "corresponding", "to", "the", "element", "and", "bounding_box", "to", "be", "removed", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L461-L487", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.getExtent", "original_string": "Envelope2D getExtent(int quad_handle) {\n\t\tEnvelope2D quad_extent = new Envelope2D();\n\t\tquad_extent.setCoords(m_extent);\n\n\t\tif (quad_handle == m_root)\n\t\t\treturn quad_extent;\n\n\t\tAttributeStreamOfInt32 quadrants = new AttributeStreamOfInt32(0);\n\n\t\tint q = quad_handle;\n\n\t\tdo {\n\t\t\tquadrants.add(get_quadrant_(q));\n\t\t\tq = get_parent_(q);\n\n\t\t} while (q != m_root);\n\n\t\tint sz = quadrants.size();\n\t\tassert (sz == getHeight(quad_handle));\n\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tint child = quadrants.getLast();\n\t\t\tquadrants.removeLast();\n\n\t\t\tif (child == 0) {//northeast\n\t\t\t\tquad_extent.xmin = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymin = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t} else if (child == 1) {//northwest\n\t\t\t\tquad_extent.xmax = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymin = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t} else if (child == 2) {//southwest\n\t\t\t\tquad_extent.xmax = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymax = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t} else {//southeast\n\t\t\t\tquad_extent.xmin = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymax = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t}\n\t\t}\n\n\t\treturn quad_extent;\n\t}", "language": "java", "code": "Envelope2D getExtent(int quad_handle) {\n\t\tEnvelope2D quad_extent = new Envelope2D();\n\t\tquad_extent.setCoords(m_extent);\n\n\t\tif (quad_handle == m_root)\n\t\t\treturn quad_extent;\n\n\t\tAttributeStreamOfInt32 quadrants = new AttributeStreamOfInt32(0);\n\n\t\tint q = quad_handle;\n\n\t\tdo {\n\t\t\tquadrants.add(get_quadrant_(q));\n\t\t\tq = get_parent_(q);\n\n\t\t} while (q != m_root);\n\n\t\tint sz = quadrants.size();\n\t\tassert (sz == getHeight(quad_handle));\n\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tint child = quadrants.getLast();\n\t\t\tquadrants.removeLast();\n\n\t\t\tif (child == 0) {//northeast\n\t\t\t\tquad_extent.xmin = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymin = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t} else if (child == 1) {//northwest\n\t\t\t\tquad_extent.xmax = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymin = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t} else if (child == 2) {//southwest\n\t\t\t\tquad_extent.xmax = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymax = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t} else {//southeast\n\t\t\t\tquad_extent.xmin = 0.5 * (quad_extent.xmin + quad_extent.xmax);\n\t\t\t\tquad_extent.ymax = 0.5 * (quad_extent.ymin + quad_extent.ymax);\n\t\t\t}\n\t\t}\n\n\t\treturn quad_extent;\n\t}", "code_tokens": ["Envelope2D", "getExtent", "(", "int", "quad_handle", ")", "{", "Envelope2D", "quad_extent", "=", "new", "Envelope2D", "(", ")", ";", "quad_extent", ".", "setCoords", "(", "m_extent", ")", ";", "if", "(", "quad_handle", "==", "m_root", ")", "return", "quad_extent", ";", "AttributeStreamOfInt32", "quadrants", "=", "new", "AttributeStreamOfInt32", "(", "0", ")", ";", "int", "q", "=", "quad_handle", ";", "do", "{", "quadrants", ".", "add", "(", "get_quadrant_", "(", "q", ")", ")", ";", "q", "=", "get_parent_", "(", "q", ")", ";", "}", "while", "(", "q", "!=", "m_root", ")", ";", "int", "sz", "=", "quadrants", ".", "size", "(", ")", ";", "assert", "(", "sz", "==", "getHeight", "(", "quad_handle", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "sz", ";", "i", "++", ")", "{", "int", "child", "=", "quadrants", ".", "getLast", "(", ")", ";", "quadrants", ".", "removeLast", "(", ")", ";", "if", "(", "child", "==", "0", ")", "{", "//northeast", "quad_extent", ".", "xmin", "=", "0.5", "*", "(", "quad_extent", ".", "xmin", "+", "quad_extent", ".", "xmax", ")", ";", "quad_extent", ".", "ymin", "=", "0.5", "*", "(", "quad_extent", ".", "ymin", "+", "quad_extent", ".", "ymax", ")", ";", "}", "else", "if", "(", "child", "==", "1", ")", "{", "//northwest", "quad_extent", ".", "xmax", "=", "0.5", "*", "(", "quad_extent", ".", "xmin", "+", "quad_extent", ".", "xmax", ")", ";", "quad_extent", ".", "ymin", "=", "0.5", "*", "(", "quad_extent", ".", "ymin", "+", "quad_extent", ".", "ymax", ")", ";", "}", "else", "if", "(", "child", "==", "2", ")", "{", "//southwest", "quad_extent", ".", "xmax", "=", "0.5", "*", "(", "quad_extent", ".", "xmin", "+", "quad_extent", ".", "xmax", ")", ";", "quad_extent", ".", "ymax", "=", "0.5", "*", "(", "quad_extent", ".", "ymin", "+", "quad_extent", ".", "ymax", ")", ";", "}", "else", "{", "//southeast", "quad_extent", ".", "xmin", "=", "0.5", "*", "(", "quad_extent", ".", "xmin", "+", "quad_extent", ".", "xmax", ")", ";", "quad_extent", ".", "ymax", "=", "0.5", "*", "(", "quad_extent", ".", "ymin", "+", "quad_extent", ".", "ymax", ")", ";", "}", "}", "return", "quad_extent", ";", "}"], "docstring": "Returns the extent of the quad at the given quad_handle.\n\\param quad_handle The handle corresponding to the quad.", "docstring_tokens": ["Returns", "the", "extent", "of", "the", "quad", "at", "the", "given", "quad_handle", ".", "\\", "param", "quad_handle", "The", "handle", "corresponding", "to", "the", "quad", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L552-L592", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.getIntersectionCount", "original_string": "int getIntersectionCount(Envelope2D query, double tolerance, int max_count) {\n\t\tif (m_root == -1)\n\t\t\treturn 0;\n\n\t\tEnvelope2D query_inflated = new Envelope2D();\n\t\tquery_inflated.setCoords(query);\n\t\tquery_inflated.inflate(tolerance, tolerance);\n\n\t\tAttributeStreamOfInt32 quads_stack = new AttributeStreamOfInt32(0);\n\t\tArrayList<Envelope2D> extents_stack = new ArrayList<Envelope2D>(0);\n\t\tquads_stack.add(m_root);\n\t\textents_stack.add(new Envelope2D(m_extent.xmin, m_extent.ymin, m_extent.xmax, m_extent.ymax));\n\n\t\tEnvelope2D[] child_extents = new Envelope2D[4];\n\t\tchild_extents[0] = new Envelope2D();\n\t\tchild_extents[1] = new Envelope2D();\n\t\tchild_extents[2] = new Envelope2D();\n\t\tchild_extents[3] = new Envelope2D();\n\n\t\tEnvelope2D current_extent = new Envelope2D();\n\n\t\tint intersection_count = 0;\n\n\t\twhile (quads_stack.size() > 0) {\n\t\t\tboolean b_subdivide = false;\n\n\t\t\tint current_quad_handle = quads_stack.getLast();\n\t\t\tcurrent_extent.setCoords(extents_stack.get(extents_stack.size() - 1));\n\n\t\t\tquads_stack.removeLast();\n\t\t\textents_stack.remove(extents_stack.size() - 1);\n\n\n\t\t\tif (query_inflated.contains(current_extent)) {\n\t\t\t\tintersection_count += getSubTreeElementCount(current_quad_handle);\n\n\t\t\t\tif (max_count > 0 && intersection_count >= max_count)\n\t\t\t\t\treturn max_count;\n\t\t\t} else {\n\t\t\t\tif (query_inflated.isIntersecting(current_extent)) {\n\t\t\t\t\tfor (int element_handle = get_first_element_(current_quad_handle); element_handle != -1; element_handle = get_next_element_(element_handle)) {\n\t\t\t\t\t\tint data_handle = get_data_(element_handle);\n\t\t\t\t\t\tEnvelope2D env = get_bounding_box_value_(data_handle);\n\n\t\t\t\t\t\tif (env.isIntersecting(query_inflated)) {\n\t\t\t\t\t\t\tintersection_count++;\n\n\t\t\t\t\t\t\tif (max_count > 0 && intersection_count >= max_count)\n\t\t\t\t\t\t\t\treturn max_count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tb_subdivide = getHeight(current_quad_handle) + 1 <= m_height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b_subdivide) {\n\t\t\t\tset_child_extents_(current_extent, child_extents);\n\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint child_handle = get_child_(current_quad_handle, i);\n\n\t\t\t\t\tif (child_handle != -1 && getSubTreeElementCount(child_handle) > 0) {\n\t\t\t\t\t\tboolean b_is_intersecting = query_inflated.isIntersecting(child_extents[i]);\n\n\t\t\t\t\t\tif (b_is_intersecting) {\n\t\t\t\t\t\t\tquads_stack.add(child_handle);\n\t\t\t\t\t\t\textents_stack.add(new Envelope2D(child_extents[i].xmin, child_extents[i].ymin, child_extents[i].xmax, child_extents[i].ymax));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn intersection_count;\n\t}", "language": "java", "code": "int getIntersectionCount(Envelope2D query, double tolerance, int max_count) {\n\t\tif (m_root == -1)\n\t\t\treturn 0;\n\n\t\tEnvelope2D query_inflated = new Envelope2D();\n\t\tquery_inflated.setCoords(query);\n\t\tquery_inflated.inflate(tolerance, tolerance);\n\n\t\tAttributeStreamOfInt32 quads_stack = new AttributeStreamOfInt32(0);\n\t\tArrayList<Envelope2D> extents_stack = new ArrayList<Envelope2D>(0);\n\t\tquads_stack.add(m_root);\n\t\textents_stack.add(new Envelope2D(m_extent.xmin, m_extent.ymin, m_extent.xmax, m_extent.ymax));\n\n\t\tEnvelope2D[] child_extents = new Envelope2D[4];\n\t\tchild_extents[0] = new Envelope2D();\n\t\tchild_extents[1] = new Envelope2D();\n\t\tchild_extents[2] = new Envelope2D();\n\t\tchild_extents[3] = new Envelope2D();\n\n\t\tEnvelope2D current_extent = new Envelope2D();\n\n\t\tint intersection_count = 0;\n\n\t\twhile (quads_stack.size() > 0) {\n\t\t\tboolean b_subdivide = false;\n\n\t\t\tint current_quad_handle = quads_stack.getLast();\n\t\t\tcurrent_extent.setCoords(extents_stack.get(extents_stack.size() - 1));\n\n\t\t\tquads_stack.removeLast();\n\t\t\textents_stack.remove(extents_stack.size() - 1);\n\n\n\t\t\tif (query_inflated.contains(current_extent)) {\n\t\t\t\tintersection_count += getSubTreeElementCount(current_quad_handle);\n\n\t\t\t\tif (max_count > 0 && intersection_count >= max_count)\n\t\t\t\t\treturn max_count;\n\t\t\t} else {\n\t\t\t\tif (query_inflated.isIntersecting(current_extent)) {\n\t\t\t\t\tfor (int element_handle = get_first_element_(current_quad_handle); element_handle != -1; element_handle = get_next_element_(element_handle)) {\n\t\t\t\t\t\tint data_handle = get_data_(element_handle);\n\t\t\t\t\t\tEnvelope2D env = get_bounding_box_value_(data_handle);\n\n\t\t\t\t\t\tif (env.isIntersecting(query_inflated)) {\n\t\t\t\t\t\t\tintersection_count++;\n\n\t\t\t\t\t\t\tif (max_count > 0 && intersection_count >= max_count)\n\t\t\t\t\t\t\t\treturn max_count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tb_subdivide = getHeight(current_quad_handle) + 1 <= m_height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b_subdivide) {\n\t\t\t\tset_child_extents_(current_extent, child_extents);\n\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint child_handle = get_child_(current_quad_handle, i);\n\n\t\t\t\t\tif (child_handle != -1 && getSubTreeElementCount(child_handle) > 0) {\n\t\t\t\t\t\tboolean b_is_intersecting = query_inflated.isIntersecting(child_extents[i]);\n\n\t\t\t\t\t\tif (b_is_intersecting) {\n\t\t\t\t\t\t\tquads_stack.add(child_handle);\n\t\t\t\t\t\t\textents_stack.add(new Envelope2D(child_extents[i].xmin, child_extents[i].ymin, child_extents[i].xmax, child_extents[i].ymax));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn intersection_count;\n\t}", "code_tokens": ["int", "getIntersectionCount", "(", "Envelope2D", "query", ",", "double", "tolerance", ",", "int", "max_count", ")", "{", "if", "(", "m_root", "==", "-", "1", ")", "return", "0", ";", "Envelope2D", "query_inflated", "=", "new", "Envelope2D", "(", ")", ";", "query_inflated", ".", "setCoords", "(", "query", ")", ";", "query_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "AttributeStreamOfInt32", "quads_stack", "=", "new", "AttributeStreamOfInt32", "(", "0", ")", ";", "ArrayList", "<", "Envelope2D", ">", "extents_stack", "=", "new", "ArrayList", "<", "Envelope2D", ">", "(", "0", ")", ";", "quads_stack", ".", "add", "(", "m_root", ")", ";", "extents_stack", ".", "add", "(", "new", "Envelope2D", "(", "m_extent", ".", "xmin", ",", "m_extent", ".", "ymin", ",", "m_extent", ".", "xmax", ",", "m_extent", ".", "ymax", ")", ")", ";", "Envelope2D", "[", "]", "child_extents", "=", "new", "Envelope2D", "[", "4", "]", ";", "child_extents", "[", "0", "]", "=", "new", "Envelope2D", "(", ")", ";", "child_extents", "[", "1", "]", "=", "new", "Envelope2D", "(", ")", ";", "child_extents", "[", "2", "]", "=", "new", "Envelope2D", "(", ")", ";", "child_extents", "[", "3", "]", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "current_extent", "=", "new", "Envelope2D", "(", ")", ";", "int", "intersection_count", "=", "0", ";", "while", "(", "quads_stack", ".", "size", "(", ")", ">", "0", ")", "{", "boolean", "b_subdivide", "=", "false", ";", "int", "current_quad_handle", "=", "quads_stack", ".", "getLast", "(", ")", ";", "current_extent", ".", "setCoords", "(", "extents_stack", ".", "get", "(", "extents_stack", ".", "size", "(", ")", "-", "1", ")", ")", ";", "quads_stack", ".", "removeLast", "(", ")", ";", "extents_stack", ".", "remove", "(", "extents_stack", ".", "size", "(", ")", "-", "1", ")", ";", "if", "(", "query_inflated", ".", "contains", "(", "current_extent", ")", ")", "{", "intersection_count", "+=", "getSubTreeElementCount", "(", "current_quad_handle", ")", ";", "if", "(", "max_count", ">", "0", "&&", "intersection_count", ">=", "max_count", ")", "return", "max_count", ";", "}", "else", "{", "if", "(", "query_inflated", ".", "isIntersecting", "(", "current_extent", ")", ")", "{", "for", "(", "int", "element_handle", "=", "get_first_element_", "(", "current_quad_handle", ")", ";", "element_handle", "!=", "-", "1", ";", "element_handle", "=", "get_next_element_", "(", "element_handle", ")", ")", "{", "int", "data_handle", "=", "get_data_", "(", "element_handle", ")", ";", "Envelope2D", "env", "=", "get_bounding_box_value_", "(", "data_handle", ")", ";", "if", "(", "env", ".", "isIntersecting", "(", "query_inflated", ")", ")", "{", "intersection_count", "++", ";", "if", "(", "max_count", ">", "0", "&&", "intersection_count", ">=", "max_count", ")", "return", "max_count", ";", "}", "}", "b_subdivide", "=", "getHeight", "(", "current_quad_handle", ")", "+", "1", "<=", "m_height", ";", "}", "}", "if", "(", "b_subdivide", ")", "{", "set_child_extents_", "(", "current_extent", ",", "child_extents", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "4", ";", "i", "++", ")", "{", "int", "child_handle", "=", "get_child_", "(", "current_quad_handle", ",", "i", ")", ";", "if", "(", "child_handle", "!=", "-", "1", "&&", "getSubTreeElementCount", "(", "child_handle", ")", ">", "0", ")", "{", "boolean", "b_is_intersecting", "=", "query_inflated", ".", "isIntersecting", "(", "child_extents", "[", "i", "]", ")", ";", "if", "(", "b_is_intersecting", ")", "{", "quads_stack", ".", "add", "(", "child_handle", ")", ";", "extents_stack", ".", "add", "(", "new", "Envelope2D", "(", "child_extents", "[", "i", "]", ".", "xmin", ",", "child_extents", "[", "i", "]", ".", "ymin", ",", "child_extents", "[", "i", "]", ".", "xmax", ",", "child_extents", "[", "i", "]", ".", "ymax", ")", ")", ";", "}", "}", "}", "}", "}", "return", "intersection_count", ";", "}"], "docstring": "Returns the number of elements in the quad tree that intersect the qiven query. Some elements may be duplicated if the quad tree stores duplicates.\n\\param query The Envelope_2D used for the query.\n\\param tolerance The tolerance used for the intersection tests.\n\\param max_count If the intersection count becomes greater than or equal to the max_count, then max_count is returned.", "docstring_tokens": ["Returns", "the", "number", "of", "elements", "in", "the", "quad", "tree", "that", "intersect", "the", "qiven", "query", ".", "Some", "elements", "may", "be", "duplicated", "if", "the", "quad", "tree", "stores", "duplicates", ".", "\\", "param", "query", "The", "Envelope_2D", "used", "for", "the", "query", ".", "\\", "param", "tolerance", "The", "tolerance", "used", "for", "the", "intersection", "tests", ".", "\\", "param", "max_count", "If", "the", "intersection", "count", "becomes", "greater", "than", "or", "equal", "to", "the", "max_count", "then", "max_count", "is", "returned", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L638-L713", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java", "func_name": "OperatorSimplifyLocalHelper.isSimplePlanar", "original_string": "static protected int isSimplePlanar(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce,\n\t\t\tProgressTracker progressTracker) {\n\t\tassert (false); // this code is not called yet.\n\t\tif (geometry.isEmpty())\n\t\t\treturn 1;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn 1;\n\t\telse if (gt == Geometry.Type.Envelope) {\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tgeometry.queryEnvelope2D(env2D);\n\t\t\tboolean bReturnValue = !env2D.isDegenerate(InternalUtils\n\t\t\t\t\t.calculateToleranceFromGeometry(spatialReference, geometry,\n\t\t\t\t\t\t\tfalse));\n\t\t\treturn bReturnValue ? 1 : 0;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t// return seg.IsSimple(m_tolerance);\n\t\t} else if (!Geometry.isMultiVertex(gt.value())) {\n\t\t\tthrow GeometryException.GeometryInternalError();// What else?\n\t\t}\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\n\t\tdouble geomTolerance = 0;\n\t\tint isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())\n\t\t\t\t.getIsSimple(tolerance);\n\t\tint knownSimpleResult = bForce ? -1 : isSimple;\n\t\t// TODO: need to distinguish KnownSimple between SimpleAsFeature and\n\t\t// SimplePlanar. The SimplePlanar implies SimpleAsFeature.\n\t\tif (knownSimpleResult != -1)\n\t\t\treturn knownSimpleResult;\n\n\t\tif (knownSimpleResult == GeometryXSimple.Weak) {\n\t\t\tassert (tolerance <= geomTolerance);\n\t\t\ttolerance = geomTolerance;// OVERRIDE the tolerance.\n\t\t}\n\n\t\tOperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(\n\t\t\t\tgeometry, spatialReference, knownSimpleResult, progressTracker,\n\t\t\t\tfalse);\n\t\tknownSimpleResult = helper.isSimplePlanarImpl_();\n\t\t((MultiVertexGeometryImpl) geometry._getImpl()).setIsSimple(\n\t\t\t\tknownSimpleResult, tolerance, false);\n\t\treturn knownSimpleResult;\n\t}", "language": "java", "code": "static protected int isSimplePlanar(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce,\n\t\t\tProgressTracker progressTracker) {\n\t\tassert (false); // this code is not called yet.\n\t\tif (geometry.isEmpty())\n\t\t\treturn 1;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn 1;\n\t\telse if (gt == Geometry.Type.Envelope) {\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tgeometry.queryEnvelope2D(env2D);\n\t\t\tboolean bReturnValue = !env2D.isDegenerate(InternalUtils\n\t\t\t\t\t.calculateToleranceFromGeometry(spatialReference, geometry,\n\t\t\t\t\t\t\tfalse));\n\t\t\treturn bReturnValue ? 1 : 0;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t\t// return seg.IsSimple(m_tolerance);\n\t\t} else if (!Geometry.isMultiVertex(gt.value())) {\n\t\t\tthrow GeometryException.GeometryInternalError();// What else?\n\t\t}\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\n\t\tdouble geomTolerance = 0;\n\t\tint isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())\n\t\t\t\t.getIsSimple(tolerance);\n\t\tint knownSimpleResult = bForce ? -1 : isSimple;\n\t\t// TODO: need to distinguish KnownSimple between SimpleAsFeature and\n\t\t// SimplePlanar. The SimplePlanar implies SimpleAsFeature.\n\t\tif (knownSimpleResult != -1)\n\t\t\treturn knownSimpleResult;\n\n\t\tif (knownSimpleResult == GeometryXSimple.Weak) {\n\t\t\tassert (tolerance <= geomTolerance);\n\t\t\ttolerance = geomTolerance;// OVERRIDE the tolerance.\n\t\t}\n\n\t\tOperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(\n\t\t\t\tgeometry, spatialReference, knownSimpleResult, progressTracker,\n\t\t\t\tfalse);\n\t\tknownSimpleResult = helper.isSimplePlanarImpl_();\n\t\t((MultiVertexGeometryImpl) geometry._getImpl()).setIsSimple(\n\t\t\t\tknownSimpleResult, tolerance, false);\n\t\treturn knownSimpleResult;\n\t}", "code_tokens": ["static", "protected", "int", "isSimplePlanar", "(", "/* const */", "Geometry", "geometry", ",", "/* const */", "SpatialReference", "spatialReference", ",", "boolean", "bForce", ",", "ProgressTracker", "progressTracker", ")", "{", "assert", "(", "false", ")", ";", "// this code is not called yet.", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", "1", ";", "Geometry", ".", "Type", "gt", "=", "geometry", ".", "getType", "(", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Point", ")", "return", "1", ";", "else", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "geometry", ".", "queryEnvelope2D", "(", "env2D", ")", ";", "boolean", "bReturnValue", "=", "!", "env2D", ".", "isDegenerate", "(", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "spatialReference", ",", "geometry", ",", "false", ")", ")", ";", "return", "bReturnValue", "?", "1", ":", "0", ";", "}", "else", "if", "(", "Geometry", ".", "isSegment", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "// return seg.IsSimple(m_tolerance);", "}", "else", "if", "(", "!", "Geometry", ".", "isMultiVertex", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "// What else?", "}", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "spatialReference", ",", "geometry", ",", "false", ")", ";", "double", "geomTolerance", "=", "0", ";", "int", "isSimple", "=", "(", "(", "MultiVertexGeometryImpl", ")", "geometry", ".", "_getImpl", "(", ")", ")", ".", "getIsSimple", "(", "tolerance", ")", ";", "int", "knownSimpleResult", "=", "bForce", "?", "-", "1", ":", "isSimple", ";", "// TODO: need to distinguish KnownSimple between SimpleAsFeature and", "// SimplePlanar. The SimplePlanar implies SimpleAsFeature.", "if", "(", "knownSimpleResult", "!=", "-", "1", ")", "return", "knownSimpleResult", ";", "if", "(", "knownSimpleResult", "==", "GeometryXSimple", ".", "Weak", ")", "{", "assert", "(", "tolerance", "<=", "geomTolerance", ")", ";", "tolerance", "=", "geomTolerance", ";", "// OVERRIDE the tolerance.", "}", "OperatorSimplifyLocalHelper", "helper", "=", "new", "OperatorSimplifyLocalHelper", "(", "geometry", ",", "spatialReference", ",", "knownSimpleResult", ",", "progressTracker", ",", "false", ")", ";", "knownSimpleResult", "=", "helper", ".", "isSimplePlanarImpl_", "(", ")", ";", "(", "(", "MultiVertexGeometryImpl", ")", "geometry", ".", "_getImpl", "(", ")", ")", ".", "setIsSimple", "(", "knownSimpleResult", ",", "tolerance", ",", "false", ")", ";", "return", "knownSimpleResult", ";", "}"], "docstring": "The code is executed in the 2D plane only.Attributes are ignored.\nMultiPoint-check for clustering. Polyline -check for clustering and\ncracking. Polygon -check for clustering,cracking,absence of\nself-intersections,and correct ring ordering.", "docstring_tokens": ["The", "code", "is", "executed", "in", "the", "2D", "plane", "only", ".", "Attributes", "are", "ignored", ".", "MultiPoint", "-", "check", "for", "clustering", ".", "Polyline", "-", "check", "for", "clustering", "and", "cracking", ".", "Polygon", "-", "check", "for", "clustering", "cracking", "absence", "of", "self", "-", "intersections", "and", "correct", "ring", "ordering", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java#L1726-L1773", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java", "func_name": "OperatorSimplifyLocalHelper.isSimpleAsFeature", "original_string": "static protected int isSimpleAsFeature(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce, NonSimpleResult result,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (result != null) {\n\t\t\tresult.m_reason = NonSimpleResult.Reason.NotDetermined;\n\t\t\tresult.m_vertexIndex1 = -1;\n\t\t\tresult.m_vertexIndex2 = -1;\n\t\t}\n\t\tif (geometry.isEmpty())\n\t\t\treturn 1;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn 1;\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\t\tif (gt == Geometry.Type.Envelope) {\n\t\t\t/* const */Envelope env = (Envelope) geometry;\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tenv.queryEnvelope2D(env2D);\n\t\t\tif (env2D.isDegenerate(tolerance)) {\n\t\t\t\tif (result != null) {\n\t\t\t\t\tresult.m_reason = NonSimpleResult.Reason.DegenerateSegments;\n\t\t\t\t\tresult.m_vertexIndex1 = -1;\n\t\t\t\t\tresult.m_vertexIndex2 = -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\t/* const */Segment seg = (Segment) geometry;\n\t\t\tPolyline polyline = new Polyline(seg.getDescription());\n\t\t\tpolyline.addSegment(seg, true);\n\t\t\treturn isSimpleAsFeature(polyline, spatialReference, bForce,\n\t\t\t\t\tresult, progressTracker);\n\t\t}\n\n\t\t// double geomTolerance = 0;\n\t\tint isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())\n\t\t\t\t.getIsSimple(tolerance);\n\t\tint knownSimpleResult = bForce ? -1 : isSimple;\n\t\t// TODO: need to distinguish KnownSimple between SimpleAsFeature and\n\t\t// SimplePlanar.\n\t\t// From the first sight it seems the SimplePlanar implies\n\t\t// SimpleAsFeature.\n\t\tif (knownSimpleResult != -1)\n\t\t\treturn knownSimpleResult;\n\n\t\tOperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(\n\t\t\t\tgeometry, spatialReference, knownSimpleResult, progressTracker,\n\t\t\t\tfalse);\n\n\t\tif (gt == Geometry.Type.MultiPoint) {\n\t\t\tknownSimpleResult = helper.multiPointIsSimpleAsFeature_();\n\t\t} else if (gt == Geometry.Type.Polyline) {\n\t\t\tknownSimpleResult = helper.polylineIsSimpleAsFeature_();\n\t\t} else if (gt == Geometry.Type.Polygon) {\n\t\t\tknownSimpleResult = helper.polygonIsSimpleAsFeature_();\n\t\t} else {\n\t\t\tthrow GeometryException.GeometryInternalError();// what else?\n\t\t}\n\n\t\t((MultiVertexGeometryImpl) (geometry._getImpl())).setIsSimple(\n\t\t\t\tknownSimpleResult, tolerance, false);\n\t\tif (result != null && knownSimpleResult == 0)\n\t\t\tresult.Assign(helper.m_nonSimpleResult);\n\t\treturn knownSimpleResult;\n\t}", "language": "java", "code": "static protected int isSimpleAsFeature(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce, NonSimpleResult result,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (result != null) {\n\t\t\tresult.m_reason = NonSimpleResult.Reason.NotDetermined;\n\t\t\tresult.m_vertexIndex1 = -1;\n\t\t\tresult.m_vertexIndex2 = -1;\n\t\t}\n\t\tif (geometry.isEmpty())\n\t\t\treturn 1;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn 1;\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\t\tif (gt == Geometry.Type.Envelope) {\n\t\t\t/* const */Envelope env = (Envelope) geometry;\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tenv.queryEnvelope2D(env2D);\n\t\t\tif (env2D.isDegenerate(tolerance)) {\n\t\t\t\tif (result != null) {\n\t\t\t\t\tresult.m_reason = NonSimpleResult.Reason.DegenerateSegments;\n\t\t\t\t\tresult.m_vertexIndex1 = -1;\n\t\t\t\t\tresult.m_vertexIndex2 = -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\t/* const */Segment seg = (Segment) geometry;\n\t\t\tPolyline polyline = new Polyline(seg.getDescription());\n\t\t\tpolyline.addSegment(seg, true);\n\t\t\treturn isSimpleAsFeature(polyline, spatialReference, bForce,\n\t\t\t\t\tresult, progressTracker);\n\t\t}\n\n\t\t// double geomTolerance = 0;\n\t\tint isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())\n\t\t\t\t.getIsSimple(tolerance);\n\t\tint knownSimpleResult = bForce ? -1 : isSimple;\n\t\t// TODO: need to distinguish KnownSimple between SimpleAsFeature and\n\t\t// SimplePlanar.\n\t\t// From the first sight it seems the SimplePlanar implies\n\t\t// SimpleAsFeature.\n\t\tif (knownSimpleResult != -1)\n\t\t\treturn knownSimpleResult;\n\n\t\tOperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(\n\t\t\t\tgeometry, spatialReference, knownSimpleResult, progressTracker,\n\t\t\t\tfalse);\n\n\t\tif (gt == Geometry.Type.MultiPoint) {\n\t\t\tknownSimpleResult = helper.multiPointIsSimpleAsFeature_();\n\t\t} else if (gt == Geometry.Type.Polyline) {\n\t\t\tknownSimpleResult = helper.polylineIsSimpleAsFeature_();\n\t\t} else if (gt == Geometry.Type.Polygon) {\n\t\t\tknownSimpleResult = helper.polygonIsSimpleAsFeature_();\n\t\t} else {\n\t\t\tthrow GeometryException.GeometryInternalError();// what else?\n\t\t}\n\n\t\t((MultiVertexGeometryImpl) (geometry._getImpl())).setIsSimple(\n\t\t\t\tknownSimpleResult, tolerance, false);\n\t\tif (result != null && knownSimpleResult == 0)\n\t\t\tresult.Assign(helper.m_nonSimpleResult);\n\t\treturn knownSimpleResult;\n\t}", "code_tokens": ["static", "protected", "int", "isSimpleAsFeature", "(", "/* const */", "Geometry", "geometry", ",", "/* const */", "SpatialReference", "spatialReference", ",", "boolean", "bForce", ",", "NonSimpleResult", "result", ",", "ProgressTracker", "progressTracker", ")", "{", "if", "(", "result", "!=", "null", ")", "{", "result", ".", "m_reason", "=", "NonSimpleResult", ".", "Reason", ".", "NotDetermined", ";", "result", ".", "m_vertexIndex1", "=", "-", "1", ";", "result", ".", "m_vertexIndex2", "=", "-", "1", ";", "}", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", "1", ";", "Geometry", ".", "Type", "gt", "=", "geometry", ".", "getType", "(", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Point", ")", "return", "1", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "spatialReference", ",", "geometry", ",", "false", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "/* const */", "Envelope", "env", "=", "(", "Envelope", ")", "geometry", ";", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "queryEnvelope2D", "(", "env2D", ")", ";", "if", "(", "env2D", ".", "isDegenerate", "(", "tolerance", ")", ")", "{", "if", "(", "result", "!=", "null", ")", "{", "result", ".", "m_reason", "=", "NonSimpleResult", ".", "Reason", ".", "DegenerateSegments", ";", "result", ".", "m_vertexIndex1", "=", "-", "1", ";", "result", ".", "m_vertexIndex2", "=", "-", "1", ";", "}", "return", "0", ";", "}", "return", "1", ";", "}", "else", "if", "(", "Geometry", ".", "isSegment", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "/* const */", "Segment", "seg", "=", "(", "Segment", ")", "geometry", ";", "Polyline", "polyline", "=", "new", "Polyline", "(", "seg", ".", "getDescription", "(", ")", ")", ";", "polyline", ".", "addSegment", "(", "seg", ",", "true", ")", ";", "return", "isSimpleAsFeature", "(", "polyline", ",", "spatialReference", ",", "bForce", ",", "result", ",", "progressTracker", ")", ";", "}", "// double geomTolerance = 0;", "int", "isSimple", "=", "(", "(", "MultiVertexGeometryImpl", ")", "geometry", ".", "_getImpl", "(", ")", ")", ".", "getIsSimple", "(", "tolerance", ")", ";", "int", "knownSimpleResult", "=", "bForce", "?", "-", "1", ":", "isSimple", ";", "// TODO: need to distinguish KnownSimple between SimpleAsFeature and", "// SimplePlanar.", "// From the first sight it seems the SimplePlanar implies", "// SimpleAsFeature.", "if", "(", "knownSimpleResult", "!=", "-", "1", ")", "return", "knownSimpleResult", ";", "OperatorSimplifyLocalHelper", "helper", "=", "new", "OperatorSimplifyLocalHelper", "(", "geometry", ",", "spatialReference", ",", "knownSimpleResult", ",", "progressTracker", ",", "false", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "MultiPoint", ")", "{", "knownSimpleResult", "=", "helper", ".", "multiPointIsSimpleAsFeature_", "(", ")", ";", "}", "else", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Polyline", ")", "{", "knownSimpleResult", "=", "helper", ".", "polylineIsSimpleAsFeature_", "(", ")", ";", "}", "else", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Polygon", ")", "{", "knownSimpleResult", "=", "helper", ".", "polygonIsSimpleAsFeature_", "(", ")", ";", "}", "else", "{", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "// what else?", "}", "(", "(", "MultiVertexGeometryImpl", ")", "(", "geometry", ".", "_getImpl", "(", ")", ")", ")", ".", "setIsSimple", "(", "knownSimpleResult", ",", "tolerance", ",", "false", ")", ";", "if", "(", "result", "!=", "null", "&&", "knownSimpleResult", "==", "0", ")", "result", ".", "Assign", "(", "helper", ".", "m_nonSimpleResult", ")", ";", "return", "knownSimpleResult", ";", "}"], "docstring": "Checks if Geometry is simple for storing in DB:\n\nMultiPoint:check that no points coincide.tolerance is ignored.\nPolyline:ensure there no segments degenerate segments. Polygon:Same as\nIsSimplePlanar.", "docstring_tokens": ["Checks", "if", "Geometry", "is", "simple", "for", "storing", "in", "DB", ":"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java#L1782-L1849", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java", "func_name": "OperatorSimplifyLocalHelper.simplifyAsFeature", "original_string": "static protected Geometry simplifyAsFeature(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn geometry;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn geometry;\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\t\tif (gt == Geometry.Type.Envelope) {\n\t\t\tEnvelope env = (Envelope) geometry;\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tenv.queryEnvelope2D(env2D);\n\t\t\tif (env2D.isDegenerate(tolerance)) {\n\t\t\t\treturn (Geometry) (env.createInstance()); // return empty\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// geometry\n\t\t\t}\n\t\t\treturn geometry;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\tSegment seg = (Segment) geometry;\n\t\t\tPolyline polyline = new Polyline(seg.getDescription());\n\t\t\tpolyline.addSegment(seg, true);\n\t\t\treturn simplifyAsFeature(polyline, spatialReference, bForce,\n\t\t\t\t\tprogressTracker);\n\t\t}\n\n\t\tdouble geomTolerance = 0;\n\t\tint isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())\n\t\t\t\t.getIsSimple(tolerance);\n\t\tint knownSimpleResult = bForce ? GeometryXSimple.Unknown : isSimple;\n\n\t\t// TODO: need to distinguish KnownSimple between SimpleAsFeature and\n\t\t// SimplePlanar.\n\t\t// From the first sight it seems the SimplePlanar implies\n\t\t// SimpleAsFeature.\n\t\tif (knownSimpleResult == GeometryXSimple.Strong) {\n\t        if (gt == Geometry.Type.Polygon && ((Polygon)geometry).getFillRule() != Polygon.FillRule.enumFillRuleOddEven)\n\t        {\n\t          Geometry res = geometry.copy();\n\t          ((Polygon)res).setFillRule(Polygon.FillRule.enumFillRuleOddEven);//standardize on odd_even fill rule\n\t          return res;\n\t        }\t\t\t\n\t        \n\t\t\treturn geometry;\n\t\t}\n\n\t\tOperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(\n\t\t\t\tgeometry, spatialReference, knownSimpleResult, progressTracker,\n\t\t\t\tfalse);\n\n\t\tGeometry result;\n\n\t\tif (gt == Geometry.Type.MultiPoint) {\n\t\t\tresult = (Geometry) (helper.multiPointSimplifyAsFeature_());\n\t\t} else if (gt == Geometry.Type.Polyline) {\n\t\t\tresult = (Geometry) (helper.polylineSimplifyAsFeature_());\n\t\t} else if (gt == Geometry.Type.Polygon) {\n\t\t\tresult = (Geometry) (helper.polygonSimplifyAsFeature_());\n\t\t} else {\n\t\t\tthrow GeometryException.GeometryInternalError(); // what else?\n\t\t}\n\n\t\treturn result;\n\t}", "language": "java", "code": "static protected Geometry simplifyAsFeature(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn geometry;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn geometry;\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\t\tif (gt == Geometry.Type.Envelope) {\n\t\t\tEnvelope env = (Envelope) geometry;\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tenv.queryEnvelope2D(env2D);\n\t\t\tif (env2D.isDegenerate(tolerance)) {\n\t\t\t\treturn (Geometry) (env.createInstance()); // return empty\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// geometry\n\t\t\t}\n\t\t\treturn geometry;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\tSegment seg = (Segment) geometry;\n\t\t\tPolyline polyline = new Polyline(seg.getDescription());\n\t\t\tpolyline.addSegment(seg, true);\n\t\t\treturn simplifyAsFeature(polyline, spatialReference, bForce,\n\t\t\t\t\tprogressTracker);\n\t\t}\n\n\t\tdouble geomTolerance = 0;\n\t\tint isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())\n\t\t\t\t.getIsSimple(tolerance);\n\t\tint knownSimpleResult = bForce ? GeometryXSimple.Unknown : isSimple;\n\n\t\t// TODO: need to distinguish KnownSimple between SimpleAsFeature and\n\t\t// SimplePlanar.\n\t\t// From the first sight it seems the SimplePlanar implies\n\t\t// SimpleAsFeature.\n\t\tif (knownSimpleResult == GeometryXSimple.Strong) {\n\t        if (gt == Geometry.Type.Polygon && ((Polygon)geometry).getFillRule() != Polygon.FillRule.enumFillRuleOddEven)\n\t        {\n\t          Geometry res = geometry.copy();\n\t          ((Polygon)res).setFillRule(Polygon.FillRule.enumFillRuleOddEven);//standardize on odd_even fill rule\n\t          return res;\n\t        }\t\t\t\n\t        \n\t\t\treturn geometry;\n\t\t}\n\n\t\tOperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(\n\t\t\t\tgeometry, spatialReference, knownSimpleResult, progressTracker,\n\t\t\t\tfalse);\n\n\t\tGeometry result;\n\n\t\tif (gt == Geometry.Type.MultiPoint) {\n\t\t\tresult = (Geometry) (helper.multiPointSimplifyAsFeature_());\n\t\t} else if (gt == Geometry.Type.Polyline) {\n\t\t\tresult = (Geometry) (helper.polylineSimplifyAsFeature_());\n\t\t} else if (gt == Geometry.Type.Polygon) {\n\t\t\tresult = (Geometry) (helper.polygonSimplifyAsFeature_());\n\t\t} else {\n\t\t\tthrow GeometryException.GeometryInternalError(); // what else?\n\t\t}\n\n\t\treturn result;\n\t}", "code_tokens": ["static", "protected", "Geometry", "simplifyAsFeature", "(", "/* const */", "Geometry", "geometry", ",", "/* const */", "SpatialReference", "spatialReference", ",", "boolean", "bForce", ",", "ProgressTracker", "progressTracker", ")", "{", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", "geometry", ";", "Geometry", ".", "Type", "gt", "=", "geometry", ".", "getType", "(", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Point", ")", "return", "geometry", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "spatialReference", ",", "geometry", ",", "false", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "Envelope", "env", "=", "(", "Envelope", ")", "geometry", ";", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "queryEnvelope2D", "(", "env2D", ")", ";", "if", "(", "env2D", ".", "isDegenerate", "(", "tolerance", ")", ")", "{", "return", "(", "Geometry", ")", "(", "env", ".", "createInstance", "(", ")", ")", ";", "// return empty", "// geometry", "}", "return", "geometry", ";", "}", "else", "if", "(", "Geometry", ".", "isSegment", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "Segment", "seg", "=", "(", "Segment", ")", "geometry", ";", "Polyline", "polyline", "=", "new", "Polyline", "(", "seg", ".", "getDescription", "(", ")", ")", ";", "polyline", ".", "addSegment", "(", "seg", ",", "true", ")", ";", "return", "simplifyAsFeature", "(", "polyline", ",", "spatialReference", ",", "bForce", ",", "progressTracker", ")", ";", "}", "double", "geomTolerance", "=", "0", ";", "int", "isSimple", "=", "(", "(", "MultiVertexGeometryImpl", ")", "geometry", ".", "_getImpl", "(", ")", ")", ".", "getIsSimple", "(", "tolerance", ")", ";", "int", "knownSimpleResult", "=", "bForce", "?", "GeometryXSimple", ".", "Unknown", ":", "isSimple", ";", "// TODO: need to distinguish KnownSimple between SimpleAsFeature and", "// SimplePlanar.", "// From the first sight it seems the SimplePlanar implies", "// SimpleAsFeature.", "if", "(", "knownSimpleResult", "==", "GeometryXSimple", ".", "Strong", ")", "{", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Polygon", "&&", "(", "(", "Polygon", ")", "geometry", ")", ".", "getFillRule", "(", ")", "!=", "Polygon", ".", "FillRule", ".", "enumFillRuleOddEven", ")", "{", "Geometry", "res", "=", "geometry", ".", "copy", "(", ")", ";", "(", "(", "Polygon", ")", "res", ")", ".", "setFillRule", "(", "Polygon", ".", "FillRule", ".", "enumFillRuleOddEven", ")", ";", "//standardize on odd_even fill rule", "return", "res", ";", "}", "return", "geometry", ";", "}", "OperatorSimplifyLocalHelper", "helper", "=", "new", "OperatorSimplifyLocalHelper", "(", "geometry", ",", "spatialReference", ",", "knownSimpleResult", ",", "progressTracker", ",", "false", ")", ";", "Geometry", "result", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "MultiPoint", ")", "{", "result", "=", "(", "Geometry", ")", "(", "helper", ".", "multiPointSimplifyAsFeature_", "(", ")", ")", ";", "}", "else", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Polyline", ")", "{", "result", "=", "(", "Geometry", ")", "(", "helper", ".", "polylineSimplifyAsFeature_", "(", ")", ")", ";", "}", "else", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Polygon", ")", "{", "result", "=", "(", "Geometry", ")", "(", "helper", ".", "polygonSimplifyAsFeature_", "(", ")", ")", ";", "}", "else", "{", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "// what else?", "}", "return", "result", ";", "}"], "docstring": "Simplifies geometries for storing in DB:\n\nMultiPoint:check that no points coincide.tolerance is ignored.\nPolyline:ensure there no segments degenerate segments. Polygon:cracks and\nclusters using cluster tolerance and resolves all self intersections,\norients rings properly and arranges the rings in the OGC order.\n\nReturns simplified geometry.", "docstring_tokens": ["Simplifies", "geometries", "for", "storing", "in", "DB", ":"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java#L1917-L1982", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java", "func_name": "OperatorSimplifyLocalHelper.simplifyOGC", "original_string": "static Geometry simplifyOGC(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn geometry;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn geometry;\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\t\tif (gt == Geometry.Type.Envelope) {\n\t\t\tEnvelope env = (Envelope) geometry;\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tenv.queryEnvelope2D(env2D);\n\t\t\tif (env2D.isDegenerate(tolerance)) {\n\t\t\t\treturn (Geometry) (env.createInstance()); // return empty\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// geometry\n\t\t\t}\n\t\t\treturn geometry;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\tSegment seg = (Segment) geometry;\n\t\t\tPolyline polyline = new Polyline(seg.getDescription());\n\t\t\tpolyline.addSegment(seg, true);\n\t\t\treturn simplifyOGC(polyline, spatialReference, bForce,\n\t\t\t\t\tprogressTracker);\n\t\t}\n\n\t\tif (!Geometry.isMultiVertex(gt.value())) {\n\t\t\tthrow new GeometryException(\"OGC simplify is not implemented for this geometry type\" + gt);\n\t\t}\n\n\t\tMultiVertexGeometry result = TopologicalOperations.simplifyOGC(\n\t\t\t\t(MultiVertexGeometry) geometry, tolerance, false, progressTracker);\n\n\t\treturn result;\n\t}", "language": "java", "code": "static Geometry simplifyOGC(/* const */Geometry geometry, /* const */\n\tSpatialReference spatialReference, boolean bForce,\n\t\t\tProgressTracker progressTracker) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn geometry;\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn geometry;\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(\n\t\t\t\tspatialReference, geometry, false);\n\t\tif (gt == Geometry.Type.Envelope) {\n\t\t\tEnvelope env = (Envelope) geometry;\n\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\tenv.queryEnvelope2D(env2D);\n\t\t\tif (env2D.isDegenerate(tolerance)) {\n\t\t\t\treturn (Geometry) (env.createInstance()); // return empty\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// geometry\n\t\t\t}\n\t\t\treturn geometry;\n\t\t} else if (Geometry.isSegment(gt.value())) {\n\t\t\tSegment seg = (Segment) geometry;\n\t\t\tPolyline polyline = new Polyline(seg.getDescription());\n\t\t\tpolyline.addSegment(seg, true);\n\t\t\treturn simplifyOGC(polyline, spatialReference, bForce,\n\t\t\t\t\tprogressTracker);\n\t\t}\n\n\t\tif (!Geometry.isMultiVertex(gt.value())) {\n\t\t\tthrow new GeometryException(\"OGC simplify is not implemented for this geometry type\" + gt);\n\t\t}\n\n\t\tMultiVertexGeometry result = TopologicalOperations.simplifyOGC(\n\t\t\t\t(MultiVertexGeometry) geometry, tolerance, false, progressTracker);\n\n\t\treturn result;\n\t}", "code_tokens": ["static", "Geometry", "simplifyOGC", "(", "/* const */", "Geometry", "geometry", ",", "/* const */", "SpatialReference", "spatialReference", ",", "boolean", "bForce", ",", "ProgressTracker", "progressTracker", ")", "{", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", "geometry", ";", "Geometry", ".", "Type", "gt", "=", "geometry", ".", "getType", "(", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Point", ")", "return", "geometry", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "spatialReference", ",", "geometry", ",", "false", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "{", "Envelope", "env", "=", "(", "Envelope", ")", "geometry", ";", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "queryEnvelope2D", "(", "env2D", ")", ";", "if", "(", "env2D", ".", "isDegenerate", "(", "tolerance", ")", ")", "{", "return", "(", "Geometry", ")", "(", "env", ".", "createInstance", "(", ")", ")", ";", "// return empty", "// geometry", "}", "return", "geometry", ";", "}", "else", "if", "(", "Geometry", ".", "isSegment", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "Segment", "seg", "=", "(", "Segment", ")", "geometry", ";", "Polyline", "polyline", "=", "new", "Polyline", "(", "seg", ".", "getDescription", "(", ")", ")", ";", "polyline", ".", "addSegment", "(", "seg", ",", "true", ")", ";", "return", "simplifyOGC", "(", "polyline", ",", "spatialReference", ",", "bForce", ",", "progressTracker", ")", ";", "}", "if", "(", "!", "Geometry", ".", "isMultiVertex", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "throw", "new", "GeometryException", "(", "\"OGC simplify is not implemented for this geometry type\"", "+", "gt", ")", ";", "}", "MultiVertexGeometry", "result", "=", "TopologicalOperations", ".", "simplifyOGC", "(", "(", "MultiVertexGeometry", ")", "geometry", ",", "tolerance", ",", "false", ",", "progressTracker", ")", ";", "return", "result", ";", "}"], "docstring": "Simplifies geometries for storing in OGC format:\n\nMultiPoint:check that no points coincide.tolerance is ignored.\nPolyline:ensure there no segments degenerate segments. Polygon:cracks and\nclusters using cluster tolerance and resolves all self intersections,\norients rings properly and arranges the rings in the OGC order.\n\nReturns simplified geometry.", "docstring_tokens": ["Simplifies", "geometries", "for", "storing", "in", "OGC", "format", ":"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java#L1994-L2030", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java", "func_name": "OperatorSimplifyLocalHelper.edgeAngleCompare_", "original_string": "private int edgeAngleCompare_(/* const */Edge edge1, /* const */Edge edge2) {\n\t\tif (edge1.equals(edge2))\n\t\t\treturn 0;\n\n\t\tPoint2D v1 = edge1.m_segment._getTangent(edge1.getReversed() ? 1.0\n\t\t\t\t: 0.0);\n\t\tif (edge1.getReversed())\n\t\t\tv1.negate();\n\t\tPoint2D v2 = edge2.m_segment._getTangent(edge2.getReversed() ? 1.0\n\t\t\t\t: 0.0);\n\t\tif (edge2.getReversed())\n\t\t\tv2.negate();\n\n\t\tint q1 = v1._getQuarter();\n\t\tint q2 = v2._getQuarter();\n\n\t\tif (q2 == q1) {\n\t\t\tdouble cross = v1.crossProduct(v2);\n\t\t\tdouble crossError = 4 * NumberUtils.doubleEps()\n\t\t\t\t\t* (Math.abs(v2.x * v1.y) + Math.abs(v2.y * v1.x));\n\t\t\tif (Math.abs(cross) <= crossError) {\n\t\t\t\tcross--; // To avoid warning of \"this line has no effect\" from\n\t\t\t\t\t\t\t// cross = cross.\n\t\t\t\tcross++;\n\t\t\t}\n\t\t\tassert (Math.abs(cross) > crossError);\n\t\t\treturn cross < 0 ? 1 : (cross > 0 ? -1 : 0);\n\t\t} else {\n\t\t\treturn q1 < q2 ? -1 : 1;\n\t\t}\n\t}", "language": "java", "code": "private int edgeAngleCompare_(/* const */Edge edge1, /* const */Edge edge2) {\n\t\tif (edge1.equals(edge2))\n\t\t\treturn 0;\n\n\t\tPoint2D v1 = edge1.m_segment._getTangent(edge1.getReversed() ? 1.0\n\t\t\t\t: 0.0);\n\t\tif (edge1.getReversed())\n\t\t\tv1.negate();\n\t\tPoint2D v2 = edge2.m_segment._getTangent(edge2.getReversed() ? 1.0\n\t\t\t\t: 0.0);\n\t\tif (edge2.getReversed())\n\t\t\tv2.negate();\n\n\t\tint q1 = v1._getQuarter();\n\t\tint q2 = v2._getQuarter();\n\n\t\tif (q2 == q1) {\n\t\t\tdouble cross = v1.crossProduct(v2);\n\t\t\tdouble crossError = 4 * NumberUtils.doubleEps()\n\t\t\t\t\t* (Math.abs(v2.x * v1.y) + Math.abs(v2.y * v1.x));\n\t\t\tif (Math.abs(cross) <= crossError) {\n\t\t\t\tcross--; // To avoid warning of \"this line has no effect\" from\n\t\t\t\t\t\t\t// cross = cross.\n\t\t\t\tcross++;\n\t\t\t}\n\t\t\tassert (Math.abs(cross) > crossError);\n\t\t\treturn cross < 0 ? 1 : (cross > 0 ? -1 : 0);\n\t\t} else {\n\t\t\treturn q1 < q2 ? -1 : 1;\n\t\t}\n\t}", "code_tokens": ["private", "int", "edgeAngleCompare_", "(", "/* const */", "Edge", "edge1", ",", "/* const */", "Edge", "edge2", ")", "{", "if", "(", "edge1", ".", "equals", "(", "edge2", ")", ")", "return", "0", ";", "Point2D", "v1", "=", "edge1", ".", "m_segment", ".", "_getTangent", "(", "edge1", ".", "getReversed", "(", ")", "?", "1.0", ":", "0.0", ")", ";", "if", "(", "edge1", ".", "getReversed", "(", ")", ")", "v1", ".", "negate", "(", ")", ";", "Point2D", "v2", "=", "edge2", ".", "m_segment", ".", "_getTangent", "(", "edge2", ".", "getReversed", "(", ")", "?", "1.0", ":", "0.0", ")", ";", "if", "(", "edge2", ".", "getReversed", "(", ")", ")", "v2", ".", "negate", "(", ")", ";", "int", "q1", "=", "v1", ".", "_getQuarter", "(", ")", ";", "int", "q2", "=", "v2", ".", "_getQuarter", "(", ")", ";", "if", "(", "q2", "==", "q1", ")", "{", "double", "cross", "=", "v1", ".", "crossProduct", "(", "v2", ")", ";", "double", "crossError", "=", "4", "*", "NumberUtils", ".", "doubleEps", "(", ")", "*", "(", "Math", ".", "abs", "(", "v2", ".", "x", "*", "v1", ".", "y", ")", "+", "Math", ".", "abs", "(", "v2", ".", "y", "*", "v1", ".", "x", ")", ")", ";", "if", "(", "Math", ".", "abs", "(", "cross", ")", "<=", "crossError", ")", "{", "cross", "--", ";", "// To avoid warning of \"this line has no effect\" from", "// cross = cross.", "cross", "++", ";", "}", "assert", "(", "Math", ".", "abs", "(", "cross", ")", ">", "crossError", ")", ";", "return", "cross", "<", "0", "?", "1", ":", "(", "cross", ">", "0", "?", "-", "1", ":", "0", ")", ";", "}", "else", "{", "return", "q1", "<", "q2", "?", "-", "1", ":", "1", ";", "}", "}"], "docstring": "compares angles between two edges", "docstring_tokens": ["compares", "angles", "between", "two", "edges"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplifyLocalHelper.java#L2190-L2220", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getEnvelope2D", "original_string": "Envelope2D getEnvelope2D() {\n\t\tEnvelope2D env = new Envelope2D();\n\t\tenv.setEmpty();\n\t\tVertexIterator vert_iter = queryVertexIterator();\n\t\tPoint2D pt = new Point2D();\n\t\tboolean b_first = true;\n\t\tfor (int ivertex = vert_iter.next(); ivertex != -1; ivertex = vert_iter\n\t\t\t\t.next()) {\n\t\t\tgetXY(ivertex, pt);\n\t\t\tif (b_first)\n\t\t\t\tenv.merge(pt.x, pt.y);\n\t\t\telse\n\t\t\t\tenv.mergeNE(pt.x, pt.y);\n\n\t\t\tb_first = false;\n\t\t}\n\n\t\treturn env;\n\t}", "language": "java", "code": "Envelope2D getEnvelope2D() {\n\t\tEnvelope2D env = new Envelope2D();\n\t\tenv.setEmpty();\n\t\tVertexIterator vert_iter = queryVertexIterator();\n\t\tPoint2D pt = new Point2D();\n\t\tboolean b_first = true;\n\t\tfor (int ivertex = vert_iter.next(); ivertex != -1; ivertex = vert_iter\n\t\t\t\t.next()) {\n\t\t\tgetXY(ivertex, pt);\n\t\t\tif (b_first)\n\t\t\t\tenv.merge(pt.x, pt.y);\n\t\t\telse\n\t\t\t\tenv.mergeNE(pt.x, pt.y);\n\n\t\t\tb_first = false;\n\t\t}\n\n\t\treturn env;\n\t}", "code_tokens": ["Envelope2D", "getEnvelope2D", "(", ")", "{", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "setEmpty", "(", ")", ";", "VertexIterator", "vert_iter", "=", "queryVertexIterator", "(", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "boolean", "b_first", "=", "true", ";", "for", "(", "int", "ivertex", "=", "vert_iter", ".", "next", "(", ")", ";", "ivertex", "!=", "-", "1", ";", "ivertex", "=", "vert_iter", ".", "next", "(", ")", ")", "{", "getXY", "(", "ivertex", ",", "pt", ")", ";", "if", "(", "b_first", ")", "env", ".", "merge", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "else", "env", ".", "mergeNE", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "b_first", "=", "false", ";", "}", "return", "env", ";", "}"], "docstring": "Returns envelope of all coordinates.", "docstring_tokens": ["Returns", "envelope", "of", "all", "coordinates", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L549-L567", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.addGeometry", "original_string": "int addGeometry(Geometry geometry) {\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (Geometry.isMultiPath(gt.value()))\n\t\t\treturn addMultiPath_((MultiPath) geometry);\n\t\tif (gt == Geometry.Type.MultiPoint)\n\t\t\treturn addMultiPoint_((MultiPoint) geometry);\n\n\t\tthrow GeometryException.GeometryInternalError();\n\t}", "language": "java", "code": "int addGeometry(Geometry geometry) {\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (Geometry.isMultiPath(gt.value()))\n\t\t\treturn addMultiPath_((MultiPath) geometry);\n\t\tif (gt == Geometry.Type.MultiPoint)\n\t\t\treturn addMultiPoint_((MultiPoint) geometry);\n\n\t\tthrow GeometryException.GeometryInternalError();\n\t}", "code_tokens": ["int", "addGeometry", "(", "Geometry", "geometry", ")", "{", "Geometry", ".", "Type", "gt", "=", "geometry", ".", "getType", "(", ")", ";", "if", "(", "Geometry", ".", "isMultiPath", "(", "gt", ".", "value", "(", ")", ")", ")", "return", "addMultiPath_", "(", "(", "MultiPath", ")", "geometry", ")", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "MultiPoint", ")", "return", "addMultiPoint_", "(", "(", "MultiPoint", ")", "geometry", ")", ";", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}"], "docstring": "Adds a Geometry to the Edit_shape", "docstring_tokens": ["Adds", "a", "Geometry", "to", "the", "Edit_shape"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L575-L583", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.appendGeometry", "original_string": "void appendGeometry(int dstGeometry, Geometry srcGeometry) {\n\t\tGeometry.Type gt = srcGeometry.getType();\n\t\tif (Geometry.isMultiPath(gt.value())) {\n\t\t\tappendMultiPath_(dstGeometry, (MultiPath) srcGeometry);\n\t\t\treturn;\n\t\t} else if (gt.value() == Geometry.GeometryType.MultiPoint) {\n\t\t\tappendMultiPoint_(dstGeometry, (MultiPoint) srcGeometry);\n\t\t\treturn;\n\t\t}\n\n\t\tthrow GeometryException.GeometryInternalError();\n\t}", "language": "java", "code": "void appendGeometry(int dstGeometry, Geometry srcGeometry) {\n\t\tGeometry.Type gt = srcGeometry.getType();\n\t\tif (Geometry.isMultiPath(gt.value())) {\n\t\t\tappendMultiPath_(dstGeometry, (MultiPath) srcGeometry);\n\t\t\treturn;\n\t\t} else if (gt.value() == Geometry.GeometryType.MultiPoint) {\n\t\t\tappendMultiPoint_(dstGeometry, (MultiPoint) srcGeometry);\n\t\t\treturn;\n\t\t}\n\n\t\tthrow GeometryException.GeometryInternalError();\n\t}", "code_tokens": ["void", "appendGeometry", "(", "int", "dstGeometry", ",", "Geometry", "srcGeometry", ")", "{", "Geometry", ".", "Type", "gt", "=", "srcGeometry", ".", "getType", "(", ")", ";", "if", "(", "Geometry", ".", "isMultiPath", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "appendMultiPath_", "(", "dstGeometry", ",", "(", "MultiPath", ")", "srcGeometry", ")", ";", "return", ";", "}", "else", "if", "(", "gt", ".", "value", "(", ")", "==", "Geometry", ".", "GeometryType", ".", "MultiPoint", ")", "{", "appendMultiPoint_", "(", "dstGeometry", ",", "(", "MultiPoint", ")", "srcGeometry", ")", ";", "return", ";", "}", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}"], "docstring": "Append a Geometry to the given geometry of the Edit_shape", "docstring_tokens": ["Append", "a", "Geometry", "to", "the", "given", "geometry", "of", "the", "Edit_shape"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L586-L597", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.addPathFromMultiPath", "original_string": "int addPathFromMultiPath(MultiPath multi_path, int ipath, boolean as_polygon) {\n\t\tint newgeom = createGeometry(as_polygon ? Geometry.Type.Polygon\n\t\t\t\t: Geometry.Type.Polyline, multi_path.getDescription());\n\n\t\tMultiPathImpl mp_impl = (MultiPathImpl) multi_path._getImpl();\n\t\tif (multi_path.getPathSize(ipath) < 2)\n\t\t\treturn newgeom; //return empty geometry\n\n\t\t// m_vertices->reserve_rounded(m_vertices->get_point_count() +\n\t\t// multi_path.get_path_size(ipath));//ensure reallocation happens by\n\t\t// blocks so that already allocated vertices do not get reallocated.\n\t\tm_vertices_mp.add(multi_path, multi_path.getPathStart(ipath),\n\t\t\t\tmp_impl.getPathEnd(ipath));\n\t\tm_xy_stream = (AttributeStreamOfDbl) m_vertices\n\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\n\t\tint path = insertPath(newgeom, -1);\n\t\tsetClosedPath(path, mp_impl.isClosedPath(ipath) || as_polygon);\n\n\t\tboolean b_some_segments = m_segments != null\n\t\t\t\t&& mp_impl.getSegmentFlagsStreamRef() != null;\n\n\t\tfor (int ivertex = mp_impl.getPathStart(ipath), iend = mp_impl\n\t\t\t\t.getPathEnd(ipath); ivertex < iend; ivertex++) {\n\t\t\tint vertex = insertVertex_(path, -1, null);\n\t\t\tif (b_some_segments) {\n\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\tif ((mp_impl.getSegmentFlags(ivertex) & SegmentFlags.enumLineSeg) != 0) {\n\t\t\t\t\tsetSegmentToIndex_(vindex, null);\n\t\t\t\t} else {\n\t\t\t\t\tSegmentBuffer seg_buffer = new SegmentBuffer();\n\t\t\t\t\tmp_impl.getSegment(ivertex, seg_buffer, true);\n\t\t\t\t\tsetSegmentToIndex_(vindex, seg_buffer.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newgeom;\n\t}", "language": "java", "code": "int addPathFromMultiPath(MultiPath multi_path, int ipath, boolean as_polygon) {\n\t\tint newgeom = createGeometry(as_polygon ? Geometry.Type.Polygon\n\t\t\t\t: Geometry.Type.Polyline, multi_path.getDescription());\n\n\t\tMultiPathImpl mp_impl = (MultiPathImpl) multi_path._getImpl();\n\t\tif (multi_path.getPathSize(ipath) < 2)\n\t\t\treturn newgeom; //return empty geometry\n\n\t\t// m_vertices->reserve_rounded(m_vertices->get_point_count() +\n\t\t// multi_path.get_path_size(ipath));//ensure reallocation happens by\n\t\t// blocks so that already allocated vertices do not get reallocated.\n\t\tm_vertices_mp.add(multi_path, multi_path.getPathStart(ipath),\n\t\t\t\tmp_impl.getPathEnd(ipath));\n\t\tm_xy_stream = (AttributeStreamOfDbl) m_vertices\n\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\n\t\tint path = insertPath(newgeom, -1);\n\t\tsetClosedPath(path, mp_impl.isClosedPath(ipath) || as_polygon);\n\n\t\tboolean b_some_segments = m_segments != null\n\t\t\t\t&& mp_impl.getSegmentFlagsStreamRef() != null;\n\n\t\tfor (int ivertex = mp_impl.getPathStart(ipath), iend = mp_impl\n\t\t\t\t.getPathEnd(ipath); ivertex < iend; ivertex++) {\n\t\t\tint vertex = insertVertex_(path, -1, null);\n\t\t\tif (b_some_segments) {\n\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\tif ((mp_impl.getSegmentFlags(ivertex) & SegmentFlags.enumLineSeg) != 0) {\n\t\t\t\t\tsetSegmentToIndex_(vindex, null);\n\t\t\t\t} else {\n\t\t\t\t\tSegmentBuffer seg_buffer = new SegmentBuffer();\n\t\t\t\t\tmp_impl.getSegment(ivertex, seg_buffer, true);\n\t\t\t\t\tsetSegmentToIndex_(vindex, seg_buffer.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newgeom;\n\t}", "code_tokens": ["int", "addPathFromMultiPath", "(", "MultiPath", "multi_path", ",", "int", "ipath", ",", "boolean", "as_polygon", ")", "{", "int", "newgeom", "=", "createGeometry", "(", "as_polygon", "?", "Geometry", ".", "Type", ".", "Polygon", ":", "Geometry", ".", "Type", ".", "Polyline", ",", "multi_path", ".", "getDescription", "(", ")", ")", ";", "MultiPathImpl", "mp_impl", "=", "(", "MultiPathImpl", ")", "multi_path", ".", "_getImpl", "(", ")", ";", "if", "(", "multi_path", ".", "getPathSize", "(", "ipath", ")", "<", "2", ")", "return", "newgeom", ";", "//return empty geometry", "// m_vertices->reserve_rounded(m_vertices->get_point_count() +", "// multi_path.get_path_size(ipath));//ensure reallocation happens by", "// blocks so that already allocated vertices do not get reallocated.", "m_vertices_mp", ".", "add", "(", "multi_path", ",", "multi_path", ".", "getPathStart", "(", "ipath", ")", ",", "mp_impl", ".", "getPathEnd", "(", "ipath", ")", ")", ";", "m_xy_stream", "=", "(", "AttributeStreamOfDbl", ")", "m_vertices", ".", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "int", "path", "=", "insertPath", "(", "newgeom", ",", "-", "1", ")", ";", "setClosedPath", "(", "path", ",", "mp_impl", ".", "isClosedPath", "(", "ipath", ")", "||", "as_polygon", ")", ";", "boolean", "b_some_segments", "=", "m_segments", "!=", "null", "&&", "mp_impl", ".", "getSegmentFlagsStreamRef", "(", ")", "!=", "null", ";", "for", "(", "int", "ivertex", "=", "mp_impl", ".", "getPathStart", "(", "ipath", ")", ",", "iend", "=", "mp_impl", ".", "getPathEnd", "(", "ipath", ")", ";", "ivertex", "<", "iend", ";", "ivertex", "++", ")", "{", "int", "vertex", "=", "insertVertex_", "(", "path", ",", "-", "1", ",", "null", ")", ";", "if", "(", "b_some_segments", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "if", "(", "(", "mp_impl", ".", "getSegmentFlags", "(", "ivertex", ")", "&", "SegmentFlags", ".", "enumLineSeg", ")", "!=", "0", ")", "{", "setSegmentToIndex_", "(", "vindex", ",", "null", ")", ";", "}", "else", "{", "SegmentBuffer", "seg_buffer", "=", "new", "SegmentBuffer", "(", ")", ";", "mp_impl", ".", "getSegment", "(", "ivertex", ",", "seg_buffer", ",", "true", ")", ";", "setSegmentToIndex_", "(", "vindex", ",", "seg_buffer", ".", "get", "(", ")", ")", ";", "}", "}", "}", "return", "newgeom", ";", "}"], "docstring": "Adds a path", "docstring_tokens": ["Adds", "a", "path"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L600-L638", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getGeometry", "original_string": "Geometry getGeometry(int geometry) {\n\t\tint gt = getGeometryType(geometry);\n\t\tGeometry geom = InternalUtils.createGeometry(gt,\n\t\t\t\tm_vertices_mp.getDescription());\n\t\tint point_count = getPointCount(geometry);\n\n\t\tif (point_count == 0)\n\t\t\treturn geom;\n\n\t\tif (Geometry.isMultiPath(gt)) {\n\t\t\tMultiPathImpl mp_impl = (MultiPathImpl) geom._getImpl();\n\t\t\tint path_count = getPathCount(geometry);\n\t\t\tAttributeStreamOfInt32 parts = (AttributeStreamOfInt32) (AttributeStreamBase\n\t\t\t\t\t.createIndexStream(path_count + 1));\n\t\t\tAttributeStreamOfInt8 pathFlags = (AttributeStreamOfInt8) (AttributeStreamBase\n\t\t\t\t\t.createByteStream(path_count + 1, (byte) 0));\n\t\t\tVertexDescription description = geom.getDescription();\n\n\t\t\tfor (int iattrib = 0, nattrib = description.getAttributeCount(); iattrib < nattrib; iattrib++) {\n\t\t\t\tint semantics = description.getSemantics(iattrib);\n\t\t\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\t\t\tAttributeStreamBase dst_stream = AttributeStreamBase\n\t\t\t\t\t\t.createAttributeStreamWithSemantics(semantics,\n\t\t\t\t\t\t\t\tpoint_count);\n\t\t\t\tAttributeStreamBase src_stream = m_vertices\n\t\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\t\tint dst_index = 0;\n\t\t\t\tint ipath = 0;\n\t\t\t\tint nvert = 0;\n\t\t\t\tfor (int path = getFirstPath(geometry); path != -1; path = getNextPath(path)) {\n\t\t\t\t\tbyte flag_mask = 0;\n\t\t\t\t\tif (isClosedPath(path)) {\n\t\t\t\t\t\tflag_mask |= (byte) PathFlags.enumClosed;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert (gt != Geometry.GeometryType.Polygon);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isExterior(path)) {\n\t\t\t\t\t\tflag_mask |= (byte) PathFlags.enumOGCStartPolygon;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flag_mask != 0)\n\t\t\t\t\t\tpathFlags.setBits(ipath, flag_mask);\n\n\t\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\t\tparts.write(ipath++, nvert);\n\t\t\t\t\tnvert += path_size;\n\t\t\t\t\tif (semantics == VertexDescription.Semantics.POSITION) {\n\t\t\t\t\t\tAttributeStreamOfDbl src_stream_dbl = (AttributeStreamOfDbl) (src_stream);\n\t\t\t\t\t\tAttributeStreamOfDbl dst_stream_dbl = (AttributeStreamOfDbl) (dst_stream);\n\t\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\t\tfor (int vertex = getFirstVertex(path); dst_index < nvert; vertex = getNextVertex(vertex), dst_index++) {\n\t\t\t\t\t\t\tint src_index = getVertexIndex(vertex);\n\t\t\t\t\t\t\tsrc_stream_dbl.read(src_index * 2, pt);\n\t\t\t\t\t\t\tdst_stream_dbl.write(dst_index * 2, pt);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int vertex = getFirstVertex(path); dst_index < nvert; vertex = getNextVertex(vertex), dst_index++) {\n\t\t\t\t\t\t\tint src_index = getVertexIndex(vertex);\n\t\t\t\t\t\t\tfor (int icomp = 0; icomp < ncomps; icomp++) {\n\t\t\t\t\t\t\t\tdouble d = src_stream.readAsDbl(src_index\n\t\t\t\t\t\t\t\t\t\t* ncomps + icomp);\n\t\t\t\t\t\t\t\tdst_stream.writeAsDbl(dst_index * ncomps\n\t\t\t\t\t\t\t\t\t\t+ icomp, d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassert (nvert == point_count);// Inconsistent content in the\n\t\t\t\t\t\t\t\t\t\t\t\t// Edit_shape. Please, fix.\n\t\t\t\tassert (ipath == path_count);\n\t\t\t\tmp_impl.setAttributeStreamRef(semantics, dst_stream);\n\t\t\t\tparts.write(path_count, point_count);\n\t\t\t}\n\n\t\t\tmp_impl.setPathFlagsStreamRef(pathFlags);\n\t\t\tmp_impl.setPathStreamRef(parts);\n\t\t\tmp_impl.notifyModified(DirtyFlags.dirtyAll);\n\t\t} else if (gt == Geometry.GeometryType.MultiPoint) {\n\t\t\tMultiPointImpl mp_impl = (MultiPointImpl) geom._getImpl();\n\t\t\tVertexDescription description = geom.getDescription();\n\t\t\t// mp_impl.reserve(point_count);\n\t\t\tmp_impl.resize(point_count);\n\n\t\t\tfor (int iattrib = 0, nattrib = description.getAttributeCount(); iattrib < nattrib; iattrib++) {\n\t\t\t\tint semantics = description.getSemantics(iattrib);\n\t\t\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\t\t\tAttributeStreamBase dst_stream = mp_impl\n\t\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\t\t// std::shared_ptr<Attribute_stream_base> dst_stream =\n\t\t\t\t// Attribute_stream_base::create_attribute_stream(semantics,\n\t\t\t\t// point_count);\n\t\t\t\tAttributeStreamBase src_stream = m_vertices\n\t\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\t\tint dst_index = 0;\n\t\t\t\tassert (getPathCount(geometry) == 1);\n\t\t\t\tint path = getFirstPath(geometry);\n\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\tfor (int vertex = getFirstVertex(path); dst_index < path_size; vertex = getNextVertex(vertex), dst_index++) {\n\t\t\t\t\tint src_index = getVertexIndex(vertex);\n\t\t\t\t\tfor (int icomp = 0; icomp < ncomps; icomp++) {\n\t\t\t\t\t\tdouble d = src_stream.readAsDbl(src_index * ncomps\n\t\t\t\t\t\t\t\t+ icomp);\n\t\t\t\t\t\tdst_stream.writeAsDbl(dst_index * ncomps + icomp, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmp_impl.setAttributeStreamRef(semantics, dst_stream);\n\t\t\t}\n\n\t\t\tmp_impl.notifyModified(DirtyFlags.dirtyAll);\n\t\t} else {\n\t\t\tassert (false);\n\t\t}\n\n\t\treturn geom;\n\t}", "language": "java", "code": "Geometry getGeometry(int geometry) {\n\t\tint gt = getGeometryType(geometry);\n\t\tGeometry geom = InternalUtils.createGeometry(gt,\n\t\t\t\tm_vertices_mp.getDescription());\n\t\tint point_count = getPointCount(geometry);\n\n\t\tif (point_count == 0)\n\t\t\treturn geom;\n\n\t\tif (Geometry.isMultiPath(gt)) {\n\t\t\tMultiPathImpl mp_impl = (MultiPathImpl) geom._getImpl();\n\t\t\tint path_count = getPathCount(geometry);\n\t\t\tAttributeStreamOfInt32 parts = (AttributeStreamOfInt32) (AttributeStreamBase\n\t\t\t\t\t.createIndexStream(path_count + 1));\n\t\t\tAttributeStreamOfInt8 pathFlags = (AttributeStreamOfInt8) (AttributeStreamBase\n\t\t\t\t\t.createByteStream(path_count + 1, (byte) 0));\n\t\t\tVertexDescription description = geom.getDescription();\n\n\t\t\tfor (int iattrib = 0, nattrib = description.getAttributeCount(); iattrib < nattrib; iattrib++) {\n\t\t\t\tint semantics = description.getSemantics(iattrib);\n\t\t\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\t\t\tAttributeStreamBase dst_stream = AttributeStreamBase\n\t\t\t\t\t\t.createAttributeStreamWithSemantics(semantics,\n\t\t\t\t\t\t\t\tpoint_count);\n\t\t\t\tAttributeStreamBase src_stream = m_vertices\n\t\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\t\tint dst_index = 0;\n\t\t\t\tint ipath = 0;\n\t\t\t\tint nvert = 0;\n\t\t\t\tfor (int path = getFirstPath(geometry); path != -1; path = getNextPath(path)) {\n\t\t\t\t\tbyte flag_mask = 0;\n\t\t\t\t\tif (isClosedPath(path)) {\n\t\t\t\t\t\tflag_mask |= (byte) PathFlags.enumClosed;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert (gt != Geometry.GeometryType.Polygon);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isExterior(path)) {\n\t\t\t\t\t\tflag_mask |= (byte) PathFlags.enumOGCStartPolygon;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flag_mask != 0)\n\t\t\t\t\t\tpathFlags.setBits(ipath, flag_mask);\n\n\t\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\t\tparts.write(ipath++, nvert);\n\t\t\t\t\tnvert += path_size;\n\t\t\t\t\tif (semantics == VertexDescription.Semantics.POSITION) {\n\t\t\t\t\t\tAttributeStreamOfDbl src_stream_dbl = (AttributeStreamOfDbl) (src_stream);\n\t\t\t\t\t\tAttributeStreamOfDbl dst_stream_dbl = (AttributeStreamOfDbl) (dst_stream);\n\t\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\t\tfor (int vertex = getFirstVertex(path); dst_index < nvert; vertex = getNextVertex(vertex), dst_index++) {\n\t\t\t\t\t\t\tint src_index = getVertexIndex(vertex);\n\t\t\t\t\t\t\tsrc_stream_dbl.read(src_index * 2, pt);\n\t\t\t\t\t\t\tdst_stream_dbl.write(dst_index * 2, pt);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int vertex = getFirstVertex(path); dst_index < nvert; vertex = getNextVertex(vertex), dst_index++) {\n\t\t\t\t\t\t\tint src_index = getVertexIndex(vertex);\n\t\t\t\t\t\t\tfor (int icomp = 0; icomp < ncomps; icomp++) {\n\t\t\t\t\t\t\t\tdouble d = src_stream.readAsDbl(src_index\n\t\t\t\t\t\t\t\t\t\t* ncomps + icomp);\n\t\t\t\t\t\t\t\tdst_stream.writeAsDbl(dst_index * ncomps\n\t\t\t\t\t\t\t\t\t\t+ icomp, d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassert (nvert == point_count);// Inconsistent content in the\n\t\t\t\t\t\t\t\t\t\t\t\t// Edit_shape. Please, fix.\n\t\t\t\tassert (ipath == path_count);\n\t\t\t\tmp_impl.setAttributeStreamRef(semantics, dst_stream);\n\t\t\t\tparts.write(path_count, point_count);\n\t\t\t}\n\n\t\t\tmp_impl.setPathFlagsStreamRef(pathFlags);\n\t\t\tmp_impl.setPathStreamRef(parts);\n\t\t\tmp_impl.notifyModified(DirtyFlags.dirtyAll);\n\t\t} else if (gt == Geometry.GeometryType.MultiPoint) {\n\t\t\tMultiPointImpl mp_impl = (MultiPointImpl) geom._getImpl();\n\t\t\tVertexDescription description = geom.getDescription();\n\t\t\t// mp_impl.reserve(point_count);\n\t\t\tmp_impl.resize(point_count);\n\n\t\t\tfor (int iattrib = 0, nattrib = description.getAttributeCount(); iattrib < nattrib; iattrib++) {\n\t\t\t\tint semantics = description.getSemantics(iattrib);\n\t\t\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\t\t\tAttributeStreamBase dst_stream = mp_impl\n\t\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\t\t// std::shared_ptr<Attribute_stream_base> dst_stream =\n\t\t\t\t// Attribute_stream_base::create_attribute_stream(semantics,\n\t\t\t\t// point_count);\n\t\t\t\tAttributeStreamBase src_stream = m_vertices\n\t\t\t\t\t\t.getAttributeStreamRef(semantics);\n\t\t\t\tint dst_index = 0;\n\t\t\t\tassert (getPathCount(geometry) == 1);\n\t\t\t\tint path = getFirstPath(geometry);\n\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\tfor (int vertex = getFirstVertex(path); dst_index < path_size; vertex = getNextVertex(vertex), dst_index++) {\n\t\t\t\t\tint src_index = getVertexIndex(vertex);\n\t\t\t\t\tfor (int icomp = 0; icomp < ncomps; icomp++) {\n\t\t\t\t\t\tdouble d = src_stream.readAsDbl(src_index * ncomps\n\t\t\t\t\t\t\t\t+ icomp);\n\t\t\t\t\t\tdst_stream.writeAsDbl(dst_index * ncomps + icomp, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmp_impl.setAttributeStreamRef(semantics, dst_stream);\n\t\t\t}\n\n\t\t\tmp_impl.notifyModified(DirtyFlags.dirtyAll);\n\t\t} else {\n\t\t\tassert (false);\n\t\t}\n\n\t\treturn geom;\n\t}", "code_tokens": ["Geometry", "getGeometry", "(", "int", "geometry", ")", "{", "int", "gt", "=", "getGeometryType", "(", "geometry", ")", ";", "Geometry", "geom", "=", "InternalUtils", ".", "createGeometry", "(", "gt", ",", "m_vertices_mp", ".", "getDescription", "(", ")", ")", ";", "int", "point_count", "=", "getPointCount", "(", "geometry", ")", ";", "if", "(", "point_count", "==", "0", ")", "return", "geom", ";", "if", "(", "Geometry", ".", "isMultiPath", "(", "gt", ")", ")", "{", "MultiPathImpl", "mp_impl", "=", "(", "MultiPathImpl", ")", "geom", ".", "_getImpl", "(", ")", ";", "int", "path_count", "=", "getPathCount", "(", "geometry", ")", ";", "AttributeStreamOfInt32", "parts", "=", "(", "AttributeStreamOfInt32", ")", "(", "AttributeStreamBase", ".", "createIndexStream", "(", "path_count", "+", "1", ")", ")", ";", "AttributeStreamOfInt8", "pathFlags", "=", "(", "AttributeStreamOfInt8", ")", "(", "AttributeStreamBase", ".", "createByteStream", "(", "path_count", "+", "1", ",", "(", "byte", ")", "0", ")", ")", ";", "VertexDescription", "description", "=", "geom", ".", "getDescription", "(", ")", ";", "for", "(", "int", "iattrib", "=", "0", ",", "nattrib", "=", "description", ".", "getAttributeCount", "(", ")", ";", "iattrib", "<", "nattrib", ";", "iattrib", "++", ")", "{", "int", "semantics", "=", "description", ".", "getSemantics", "(", "iattrib", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "AttributeStreamBase", "dst_stream", "=", "AttributeStreamBase", ".", "createAttributeStreamWithSemantics", "(", "semantics", ",", "point_count", ")", ";", "AttributeStreamBase", "src_stream", "=", "m_vertices", ".", "getAttributeStreamRef", "(", "semantics", ")", ";", "int", "dst_index", "=", "0", ";", "int", "ipath", "=", "0", ";", "int", "nvert", "=", "0", ";", "for", "(", "int", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "path", "!=", "-", "1", ";", "path", "=", "getNextPath", "(", "path", ")", ")", "{", "byte", "flag_mask", "=", "0", ";", "if", "(", "isClosedPath", "(", "path", ")", ")", "{", "flag_mask", "|=", "(", "byte", ")", "PathFlags", ".", "enumClosed", ";", "}", "else", "{", "assert", "(", "gt", "!=", "Geometry", ".", "GeometryType", ".", "Polygon", ")", ";", "}", "if", "(", "isExterior", "(", "path", ")", ")", "{", "flag_mask", "|=", "(", "byte", ")", "PathFlags", ".", "enumOGCStartPolygon", ";", "}", "if", "(", "flag_mask", "!=", "0", ")", "pathFlags", ".", "setBits", "(", "ipath", ",", "flag_mask", ")", ";", "int", "path_size", "=", "getPathSize", "(", "path", ")", ";", "parts", ".", "write", "(", "ipath", "++", ",", "nvert", ")", ";", "nvert", "+=", "path_size", ";", "if", "(", "semantics", "==", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", "{", "AttributeStreamOfDbl", "src_stream_dbl", "=", "(", "AttributeStreamOfDbl", ")", "(", "src_stream", ")", ";", "AttributeStreamOfDbl", "dst_stream_dbl", "=", "(", "AttributeStreamOfDbl", ")", "(", "dst_stream", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "dst_index", "<", "nvert", ";", "vertex", "=", "getNextVertex", "(", "vertex", ")", ",", "dst_index", "++", ")", "{", "int", "src_index", "=", "getVertexIndex", "(", "vertex", ")", ";", "src_stream_dbl", ".", "read", "(", "src_index", "*", "2", ",", "pt", ")", ";", "dst_stream_dbl", ".", "write", "(", "dst_index", "*", "2", ",", "pt", ")", ";", "}", "}", "else", "{", "for", "(", "int", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "dst_index", "<", "nvert", ";", "vertex", "=", "getNextVertex", "(", "vertex", ")", ",", "dst_index", "++", ")", "{", "int", "src_index", "=", "getVertexIndex", "(", "vertex", ")", ";", "for", "(", "int", "icomp", "=", "0", ";", "icomp", "<", "ncomps", ";", "icomp", "++", ")", "{", "double", "d", "=", "src_stream", ".", "readAsDbl", "(", "src_index", "*", "ncomps", "+", "icomp", ")", ";", "dst_stream", ".", "writeAsDbl", "(", "dst_index", "*", "ncomps", "+", "icomp", ",", "d", ")", ";", "}", "}", "}", "}", "assert", "(", "nvert", "==", "point_count", ")", ";", "// Inconsistent content in the", "// Edit_shape. Please, fix.", "assert", "(", "ipath", "==", "path_count", ")", ";", "mp_impl", ".", "setAttributeStreamRef", "(", "semantics", ",", "dst_stream", ")", ";", "parts", ".", "write", "(", "path_count", ",", "point_count", ")", ";", "}", "mp_impl", ".", "setPathFlagsStreamRef", "(", "pathFlags", ")", ";", "mp_impl", ".", "setPathStreamRef", "(", "parts", ")", ";", "mp_impl", ".", "notifyModified", "(", "DirtyFlags", ".", "dirtyAll", ")", ";", "}", "else", "if", "(", "gt", "==", "Geometry", ".", "GeometryType", ".", "MultiPoint", ")", "{", "MultiPointImpl", "mp_impl", "=", "(", "MultiPointImpl", ")", "geom", ".", "_getImpl", "(", ")", ";", "VertexDescription", "description", "=", "geom", ".", "getDescription", "(", ")", ";", "// mp_impl.reserve(point_count);", "mp_impl", ".", "resize", "(", "point_count", ")", ";", "for", "(", "int", "iattrib", "=", "0", ",", "nattrib", "=", "description", ".", "getAttributeCount", "(", ")", ";", "iattrib", "<", "nattrib", ";", "iattrib", "++", ")", "{", "int", "semantics", "=", "description", ".", "getSemantics", "(", "iattrib", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "AttributeStreamBase", "dst_stream", "=", "mp_impl", ".", "getAttributeStreamRef", "(", "semantics", ")", ";", "// std::shared_ptr<Attribute_stream_base> dst_stream =", "// Attribute_stream_base::create_attribute_stream(semantics,", "// point_count);", "AttributeStreamBase", "src_stream", "=", "m_vertices", ".", "getAttributeStreamRef", "(", "semantics", ")", ";", "int", "dst_index", "=", "0", ";", "assert", "(", "getPathCount", "(", "geometry", ")", "==", "1", ")", ";", "int", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "int", "path_size", "=", "getPathSize", "(", "path", ")", ";", "for", "(", "int", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "dst_index", "<", "path_size", ";", "vertex", "=", "getNextVertex", "(", "vertex", ")", ",", "dst_index", "++", ")", "{", "int", "src_index", "=", "getVertexIndex", "(", "vertex", ")", ";", "for", "(", "int", "icomp", "=", "0", ";", "icomp", "<", "ncomps", ";", "icomp", "++", ")", "{", "double", "d", "=", "src_stream", ".", "readAsDbl", "(", "src_index", "*", "ncomps", "+", "icomp", ")", ";", "dst_stream", ".", "writeAsDbl", "(", "dst_index", "*", "ncomps", "+", "icomp", ",", "d", ")", ";", "}", "}", "mp_impl", ".", "setAttributeStreamRef", "(", "semantics", ",", "dst_stream", ")", ";", "}", "mp_impl", ".", "notifyModified", "(", "DirtyFlags", ".", "dirtyAll", ")", ";", "}", "else", "{", "assert", "(", "false", ")", ";", "}", "return", "geom", ";", "}"], "docstring": "given geometry.", "docstring_tokens": ["given", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L643-L760", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.removeGeometry", "original_string": "int removeGeometry(int geometry) {\n\t\tfor (int path = getFirstPath(geometry); path != -1; path = removePath(path)) {\n\t\t\t// removing paths in a loop\n\t\t}\n\n\t\tint prev = getPrevGeometry(geometry);\n\t\tint next = getNextGeometry(geometry);\n\t\tif (prev != -1)\n\t\t\tsetNextGeometry_(prev, next);\n\t\telse {\n\t\t\tm_first_geometry = next;\n\t\t}\n\t\tif (next != -1)\n\t\t\tsetPrevGeometry_(next, prev);\n\t\telse {\n\t\t\tm_last_geometry = prev;\n\t\t}\n\n\t\tfreeGeometry_(geometry);\n\t\treturn next;\n\t}", "language": "java", "code": "int removeGeometry(int geometry) {\n\t\tfor (int path = getFirstPath(geometry); path != -1; path = removePath(path)) {\n\t\t\t// removing paths in a loop\n\t\t}\n\n\t\tint prev = getPrevGeometry(geometry);\n\t\tint next = getNextGeometry(geometry);\n\t\tif (prev != -1)\n\t\t\tsetNextGeometry_(prev, next);\n\t\telse {\n\t\t\tm_first_geometry = next;\n\t\t}\n\t\tif (next != -1)\n\t\t\tsetPrevGeometry_(next, prev);\n\t\telse {\n\t\t\tm_last_geometry = prev;\n\t\t}\n\n\t\tfreeGeometry_(geometry);\n\t\treturn next;\n\t}", "code_tokens": ["int", "removeGeometry", "(", "int", "geometry", ")", "{", "for", "(", "int", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "path", "!=", "-", "1", ";", "path", "=", "removePath", "(", "path", ")", ")", "{", "// removing paths in a loop", "}", "int", "prev", "=", "getPrevGeometry", "(", "geometry", ")", ";", "int", "next", "=", "getNextGeometry", "(", "geometry", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "setNextGeometry_", "(", "prev", ",", "next", ")", ";", "else", "{", "m_first_geometry", "=", "next", ";", "}", "if", "(", "next", "!=", "-", "1", ")", "setPrevGeometry_", "(", "next", ",", "prev", ")", ";", "else", "{", "m_last_geometry", "=", "prev", ";", "}", "freeGeometry_", "(", "geometry", ")", ";", "return", "next", ";", "}"], "docstring": "Deletes existing geometry from the edit shape and returns the next one.", "docstring_tokens": ["Deletes", "existing", "geometry", "from", "the", "edit", "shape", "and", "returns", "the", "next", "one", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L769-L789", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.createGeometry", "original_string": "int createGeometry(Geometry.Type geometry_type,\n\t\t\tVertexDescription description) {\n\t\tint newgeom = newGeometry_(geometry_type.value());\n\t\tif (m_vertices == null) {\n\t\t\tm_vertices_mp = new MultiPoint(description);\n\t\t\tm_vertices = (MultiPointImpl) m_vertices_mp._getImpl();\n\t\t} else\n\t\t\tm_vertices_mp.mergeVertexDescription(description);\n\n\t\tm_vertex_description = m_vertices_mp.getDescription();// this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// description\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// will be a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// merge of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// existing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// description\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// description\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// of the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// multi_path\n\t\tm_b_has_attributes = m_vertex_description.getAttributeCount() > 1;\n\n\t\tif (m_first_geometry == -1) {\n\t\t\tm_first_geometry = newgeom;\n\t\t\tm_last_geometry = newgeom;\n\t\t} else {\n\t\t\tsetPrevGeometry_(newgeom, m_last_geometry);\n\t\t\tsetNextGeometry_(m_last_geometry, newgeom);\n\t\t\tm_last_geometry = newgeom;\n\t\t}\n\t\treturn newgeom;\n\t}", "language": "java", "code": "int createGeometry(Geometry.Type geometry_type,\n\t\t\tVertexDescription description) {\n\t\tint newgeom = newGeometry_(geometry_type.value());\n\t\tif (m_vertices == null) {\n\t\t\tm_vertices_mp = new MultiPoint(description);\n\t\t\tm_vertices = (MultiPointImpl) m_vertices_mp._getImpl();\n\t\t} else\n\t\t\tm_vertices_mp.mergeVertexDescription(description);\n\n\t\tm_vertex_description = m_vertices_mp.getDescription();// this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// description\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// will be a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// merge of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// existing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// description\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// description\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// of the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// multi_path\n\t\tm_b_has_attributes = m_vertex_description.getAttributeCount() > 1;\n\n\t\tif (m_first_geometry == -1) {\n\t\t\tm_first_geometry = newgeom;\n\t\t\tm_last_geometry = newgeom;\n\t\t} else {\n\t\t\tsetPrevGeometry_(newgeom, m_last_geometry);\n\t\t\tsetNextGeometry_(m_last_geometry, newgeom);\n\t\t\tm_last_geometry = newgeom;\n\t\t}\n\t\treturn newgeom;\n\t}", "code_tokens": ["int", "createGeometry", "(", "Geometry", ".", "Type", "geometry_type", ",", "VertexDescription", "description", ")", "{", "int", "newgeom", "=", "newGeometry_", "(", "geometry_type", ".", "value", "(", ")", ")", ";", "if", "(", "m_vertices", "==", "null", ")", "{", "m_vertices_mp", "=", "new", "MultiPoint", "(", "description", ")", ";", "m_vertices", "=", "(", "MultiPointImpl", ")", "m_vertices_mp", ".", "_getImpl", "(", ")", ";", "}", "else", "m_vertices_mp", ".", "mergeVertexDescription", "(", "description", ")", ";", "m_vertex_description", "=", "m_vertices_mp", ".", "getDescription", "(", ")", ";", "// this", "// description", "// will be a", "// merge of", "// existing", "// description", "// and the", "// description", "// of the", "// multi_path", "m_b_has_attributes", "=", "m_vertex_description", ".", "getAttributeCount", "(", ")", ">", "1", ";", "if", "(", "m_first_geometry", "==", "-", "1", ")", "{", "m_first_geometry", "=", "newgeom", ";", "m_last_geometry", "=", "newgeom", ";", "}", "else", "{", "setPrevGeometry_", "(", "newgeom", ",", "m_last_geometry", ")", ";", "setNextGeometry_", "(", "m_last_geometry", ",", "newgeom", ")", ";", "m_last_geometry", "=", "newgeom", ";", "}", "return", "newgeom", ";", "}"], "docstring": "create a new empty geometry of the given type and attribute set.", "docstring_tokens": ["create", "a", "new", "empty", "geometry", "of", "the", "given", "type", "and", "attribute", "set", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L792-L822", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.setGeometryUserIndex", "original_string": "void setGeometryUserIndex(int geom, int index, int value) {\n\t\tAttributeStreamOfInt32 stream = m_geometry_indices.get(index);\n\t\tint pindex = getGeometryIndex_(geom);\n\t\tif (pindex >= stream.size())\n\t\t\tstream.resize(Math.max((int) (pindex * 1.25), (int) 16), -1);\n\t\tstream.write(pindex, value);\n\t}", "language": "java", "code": "void setGeometryUserIndex(int geom, int index, int value) {\n\t\tAttributeStreamOfInt32 stream = m_geometry_indices.get(index);\n\t\tint pindex = getGeometryIndex_(geom);\n\t\tif (pindex >= stream.size())\n\t\t\tstream.resize(Math.max((int) (pindex * 1.25), (int) 16), -1);\n\t\tstream.write(pindex, value);\n\t}", "code_tokens": ["void", "setGeometryUserIndex", "(", "int", "geom", ",", "int", "index", ",", "int", "value", ")", "{", "AttributeStreamOfInt32", "stream", "=", "m_geometry_indices", ".", "get", "(", "index", ")", ";", "int", "pindex", "=", "getGeometryIndex_", "(", "geom", ")", ";", "if", "(", "pindex", ">=", "stream", ".", "size", "(", ")", ")", "stream", ".", "resize", "(", "Math", ".", "max", "(", "(", "int", ")", "(", "pindex", "*", "1.25", ")", ",", "(", "int", ")", "16", ")", ",", "-", "1", ")", ";", "stream", ".", "write", "(", "pindex", ",", "value", ")", ";", "}"], "docstring": "Sets value to the given user index on a geometry.", "docstring_tokens": ["Sets", "value", "to", "the", "given", "user", "index", "on", "a", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L847-L853", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getGeometryUserIndex", "original_string": "int getGeometryUserIndex(int geom, int index) {\n\t\tint pindex = getGeometryIndex_(geom);\n\t\tAttributeStreamOfInt32 stream = m_geometry_indices.get(index);\n\t\tif (pindex < stream.size())\n\t\t\treturn stream.read(pindex);\n\t\telse\n\t\t\treturn -1;\n\t}", "language": "java", "code": "int getGeometryUserIndex(int geom, int index) {\n\t\tint pindex = getGeometryIndex_(geom);\n\t\tAttributeStreamOfInt32 stream = m_geometry_indices.get(index);\n\t\tif (pindex < stream.size())\n\t\t\treturn stream.read(pindex);\n\t\telse\n\t\t\treturn -1;\n\t}", "code_tokens": ["int", "getGeometryUserIndex", "(", "int", "geom", ",", "int", "index", ")", "{", "int", "pindex", "=", "getGeometryIndex_", "(", "geom", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_geometry_indices", ".", "get", "(", "index", ")", ";", "if", "(", "pindex", "<", "stream", ".", "size", "(", ")", ")", "return", "stream", ".", "read", "(", "pindex", ")", ";", "else", "return", "-", "1", ";", "}"], "docstring": "Returns the value of the given user index of a geometry", "docstring_tokens": ["Returns", "the", "value", "of", "the", "given", "user", "index", "of", "a", "geometry"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L856-L863", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.createGeometryUserIndex", "original_string": "int createGeometryUserIndex() {\n\t\tif (m_geometry_indices == null)\n\t\t\tm_geometry_indices = new ArrayList<AttributeStreamOfInt32>(4);\n\n\t\t// Try getting existing index. Use linear search. We do not expect many\n\t\t// indices to be created.\n\t\tfor (int i = 0; i < m_geometry_indices.size(); i++) {\n\t\t\tif (m_geometry_indices.get(i) == null) {\n\t\t\t\tm_geometry_indices.set(i,\n\t\t\t\t\t\t(AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t\t\t\t.createIndexStream(0));\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tm_geometry_indices.add((AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t.createIndexStream(0));\n\t\treturn m_geometry_indices.size() - 1;\n\t}", "language": "java", "code": "int createGeometryUserIndex() {\n\t\tif (m_geometry_indices == null)\n\t\t\tm_geometry_indices = new ArrayList<AttributeStreamOfInt32>(4);\n\n\t\t// Try getting existing index. Use linear search. We do not expect many\n\t\t// indices to be created.\n\t\tfor (int i = 0; i < m_geometry_indices.size(); i++) {\n\t\t\tif (m_geometry_indices.get(i) == null) {\n\t\t\t\tm_geometry_indices.set(i,\n\t\t\t\t\t\t(AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t\t\t\t.createIndexStream(0));\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tm_geometry_indices.add((AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t.createIndexStream(0));\n\t\treturn m_geometry_indices.size() - 1;\n\t}", "code_tokens": ["int", "createGeometryUserIndex", "(", ")", "{", "if", "(", "m_geometry_indices", "==", "null", ")", "m_geometry_indices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "4", ")", ";", "// Try getting existing index. Use linear search. We do not expect many", "// indices to be created.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_geometry_indices", ".", "size", "(", ")", ";", "i", "++", ")", "{", "if", "(", "m_geometry_indices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_geometry_indices", ".", "set", "(", "i", ",", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "0", ")", ")", ";", "return", "i", ";", "}", "}", "m_geometry_indices", ".", "add", "(", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "0", ")", ")", ";", "return", "m_geometry_indices", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "stores -1 for that geometry.", "docstring_tokens": ["stores", "-", "1", "for", "that", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L869-L887", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.filterClosePoints", "original_string": "int filterClosePoints(double tolerance, boolean b_remove_last_vertices, boolean only_polygons) {\n\t\tint res = 0;\n\t\tfor (int geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry)) {\n\t\t\tint gt = getGeometryType(geometry);\n\t\t\tif (!Geometry.isMultiPath(gt))\n\t\t\t\tcontinue;\n\t\t\tif (only_polygons && gt != GeometryType.Polygon)\n\t\t\t\tcontinue;\n\n\t\t\tboolean b_polygon = getGeometryType(geometry) == Geometry.GeometryType.Polygon;\n\n\t\t\tfor (int path = getFirstPath(geometry); path != -1;) {\n\t\t\t\t// We go from the start to the half of the path first, then we\n\t\t\t\t// go from the end to the half of the path.\n\t\t\t\tint vertex_counter = 0;\n\t\t\t\tfor (int vertex = getFirstVertex(path); vertex_counter < getPathSize(path) / 2;) {\n\t\t\t\t\tint next = getNextVertex(vertex);\n\t\t\t\t\tif (next == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\t\t\t\tdouble length = 0;\n\t\t\t\t\tif (seg != null) {\n\t\t\t\t\t\tlength = seg.calculateLength2D();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\t\t\t\tlength = m_vertices._getShortestDistance(vindex,\n\t\t\t\t\t\t\t\tvindex_next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (length <= tolerance) {\n\t\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\t\tif (res == 0)\n\t\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tres = 1;\n\n\t\t\t\t\t\tif (next != getLastVertex(path)) {\n\t\t\t\t\t\t\ttransferAllDataToTheVertex(next, vertex);\n\t\t\t\t\t\t\tremoveVertex(next, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvertex = getNextVertex(vertex);\n\t\t\t\t\t}\n\t\t\t\t\tvertex_counter++;\n\t\t\t\t}\n\n\t\t\t\tint first_vertex = getFirstVertex(path);\n\t\t\t\tfor (int vertex = isClosedPath(path) ? first_vertex\n\t\t\t\t\t\t: getLastVertex(path); getPathSize(path) > 0;) {\n\t\t\t\t\tint prev = getPrevVertex(vertex);\n\t\t\t\t\tif (prev != -1) {\n\t\t\t\t\t\tint vindex_prev = getVertexIndex(prev);\n\t\t\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_prev);\n\t\t\t\t\t\tdouble length = 0;\n\t\t\t\t\t\tif (seg != null) {\n\t\t\t\t\t\t\tlength = seg.calculateLength2D();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\t\t\t\tlength = m_vertices._getShortestDistance(vindex,\n\t\t\t\t\t\t\t\t\tvindex_prev);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (length <= tolerance) {\n\t\t\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\t\t\tif (res == 0)\n\t\t\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tres = 1;\n\n\t\t\t\t\t\t\ttransferAllDataToTheVertex(prev, vertex);\n\t\t\t\t\t\t\tremoveVertex(prev, false);\n\t\t\t\t\t\t\tif (first_vertex == prev)\n\t\t\t\t\t\t\t\tfirst_vertex = getFirstVertex(path);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvertex = getPrevVertex(vertex);\n\t\t\t\t\t\t\tif (vertex == first_vertex)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoveVertex(vertex, true);// remove the last vertex in\n\t\t\t\t\t\t\t\t\t\t\t\t\t// the path\n\t\t\t\t\t\tif (res == 0)\n\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\tif (b_remove_last_vertices\n\t\t\t\t\t\t&& (b_polygon ? path_size < 3 : path_size < 2)) {\n\t\t\t\t\tpath = removePath(path);\n\t\t\t\t\tres = path_size > 0 ? 1 : (res == 0 ? -1 : res);\n\t\t\t\t} else\n\t\t\t\t\tpath = getNextPath(path);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}", "language": "java", "code": "int filterClosePoints(double tolerance, boolean b_remove_last_vertices, boolean only_polygons) {\n\t\tint res = 0;\n\t\tfor (int geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry)) {\n\t\t\tint gt = getGeometryType(geometry);\n\t\t\tif (!Geometry.isMultiPath(gt))\n\t\t\t\tcontinue;\n\t\t\tif (only_polygons && gt != GeometryType.Polygon)\n\t\t\t\tcontinue;\n\n\t\t\tboolean b_polygon = getGeometryType(geometry) == Geometry.GeometryType.Polygon;\n\n\t\t\tfor (int path = getFirstPath(geometry); path != -1;) {\n\t\t\t\t// We go from the start to the half of the path first, then we\n\t\t\t\t// go from the end to the half of the path.\n\t\t\t\tint vertex_counter = 0;\n\t\t\t\tfor (int vertex = getFirstVertex(path); vertex_counter < getPathSize(path) / 2;) {\n\t\t\t\t\tint next = getNextVertex(vertex);\n\t\t\t\t\tif (next == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\t\t\t\tdouble length = 0;\n\t\t\t\t\tif (seg != null) {\n\t\t\t\t\t\tlength = seg.calculateLength2D();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\t\t\t\tlength = m_vertices._getShortestDistance(vindex,\n\t\t\t\t\t\t\t\tvindex_next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (length <= tolerance) {\n\t\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\t\tif (res == 0)\n\t\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tres = 1;\n\n\t\t\t\t\t\tif (next != getLastVertex(path)) {\n\t\t\t\t\t\t\ttransferAllDataToTheVertex(next, vertex);\n\t\t\t\t\t\t\tremoveVertex(next, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvertex = getNextVertex(vertex);\n\t\t\t\t\t}\n\t\t\t\t\tvertex_counter++;\n\t\t\t\t}\n\n\t\t\t\tint first_vertex = getFirstVertex(path);\n\t\t\t\tfor (int vertex = isClosedPath(path) ? first_vertex\n\t\t\t\t\t\t: getLastVertex(path); getPathSize(path) > 0;) {\n\t\t\t\t\tint prev = getPrevVertex(vertex);\n\t\t\t\t\tif (prev != -1) {\n\t\t\t\t\t\tint vindex_prev = getVertexIndex(prev);\n\t\t\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_prev);\n\t\t\t\t\t\tdouble length = 0;\n\t\t\t\t\t\tif (seg != null) {\n\t\t\t\t\t\t\tlength = seg.calculateLength2D();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\t\t\t\tlength = m_vertices._getShortestDistance(vindex,\n\t\t\t\t\t\t\t\t\tvindex_prev);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (length <= tolerance) {\n\t\t\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\t\t\tif (res == 0)\n\t\t\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tres = 1;\n\n\t\t\t\t\t\t\ttransferAllDataToTheVertex(prev, vertex);\n\t\t\t\t\t\t\tremoveVertex(prev, false);\n\t\t\t\t\t\t\tif (first_vertex == prev)\n\t\t\t\t\t\t\t\tfirst_vertex = getFirstVertex(path);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvertex = getPrevVertex(vertex);\n\t\t\t\t\t\t\tif (vertex == first_vertex)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoveVertex(vertex, true);// remove the last vertex in\n\t\t\t\t\t\t\t\t\t\t\t\t\t// the path\n\t\t\t\t\t\tif (res == 0)\n\t\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\tif (b_remove_last_vertices\n\t\t\t\t\t\t&& (b_polygon ? path_size < 3 : path_size < 2)) {\n\t\t\t\t\tpath = removePath(path);\n\t\t\t\t\tres = path_size > 0 ? 1 : (res == 0 ? -1 : res);\n\t\t\t\t} else\n\t\t\t\t\tpath = getNextPath(path);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}", "code_tokens": ["int", "filterClosePoints", "(", "double", "tolerance", ",", "boolean", "b_remove_last_vertices", ",", "boolean", "only_polygons", ")", "{", "int", "res", "=", "0", ";", "for", "(", "int", "geometry", "=", "getFirstGeometry", "(", ")", ";", "geometry", "!=", "-", "1", ";", "geometry", "=", "getNextGeometry", "(", "geometry", ")", ")", "{", "int", "gt", "=", "getGeometryType", "(", "geometry", ")", ";", "if", "(", "!", "Geometry", ".", "isMultiPath", "(", "gt", ")", ")", "continue", ";", "if", "(", "only_polygons", "&&", "gt", "!=", "GeometryType", ".", "Polygon", ")", "continue", ";", "boolean", "b_polygon", "=", "getGeometryType", "(", "geometry", ")", "==", "Geometry", ".", "GeometryType", ".", "Polygon", ";", "for", "(", "int", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "path", "!=", "-", "1", ";", ")", "{", "// We go from the start to the half of the path first, then we", "// go from the end to the half of the path.", "int", "vertex_counter", "=", "0", ";", "for", "(", "int", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "vertex_counter", "<", "getPathSize", "(", "path", ")", "/", "2", ";", ")", "{", "int", "next", "=", "getNextVertex", "(", "vertex", ")", ";", "if", "(", "next", "==", "-", "1", ")", "break", ";", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex", ")", ";", "double", "length", "=", "0", ";", "if", "(", "seg", "!=", "null", ")", "{", "length", "=", "seg", ".", "calculateLength2D", "(", ")", ";", "}", "else", "{", "int", "vindex_next", "=", "getVertexIndex", "(", "next", ")", ";", "length", "=", "m_vertices", ".", "_getShortestDistance", "(", "vindex", ",", "vindex_next", ")", ";", "}", "if", "(", "length", "<=", "tolerance", ")", "{", "if", "(", "length", "==", "0", ")", "{", "if", "(", "res", "==", "0", ")", "res", "=", "-", "1", ";", "}", "else", "res", "=", "1", ";", "if", "(", "next", "!=", "getLastVertex", "(", "path", ")", ")", "{", "transferAllDataToTheVertex", "(", "next", ",", "vertex", ")", ";", "removeVertex", "(", "next", ",", "true", ")", ";", "}", "}", "else", "{", "vertex", "=", "getNextVertex", "(", "vertex", ")", ";", "}", "vertex_counter", "++", ";", "}", "int", "first_vertex", "=", "getFirstVertex", "(", "path", ")", ";", "for", "(", "int", "vertex", "=", "isClosedPath", "(", "path", ")", "?", "first_vertex", ":", "getLastVertex", "(", "path", ")", ";", "getPathSize", "(", "path", ")", ">", "0", ";", ")", "{", "int", "prev", "=", "getPrevVertex", "(", "vertex", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "{", "int", "vindex_prev", "=", "getVertexIndex", "(", "prev", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex_prev", ")", ";", "double", "length", "=", "0", ";", "if", "(", "seg", "!=", "null", ")", "{", "length", "=", "seg", ".", "calculateLength2D", "(", ")", ";", "}", "else", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "length", "=", "m_vertices", ".", "_getShortestDistance", "(", "vindex", ",", "vindex_prev", ")", ";", "}", "if", "(", "length", "<=", "tolerance", ")", "{", "if", "(", "length", "==", "0", ")", "{", "if", "(", "res", "==", "0", ")", "res", "=", "-", "1", ";", "}", "else", "res", "=", "1", ";", "transferAllDataToTheVertex", "(", "prev", ",", "vertex", ")", ";", "removeVertex", "(", "prev", ",", "false", ")", ";", "if", "(", "first_vertex", "==", "prev", ")", "first_vertex", "=", "getFirstVertex", "(", "path", ")", ";", "}", "else", "{", "vertex", "=", "getPrevVertex", "(", "vertex", ")", ";", "if", "(", "vertex", "==", "first_vertex", ")", "break", ";", "}", "}", "else", "{", "removeVertex", "(", "vertex", ",", "true", ")", ";", "// remove the last vertex in", "// the path", "if", "(", "res", "==", "0", ")", "res", "=", "-", "1", ";", "break", ";", "}", "}", "int", "path_size", "=", "getPathSize", "(", "path", ")", ";", "if", "(", "b_remove_last_vertices", "&&", "(", "b_polygon", "?", "path_size", "<", "3", ":", "path_size", "<", "2", ")", ")", "{", "path", "=", "removePath", "(", "path", ")", ";", "res", "=", "path_size", ">", "0", "?", "1", ":", "(", "res", "==", "0", "?", "-", "1", ":", "res", ")", ";", "}", "else", "path", "=", "getNextPath", "(", "path", ")", ";", "}", "}", "return", "res", ";", "}"], "docstring": "for polyline, it'll be removed.", "docstring_tokens": ["for", "polyline", "it", "ll", "be", "removed", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L920-L1019", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.hasDegenerateSegments", "original_string": "boolean hasDegenerateSegments(double tolerance) {\n\t\tfor (int geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry)) {\n\t\t\tif (!Geometry.isMultiPath(getGeometryType(geometry)))\n\t\t\t\tcontinue;\n\n\t\t\tboolean b_polygon = getGeometryType(geometry) == Geometry.GeometryType.Polygon;\n\n\t\t\tfor (int path = getFirstPath(geometry); path != -1;) {\n\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\tif (b_polygon ? path_size < 3 : path_size < 2)\n\t\t\t\t\treturn true;\n\n\t\t\t\tint vertex = getFirstVertex(path);\n\t\t\t\tfor (int index = 0; index < path_size; index++) {\n\t\t\t\t\tint next = getNextVertex(vertex);\n\t\t\t\t\tif (next == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\t\t\t\tdouble length = 0;\n\t\t\t\t\tif (seg != null) {\n\t\t\t\t\t\tlength = seg.calculateLength2D();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\t\t\t\tlength = m_vertices._getShortestDistance(vindex,\n\t\t\t\t\t\t\t\tvindex_next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (length <= tolerance)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tvertex = next;\n\t\t\t\t}\n\n\t\t\t\tpath = getNextPath(path);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "boolean hasDegenerateSegments(double tolerance) {\n\t\tfor (int geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry)) {\n\t\t\tif (!Geometry.isMultiPath(getGeometryType(geometry)))\n\t\t\t\tcontinue;\n\n\t\t\tboolean b_polygon = getGeometryType(geometry) == Geometry.GeometryType.Polygon;\n\n\t\t\tfor (int path = getFirstPath(geometry); path != -1;) {\n\t\t\t\tint path_size = getPathSize(path);\n\t\t\t\tif (b_polygon ? path_size < 3 : path_size < 2)\n\t\t\t\t\treturn true;\n\n\t\t\t\tint vertex = getFirstVertex(path);\n\t\t\t\tfor (int index = 0; index < path_size; index++) {\n\t\t\t\t\tint next = getNextVertex(vertex);\n\t\t\t\t\tif (next == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\t\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\t\t\t\tdouble length = 0;\n\t\t\t\t\tif (seg != null) {\n\t\t\t\t\t\tlength = seg.calculateLength2D();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\t\t\t\tlength = m_vertices._getShortestDistance(vindex,\n\t\t\t\t\t\t\t\tvindex_next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (length <= tolerance)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tvertex = next;\n\t\t\t\t}\n\n\t\t\t\tpath = getNextPath(path);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["boolean", "hasDegenerateSegments", "(", "double", "tolerance", ")", "{", "for", "(", "int", "geometry", "=", "getFirstGeometry", "(", ")", ";", "geometry", "!=", "-", "1", ";", "geometry", "=", "getNextGeometry", "(", "geometry", ")", ")", "{", "if", "(", "!", "Geometry", ".", "isMultiPath", "(", "getGeometryType", "(", "geometry", ")", ")", ")", "continue", ";", "boolean", "b_polygon", "=", "getGeometryType", "(", "geometry", ")", "==", "Geometry", ".", "GeometryType", ".", "Polygon", ";", "for", "(", "int", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "path", "!=", "-", "1", ";", ")", "{", "int", "path_size", "=", "getPathSize", "(", "path", ")", ";", "if", "(", "b_polygon", "?", "path_size", "<", "3", ":", "path_size", "<", "2", ")", "return", "true", ";", "int", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "for", "(", "int", "index", "=", "0", ";", "index", "<", "path_size", ";", "index", "++", ")", "{", "int", "next", "=", "getNextVertex", "(", "vertex", ")", ";", "if", "(", "next", "==", "-", "1", ")", "break", ";", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex", ")", ";", "double", "length", "=", "0", ";", "if", "(", "seg", "!=", "null", ")", "{", "length", "=", "seg", ".", "calculateLength2D", "(", ")", ";", "}", "else", "{", "int", "vindex_next", "=", "getVertexIndex", "(", "next", ")", ";", "length", "=", "m_vertices", ".", "_getShortestDistance", "(", "vindex", ",", "vindex_next", ")", ";", "}", "if", "(", "length", "<=", "tolerance", ")", "return", "true", ";", "vertex", "=", "next", ";", "}", "path", "=", "getNextPath", "(", "path", ")", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Checks if there are degenerate segments in any of multipath geometries", "docstring_tokens": ["Checks", "if", "there", "are", "degenerate", "segments", "in", "any", "of", "multipath", "geometries"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1022-L1061", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.splitSegment", "original_string": "int splitSegment(int origin_vertex, double[] split_scalars, int split_count) {\n\t\tint actual_splits = 0;\n\t\tint next_vertex = getNextVertex(origin_vertex);\n\t\tif (next_vertex == -1)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tint vindex = getVertexIndex(origin_vertex);\n\t\tint vindex_next = getVertexIndex(next_vertex);\n\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\tdouble seg_length = seg == null ? m_vertices._getShortestDistance(\n\t\t\t\tvindex, vindex_next) : seg.calculateLength2D();\n\t\tdouble told = 0.0;\n\t\tfor (int i = 0; i < split_count; i++) {\n\t\t\tdouble t = split_scalars[i];\n\t\t\tif (told < t && t < 1.0) {\n\t\t\t\tdouble f = t;\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tf = seg_length > 0 ? seg._calculateSubLength(t)\n\t\t\t\t\t\t\t/ seg_length : 0.0;\n\t\t\t\t}\n\n\t\t\t\tm_vertices._interpolateTwoVertices(vindex, vindex_next, f,\n\t\t\t\t\t\tgetHelperPoint_());// use this call mainly to\n\t\t\t\t\t\t\t\t\t\t\t// interpolate the attributes. XYs\n\t\t\t\t\t\t\t\t\t\t\t// are interpolated incorrectly for\n\t\t\t\t\t\t\t\t\t\t\t// curves and are recalculated when\n\t\t\t\t\t\t\t\t\t\t\t// segment is cut below.\n\t\t\t\tint inserted_vertex = insertVertex_(\n\t\t\t\t\t\tgetPathFromVertex(origin_vertex), next_vertex,\n\t\t\t\t\t\tgetHelperPoint_());\n\t\t\t\tactual_splits++;\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tSegment subseg = seg.cut(told, t);\n\t\t\t\t\tint prev_vertex = getPrevVertex(inserted_vertex);\n\t\t\t\t\tint vindex_prev = getVertexIndex(prev_vertex);\n\t\t\t\t\tsetSegmentToIndex_(vindex_prev, subseg);\n\t\t\t\t\tsetXY(inserted_vertex, subseg.getEndXY()); // fix XY\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// coordinates\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// parameter\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// based\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (interpolate_two_vertices_)\n\t\t\t\t\tif (i == split_count - 1 || split_scalars[i + 1] == 1.0) {// last\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// split\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// segment\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// here:\n\t\t\t\t\t\tSegment subseg_end = seg.cut(t, 1.0);\n\t\t\t\t\t\tsetSegmentToIndex_(vindex_prev, subseg_end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actual_splits;\n\t}", "language": "java", "code": "int splitSegment(int origin_vertex, double[] split_scalars, int split_count) {\n\t\tint actual_splits = 0;\n\t\tint next_vertex = getNextVertex(origin_vertex);\n\t\tif (next_vertex == -1)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tint vindex = getVertexIndex(origin_vertex);\n\t\tint vindex_next = getVertexIndex(next_vertex);\n\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\tdouble seg_length = seg == null ? m_vertices._getShortestDistance(\n\t\t\t\tvindex, vindex_next) : seg.calculateLength2D();\n\t\tdouble told = 0.0;\n\t\tfor (int i = 0; i < split_count; i++) {\n\t\t\tdouble t = split_scalars[i];\n\t\t\tif (told < t && t < 1.0) {\n\t\t\t\tdouble f = t;\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tf = seg_length > 0 ? seg._calculateSubLength(t)\n\t\t\t\t\t\t\t/ seg_length : 0.0;\n\t\t\t\t}\n\n\t\t\t\tm_vertices._interpolateTwoVertices(vindex, vindex_next, f,\n\t\t\t\t\t\tgetHelperPoint_());// use this call mainly to\n\t\t\t\t\t\t\t\t\t\t\t// interpolate the attributes. XYs\n\t\t\t\t\t\t\t\t\t\t\t// are interpolated incorrectly for\n\t\t\t\t\t\t\t\t\t\t\t// curves and are recalculated when\n\t\t\t\t\t\t\t\t\t\t\t// segment is cut below.\n\t\t\t\tint inserted_vertex = insertVertex_(\n\t\t\t\t\t\tgetPathFromVertex(origin_vertex), next_vertex,\n\t\t\t\t\t\tgetHelperPoint_());\n\t\t\t\tactual_splits++;\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tSegment subseg = seg.cut(told, t);\n\t\t\t\t\tint prev_vertex = getPrevVertex(inserted_vertex);\n\t\t\t\t\tint vindex_prev = getVertexIndex(prev_vertex);\n\t\t\t\t\tsetSegmentToIndex_(vindex_prev, subseg);\n\t\t\t\t\tsetXY(inserted_vertex, subseg.getEndXY()); // fix XY\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// coordinates\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// parameter\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// based\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (interpolate_two_vertices_)\n\t\t\t\t\tif (i == split_count - 1 || split_scalars[i + 1] == 1.0) {// last\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// chance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// split\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// segment\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// here:\n\t\t\t\t\t\tSegment subseg_end = seg.cut(t, 1.0);\n\t\t\t\t\t\tsetSegmentToIndex_(vindex_prev, subseg_end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actual_splits;\n\t}", "code_tokens": ["int", "splitSegment", "(", "int", "origin_vertex", ",", "double", "[", "]", "split_scalars", ",", "int", "split_count", ")", "{", "int", "actual_splits", "=", "0", ";", "int", "next_vertex", "=", "getNextVertex", "(", "origin_vertex", ")", ";", "if", "(", "next_vertex", "==", "-", "1", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "int", "vindex", "=", "getVertexIndex", "(", "origin_vertex", ")", ";", "int", "vindex_next", "=", "getVertexIndex", "(", "next_vertex", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex", ")", ";", "double", "seg_length", "=", "seg", "==", "null", "?", "m_vertices", ".", "_getShortestDistance", "(", "vindex", ",", "vindex_next", ")", ":", "seg", ".", "calculateLength2D", "(", ")", ";", "double", "told", "=", "0.0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "split_count", ";", "i", "++", ")", "{", "double", "t", "=", "split_scalars", "[", "i", "]", ";", "if", "(", "told", "<", "t", "&&", "t", "<", "1.0", ")", "{", "double", "f", "=", "t", ";", "if", "(", "seg", "!=", "null", ")", "{", "f", "=", "seg_length", ">", "0", "?", "seg", ".", "_calculateSubLength", "(", "t", ")", "/", "seg_length", ":", "0.0", ";", "}", "m_vertices", ".", "_interpolateTwoVertices", "(", "vindex", ",", "vindex_next", ",", "f", ",", "getHelperPoint_", "(", ")", ")", ";", "// use this call mainly to", "// interpolate the attributes. XYs", "// are interpolated incorrectly for", "// curves and are recalculated when", "// segment is cut below.", "int", "inserted_vertex", "=", "insertVertex_", "(", "getPathFromVertex", "(", "origin_vertex", ")", ",", "next_vertex", ",", "getHelperPoint_", "(", ")", ")", ";", "actual_splits", "++", ";", "if", "(", "seg", "!=", "null", ")", "{", "Segment", "subseg", "=", "seg", ".", "cut", "(", "told", ",", "t", ")", ";", "int", "prev_vertex", "=", "getPrevVertex", "(", "inserted_vertex", ")", ";", "int", "vindex_prev", "=", "getVertexIndex", "(", "prev_vertex", ")", ";", "setSegmentToIndex_", "(", "vindex_prev", ",", "subseg", ")", ";", "setXY", "(", "inserted_vertex", ",", "subseg", ".", "getEndXY", "(", ")", ")", ";", "// fix XY", "// coordinates", "// to be", "// parameter", "// based", "// (interpolate_two_vertices_)", "if", "(", "i", "==", "split_count", "-", "1", "||", "split_scalars", "[", "i", "+", "1", "]", "==", "1.0", ")", "{", "// last", "// chance", "// to", "// set", "// last", "// split", "// segment", "// here:", "Segment", "subseg_end", "=", "seg", ".", "cut", "(", "t", ",", "1.0", ")", ";", "setSegmentToIndex_", "(", "vindex_prev", ",", "subseg_end", ")", ";", "}", "}", "}", "}", "return", "actual_splits", ";", "}"], "docstring": "happend).", "docstring_tokens": ["happend", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1097-L1155", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.interpolateAttributesForClosedPath", "original_string": "void interpolateAttributesForClosedPath(int path, int from_vertex,\n\t\t\tint to_vertex) {\n\t\tassert (isClosedPath(path));\n\n\t\tif (!m_b_has_attributes)\n\t\t\treturn;\n\n\t\tdouble sub_length = calculateSubLength2D(path, from_vertex, to_vertex);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tint nattr = m_vertex_description.getAttributeCount();\n\n\t\tfor (int iattr = 1; iattr < nattr; iattr++) {\n\t\t\tint semantics = m_vertex_description.getSemantics(iattr);\n\n\t\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\t\tcontinue;\n\n\t\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\t\tinterpolateAttributesForClosedPath_(semantics, path,\n\t\t\t\t\t\tfrom_vertex, to_vertex, sub_length, ordinate);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// calculates the length for the specified path between from_vertex and\n\t// to_vertex\n\tdouble calculateSubLength2D(int path, int from_vertex, int to_vertex) {\n\t\tint shape_from_index = getVertexIndex(from_vertex);\n\t\tint shape_to_index = getVertexIndex(to_vertex);\n\n\t\tif (shape_from_index < 0 || shape_to_index > getTotalPointCount() - 1)\n\t\t\tthrow new IllegalArgumentException(\"invalid call\");\n\n\t\tif (shape_from_index > shape_to_index) {\n\t\t\tif (!isClosedPath(path))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"cannot iterate across an open path\");\n\t\t}\n\n\t\tdouble sub_length = 0.0;\n\n\t\tfor (int vertex = from_vertex; vertex != to_vertex; vertex = getNextVertex(vertex)) {\n\t\t\tint vertex_index = getVertexIndex(vertex);\n\t\t\tSegment segment = getSegmentFromIndex_(vertex_index);\n\t\t\tif (segment != null) {\n\t\t\t\tsub_length += segment.calculateLength2D();\n\t\t\t} else {\n\t\t\t\tint next_vertex_index = getVertexIndex(getNextVertex(vertex));\n\t\t\t\tsub_length += m_vertices._getShortestDistance(vertex_index,\n\t\t\t\t\t\tnext_vertex_index);\n\t\t\t}\n\t\t}\n\n\t\treturn sub_length;\n\t}\n\n\t// set_point modifies the vertex and associated segments.\n\tvoid setPoint(int vertex, Point new_coord) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tm_vertices.setPointByVal(vindex, new_coord);\n\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\tif (seg != null) {\n\t\t\tseg.setStart(new_coord);\n\t\t}\n\t\tint prev = getPrevVertex(vertex);\n\t\tif (prev != -1) {\n\t\t\tint vindex_p = getVertexIndex(prev);\n\t\t\tSegment seg_p = getSegmentFromIndex_(vindex_p);\n\t\t\tif (seg_p != null) {\n\t\t\t\tseg.setEnd(new_coord);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Queries point for a given vertex.\n\tvoid queryPoint(int vertex, Point point) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tm_vertices.getPointByVal(vindex, point);\n\t\t// assert(getXY(vertex) == point.getXY());\n\t}\n\n\t// set_xy modifies the vertex and associated segments.\n\tvoid setXY(int vertex, Point2D new_coord) {\n\t\tsetXY(vertex, new_coord.x, new_coord.y);\n\t}\n\n\t// set_xy modifies the vertex and associated segments.\n\tvoid setXY(int vertex, double new_x, double new_y) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tm_vertices.setXY(vindex, new_x, new_y);\n\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\tif (seg != null) {\n\t\t\tseg.setStartXY(new_x, new_y);\n\t\t}\n\t\tint prev = getPrevVertex(vertex);\n\t\tif (prev != -1) {\n\t\t\tint vindex_p = getVertexIndex(prev);\n\t\t\tSegment seg_p = getSegmentFromIndex_(vindex_p);\n\t\t\tif (seg_p != null) {\n\t\t\t\tseg.setEndXY(new_x, new_y);\n\t\t\t}\n\t\t}\n\t}\n\n\tPoint2D getXY(int vertex) {\n\t\tPoint2D pt = new Point2D();\n\t\tint vindex = getVertexIndex(vertex);\n\t\tpt.setCoords(m_vertices.getXY(vindex));\n\t\treturn pt;\n\t}\n\n\t// Returns the coordinates of the vertex.\n\tvoid getXY(int vertex, Point2D ptOut) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tptOut.setCoords(m_vertices.getXY(vindex));\n\t}\n\n\tvoid getXYWithIndex(int index, Point2D ptOut) {\n\t\tm_xy_stream.read(2 * index, ptOut);\n\t}\n\n\t// Gets the attribute for the given semantics and ordinate.\n\tdouble getAttributeAsDbl(int semantics, int vertex, int ordinate) {\n\t\treturn m_vertices.getAttributeAsDbl(semantics, getVertexIndex(vertex),\n\t\t\t\tordinate);\n\t}\n\n\t// Sets the attribute for the given semantics and ordinate.\n\tvoid setAttribute(int semantics, int vertex, int ordinate, double value) {\n\t\tm_vertices.setAttribute(semantics, getVertexIndex(vertex), ordinate,\n\t\t\t\tvalue);\n\t}\n\n\t// Sets the attribute for the given semantics and ordinate.\n\tvoid setAttribute(int semantics, int vertex, int ordinate, int value) {\n\t\tm_vertices.setAttribute(semantics, getVertexIndex(vertex), ordinate,\n\t\t\t\tvalue);\n\t}\n\n\t// Returns a reference to the vertex description\n\tVertexDescription getVertexDescription() {\n\t\treturn m_vertex_description;\n\t}\n\n\tint getMinPathVertexY(int path) {\n\t\tint first_vert = getFirstVertex(path);\n\t\tint minv = first_vert;\n\t\tint vert = getNextVertex(first_vert);\n\t\twhile (vert != -1 && vert != first_vert) {\n\t\t\tif (compareVerticesSimpleY_(vert, minv) < 0)\n\t\t\t\tminv = vert;\n\t\t\tvert = getNextVertex(vert);\n\t\t}\n\t\treturn minv;\n\t}\n\n\t// Returns an index value for the vertex inside of the underlying array of\n\t// vertices.\n\t// This index is for the use with the get_xy_with_index. get_xy is\n\t// equivalent to calling get_vertex_index and get_xy_with_index.\n\tint getVertexIndex(int vertex) {\n\t\treturn m_vertex_index_list.getField(vertex, 0);\n\t}\n\n\t// Returns the y coordinate of the vertex.\n\tdouble getY(int vertex) {\n\t\tPoint2D pt = new Point2D();\n\t\tgetXY(vertex, pt);\n\t\treturn pt.y;\n\t}\n\n\t// returns True if xy coordinates at vertices are equal.\n\tboolean isEqualXY(int vertex_1, int vertex_2) {\n\t\tint vindex1 = getVertexIndex(vertex_1);\n\t\tint vindex2 = getVertexIndex(vertex_2);\n\t\treturn m_vertices.getXY(vindex1).isEqual(m_vertices.getXY(vindex2));\n\t}\n\n\t// returns True if xy coordinates at vertices are equal.\n\tboolean isEqualXY(int vertex, Point2D pt) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\treturn m_vertices.getXY(vindex).isEqual(pt);\n\t}\n\n\t// Sets weight to the vertex. Weight is used by clustering and cracking.\n\tvoid setWeight(int vertex, double weight) {\n\t\tif (weight < 1.0)\n\t\t\tweight = 1.0;\n\n\t\tif (m_weights == null) {\n\t\t\tif (weight == 1.0)\n\t\t\t\treturn;\n\n\t\t\tm_weights = (AttributeStreamOfDbl) (AttributeStreamBase\n\t\t\t\t\t.createDoubleStream(m_vertices.getPointCount(), 1.0));\n\t\t}\n\n\t\tint vindex = getVertexIndex(vertex);\n\t\tif (vindex >= m_weights.size()) {\n\t\t\tm_weights.resize(vindex + 1, 1.0);\n\t\t}\n\t\t\n\t\tm_weights.write(vindex, weight);\n\t}\n\n\tdouble getWeight(int vertex) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tif (m_weights == null || vindex >= m_weights.size())\n\t\t\treturn 1.0;\n\t\t\n\t\treturn m_weights.read(vindex);\n\t}\n\n\t// Removes associated weights\n\tvoid removeWeights() {\n\t\tm_weights = null;\n\t}\n\n\t// Sets value to the given user index.\n\tvoid setUserIndex(int vertex, int index, int value) {\n\t\t// CHECKVERTEXHANDLE(vertex);\n\t\tAttributeStreamOfInt32 stream = m_indices.get(index);\n\t\t// assert(get_prev_vertex(vertex) != -0x7eadbeaf);//using deleted vertex\n\t\tint vindex = getVertexIndex(vertex);\n\t\tif (stream.size() < m_vertices.getPointCount())\n\t\t\tstream.resize(m_vertices.getPointCount(), -1);\n\t\tstream.write(vindex, value);\n\t}\n\n\tint getUserIndex(int vertex, int index) {\n\t\t// CHECKVERTEXHANDLE(vertex);\n\t\tint vindex = getVertexIndex(vertex);\n\t\tAttributeStreamOfInt32 stream = m_indices.get(index);\n\t\tif (vindex < stream.size()) {\n\t\t\tint val = stream.read(vindex);\n\t\t\treturn val;\n\t\t} else\n\t\t\treturn -1;\n\t}", "language": "java", "code": "void interpolateAttributesForClosedPath(int path, int from_vertex,\n\t\t\tint to_vertex) {\n\t\tassert (isClosedPath(path));\n\n\t\tif (!m_b_has_attributes)\n\t\t\treturn;\n\n\t\tdouble sub_length = calculateSubLength2D(path, from_vertex, to_vertex);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tint nattr = m_vertex_description.getAttributeCount();\n\n\t\tfor (int iattr = 1; iattr < nattr; iattr++) {\n\t\t\tint semantics = m_vertex_description.getSemantics(iattr);\n\n\t\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\t\tcontinue;\n\n\t\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\t\tinterpolateAttributesForClosedPath_(semantics, path,\n\t\t\t\t\t\tfrom_vertex, to_vertex, sub_length, ordinate);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// calculates the length for the specified path between from_vertex and\n\t// to_vertex\n\tdouble calculateSubLength2D(int path, int from_vertex, int to_vertex) {\n\t\tint shape_from_index = getVertexIndex(from_vertex);\n\t\tint shape_to_index = getVertexIndex(to_vertex);\n\n\t\tif (shape_from_index < 0 || shape_to_index > getTotalPointCount() - 1)\n\t\t\tthrow new IllegalArgumentException(\"invalid call\");\n\n\t\tif (shape_from_index > shape_to_index) {\n\t\t\tif (!isClosedPath(path))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"cannot iterate across an open path\");\n\t\t}\n\n\t\tdouble sub_length = 0.0;\n\n\t\tfor (int vertex = from_vertex; vertex != to_vertex; vertex = getNextVertex(vertex)) {\n\t\t\tint vertex_index = getVertexIndex(vertex);\n\t\t\tSegment segment = getSegmentFromIndex_(vertex_index);\n\t\t\tif (segment != null) {\n\t\t\t\tsub_length += segment.calculateLength2D();\n\t\t\t} else {\n\t\t\t\tint next_vertex_index = getVertexIndex(getNextVertex(vertex));\n\t\t\t\tsub_length += m_vertices._getShortestDistance(vertex_index,\n\t\t\t\t\t\tnext_vertex_index);\n\t\t\t}\n\t\t}\n\n\t\treturn sub_length;\n\t}\n\n\t// set_point modifies the vertex and associated segments.\n\tvoid setPoint(int vertex, Point new_coord) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tm_vertices.setPointByVal(vindex, new_coord);\n\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\tif (seg != null) {\n\t\t\tseg.setStart(new_coord);\n\t\t}\n\t\tint prev = getPrevVertex(vertex);\n\t\tif (prev != -1) {\n\t\t\tint vindex_p = getVertexIndex(prev);\n\t\t\tSegment seg_p = getSegmentFromIndex_(vindex_p);\n\t\t\tif (seg_p != null) {\n\t\t\t\tseg.setEnd(new_coord);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Queries point for a given vertex.\n\tvoid queryPoint(int vertex, Point point) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tm_vertices.getPointByVal(vindex, point);\n\t\t// assert(getXY(vertex) == point.getXY());\n\t}\n\n\t// set_xy modifies the vertex and associated segments.\n\tvoid setXY(int vertex, Point2D new_coord) {\n\t\tsetXY(vertex, new_coord.x, new_coord.y);\n\t}\n\n\t// set_xy modifies the vertex and associated segments.\n\tvoid setXY(int vertex, double new_x, double new_y) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tm_vertices.setXY(vindex, new_x, new_y);\n\t\tSegment seg = getSegmentFromIndex_(vindex);\n\t\tif (seg != null) {\n\t\t\tseg.setStartXY(new_x, new_y);\n\t\t}\n\t\tint prev = getPrevVertex(vertex);\n\t\tif (prev != -1) {\n\t\t\tint vindex_p = getVertexIndex(prev);\n\t\t\tSegment seg_p = getSegmentFromIndex_(vindex_p);\n\t\t\tif (seg_p != null) {\n\t\t\t\tseg.setEndXY(new_x, new_y);\n\t\t\t}\n\t\t}\n\t}\n\n\tPoint2D getXY(int vertex) {\n\t\tPoint2D pt = new Point2D();\n\t\tint vindex = getVertexIndex(vertex);\n\t\tpt.setCoords(m_vertices.getXY(vindex));\n\t\treturn pt;\n\t}\n\n\t// Returns the coordinates of the vertex.\n\tvoid getXY(int vertex, Point2D ptOut) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tptOut.setCoords(m_vertices.getXY(vindex));\n\t}\n\n\tvoid getXYWithIndex(int index, Point2D ptOut) {\n\t\tm_xy_stream.read(2 * index, ptOut);\n\t}\n\n\t// Gets the attribute for the given semantics and ordinate.\n\tdouble getAttributeAsDbl(int semantics, int vertex, int ordinate) {\n\t\treturn m_vertices.getAttributeAsDbl(semantics, getVertexIndex(vertex),\n\t\t\t\tordinate);\n\t}\n\n\t// Sets the attribute for the given semantics and ordinate.\n\tvoid setAttribute(int semantics, int vertex, int ordinate, double value) {\n\t\tm_vertices.setAttribute(semantics, getVertexIndex(vertex), ordinate,\n\t\t\t\tvalue);\n\t}\n\n\t// Sets the attribute for the given semantics and ordinate.\n\tvoid setAttribute(int semantics, int vertex, int ordinate, int value) {\n\t\tm_vertices.setAttribute(semantics, getVertexIndex(vertex), ordinate,\n\t\t\t\tvalue);\n\t}\n\n\t// Returns a reference to the vertex description\n\tVertexDescription getVertexDescription() {\n\t\treturn m_vertex_description;\n\t}\n\n\tint getMinPathVertexY(int path) {\n\t\tint first_vert = getFirstVertex(path);\n\t\tint minv = first_vert;\n\t\tint vert = getNextVertex(first_vert);\n\t\twhile (vert != -1 && vert != first_vert) {\n\t\t\tif (compareVerticesSimpleY_(vert, minv) < 0)\n\t\t\t\tminv = vert;\n\t\t\tvert = getNextVertex(vert);\n\t\t}\n\t\treturn minv;\n\t}\n\n\t// Returns an index value for the vertex inside of the underlying array of\n\t// vertices.\n\t// This index is for the use with the get_xy_with_index. get_xy is\n\t// equivalent to calling get_vertex_index and get_xy_with_index.\n\tint getVertexIndex(int vertex) {\n\t\treturn m_vertex_index_list.getField(vertex, 0);\n\t}\n\n\t// Returns the y coordinate of the vertex.\n\tdouble getY(int vertex) {\n\t\tPoint2D pt = new Point2D();\n\t\tgetXY(vertex, pt);\n\t\treturn pt.y;\n\t}\n\n\t// returns True if xy coordinates at vertices are equal.\n\tboolean isEqualXY(int vertex_1, int vertex_2) {\n\t\tint vindex1 = getVertexIndex(vertex_1);\n\t\tint vindex2 = getVertexIndex(vertex_2);\n\t\treturn m_vertices.getXY(vindex1).isEqual(m_vertices.getXY(vindex2));\n\t}\n\n\t// returns True if xy coordinates at vertices are equal.\n\tboolean isEqualXY(int vertex, Point2D pt) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\treturn m_vertices.getXY(vindex).isEqual(pt);\n\t}\n\n\t// Sets weight to the vertex. Weight is used by clustering and cracking.\n\tvoid setWeight(int vertex, double weight) {\n\t\tif (weight < 1.0)\n\t\t\tweight = 1.0;\n\n\t\tif (m_weights == null) {\n\t\t\tif (weight == 1.0)\n\t\t\t\treturn;\n\n\t\t\tm_weights = (AttributeStreamOfDbl) (AttributeStreamBase\n\t\t\t\t\t.createDoubleStream(m_vertices.getPointCount(), 1.0));\n\t\t}\n\n\t\tint vindex = getVertexIndex(vertex);\n\t\tif (vindex >= m_weights.size()) {\n\t\t\tm_weights.resize(vindex + 1, 1.0);\n\t\t}\n\t\t\n\t\tm_weights.write(vindex, weight);\n\t}\n\n\tdouble getWeight(int vertex) {\n\t\tint vindex = getVertexIndex(vertex);\n\t\tif (m_weights == null || vindex >= m_weights.size())\n\t\t\treturn 1.0;\n\t\t\n\t\treturn m_weights.read(vindex);\n\t}\n\n\t// Removes associated weights\n\tvoid removeWeights() {\n\t\tm_weights = null;\n\t}\n\n\t// Sets value to the given user index.\n\tvoid setUserIndex(int vertex, int index, int value) {\n\t\t// CHECKVERTEXHANDLE(vertex);\n\t\tAttributeStreamOfInt32 stream = m_indices.get(index);\n\t\t// assert(get_prev_vertex(vertex) != -0x7eadbeaf);//using deleted vertex\n\t\tint vindex = getVertexIndex(vertex);\n\t\tif (stream.size() < m_vertices.getPointCount())\n\t\t\tstream.resize(m_vertices.getPointCount(), -1);\n\t\tstream.write(vindex, value);\n\t}\n\n\tint getUserIndex(int vertex, int index) {\n\t\t// CHECKVERTEXHANDLE(vertex);\n\t\tint vindex = getVertexIndex(vertex);\n\t\tAttributeStreamOfInt32 stream = m_indices.get(index);\n\t\tif (vindex < stream.size()) {\n\t\t\tint val = stream.read(vindex);\n\t\t\treturn val;\n\t\t} else\n\t\t\treturn -1;\n\t}", "code_tokens": ["void", "interpolateAttributesForClosedPath", "(", "int", "path", ",", "int", "from_vertex", ",", "int", "to_vertex", ")", "{", "assert", "(", "isClosedPath", "(", "path", ")", ")", ";", "if", "(", "!", "m_b_has_attributes", ")", "return", ";", "double", "sub_length", "=", "calculateSubLength2D", "(", "path", ",", "from_vertex", ",", "to_vertex", ")", ";", "if", "(", "sub_length", "==", "0.0", ")", "return", ";", "int", "nattr", "=", "m_vertex_description", ".", "getAttributeCount", "(", ")", ";", "for", "(", "int", "iattr", "=", "1", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "int", "semantics", "=", "m_vertex_description", ".", "getSemantics", "(", "iattr", ")", ";", "int", "interpolation", "=", "VertexDescription", ".", "getInterpolation", "(", "semantics", ")", ";", "if", "(", "interpolation", "==", "VertexDescription", ".", "Interpolation", ".", "ANGULAR", ")", "continue", ";", "int", "components", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "for", "(", "int", "ordinate", "=", "0", ";", "ordinate", "<", "components", ";", "ordinate", "++", ")", "interpolateAttributesForClosedPath_", "(", "semantics", ",", "path", ",", "from_vertex", ",", "to_vertex", ",", "sub_length", ",", "ordinate", ")", ";", "}", "return", ";", "}", "// calculates the length for the specified path between from_vertex and", "// to_vertex", "double", "calculateSubLength2D", "(", "int", "path", ",", "int", "from_vertex", ",", "int", "to_vertex", ")", "{", "int", "shape_from_index", "=", "getVertexIndex", "(", "from_vertex", ")", ";", "int", "shape_to_index", "=", "getVertexIndex", "(", "to_vertex", ")", ";", "if", "(", "shape_from_index", "<", "0", "||", "shape_to_index", ">", "getTotalPointCount", "(", ")", "-", "1", ")", "throw", "new", "IllegalArgumentException", "(", "\"invalid call\"", ")", ";", "if", "(", "shape_from_index", ">", "shape_to_index", ")", "{", "if", "(", "!", "isClosedPath", "(", "path", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"cannot iterate across an open path\"", ")", ";", "}", "double", "sub_length", "=", "0.0", ";", "for", "(", "int", "vertex", "=", "from_vertex", ";", "vertex", "!=", "to_vertex", ";", "vertex", "=", "getNextVertex", "(", "vertex", ")", ")", "{", "int", "vertex_index", "=", "getVertexIndex", "(", "vertex", ")", ";", "Segment", "segment", "=", "getSegmentFromIndex_", "(", "vertex_index", ")", ";", "if", "(", "segment", "!=", "null", ")", "{", "sub_length", "+=", "segment", ".", "calculateLength2D", "(", ")", ";", "}", "else", "{", "int", "next_vertex_index", "=", "getVertexIndex", "(", "getNextVertex", "(", "vertex", ")", ")", ";", "sub_length", "+=", "m_vertices", ".", "_getShortestDistance", "(", "vertex_index", ",", "next_vertex_index", ")", ";", "}", "}", "return", "sub_length", ";", "}", "// set_point modifies the vertex and associated segments.", "void", "setPoint", "", "(", "int", "vertex", ",", "Point", "new_coord", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "m_vertices", ".", "setPointByVal", "(", "vindex", ",", "new_coord", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex", ")", ";", "if", "(", "seg", "!=", "null", ")", "{", "seg", ".", "setStart", "(", "new_coord", ")", ";", "}", "int", "prev", "=", "getPrevVertex", "(", "vertex", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "{", "int", "vindex_p", "=", "getVertexIndex", "(", "prev", ")", ";", "Segment", "seg_p", "=", "getSegmentFromIndex_", "(", "vindex_p", ")", ";", "if", "(", "seg_p", "!=", "null", ")", "{", "seg", ".", "setEnd", "(", "new_coord", ")", ";", "}", "}", "}", "// Queries point for a given vertex.", "void", "queryPoint", "", "(", "int", "vertex", ",", "Point", "point", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "m_vertices", ".", "getPointByVal", "(", "vindex", ",", "point", ")", ";", "// assert(getXY(vertex) == point.getXY());", "}", "// set_xy modifies the vertex and associated segments.", "void", "setXY", "", "(", "int", "vertex", ",", "Point2D", "new_coord", ")", "{", "setXY", "(", "vertex", ",", "new_coord", ".", "x", ",", "new_coord", ".", "y", ")", ";", "}", "// set_xy modifies the vertex and associated segments.", "void", "setXY", "", "(", "int", "vertex", ",", "double", "new_x", ",", "double", "new_y", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "m_vertices", ".", "setXY", "(", "vindex", ",", "new_x", ",", "new_y", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex", ")", ";", "if", "(", "seg", "!=", "null", ")", "{", "seg", ".", "setStartXY", "(", "new_x", ",", "new_y", ")", ";", "}", "int", "prev", "=", "getPrevVertex", "(", "vertex", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "{", "int", "vindex_p", "=", "getVertexIndex", "(", "prev", ")", ";", "Segment", "seg_p", "=", "getSegmentFromIndex_", "(", "vindex_p", ")", ";", "if", "(", "seg_p", "!=", "null", ")", "{", "seg", ".", "setEndXY", "(", "new_x", ",", "new_y", ")", ";", "}", "}", "}", "Point2D", "getXY", "", "(", "int", "vertex", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "pt", ".", "setCoords", "(", "m_vertices", ".", "getXY", "(", "vindex", ")", ")", ";", "return", "pt", ";", "}", "// Returns the coordinates of the vertex.", "void", "getXY", "", "(", "int", "vertex", ",", "Point2D", "ptOut", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "ptOut", ".", "setCoords", "(", "m_vertices", ".", "getXY", "(", "vindex", ")", ")", ";", "}", "void", "getXYWithIndex", "", "(", "int", "index", ",", "Point2D", "ptOut", ")", "{", "m_xy_stream", ".", "read", "(", "2", "*", "index", ",", "ptOut", ")", ";", "}", "// Gets the attribute for the given semantics and ordinate.", "double", "getAttributeAsDbl", "", "(", "int", "semantics", ",", "int", "vertex", ",", "int", "ordinate", ")", "{", "return", "m_vertices", ".", "getAttributeAsDbl", "(", "semantics", ",", "getVertexIndex", "(", "vertex", ")", ",", "ordinate", ")", ";", "}", "// Sets the attribute for the given semantics and ordinate.", "void", "setAttribute", "", "(", "int", "semantics", ",", "int", "vertex", ",", "int", "ordinate", ",", "double", "value", ")", "{", "m_vertices", ".", "setAttribute", "(", "semantics", ",", "getVertexIndex", "(", "vertex", ")", ",", "ordinate", ",", "value", ")", ";", "}", "// Sets the attribute for the given semantics and ordinate.", "void", "setAttribute", "", "(", "int", "semantics", ",", "int", "vertex", ",", "int", "ordinate", ",", "int", "value", ")", "{", "m_vertices", ".", "setAttribute", "(", "semantics", ",", "getVertexIndex", "(", "vertex", ")", ",", "ordinate", ",", "value", ")", ";", "}", "// Returns a reference to the vertex description", "VertexDescription", "getVertexDescription", "", "(", ")", "{", "return", "m_vertex_description", ";", "}", "int", "getMinPathVertexY", "", "(", "int", "path", ")", "{", "int", "first_vert", "=", "getFirstVertex", "(", "path", ")", ";", "int", "minv", "=", "first_vert", ";", "int", "vert", "=", "getNextVertex", "(", "first_vert", ")", ";", "while", "(", "vert", "!=", "-", "1", "&&", "vert", "!=", "first_vert", ")", "{", "if", "(", "compareVerticesSimpleY_", "(", "vert", ",", "minv", ")", "<", "0", ")", "minv", "=", "vert", ";", "vert", "=", "getNextVertex", "(", "vert", ")", ";", "}", "return", "minv", ";", "}", "// Returns an index value for the vertex inside of the underlying array of", "// vertices.", "// This index is for the use with the get_xy_with_index. get_xy is", "// equivalent to calling get_vertex_index and get_xy_with_index.", "int", "getVertexIndex", "", "(", "int", "vertex", ")", "{", "return", "m_vertex_index_list", ".", "getField", "(", "vertex", ",", "0", ")", ";", "}", "// Returns the y coordinate of the vertex.", "double", "getY", "", "(", "int", "vertex", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "getXY", "(", "vertex", ",", "pt", ")", ";", "return", "pt", ".", "y", ";", "}", "// returns True if xy coordinates at vertices are equal.", "boolean", "isEqualXY", "", "(", "int", "vertex_1", ",", "int", "vertex_2", ")", "{", "int", "vindex1", "=", "getVertexIndex", "(", "vertex_1", ")", ";", "int", "vindex2", "=", "getVertexIndex", "(", "vertex_2", ")", ";", "return", "m_vertices", ".", "getXY", "(", "vindex1", ")", ".", "isEqual", "(", "m_vertices", ".", "getXY", "(", "vindex2", ")", ")", ";", "}", "// returns True if xy coordinates at vertices are equal.", "boolean", "isEqualXY", "", "(", "int", "vertex", ",", "Point2D", "pt", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "return", "m_vertices", ".", "getXY", "(", "vindex", ")", ".", "isEqual", "(", "pt", ")", ";", "}", "// Sets weight to the vertex. Weight is used by clustering and cracking.", "void", "setWeight", "", "(", "int", "vertex", ",", "double", "weight", ")", "{", "if", "(", "weight", "<", "1.0", ")", "weight", "=", "1.0", ";", "if", "(", "m_weights", "==", "null", ")", "{", "if", "(", "weight", "==", "1.0", ")", "return", ";", "m_weights", "=", "(", "AttributeStreamOfDbl", ")", "(", "AttributeStreamBase", ".", "createDoubleStream", "(", "m_vertices", ".", "getPointCount", "(", ")", ",", "1.0", ")", ")", ";", "}", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "if", "(", "vindex", ">=", "m_weights", ".", "size", "(", ")", ")", "{", "m_weights", ".", "resize", "(", "vindex", "+", "1", ",", "1.0", ")", ";", "}", "m_weights", ".", "write", "(", "vindex", ",", "weight", ")", ";", "}", "double", "getWeight", "", "(", "int", "vertex", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "if", "(", "m_weights", "==", "null", "||", "vindex", ">=", "m_weights", ".", "size", "(", ")", ")", "return", "1.0", ";", "return", "m_weights", ".", "read", "(", "vindex", ")", ";", "}", "// Removes associated weights", "void", "removeWeights", "", "(", ")", "{", "m_weights", "=", "null", ";", "}", "// Sets value to the given user index.", "void", "setUserIndex", "", "(", "int", "vertex", ",", "int", "index", ",", "int", "value", ")", "{", "// CHECKVERTEXHANDLE(vertex);", "AttributeStreamOfInt32", "stream", "=", "m_indices", ".", "get", "(", "index", ")", ";", "// assert(get_prev_vertex(vertex) != -0x7eadbeaf);//using deleted vertex", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<", "m_vertices", ".", "getPointCount", "(", ")", ")", "stream", ".", "resize", "(", "m_vertices", ".", "getPointCount", "(", ")", ",", "-", "1", ")", ";", "stream", ".", "write", "(", "vindex", ",", "value", ")", ";", "}", "int", "getUserIndex", "", "(", "int", "vertex", ",", "int", "index", ")", "{", "// CHECKVERTEXHANDLE(vertex);", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_indices", ".", "get", "(", "index", ")", ";", "if", "(", "vindex", "<", "stream", ".", "size", "(", ")", ")", "{", "int", "val", "=", "stream", ".", "read", "(", "vindex", ")", ";", "return", "val", ";", "}", "else", "return", "-", "1", ";", "}"], "docstring": "and to_vertex", "docstring_tokens": ["and", "to_vertex"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1159-L1404", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.createUserIndex", "original_string": "int createUserIndex() {\n\t\tif (m_indices == null)\n\t\t\tm_indices = new ArrayList<AttributeStreamOfInt32>(0);\n\n\t\t// Try getting existing index. Use linear search. We do not expect many\n\t\t// indices to be created.\n\t\tfor (int i = 0; i < m_indices.size(); i++) {\n\t\t\tif (m_indices.get(i) == null) {\n\t\t\t\tm_indices.set(i, (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t\t.createIndexStream(0, -1));\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tm_indices.add((AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t.createIndexStream(0, -1));\n\t\treturn m_indices.size() - 1;\n\t}", "language": "java", "code": "int createUserIndex() {\n\t\tif (m_indices == null)\n\t\t\tm_indices = new ArrayList<AttributeStreamOfInt32>(0);\n\n\t\t// Try getting existing index. Use linear search. We do not expect many\n\t\t// indices to be created.\n\t\tfor (int i = 0; i < m_indices.size(); i++) {\n\t\t\tif (m_indices.get(i) == null) {\n\t\t\t\tm_indices.set(i, (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t\t.createIndexStream(0, -1));\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tm_indices.add((AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t.createIndexStream(0, -1));\n\t\treturn m_indices.size() - 1;\n\t}", "code_tokens": ["int", "createUserIndex", "(", ")", "{", "if", "(", "m_indices", "==", "null", ")", "m_indices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "0", ")", ";", "// Try getting existing index. Use linear search. We do not expect many", "// indices to be created.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_indices", ".", "size", "(", ")", ";", "i", "++", ")", "{", "if", "(", "m_indices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_indices", ".", "set", "(", "i", ",", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "0", ",", "-", "1", ")", ")", ";", "return", "i", ";", "}", "}", "m_indices", ".", "add", "(", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "0", ",", "-", "1", ")", ")", ";", "return", "m_indices", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "store an integer user value on the vertex.", "docstring_tokens": ["store", "an", "integer", "user", "value", "on", "the", "vertex", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1408-L1425", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getSegment", "original_string": "Segment getSegment(int vertex) {\n\t\tif (m_segments != null) {\n\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\treturn m_segments.get(vindex);\n\t\t}\n\t\treturn null;\n\t}", "language": "java", "code": "Segment getSegment(int vertex) {\n\t\tif (m_segments != null) {\n\t\t\tint vindex = getVertexIndex(vertex);\n\t\t\treturn m_segments.get(vindex);\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["Segment", "getSegment", "(", "int", "vertex", ")", "{", "if", "(", "m_segments", "!=", "null", ")", "{", "int", "vindex", "=", "getVertexIndex", "(", "vertex", ")", ";", "return", "m_segments", ".", "get", "(", "vindex", ")", ";", "}", "return", "null", ";", "}"], "docstring": "if it is a Line.", "docstring_tokens": ["if", "it", "is", "a", "Line", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1434-L1440", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.queryLineConnector", "original_string": "boolean queryLineConnector(int vertex, Line line) {\n\t\tint next = getNextVertex(vertex);\n\t\tif (next == -1)\n\t\t\treturn false;\n\n\t\tif (!m_b_has_attributes) {\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tgetXY(vertex, pt);\n\t\t\tline.setStartXY(pt);\n\t\t\tgetXY(next, pt);\n\t\t\tline.setEndXY(pt);\n\t\t} else {\n\t\t\tPoint pt = new Point();\n\t\t\tqueryPoint(vertex, pt);\n\t\t\tline.setStart(pt);\n\t\t\tqueryPoint(next, pt);\n\t\t\tline.setEnd(pt);\n\t\t}\n\n\t\treturn true;\n\t}", "language": "java", "code": "boolean queryLineConnector(int vertex, Line line) {\n\t\tint next = getNextVertex(vertex);\n\t\tif (next == -1)\n\t\t\treturn false;\n\n\t\tif (!m_b_has_attributes) {\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tgetXY(vertex, pt);\n\t\t\tline.setStartXY(pt);\n\t\t\tgetXY(next, pt);\n\t\t\tline.setEndXY(pt);\n\t\t} else {\n\t\t\tPoint pt = new Point();\n\t\t\tqueryPoint(vertex, pt);\n\t\t\tline.setStart(pt);\n\t\t\tqueryPoint(next, pt);\n\t\t\tline.setEnd(pt);\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["boolean", "queryLineConnector", "(", "int", "vertex", ",", "Line", "line", ")", "{", "int", "next", "=", "getNextVertex", "(", "vertex", ")", ";", "if", "(", "next", "==", "-", "1", ")", "return", "false", ";", "if", "(", "!", "m_b_has_attributes", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "getXY", "(", "vertex", ",", "pt", ")", ";", "line", ".", "setStartXY", "(", "pt", ")", ";", "getXY", "(", "next", ",", "pt", ")", ";", "line", ".", "setEndXY", "(", "pt", ")", ";", "}", "else", "{", "Point", "pt", "=", "new", "Point", "(", ")", ";", "queryPoint", "(", "vertex", ",", "pt", ")", ";", "line", ".", "setStart", "(", "pt", ")", ";", "queryPoint", "(", "next", ",", "pt", ")", ";", "line", ".", "setEnd", "(", "pt", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Can be used together with get_segment.", "docstring_tokens": ["Can", "be", "used", "together", "with", "get_segment", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1446-L1466", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.insertPath", "original_string": "int insertPath(int geometry, int before_path) {\n\t\tint prev = -1;\n\n\t\tif (before_path != -1) {\n\t\t\tif (geometry != getGeometryFromPath(before_path))\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\tprev = getPrevPath(before_path);\n\t\t} else\n\t\t\tprev = getLastPath(geometry);\n\n\t\tint newpath = newPath_(geometry);\n\t\tif (before_path != -1)\n\t\t\tsetPrevPath_(before_path, newpath);\n\n\t\tsetNextPath_(newpath, before_path);\n\t\tsetPrevPath_(newpath, prev);\n\t\tif (prev != -1)\n\t\t\tsetNextPath_(prev, newpath);\n\t\telse\n\t\t\tsetFirstPath_(geometry, newpath);\n\n\t\tif (before_path == -1)\n\t\t\tsetLastPath_(geometry, newpath);\n\n\t\tsetGeometryPathCount_(geometry, getPathCount(geometry) + 1);\n\t\treturn newpath;\n\t}", "language": "java", "code": "int insertPath(int geometry, int before_path) {\n\t\tint prev = -1;\n\n\t\tif (before_path != -1) {\n\t\t\tif (geometry != getGeometryFromPath(before_path))\n\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\tprev = getPrevPath(before_path);\n\t\t} else\n\t\t\tprev = getLastPath(geometry);\n\n\t\tint newpath = newPath_(geometry);\n\t\tif (before_path != -1)\n\t\t\tsetPrevPath_(before_path, newpath);\n\n\t\tsetNextPath_(newpath, before_path);\n\t\tsetPrevPath_(newpath, prev);\n\t\tif (prev != -1)\n\t\t\tsetNextPath_(prev, newpath);\n\t\telse\n\t\t\tsetFirstPath_(geometry, newpath);\n\n\t\tif (before_path == -1)\n\t\t\tsetLastPath_(geometry, newpath);\n\n\t\tsetGeometryPathCount_(geometry, getPathCount(geometry) + 1);\n\t\treturn newpath;\n\t}", "code_tokens": ["int", "insertPath", "(", "int", "geometry", ",", "int", "before_path", ")", "{", "int", "prev", "=", "-", "1", ";", "if", "(", "before_path", "!=", "-", "1", ")", "{", "if", "(", "geometry", "!=", "getGeometryFromPath", "(", "before_path", ")", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "prev", "=", "getPrevPath", "(", "before_path", ")", ";", "}", "else", "prev", "=", "getLastPath", "(", "geometry", ")", ";", "int", "newpath", "=", "newPath_", "(", "geometry", ")", ";", "if", "(", "before_path", "!=", "-", "1", ")", "setPrevPath_", "(", "before_path", ",", "newpath", ")", ";", "setNextPath_", "(", "newpath", ",", "before_path", ")", ";", "setPrevPath_", "(", "newpath", ",", "prev", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "setNextPath_", "(", "prev", ",", "newpath", ")", ";", "else", "setFirstPath_", "(", "geometry", ",", "newpath", ")", ";", "if", "(", "before_path", "==", "-", "1", ")", "setLastPath_", "(", "geometry", ",", "newpath", ")", ";", "setGeometryPathCount_", "(", "geometry", ",", "getPathCount", "(", "geometry", ")", "+", "1", ")", ";", "return", "newpath", ";", "}"], "docstring": "path at the end.", "docstring_tokens": ["path", "at", "the", "end", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1470-L1497", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.removePath", "original_string": "int removePath(int path) {\n\t\tint prev = getPrevPath(path);\n\t\tint next = getNextPath(path);\n\t\tint geometry = getGeometryFromPath(path);\n\t\tif (prev != -1)\n\t\t\tsetNextPath_(prev, next);\n\t\telse {\n\t\t\tsetFirstPath_(geometry, next);\n\t\t}\n\t\tif (next != -1)\n\t\t\tsetPrevPath_(next, prev);\n\t\telse {\n\t\t\tsetLastPath_(geometry, prev);\n\t\t}\n\n\t\tclearPath(path);\n\n\t\tsetGeometryPathCount_(geometry, getPathCount(geometry) - 1);\n\t\tfreePath_(path);\n\t\treturn next;\n\t}", "language": "java", "code": "int removePath(int path) {\n\t\tint prev = getPrevPath(path);\n\t\tint next = getNextPath(path);\n\t\tint geometry = getGeometryFromPath(path);\n\t\tif (prev != -1)\n\t\t\tsetNextPath_(prev, next);\n\t\telse {\n\t\t\tsetFirstPath_(geometry, next);\n\t\t}\n\t\tif (next != -1)\n\t\t\tsetPrevPath_(next, prev);\n\t\telse {\n\t\t\tsetLastPath_(geometry, prev);\n\t\t}\n\n\t\tclearPath(path);\n\n\t\tsetGeometryPathCount_(geometry, getPathCount(geometry) - 1);\n\t\tfreePath_(path);\n\t\treturn next;\n\t}", "code_tokens": ["int", "removePath", "(", "int", "path", ")", "{", "int", "prev", "=", "getPrevPath", "(", "path", ")", ";", "int", "next", "=", "getNextPath", "(", "path", ")", ";", "int", "geometry", "=", "getGeometryFromPath", "(", "path", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "setNextPath_", "(", "prev", ",", "next", ")", ";", "else", "{", "setFirstPath_", "(", "geometry", ",", "next", ")", ";", "}", "if", "(", "next", "!=", "-", "1", ")", "setPrevPath_", "(", "next", ",", "prev", ")", ";", "else", "{", "setLastPath_", "(", "geometry", ",", "prev", ")", ";", "}", "clearPath", "(", "path", ")", ";", "setGeometryPathCount_", "(", "geometry", ",", "getPathCount", "(", "geometry", ")", "-", "1", ")", ";", "freePath_", "(", "path", ")", ";", "return", "next", ";", "}"], "docstring": "Removes a path, gets rid of all its vertices, and returns the next one", "docstring_tokens": ["Removes", "a", "path", "gets", "rid", "of", "all", "its", "vertices", "and", "returns", "the", "next", "one"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1539-L1559", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.clearPath", "original_string": "void clearPath(int path) {\n\t\tint first_vertex = getFirstVertex(path);\n\t\tif (first_vertex != -1) {\n\t\t\t// TODO: can ve do this in one shot?\n\t\t\tint vertex = first_vertex;\n\t\t\tfor (int i = 0, n = getPathSize(path); i < n; i++) {\n\t\t\t\tint v = vertex;\n\t\t\t\tvertex = getNextVertex(vertex);\n\t\t\t\tfreeVertex_(v);\n\t\t\t}\n\t\t\tint geometry = getGeometryFromPath(path);\n\t\t\tsetGeometryVertexCount_(geometry, getPointCount(geometry)\n\t\t\t\t\t- getPathSize(path));\n\t\t}\n\t\tsetPathSize_(path, 0);\n\t}", "language": "java", "code": "void clearPath(int path) {\n\t\tint first_vertex = getFirstVertex(path);\n\t\tif (first_vertex != -1) {\n\t\t\t// TODO: can ve do this in one shot?\n\t\t\tint vertex = first_vertex;\n\t\t\tfor (int i = 0, n = getPathSize(path); i < n; i++) {\n\t\t\t\tint v = vertex;\n\t\t\t\tvertex = getNextVertex(vertex);\n\t\t\t\tfreeVertex_(v);\n\t\t\t}\n\t\t\tint geometry = getGeometryFromPath(path);\n\t\t\tsetGeometryVertexCount_(geometry, getPointCount(geometry)\n\t\t\t\t\t- getPathSize(path));\n\t\t}\n\t\tsetPathSize_(path, 0);\n\t}", "code_tokens": ["void", "clearPath", "(", "int", "path", ")", "{", "int", "first_vertex", "=", "getFirstVertex", "(", "path", ")", ";", "if", "(", "first_vertex", "!=", "-", "1", ")", "{", "// TODO: can ve do this in one shot?", "int", "vertex", "=", "first_vertex", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "getPathSize", "(", "path", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "v", "=", "vertex", ";", "vertex", "=", "getNextVertex", "(", "vertex", ")", ";", "freeVertex_", "(", "v", ")", ";", "}", "int", "geometry", "=", "getGeometryFromPath", "(", "path", ")", ";", "setGeometryVertexCount_", "(", "geometry", ",", "getPointCount", "(", "geometry", ")", "-", "getPathSize", "(", "path", ")", ")", ";", "}", "setPathSize_", "(", "path", ",", "0", ")", ";", "}"], "docstring": "Clears all vertices from the path", "docstring_tokens": ["Clears", "all", "vertices", "from", "the", "path"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1562-L1577", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.setClosedPath", "original_string": "void setClosedPath(int path, boolean b_yes_no) {\n\t\tif (isClosedPath(path) == b_yes_no)\n\t\t\treturn;\n\t\tif (getPathSize(path) > 0) {\n\t\t\tint first = getFirstVertex(path);\n\t\t\tint last = getLastVertex(path);\n\t\t\tif (b_yes_no) {\n\t\t\t\t// make a circular list\n\t\t\t\tsetNextVertex_(last, first);\n\t\t\t\tsetPrevVertex_(first, last);\n\t\t\t\t// set segment to NULL (just in case)\n\t\t\t\tint vindex = getVertexIndex(last);\n\t\t\t\tsetSegmentToIndex_(vindex, null);\n\t\t\t} else {\n\t\t\t\tsetNextVertex_(last, -1);\n\t\t\t\tsetPrevVertex_(first, -1);\n\t\t\t\tint vindex = getVertexIndex(last);\n\t\t\t\tsetSegmentToIndex_(vindex, null);\n\t\t\t}\n\t\t}\n\n\t\tint oldflags = getPathFlags_(path);\n\t\tint flags = (oldflags | (int) PathFlags_.closedPath)\n\t\t\t\t- (int) PathFlags_.closedPath;// clear the bit;\n\t\tsetPathFlags_(path, flags\n\t\t\t\t| (b_yes_no ? (int) PathFlags_.closedPath : 0));\n\t}", "language": "java", "code": "void setClosedPath(int path, boolean b_yes_no) {\n\t\tif (isClosedPath(path) == b_yes_no)\n\t\t\treturn;\n\t\tif (getPathSize(path) > 0) {\n\t\t\tint first = getFirstVertex(path);\n\t\t\tint last = getLastVertex(path);\n\t\t\tif (b_yes_no) {\n\t\t\t\t// make a circular list\n\t\t\t\tsetNextVertex_(last, first);\n\t\t\t\tsetPrevVertex_(first, last);\n\t\t\t\t// set segment to NULL (just in case)\n\t\t\t\tint vindex = getVertexIndex(last);\n\t\t\t\tsetSegmentToIndex_(vindex, null);\n\t\t\t} else {\n\t\t\t\tsetNextVertex_(last, -1);\n\t\t\t\tsetPrevVertex_(first, -1);\n\t\t\t\tint vindex = getVertexIndex(last);\n\t\t\t\tsetSegmentToIndex_(vindex, null);\n\t\t\t}\n\t\t}\n\n\t\tint oldflags = getPathFlags_(path);\n\t\tint flags = (oldflags | (int) PathFlags_.closedPath)\n\t\t\t\t- (int) PathFlags_.closedPath;// clear the bit;\n\t\tsetPathFlags_(path, flags\n\t\t\t\t| (b_yes_no ? (int) PathFlags_.closedPath : 0));\n\t}", "code_tokens": ["void", "setClosedPath", "(", "int", "path", ",", "boolean", "b_yes_no", ")", "{", "if", "(", "isClosedPath", "(", "path", ")", "==", "b_yes_no", ")", "return", ";", "if", "(", "getPathSize", "(", "path", ")", ">", "0", ")", "{", "int", "first", "=", "getFirstVertex", "(", "path", ")", ";", "int", "last", "=", "getLastVertex", "(", "path", ")", ";", "if", "(", "b_yes_no", ")", "{", "// make a circular list", "setNextVertex_", "(", "last", ",", "first", ")", ";", "setPrevVertex_", "(", "first", ",", "last", ")", ";", "// set segment to NULL (just in case)", "int", "vindex", "=", "getVertexIndex", "(", "last", ")", ";", "setSegmentToIndex_", "(", "vindex", ",", "null", ")", ";", "}", "else", "{", "setNextVertex_", "(", "last", ",", "-", "1", ")", ";", "setPrevVertex_", "(", "first", ",", "-", "1", ")", ";", "int", "vindex", "=", "getVertexIndex", "(", "last", ")", ";", "setSegmentToIndex_", "(", "vindex", ",", "null", ")", ";", "}", "}", "int", "oldflags", "=", "getPathFlags_", "(", "path", ")", ";", "int", "flags", "=", "(", "oldflags", "|", "(", "int", ")", "PathFlags_", ".", "closedPath", ")", "-", "(", "int", ")", "PathFlags_", ".", "closedPath", ";", "// clear the bit;", "setPathFlags_", "(", "path", ",", "flags", "|", "(", "b_yes_no", "?", "(", "int", ")", "PathFlags_", ".", "closedPath", ":", "0", ")", ")", ";", "}"], "docstring": "always succeeds", "docstring_tokens": ["always", "succeeds"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1602-L1628", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.closeAllPaths", "original_string": "void closeAllPaths(int geometry) {\n\t\tif (getGeometryType(geometry) == Geometry.GeometryType.Polygon)\n\t\t\treturn;\n\t\tif (!Geometry.isLinear(getGeometryType(geometry)))\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tfor (int path = getFirstPath(geometry); path != -1; path = getNextPath(path)) {\n\t\t\tsetClosedPath(path, true);\n\t\t}\n\t}", "language": "java", "code": "void closeAllPaths(int geometry) {\n\t\tif (getGeometryType(geometry) == Geometry.GeometryType.Polygon)\n\t\t\treturn;\n\t\tif (!Geometry.isLinear(getGeometryType(geometry)))\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tfor (int path = getFirstPath(geometry); path != -1; path = getNextPath(path)) {\n\t\t\tsetClosedPath(path, true);\n\t\t}\n\t}", "code_tokens": ["void", "closeAllPaths", "(", "int", "geometry", ")", "{", "if", "(", "getGeometryType", "(", "geometry", ")", "==", "Geometry", ".", "GeometryType", ".", "Polygon", ")", "return", ";", "if", "(", "!", "Geometry", ".", "isLinear", "(", "getGeometryType", "(", "geometry", ")", ")", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "for", "(", "int", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "path", "!=", "-", "1", ";", "path", "=", "getNextPath", "(", "path", ")", ")", "{", "setClosedPath", "(", "path", ",", "true", ")", ";", "}", "}"], "docstring": "Closes all paths of the geometry (has to be a polyline or polygon).", "docstring_tokens": ["Closes", "all", "paths", "of", "the", "geometry", "(", "has", "to", "be", "a", "polyline", "or", "polygon", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1631-L1640", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.setExterior", "original_string": "void setExterior(int path, boolean b_yes_no) {\n\t\tint oldflags = getPathFlags_(path);\n\t\tint flags = (oldflags | (int) PathFlags_.exteriorPath)\n\t\t\t\t- (int) PathFlags_.exteriorPath;// clear the bit;\n\t\tsetPathFlags_(path, flags\n\t\t\t\t| (b_yes_no ? (int) PathFlags_.exteriorPath : 0));\n\t}", "language": "java", "code": "void setExterior(int path, boolean b_yes_no) {\n\t\tint oldflags = getPathFlags_(path);\n\t\tint flags = (oldflags | (int) PathFlags_.exteriorPath)\n\t\t\t\t- (int) PathFlags_.exteriorPath;// clear the bit;\n\t\tsetPathFlags_(path, flags\n\t\t\t\t| (b_yes_no ? (int) PathFlags_.exteriorPath : 0));\n\t}", "code_tokens": ["void", "setExterior", "(", "int", "path", ",", "boolean", "b_yes_no", ")", "{", "int", "oldflags", "=", "getPathFlags_", "(", "path", ")", ";", "int", "flags", "=", "(", "oldflags", "|", "(", "int", ")", "PathFlags_", ".", "exteriorPath", ")", "-", "(", "int", ")", "PathFlags_", ".", "exteriorPath", ";", "// clear the bit;", "setPathFlags_", "(", "path", ",", "flags", "|", "(", "b_yes_no", "?", "(", "int", ")", "PathFlags_", ".", "exteriorPath", ":", "0", ")", ")", ";", "}"], "docstring": "Sets exterior flag", "docstring_tokens": ["Sets", "exterior", "flag"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1653-L1659", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getRingArea", "original_string": "double getRingArea(int path) {\n\t\tif (isRingAreaValid_(path))\n\t\t\treturn m_path_areas.get(getPathIndex_(path));\n\n\t\tLine line = new Line();\n\t\tint vertex = getFirstVertex(path);\n\t\tif (vertex == -1)\n\t\t\treturn 0;\n\t\tPoint2D pt0 = new Point2D();\n\t\tgetXY(vertex, pt0);\n\t\tdouble area = 0;\n\t\tfor (int i = 0, n = getPathSize(path); i < n; i++, vertex = getNextVertex(vertex)) {\n\t\t\tSegment seg = getSegment(vertex);\n\t\t\tif (seg == null) {\n\t\t\t\tif (!queryLineConnector(vertex, line))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tseg = line;\n\t\t\t}\n\n\t\t\tdouble a = seg._calculateArea2DHelper(pt0.x, pt0.y);\n\t\t\tarea += a;\n\t\t}\n\n\t\tsetRingAreaValid_(path, true);\n\t\tm_path_areas.set(getPathIndex_(path), area);\n\n\t\treturn area;\n\t}", "language": "java", "code": "double getRingArea(int path) {\n\t\tif (isRingAreaValid_(path))\n\t\t\treturn m_path_areas.get(getPathIndex_(path));\n\n\t\tLine line = new Line();\n\t\tint vertex = getFirstVertex(path);\n\t\tif (vertex == -1)\n\t\t\treturn 0;\n\t\tPoint2D pt0 = new Point2D();\n\t\tgetXY(vertex, pt0);\n\t\tdouble area = 0;\n\t\tfor (int i = 0, n = getPathSize(path); i < n; i++, vertex = getNextVertex(vertex)) {\n\t\t\tSegment seg = getSegment(vertex);\n\t\t\tif (seg == null) {\n\t\t\t\tif (!queryLineConnector(vertex, line))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tseg = line;\n\t\t\t}\n\n\t\t\tdouble a = seg._calculateArea2DHelper(pt0.x, pt0.y);\n\t\t\tarea += a;\n\t\t}\n\n\t\tsetRingAreaValid_(path, true);\n\t\tm_path_areas.set(getPathIndex_(path), area);\n\n\t\treturn area;\n\t}", "code_tokens": ["double", "getRingArea", "(", "int", "path", ")", "{", "if", "(", "isRingAreaValid_", "(", "path", ")", ")", "return", "m_path_areas", ".", "get", "(", "getPathIndex_", "(", "path", ")", ")", ";", "Line", "line", "=", "new", "Line", "(", ")", ";", "int", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "if", "(", "vertex", "==", "-", "1", ")", "return", "0", ";", "Point2D", "pt0", "=", "new", "Point2D", "(", ")", ";", "getXY", "(", "vertex", ",", "pt0", ")", ";", "double", "area", "=", "0", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "getPathSize", "(", "path", ")", ";", "i", "<", "n", ";", "i", "++", ",", "vertex", "=", "getNextVertex", "(", "vertex", ")", ")", "{", "Segment", "seg", "=", "getSegment", "(", "vertex", ")", ";", "if", "(", "seg", "==", "null", ")", "{", "if", "(", "!", "queryLineConnector", "(", "vertex", ",", "line", ")", ")", "continue", ";", "seg", "=", "line", ";", "}", "double", "a", "=", "seg", ".", "_calculateArea2DHelper", "(", "pt0", ".", "x", ",", "pt0", ".", "y", ")", ";", "area", "+=", "a", ";", "}", "setRingAreaValid_", "(", "path", ",", "true", ")", ";", "m_path_areas", ".", "set", "(", "getPathIndex_", "(", "path", ")", ",", "area", ")", ";", "return", "area", ";", "}"], "docstring": "Returns the ring area", "docstring_tokens": ["Returns", "the", "ring", "area"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1662-L1690", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.setPathUserIndex", "original_string": "void setPathUserIndex(int path, int index, int value) {\n\t\tAttributeStreamOfInt32 stream = m_pathindices.get(index);\n\t\tint pindex = getPathIndex_(path);\n\t\tif (stream.size() < m_path_areas.size())\n\t\t\tstream.resize(m_path_areas.size(), -1);\n\t\tstream.write(pindex, value);\n\t}", "language": "java", "code": "void setPathUserIndex(int path, int index, int value) {\n\t\tAttributeStreamOfInt32 stream = m_pathindices.get(index);\n\t\tint pindex = getPathIndex_(path);\n\t\tif (stream.size() < m_path_areas.size())\n\t\t\tstream.resize(m_path_areas.size(), -1);\n\t\tstream.write(pindex, value);\n\t}", "code_tokens": ["void", "setPathUserIndex", "(", "int", "path", ",", "int", "index", ",", "int", "value", ")", "{", "AttributeStreamOfInt32", "stream", "=", "m_pathindices", ".", "get", "(", "index", ")", ";", "int", "pindex", "=", "getPathIndex_", "(", "path", ")", ";", "if", "(", "stream", ".", "size", "(", ")", "<", "m_path_areas", ".", "size", "(", ")", ")", "stream", ".", "resize", "(", "m_path_areas", ".", "size", "(", ")", ",", "-", "1", ")", ";", "stream", ".", "write", "(", "pindex", ",", "value", ")", ";", "}"], "docstring": "Sets value to the given user index on a path.", "docstring_tokens": ["Sets", "value", "to", "the", "given", "user", "index", "on", "a", "path", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1693-L1699", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getPathUserIndex", "original_string": "int getPathUserIndex(int path, int index) {\n\t\tint pindex = getPathIndex_(path);\n\t\tAttributeStreamOfInt32 stream = m_pathindices.get(index);\n\t\tif (pindex < stream.size())\n\t\t\treturn stream.read(pindex);\n\t\telse\n\t\t\treturn -1;\n\t}", "language": "java", "code": "int getPathUserIndex(int path, int index) {\n\t\tint pindex = getPathIndex_(path);\n\t\tAttributeStreamOfInt32 stream = m_pathindices.get(index);\n\t\tif (pindex < stream.size())\n\t\t\treturn stream.read(pindex);\n\t\telse\n\t\t\treturn -1;\n\t}", "code_tokens": ["int", "getPathUserIndex", "(", "int", "path", ",", "int", "index", ")", "{", "int", "pindex", "=", "getPathIndex_", "(", "path", ")", ";", "AttributeStreamOfInt32", "stream", "=", "m_pathindices", ".", "get", "(", "index", ")", ";", "if", "(", "pindex", "<", "stream", ".", "size", "(", ")", ")", "return", "stream", ".", "read", "(", "pindex", ")", ";", "else", "return", "-", "1", ";", "}"], "docstring": "Returns the value of the given user index of a path", "docstring_tokens": ["Returns", "the", "value", "of", "the", "given", "user", "index", "of", "a", "path"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1702-L1709", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.createPathUserIndex", "original_string": "int createPathUserIndex() {\n\t\tif (m_pathindices == null)\n\t\t\tm_pathindices = new ArrayList<AttributeStreamOfInt32>(0);\n\t\t// Try getting existing index. Use linear search. We do not expect many\n\t\t// indices to be created.\n\t\tfor (int i = 0; i < m_pathindices.size(); i++) {\n\t\t\tif (m_pathindices.get(i) == null) {\n\t\t\t\tm_pathindices.set(i,\n\t\t\t\t\t\t(AttributeStreamOfInt32) (AttributeStreamBase\n\t\t\t\t\t\t\t\t.createIndexStream(0)));\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tm_pathindices.add((AttributeStreamOfInt32) (AttributeStreamBase\n\t\t\t\t.createIndexStream(0)));\n\t\treturn (int) (m_pathindices.size() - 1);\n\t}", "language": "java", "code": "int createPathUserIndex() {\n\t\tif (m_pathindices == null)\n\t\t\tm_pathindices = new ArrayList<AttributeStreamOfInt32>(0);\n\t\t// Try getting existing index. Use linear search. We do not expect many\n\t\t// indices to be created.\n\t\tfor (int i = 0; i < m_pathindices.size(); i++) {\n\t\t\tif (m_pathindices.get(i) == null) {\n\t\t\t\tm_pathindices.set(i,\n\t\t\t\t\t\t(AttributeStreamOfInt32) (AttributeStreamBase\n\t\t\t\t\t\t\t\t.createIndexStream(0)));\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tm_pathindices.add((AttributeStreamOfInt32) (AttributeStreamBase\n\t\t\t\t.createIndexStream(0)));\n\t\treturn (int) (m_pathindices.size() - 1);\n\t}", "code_tokens": ["int", "createPathUserIndex", "(", ")", "{", "if", "(", "m_pathindices", "==", "null", ")", "m_pathindices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "0", ")", ";", "// Try getting existing index. Use linear search. We do not expect many", "// indices to be created.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_pathindices", ".", "size", "(", ")", ";", "i", "++", ")", "{", "if", "(", "m_pathindices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_pathindices", ".", "set", "(", "i", ",", "(", "AttributeStreamOfInt32", ")", "(", "AttributeStreamBase", ".", "createIndexStream", "(", "0", ")", ")", ")", ";", "return", "i", ";", "}", "}", "m_pathindices", ".", "add", "(", "(", "AttributeStreamOfInt32", ")", "(", "AttributeStreamBase", ".", "createIndexStream", "(", "0", ")", ")", ")", ";", "return", "(", "int", ")", "(", "m_pathindices", ".", "size", "(", ")", "-", "1", ")", ";", "}"], "docstring": "index allows to store an integer user value on the path.", "docstring_tokens": ["index", "allows", "to", "store", "an", "integer", "user", "value", "on", "the", "path", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1713-L1730", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.movePath", "original_string": "void movePath(int geom, int before_path, int path_to_move) {\n\t\tif (path_to_move == -1)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (before_path == path_to_move)\n\t\t\treturn;\n\n\t\tint next = getNextPath(path_to_move);\n\t\tint prev = getPrevPath(path_to_move);\n\t\tint geom_src = getGeometryFromPath(path_to_move);\n\t\tif (prev == -1) {\n\t\t\tsetFirstPath_(geom_src, next);\n\t\t} else {\n\t\t\tsetNextPath_(prev, next);\n\t\t}\n\n\t\tif (next == -1) {\n\t\t\tsetLastPath_(geom_src, prev);\n\t\t} else {\n\t\t\tsetPrevPath_(next, prev);\n\t\t}\n\n\t\tsetGeometryVertexCount_(geom_src, getPointCount(geom_src)\n\t\t\t\t- getPathSize(path_to_move));\n\t\tsetGeometryPathCount_(geom_src, getPathCount(geom_src) - 1);\n\n\t\tif (before_path == -1)\n\t\t\tprev = getLastPath(geom);\n\t\telse\n\t\t\tprev = getPrevPath(before_path);\n\n\t\tsetPrevPath_(path_to_move, prev);\n\t\tsetNextPath_(path_to_move, before_path);\n\t\tif (before_path == -1)\n\t\t\tsetLastPath_(geom, path_to_move);\n\t\telse\n\t\t\tsetPrevPath_(before_path, path_to_move);\n\t\tif (prev == -1)\n\t\t\tsetFirstPath_(geom, path_to_move);\n\t\telse\n\t\t\tsetNextPath_(prev, path_to_move);\n\t\tsetGeometryVertexCount_(geom, getPointCount(geom)\n\t\t\t\t+ getPathSize(path_to_move));\n\t\tsetGeometryPathCount_(geom, getPathCount(geom) + 1);\n\t\tsetPathGeometry_(path_to_move, geom);\n\t}", "language": "java", "code": "void movePath(int geom, int before_path, int path_to_move) {\n\t\tif (path_to_move == -1)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (before_path == path_to_move)\n\t\t\treturn;\n\n\t\tint next = getNextPath(path_to_move);\n\t\tint prev = getPrevPath(path_to_move);\n\t\tint geom_src = getGeometryFromPath(path_to_move);\n\t\tif (prev == -1) {\n\t\t\tsetFirstPath_(geom_src, next);\n\t\t} else {\n\t\t\tsetNextPath_(prev, next);\n\t\t}\n\n\t\tif (next == -1) {\n\t\t\tsetLastPath_(geom_src, prev);\n\t\t} else {\n\t\t\tsetPrevPath_(next, prev);\n\t\t}\n\n\t\tsetGeometryVertexCount_(geom_src, getPointCount(geom_src)\n\t\t\t\t- getPathSize(path_to_move));\n\t\tsetGeometryPathCount_(geom_src, getPathCount(geom_src) - 1);\n\n\t\tif (before_path == -1)\n\t\t\tprev = getLastPath(geom);\n\t\telse\n\t\t\tprev = getPrevPath(before_path);\n\n\t\tsetPrevPath_(path_to_move, prev);\n\t\tsetNextPath_(path_to_move, before_path);\n\t\tif (before_path == -1)\n\t\t\tsetLastPath_(geom, path_to_move);\n\t\telse\n\t\t\tsetPrevPath_(before_path, path_to_move);\n\t\tif (prev == -1)\n\t\t\tsetFirstPath_(geom, path_to_move);\n\t\telse\n\t\t\tsetNextPath_(prev, path_to_move);\n\t\tsetGeometryVertexCount_(geom, getPointCount(geom)\n\t\t\t\t+ getPathSize(path_to_move));\n\t\tsetGeometryPathCount_(geom, getPathCount(geom) + 1);\n\t\tsetPathGeometry_(path_to_move, geom);\n\t}", "code_tokens": ["void", "movePath", "(", "int", "geom", ",", "int", "before_path", ",", "int", "path_to_move", ")", "{", "if", "(", "path_to_move", "==", "-", "1", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "before_path", "==", "path_to_move", ")", "return", ";", "int", "next", "=", "getNextPath", "(", "path_to_move", ")", ";", "int", "prev", "=", "getPrevPath", "(", "path_to_move", ")", ";", "int", "geom_src", "=", "getGeometryFromPath", "(", "path_to_move", ")", ";", "if", "(", "prev", "==", "-", "1", ")", "{", "setFirstPath_", "(", "geom_src", ",", "next", ")", ";", "}", "else", "{", "setNextPath_", "(", "prev", ",", "next", ")", ";", "}", "if", "(", "next", "==", "-", "1", ")", "{", "setLastPath_", "(", "geom_src", ",", "prev", ")", ";", "}", "else", "{", "setPrevPath_", "(", "next", ",", "prev", ")", ";", "}", "setGeometryVertexCount_", "(", "geom_src", ",", "getPointCount", "(", "geom_src", ")", "-", "getPathSize", "(", "path_to_move", ")", ")", ";", "setGeometryPathCount_", "(", "geom_src", ",", "getPathCount", "(", "geom_src", ")", "-", "1", ")", ";", "if", "(", "before_path", "==", "-", "1", ")", "prev", "=", "getLastPath", "(", "geom", ")", ";", "else", "prev", "=", "getPrevPath", "(", "before_path", ")", ";", "setPrevPath_", "(", "path_to_move", ",", "prev", ")", ";", "setNextPath_", "(", "path_to_move", ",", "before_path", ")", ";", "if", "(", "before_path", "==", "-", "1", ")", "setLastPath_", "(", "geom", ",", "path_to_move", ")", ";", "else", "setPrevPath_", "(", "before_path", ",", "path_to_move", ")", ";", "if", "(", "prev", "==", "-", "1", ")", "setFirstPath_", "(", "geom", ",", "path_to_move", ")", ";", "else", "setNextPath_", "(", "prev", ",", "path_to_move", ")", ";", "setGeometryVertexCount_", "(", "geom", ",", "getPointCount", "(", "geom", ")", "+", "getPathSize", "(", "path_to_move", ")", ")", ";", "setGeometryPathCount_", "(", "geom", ",", "getPathCount", "(", "geom", ")", "+", "1", ")", ";", "setPathGeometry_", "(", "path_to_move", ",", "geom", ")", ";", "}"], "docstring": "before_path can be -1, then the path is moved to the end of the dst_geom.", "docstring_tokens": ["before_path", "can", "be", "-", "1", "then", "the", "path", "is", "moved", "to", "the", "end", "of", "the", "dst_geom", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1740-L1785", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.addVertex", "original_string": "int addVertex(int path, int vertex) {\n\t\tm_vertices.getPointByVal(getVertexIndex(vertex), getHelperPoint_());\n\t\treturn insertVertex_(path, -1, getHelperPoint_());\n\t}", "language": "java", "code": "int addVertex(int path, int vertex) {\n\t\tm_vertices.getPointByVal(getVertexIndex(vertex), getHelperPoint_());\n\t\treturn insertVertex_(path, -1, getHelperPoint_());\n\t}", "code_tokens": ["int", "addVertex", "(", "int", "path", ",", "int", "vertex", ")", "{", "m_vertices", ".", "getPointByVal", "(", "getVertexIndex", "(", "vertex", ")", ",", "getHelperPoint_", "(", ")", ")", ";", "return", "insertVertex_", "(", "path", ",", "-", "1", ",", "getHelperPoint_", "(", ")", ")", ";", "}"], "docstring": "Returns new vertex handle.", "docstring_tokens": ["Returns", "new", "vertex", "handle", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1789-L1792", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.removeVertex", "original_string": "int removeVertex(int vertex, boolean b_left_segment) {\n\t\tint path = getPathFromVertex(vertex);\n\t\tint prev = getPrevVertex(vertex);\n\t\tint next = getNextVertex(vertex);\n\t\tif (prev != -1)\n\t\t\tsetNextVertex_(prev, next);\n\n\t\tint path_size = getPathSize(path);\n\n\t\tif (vertex == getFirstVertex(path)) {\n\t\t\tsetFirstVertex_(path, path_size > 1 ? next : -1);\n\t\t}\n\n\t\tif (next != -1)\n\t\t\tsetPrevVertex_(next, prev);\n\n\t\tif (vertex == getLastVertex(path)) {\n\t\t\tsetLastVertex_(path, path_size > 1 ? prev : -1);\n\t\t}\n\n\t\tif (prev != -1 && next != -1) {\n\t\t\tint vindex_prev = getVertexIndex(prev);\n\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\tif (b_left_segment) {\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_prev);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\tm_vertices.getXY(vindex_next, pt);\n\t\t\t\t\tseg.setEndXY(pt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint vindex_erased = getVertexIndex(vertex);\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_erased);\n\t\t\t\tsetSegmentToIndex_(vindex_prev, seg);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = m_vertices.getXY(vindex_prev);\n\t\t\t\t\tseg.setStartXY(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsetPathSize_(path, path_size - 1);\n\t\tint geometry = getGeometryFromPath(path);\n\t\tsetGeometryVertexCount_(geometry, getPointCount(geometry) - 1);\n\t\tfreeVertex_(vertex);\n\t\treturn next;\n\t}", "language": "java", "code": "int removeVertex(int vertex, boolean b_left_segment) {\n\t\tint path = getPathFromVertex(vertex);\n\t\tint prev = getPrevVertex(vertex);\n\t\tint next = getNextVertex(vertex);\n\t\tif (prev != -1)\n\t\t\tsetNextVertex_(prev, next);\n\n\t\tint path_size = getPathSize(path);\n\n\t\tif (vertex == getFirstVertex(path)) {\n\t\t\tsetFirstVertex_(path, path_size > 1 ? next : -1);\n\t\t}\n\n\t\tif (next != -1)\n\t\t\tsetPrevVertex_(next, prev);\n\n\t\tif (vertex == getLastVertex(path)) {\n\t\t\tsetLastVertex_(path, path_size > 1 ? prev : -1);\n\t\t}\n\n\t\tif (prev != -1 && next != -1) {\n\t\t\tint vindex_prev = getVertexIndex(prev);\n\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\tif (b_left_segment) {\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_prev);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\tm_vertices.getXY(vindex_next, pt);\n\t\t\t\t\tseg.setEndXY(pt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint vindex_erased = getVertexIndex(vertex);\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_erased);\n\t\t\t\tsetSegmentToIndex_(vindex_prev, seg);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = m_vertices.getXY(vindex_prev);\n\t\t\t\t\tseg.setStartXY(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsetPathSize_(path, path_size - 1);\n\t\tint geometry = getGeometryFromPath(path);\n\t\tsetGeometryVertexCount_(geometry, getPointCount(geometry) - 1);\n\t\tfreeVertex_(vertex);\n\t\treturn next;\n\t}", "code_tokens": ["int", "removeVertex", "(", "int", "vertex", ",", "boolean", "b_left_segment", ")", "{", "int", "path", "=", "getPathFromVertex", "(", "vertex", ")", ";", "int", "prev", "=", "getPrevVertex", "(", "vertex", ")", ";", "int", "next", "=", "getNextVertex", "(", "vertex", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "setNextVertex_", "(", "prev", ",", "next", ")", ";", "int", "path_size", "=", "getPathSize", "(", "path", ")", ";", "if", "(", "vertex", "==", "getFirstVertex", "(", "path", ")", ")", "{", "setFirstVertex_", "(", "path", ",", "path_size", ">", "1", "?", "next", ":", "-", "1", ")", ";", "}", "if", "(", "next", "!=", "-", "1", ")", "setPrevVertex_", "(", "next", ",", "prev", ")", ";", "if", "(", "vertex", "==", "getLastVertex", "(", "path", ")", ")", "{", "setLastVertex_", "(", "path", ",", "path_size", ">", "1", "?", "prev", ":", "-", "1", ")", ";", "}", "if", "(", "prev", "!=", "-", "1", "&&", "next", "!=", "-", "1", ")", "{", "int", "vindex_prev", "=", "getVertexIndex", "(", "prev", ")", ";", "int", "vindex_next", "=", "getVertexIndex", "(", "next", ")", ";", "if", "(", "b_left_segment", ")", "{", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex_prev", ")", ";", "if", "(", "seg", "!=", "null", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "m_vertices", ".", "getXY", "(", "vindex_next", ",", "pt", ")", ";", "seg", ".", "setEndXY", "(", "pt", ")", ";", "}", "}", "else", "{", "int", "vindex_erased", "=", "getVertexIndex", "(", "vertex", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex_erased", ")", ";", "setSegmentToIndex_", "(", "vindex_prev", ",", "seg", ")", ";", "if", "(", "seg", "!=", "null", ")", "{", "Point2D", "pt", "=", "m_vertices", ".", "getXY", "(", "vindex_prev", ")", ";", "seg", ".", "setStartXY", "(", "pt", ")", ";", "}", "}", "}", "setPathSize_", "(", "path", ",", "path_size", "-", "1", ")", ";", "int", "geometry", "=", "getGeometryFromPath", "(", "path", ")", ";", "setGeometryVertexCount_", "(", "geometry", ",", "getPointCount", "(", "geometry", ")", "-", "1", ")", ";", "freeVertex_", "(", "vertex", ")", ";", "return", "next", ";", "}"], "docstring": "reconnect. Returns next vertex after erased one.", "docstring_tokens": ["reconnect", ".", "Returns", "next", "vertex", "after", "erased", "one", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L1796-L1842", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.queryVertexIterator", "original_string": "VertexIterator queryVertexIterator(boolean b_skip_multi_points) {\n\t\tint geometry = -1;\n\t\tint path = -1;\n\t\tint vertex = -1;\n\t\tint first_vertex = -1;\n\t\tint index = 0;\n\t\tboolean bFound = false;\n\n\t\tfor (geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry)) {\n\t\t\tif (b_skip_multi_points\n\t\t\t\t\t&& !Geometry.isMultiPath(getGeometryType(geometry)))\n\t\t\t\tcontinue;\n\n\t\t\tfor (path = getFirstPath(geometry); path != -1; path = getNextPath(path)) {\n\t\t\t\tvertex = getFirstVertex(path);\n\t\t\t\tfirst_vertex = vertex;\n\t\t\t\tindex = 0;\n\t\t\t\tif (vertex == -1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbFound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (bFound)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn VertexIterator.create_(this, geometry, path, vertex,\n\t\t\t\tfirst_vertex, index, b_skip_multi_points);\n\t}", "language": "java", "code": "VertexIterator queryVertexIterator(boolean b_skip_multi_points) {\n\t\tint geometry = -1;\n\t\tint path = -1;\n\t\tint vertex = -1;\n\t\tint first_vertex = -1;\n\t\tint index = 0;\n\t\tboolean bFound = false;\n\n\t\tfor (geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry)) {\n\t\t\tif (b_skip_multi_points\n\t\t\t\t\t&& !Geometry.isMultiPath(getGeometryType(geometry)))\n\t\t\t\tcontinue;\n\n\t\t\tfor (path = getFirstPath(geometry); path != -1; path = getNextPath(path)) {\n\t\t\t\tvertex = getFirstVertex(path);\n\t\t\t\tfirst_vertex = vertex;\n\t\t\t\tindex = 0;\n\t\t\t\tif (vertex == -1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbFound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (bFound)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn VertexIterator.create_(this, geometry, path, vertex,\n\t\t\t\tfirst_vertex, index, b_skip_multi_points);\n\t}", "code_tokens": ["VertexIterator", "queryVertexIterator", "(", "boolean", "b_skip_multi_points", ")", "{", "int", "geometry", "=", "-", "1", ";", "int", "path", "=", "-", "1", ";", "int", "vertex", "=", "-", "1", ";", "int", "first_vertex", "=", "-", "1", ";", "int", "index", "=", "0", ";", "boolean", "bFound", "=", "false", ";", "for", "(", "geometry", "=", "getFirstGeometry", "(", ")", ";", "geometry", "!=", "-", "1", ";", "geometry", "=", "getNextGeometry", "(", "geometry", ")", ")", "{", "if", "(", "b_skip_multi_points", "&&", "!", "Geometry", ".", "isMultiPath", "(", "getGeometryType", "(", "geometry", ")", ")", ")", "continue", ";", "for", "(", "path", "=", "getFirstPath", "(", "geometry", ")", ";", "path", "!=", "-", "1", ";", "path", "=", "getNextPath", "(", "path", ")", ")", "{", "vertex", "=", "getFirstVertex", "(", "path", ")", ";", "first_vertex", "=", "vertex", ";", "index", "=", "0", ";", "if", "(", "vertex", "==", "-", "1", ")", "continue", ";", "bFound", "=", "true", ";", "break", ";", "}", "if", "(", "bFound", ")", "break", ";", "}", "return", "VertexIterator", ".", "create_", "(", "this", ",", "geometry", ",", "path", ",", "vertex", ",", "first_vertex", ",", "index", ",", "b_skip_multi_points", ")", ";", "}"], "docstring": "vertices", "docstring_tokens": ["vertices"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L2005-L2035", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.applyTransformation", "original_string": "void applyTransformation(Transformation2D transform) {\n\t\tm_vertices_mp.applyTransformation(transform);\n\t\tif (m_segments != null) {\n\t\t\tfor (int i = 0, n = m_segments.size(); i < n; i++) {\n\t\t\t\tif (m_segments.get(i) != null) {\n\t\t\t\t\tm_segments.get(i).applyTransformation(transform);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "void applyTransformation(Transformation2D transform) {\n\t\tm_vertices_mp.applyTransformation(transform);\n\t\tif (m_segments != null) {\n\t\t\tfor (int i = 0, n = m_segments.size(); i < n; i++) {\n\t\t\t\tif (m_segments.get(i) != null) {\n\t\t\t\t\tm_segments.get(i).applyTransformation(transform);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["void", "applyTransformation", "(", "Transformation2D", "transform", ")", "{", "m_vertices_mp", ".", "applyTransformation", "(", "transform", ")", ";", "if", "(", "m_segments", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_segments", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "m_segments", ".", "get", "(", "i", ")", "!=", "null", ")", "{", "m_segments", ".", "get", "(", "i", ")", ".", "applyTransformation", "(", "transform", ")", ";", "}", "}", "}", "}"], "docstring": "Applies affine transformation", "docstring_tokens": ["Applies", "affine", "transformation"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L2038-L2047", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.removeVertexInternal_", "original_string": "int removeVertexInternal_(int vertex, boolean b_left_segment) {\n\t\tint prev = getPrevVertex(vertex);\n\t\tint next = getNextVertex(vertex);\n\t\tif (prev != -1)\n\t\t\tsetNextVertex_(prev, next);\n\n\t\tif (next != -1)\n\t\t\tsetPrevVertex_(next, prev);\n\n\t\tif (prev != -1 && next != -1) {\n\t\t\tint vindex_prev = getVertexIndex(prev);\n\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\tif (b_left_segment) {\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_prev);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\tm_vertices.getXY(vindex_next, pt);\n\t\t\t\t\tseg.setEndXY(pt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint vindex_erased = getVertexIndex(vertex);\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_erased);\n\t\t\t\tsetSegmentToIndex_(vindex_prev, seg);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\tm_vertices.getXY(vindex_prev, pt);\n\t\t\t\t\tseg.setStartXY(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfreeVertex_(vertex);\n\t\treturn next;\n\t}", "language": "java", "code": "int removeVertexInternal_(int vertex, boolean b_left_segment) {\n\t\tint prev = getPrevVertex(vertex);\n\t\tint next = getNextVertex(vertex);\n\t\tif (prev != -1)\n\t\t\tsetNextVertex_(prev, next);\n\n\t\tif (next != -1)\n\t\t\tsetPrevVertex_(next, prev);\n\n\t\tif (prev != -1 && next != -1) {\n\t\t\tint vindex_prev = getVertexIndex(prev);\n\t\t\tint vindex_next = getVertexIndex(next);\n\t\t\tif (b_left_segment) {\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_prev);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\tm_vertices.getXY(vindex_next, pt);\n\t\t\t\t\tseg.setEndXY(pt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint vindex_erased = getVertexIndex(vertex);\n\t\t\t\tSegment seg = getSegmentFromIndex_(vindex_erased);\n\t\t\t\tsetSegmentToIndex_(vindex_prev, seg);\n\t\t\t\tif (seg != null) {\n\t\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t\tm_vertices.getXY(vindex_prev, pt);\n\t\t\t\t\tseg.setStartXY(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfreeVertex_(vertex);\n\t\treturn next;\n\t}", "code_tokens": ["int", "removeVertexInternal_", "(", "int", "vertex", ",", "boolean", "b_left_segment", ")", "{", "int", "prev", "=", "getPrevVertex", "(", "vertex", ")", ";", "int", "next", "=", "getNextVertex", "(", "vertex", ")", ";", "if", "(", "prev", "!=", "-", "1", ")", "setNextVertex_", "(", "prev", ",", "next", ")", ";", "if", "(", "next", "!=", "-", "1", ")", "setPrevVertex_", "(", "next", ",", "prev", ")", ";", "if", "(", "prev", "!=", "-", "1", "&&", "next", "!=", "-", "1", ")", "{", "int", "vindex_prev", "=", "getVertexIndex", "(", "prev", ")", ";", "int", "vindex_next", "=", "getVertexIndex", "(", "next", ")", ";", "if", "(", "b_left_segment", ")", "{", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex_prev", ")", ";", "if", "(", "seg", "!=", "null", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "m_vertices", ".", "getXY", "(", "vindex_next", ",", "pt", ")", ";", "seg", ".", "setEndXY", "(", "pt", ")", ";", "}", "}", "else", "{", "int", "vindex_erased", "=", "getVertexIndex", "(", "vertex", ")", ";", "Segment", "seg", "=", "getSegmentFromIndex_", "(", "vindex_erased", ")", ";", "setSegmentToIndex_", "(", "vindex_prev", ",", "seg", ")", ";", "if", "(", "seg", "!=", "null", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "m_vertices", ".", "getXY", "(", "vindex_prev", ",", "pt", ")", ";", "seg", ".", "setStartXY", "(", "pt", ")", ";", "}", "}", "}", "freeVertex_", "(", "vertex", ")", ";", "return", "next", ";", "}"], "docstring": "void dbg_verify_vertex_counts();", "docstring_tokens": ["void", "dbg_verify_vertex_counts", "()", ";"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L2189-L2221", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.setRingAreaValid_", "original_string": "void setRingAreaValid_(int path, boolean b_yes_no) {\n\t\tint oldflags = getPathFlags_(path);\n\t\tint flags = (oldflags | (int) PathFlags_.ringAreaValid)\n\t\t\t\t- (int) PathFlags_.ringAreaValid;// clear the bit;\n\t\tsetPathFlags_(path, flags\n\t\t\t\t| (b_yes_no ? (int) PathFlags_.ringAreaValid : 0));\n\t}", "language": "java", "code": "void setRingAreaValid_(int path, boolean b_yes_no) {\n\t\tint oldflags = getPathFlags_(path);\n\t\tint flags = (oldflags | (int) PathFlags_.ringAreaValid)\n\t\t\t\t- (int) PathFlags_.ringAreaValid;// clear the bit;\n\t\tsetPathFlags_(path, flags\n\t\t\t\t| (b_yes_no ? (int) PathFlags_.ringAreaValid : 0));\n\t}", "code_tokens": ["void", "setRingAreaValid_", "(", "int", "path", ",", "boolean", "b_yes_no", ")", "{", "int", "oldflags", "=", "getPathFlags_", "(", "path", ")", ";", "int", "flags", "=", "(", "oldflags", "|", "(", "int", ")", "PathFlags_", ".", "ringAreaValid", ")", "-", "(", "int", ")", "PathFlags_", ".", "ringAreaValid", ";", "// clear the bit;", "setPathFlags_", "(", "path", ",", "flags", "|", "(", "b_yes_no", "?", "(", "int", ")", "PathFlags_", ".", "ringAreaValid", ":", "0", ")", ")", ";", "}"], "docstring": "Sets exterior flag", "docstring_tokens": ["Sets", "exterior", "flag"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L2228-L2234", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.sortVerticesSimpleByY_", "original_string": "void sortVerticesSimpleByY_(AttributeStreamOfInt32 points, int begin_,\n\t\t\tint end_) {\n\t\tif (m_bucket_sort == null)\n\t\t\tm_bucket_sort = new BucketSort();\n\t\tm_bucket_sort.sort(points, begin_, end_, new EditShapeBucketSortHelper(\n\t\t\t\tthis));\n\t}", "language": "java", "code": "void sortVerticesSimpleByY_(AttributeStreamOfInt32 points, int begin_,\n\t\t\tint end_) {\n\t\tif (m_bucket_sort == null)\n\t\t\tm_bucket_sort = new BucketSort();\n\t\tm_bucket_sort.sort(points, begin_, end_, new EditShapeBucketSortHelper(\n\t\t\t\tthis));\n\t}", "code_tokens": ["void", "sortVerticesSimpleByY_", "(", "AttributeStreamOfInt32", "points", ",", "int", "begin_", ",", "int", "end_", ")", "{", "if", "(", "m_bucket_sort", "==", "null", ")", "m_bucket_sort", "=", "new", "BucketSort", "(", ")", ";", "m_bucket_sort", ".", "sort", "(", "points", ",", "begin_", ",", "end_", ",", "new", "EditShapeBucketSortHelper", "(", "this", ")", ")", ";", "}"], "docstring": "const Dynamic_array<int>* geoms);", "docstring_tokens": ["const", "Dynamic_array<int", ">", "*", "geoms", ")", ";"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L2285-L2291", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.hasPointFeatures", "original_string": "boolean hasPointFeatures()\n    {\n      for (int geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry))\n      {\n        if (!Geometry.isMultiPath(getGeometryType(geometry)))\n          return true;\n      }\n      return false;\n    }", "language": "java", "code": "boolean hasPointFeatures()\n    {\n      for (int geometry = getFirstGeometry(); geometry != -1; geometry = getNextGeometry(geometry))\n      {\n        if (!Geometry.isMultiPath(getGeometryType(geometry)))\n          return true;\n      }\n      return false;\n    }", "code_tokens": ["boolean", "hasPointFeatures", "(", ")", "{", "for", "(", "int", "geometry", "=", "getFirstGeometry", "(", ")", ";", "geometry", "!=", "-", "1", ";", "geometry", "=", "getNextGeometry", "(", "geometry", ")", ")", "{", "if", "(", "!", "Geometry", ".", "isMultiPath", "(", "getGeometryType", "(", "geometry", ")", ")", ")", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "int estimate_memory_size() const;", "docstring_tokens": ["int", "estimate_memory_size", "()", "const", ";"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L2307-L2315", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTree.java", "func_name": "QuadTree.insert", "original_string": "public int insert(int element, Envelope2D boundingBox, int hintIndex) {\n\t\treturn m_impl.insert(element, boundingBox, hintIndex);\n\t}", "language": "java", "code": "public int insert(int element, Envelope2D boundingBox, int hintIndex) {\n\t\treturn m_impl.insert(element, boundingBox, hintIndex);\n\t}", "code_tokens": ["public", "int", "insert", "(", "int", "element", ",", "Envelope2D", "boundingBox", ",", "int", "hintIndex", ")", "{", "return", "m_impl", ".", "insert", "(", "element", ",", "boundingBox", ",", "hintIndex", ")", ";", "}"], "docstring": "Inserts the element and bounding_box into the QuadTree at the given\nquad_handle. Note that a copy will me made of the input bounding_box.\nNote that this will invalidate any active iterator on the QuadTree.\nReturns an Element_handle corresponding to the element and bounding_box.\n\\param element The element of the Geometry to be inserted.\n\\param bounding_box The bounding_box of the Geometry to be inserted.\n\\param hint_index A handle used as a hint where to place the element. This can\nbe a handle obtained from a previous insertion and is useful on data\nhaving strong locality such as segments of a Polygon.", "docstring_tokens": ["Inserts", "the", "element", "and", "bounding_box", "into", "the", "QuadTree", "at", "the", "given", "quad_handle", ".", "Note", "that", "a", "copy", "will", "me", "made", "of", "the", "input", "bounding_box", ".", "Note", "that", "this", "will", "invalidate", "any", "active", "iterator", "on", "the", "QuadTree", ".", "Returns", "an", "Element_handle", "corresponding", "to", "the", "element", "and", "bounding_box", ".", "\\", "param", "element", "The", "element", "of", "the", "Geometry", "to", "be", "inserted", ".", "\\", "param", "bounding_box", "The", "bounding_box", "of", "the", "Geometry", "to", "be", "inserted", ".", "\\", "param", "hint_index", "A", "handle", "used", "as", "a", "hint", "where", "to", "place", "the", "element", ".", "This", "can", "be", "a", "handle", "obtained", "from", "a", "previous", "insertion", "and", "is", "useful", "on", "data", "having", "strong", "locality", "such", "as", "segments", "of", "a", "Polygon", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTree.java#L136-L138", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTree.java", "func_name": "QuadTree.getIntersectionCount", "original_string": "public int getIntersectionCount(Envelope2D query, double tolerance, int maxCount) {\n\t\treturn m_impl.getIntersectionCount(query, tolerance, maxCount);\n\t}", "language": "java", "code": "public int getIntersectionCount(Envelope2D query, double tolerance, int maxCount) {\n\t\treturn m_impl.getIntersectionCount(query, tolerance, maxCount);\n\t}", "code_tokens": ["public", "int", "getIntersectionCount", "(", "Envelope2D", "query", ",", "double", "tolerance", ",", "int", "maxCount", ")", "{", "return", "m_impl", ".", "getIntersectionCount", "(", "query", ",", "tolerance", ",", "maxCount", ")", ";", "}"], "docstring": "Returns the number of elements in the quad tree that intersect the qiven query. Some elements may be duplicated if the quad tree stores duplicates.\n\\param query The Envelope2D used for the query.\n\\param tolerance The tolerance used for the intersection tests.\n\\param max_count If the intersection count becomes greater than or equal to the max_count, then max_count is returned.", "docstring_tokens": ["Returns", "the", "number", "of", "elements", "in", "the", "quad", "tree", "that", "intersect", "the", "qiven", "query", ".", "Some", "elements", "may", "be", "duplicated", "if", "the", "quad", "tree", "stores", "duplicates", ".", "\\", "param", "query", "The", "Envelope2D", "used", "for", "the", "query", ".", "\\", "param", "tolerance", "The", "tolerance", "used", "for", "the", "intersection", "tests", ".", "\\", "param", "max_count", "If", "the", "intersection", "count", "becomes", "greater", "than", "or", "equal", "to", "the", "max_count", "then", "max_count", "is", "returned", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTree.java#L202-L204", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTree.java", "func_name": "QuadTree.getIterator", "original_string": "public QuadTreeIterator getIterator(Geometry query, double tolerance) {\n\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator(query, tolerance);\n\t\treturn new QuadTreeIterator(iterator, false);\n\t}", "language": "java", "code": "public QuadTreeIterator getIterator(Geometry query, double tolerance) {\n\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator(query, tolerance);\n\t\treturn new QuadTreeIterator(iterator, false);\n\t}", "code_tokens": ["public", "QuadTreeIterator", "getIterator", "(", "Geometry", "query", ",", "double", "tolerance", ")", "{", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "iterator", "=", "m_impl", ".", "getIterator", "(", "query", ",", "tolerance", ")", ";", "return", "new", "QuadTreeIterator", "(", "iterator", ",", "false", ")", ";", "}"], "docstring": "Gets an iterator on the QuadTree. The query will be the Envelope2D that\nbounds the input Geometry. To reuse the existing iterator on the same\nQuadTree but with a new query, use the reset_iterator function on the\nQuadTree_iterator.\n\\param query The Geometry used for the query. If the\nGeometry is a Line segment, then the query will be the segment. Otherwise\nthe query will be the Envelope2D bounding the Geometry.\n\\param tolerance The tolerance used for the intersection tests.", "docstring_tokens": ["Gets", "an", "iterator", "on", "the", "QuadTree", ".", "The", "query", "will", "be", "the", "Envelope2D", "that", "bounds", "the", "input", "Geometry", ".", "To", "reuse", "the", "existing", "iterator", "on", "the", "same", "QuadTree", "but", "with", "a", "new", "query", "use", "the", "reset_iterator", "function", "on", "the", "QuadTree_iterator", ".", "\\", "param", "query", "The", "Geometry", "used", "for", "the", "query", ".", "If", "the", "Geometry", "is", "a", "Line", "segment", "then", "the", "query", "will", "be", "the", "segment", ".", "Otherwise", "the", "query", "will", "be", "the", "Envelope2D", "bounding", "the", "Geometry", ".", "\\", "param", "tolerance", "The", "tolerance", "used", "for", "the", "intersection", "tests", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTree.java#L263-L266", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTree.java", "func_name": "QuadTree.getIterator", "original_string": "public QuadTreeIterator getIterator() {\n\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator();\n\t\treturn new QuadTreeIterator(iterator, false);\n\t}", "language": "java", "code": "public QuadTreeIterator getIterator() {\n\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator();\n\t\treturn new QuadTreeIterator(iterator, false);\n\t}", "code_tokens": ["public", "QuadTreeIterator", "getIterator", "(", ")", "{", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "iterator", "=", "m_impl", ".", "getIterator", "(", ")", ";", "return", "new", "QuadTreeIterator", "(", "iterator", ",", "false", ")", ";", "}"], "docstring": "Gets an iterator on the QuadTree.", "docstring_tokens": ["Gets", "an", "iterator", "on", "the", "QuadTree", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTree.java#L283-L286", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTree.java", "func_name": "QuadTree.getIterator", "original_string": "public QuadTreeIterator getIterator(Geometry query, double tolerance, boolean bSorted) {\n\t\tif (!bSorted) {\n\t\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator(query, tolerance);\n\t\t\treturn new QuadTreeIterator(iterator, false);\n\t\t} else {\n\t\t\tQuadTreeImpl.QuadTreeSortedIteratorImpl iterator = m_impl.getSortedIterator(query, tolerance);\n\t\t\treturn new QuadTreeIterator(iterator, true);\n\t\t}\n\t}", "language": "java", "code": "public QuadTreeIterator getIterator(Geometry query, double tolerance, boolean bSorted) {\n\t\tif (!bSorted) {\n\t\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator(query, tolerance);\n\t\t\treturn new QuadTreeIterator(iterator, false);\n\t\t} else {\n\t\t\tQuadTreeImpl.QuadTreeSortedIteratorImpl iterator = m_impl.getSortedIterator(query, tolerance);\n\t\t\treturn new QuadTreeIterator(iterator, true);\n\t\t}\n\t}", "code_tokens": ["public", "QuadTreeIterator", "getIterator", "(", "Geometry", "query", ",", "double", "tolerance", ",", "boolean", "bSorted", ")", "{", "if", "(", "!", "bSorted", ")", "{", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "iterator", "=", "m_impl", ".", "getIterator", "(", "query", ",", "tolerance", ")", ";", "return", "new", "QuadTreeIterator", "(", "iterator", ",", "false", ")", ";", "}", "else", "{", "QuadTreeImpl", ".", "QuadTreeSortedIteratorImpl", "iterator", "=", "m_impl", ".", "getSortedIterator", "(", "query", ",", "tolerance", ")", ";", "return", "new", "QuadTreeIterator", "(", "iterator", ",", "true", ")", ";", "}", "}"], "docstring": "Gets an iterator on the QuadTree. The query will be the Envelope2D that bounds the input Geometry.\nTo reuse the existing iterator on the same QuadTree but with a new query, use the reset_iterator function on the QuadTree_iterator.\n\\param query The Geometry used for the query. If the Geometry is a Line segment, then the query will be the segment. Otherwise the query will be the Envelope2D bounding the Geometry.\n\\param tolerance The tolerance used for the intersection tests.\n\\param bSorted Put true to iterate the quad tree in the order of the Element_types.", "docstring_tokens": ["Gets", "an", "iterator", "on", "the", "QuadTree", ".", "The", "query", "will", "be", "the", "Envelope2D", "that", "bounds", "the", "input", "Geometry", ".", "To", "reuse", "the", "existing", "iterator", "on", "the", "same", "QuadTree", "but", "with", "a", "new", "query", "use", "the", "reset_iterator", "function", "on", "the", "QuadTree_iterator", ".", "\\", "param", "query", "The", "Geometry", "used", "for", "the", "query", ".", "If", "the", "Geometry", "is", "a", "Line", "segment", "then", "the", "query", "will", "be", "the", "segment", ".", "Otherwise", "the", "query", "will", "be", "the", "Envelope2D", "bounding", "the", "Geometry", ".", "\\", "param", "tolerance", "The", "tolerance", "used", "for", "the", "intersection", "tests", ".", "\\", "param", "bSorted", "Put", "true", "to", "iterate", "the", "quad", "tree", "in", "the", "order", "of", "the", "Element_types", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTree.java#L295-L303", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTree.java", "func_name": "QuadTree.getIterator", "original_string": "public QuadTreeIterator getIterator(boolean bSorted) {\n\t\tif (!bSorted) {\n\t\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator();\n\t\t\treturn new QuadTreeIterator(iterator, false);\n\t\t} else {\n\t\t\tQuadTreeImpl.QuadTreeSortedIteratorImpl iterator = m_impl.getSortedIterator();\n\t\t\treturn new QuadTreeIterator(iterator, true);\n\t\t}\n\t}", "language": "java", "code": "public QuadTreeIterator getIterator(boolean bSorted) {\n\t\tif (!bSorted) {\n\t\t\tQuadTreeImpl.QuadTreeIteratorImpl iterator = m_impl.getIterator();\n\t\t\treturn new QuadTreeIterator(iterator, false);\n\t\t} else {\n\t\t\tQuadTreeImpl.QuadTreeSortedIteratorImpl iterator = m_impl.getSortedIterator();\n\t\t\treturn new QuadTreeIterator(iterator, true);\n\t\t}\n\t}", "code_tokens": ["public", "QuadTreeIterator", "getIterator", "(", "boolean", "bSorted", ")", "{", "if", "(", "!", "bSorted", ")", "{", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "iterator", "=", "m_impl", ".", "getIterator", "(", ")", ";", "return", "new", "QuadTreeIterator", "(", "iterator", ",", "false", ")", ";", "}", "else", "{", "QuadTreeImpl", ".", "QuadTreeSortedIteratorImpl", "iterator", "=", "m_impl", ".", "getSortedIterator", "(", ")", ";", "return", "new", "QuadTreeIterator", "(", "iterator", ",", "true", ")", ";", "}", "}"], "docstring": "Gets an iterator on the QuadTree.\n\\param bSorted Put true to iterate the quad tree in the order of the Element_types.", "docstring_tokens": ["Gets", "an", "iterator", "on", "the", "QuadTree", ".", "\\", "param", "bSorted", "Put", "true", "to", "iterate", "the", "quad", "tree", "in", "the", "order", "of", "the", "Element_types", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTree.java#L326-L334", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Segment.java", "func_name": "Segment.intersect", "original_string": "int intersect(Segment other, Point2D[] intersectionPoints,\n\t\t\tdouble[] paramThis, double[] paramOther, double tolerance) {\n\t\treturn _intersect(other, intersectionPoints, paramThis, paramOther,\n\t\t\t\ttolerance);\n\t}", "language": "java", "code": "int intersect(Segment other, Point2D[] intersectionPoints,\n\t\t\tdouble[] paramThis, double[] paramOther, double tolerance) {\n\t\treturn _intersect(other, intersectionPoints, paramThis, paramOther,\n\t\t\t\ttolerance);\n\t}", "code_tokens": ["int", "intersect", "(", "Segment", "other", ",", "Point2D", "[", "]", "intersectionPoints", ",", "double", "[", "]", "paramThis", ",", "double", "[", "]", "paramOther", ",", "double", "tolerance", ")", "{", "return", "_intersect", "(", "other", ",", "intersectionPoints", ",", "paramThis", ",", "paramOther", ",", "tolerance", ")", ";", "}"], "docstring": "Calculates intersections of this segment with another segment.\n<p>\nNote: This is not a topological operation. It needs to be paired with the\nSegment.Overlap call.\n\n@param other\nThe segment to calculate intersection with.\n@param intersectionPoints\nThe intersection points. Can be NULL.\n@param paramThis\nThe value of the parameter in the intersection points for this\nSegment (between 0 and 1). Can be NULL.\n@param paramOther\nThe value of the parameter in the intersection points for the\nother Segment (between 0 and 1). Can be NULL.\n@param tolerance\nThe tolerance value for the intersection calculation. Can be\n0.\n@return The number of intersection points, 0 when no intersection points\nexist.", "docstring_tokens": ["Calculates", "intersections", "of", "this", "segment", "with", "another", "segment", ".", "<p", ">", "Note", ":", "This", "is", "not", "a", "topological", "operation", ".", "It", "needs", "to", "be", "paired", "with", "the", "Segment", ".", "Overlap", "call", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Segment.java#L348-L352", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Segment.java", "func_name": "Segment.getCoord2D", "original_string": "public Point2D getCoord2D(double t) {\n\t\tPoint2D pt = new Point2D();\n\t\tgetCoord2D(t, pt);\n\t\treturn pt;\n\t}", "language": "java", "code": "public Point2D getCoord2D(double t) {\n\t\tPoint2D pt = new Point2D();\n\t\tgetCoord2D(t, pt);\n\t\treturn pt;\n\t}", "code_tokens": ["public", "Point2D", "getCoord2D", "(", "double", "t", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "getCoord2D", "(", "t", ",", "pt", ")", ";", "return", "pt", ";", "}"], "docstring": "Returns the coordinate of the point on this segment for the given\nparameter value.", "docstring_tokens": ["Returns", "the", "coordinate", "of", "the", "point", "on", "this", "segment", "for", "the", "given", "parameter", "value", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Segment.java#L781-L785", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.estimateMemorySize", "original_string": "@Override\n\tpublic long estimateMemorySize()\n\t{\n\t\tlong size = SIZE_OF_MULTI_PATH_IMPL +\n\t\t\t+ (m_envelope != null ? m_envelope.estimateMemorySize() : 0)\n\t\t\t+ (m_moveToPoint != null ? m_moveToPoint.estimateMemorySize() : 0)\n\t\t\t+ (m_cachedRingAreas2D != null ? m_cachedRingAreas2D.estimateMemorySize() : 0)\n\t\t\t+ (m_paths != null ? m_paths.estimateMemorySize() : 0)\n\t\t\t+ (m_pathFlags != null ? m_pathFlags.estimateMemorySize() : 0)\n\t\t\t+ (m_segmentFlags != null ? m_segmentFlags.estimateMemorySize() : 0)\n\t\t\t+ (m_segmentParamIndex != null ? m_segmentParamIndex.estimateMemorySize() : 0)\n\t\t\t+ (m_segmentParams != null ? m_segmentParams.estimateMemorySize() : 0);\n\n\t\tif (m_vertexAttributes != null) {\n\t\t\tfor (int i = 0; i < m_vertexAttributes.length; i++) {\n\t\t\t\tsize += m_vertexAttributes[i].estimateMemorySize();\n\t\t\t}\n\t\t}\n\n\t\tif (m_accelerators != null) {\n\t\t\tsize += m_accelerators.estimateMemorySize();\n\t\t}\n\n\t\treturn size;\n\t}", "language": "java", "code": "@Override\n\tpublic long estimateMemorySize()\n\t{\n\t\tlong size = SIZE_OF_MULTI_PATH_IMPL +\n\t\t\t+ (m_envelope != null ? m_envelope.estimateMemorySize() : 0)\n\t\t\t+ (m_moveToPoint != null ? m_moveToPoint.estimateMemorySize() : 0)\n\t\t\t+ (m_cachedRingAreas2D != null ? m_cachedRingAreas2D.estimateMemorySize() : 0)\n\t\t\t+ (m_paths != null ? m_paths.estimateMemorySize() : 0)\n\t\t\t+ (m_pathFlags != null ? m_pathFlags.estimateMemorySize() : 0)\n\t\t\t+ (m_segmentFlags != null ? m_segmentFlags.estimateMemorySize() : 0)\n\t\t\t+ (m_segmentParamIndex != null ? m_segmentParamIndex.estimateMemorySize() : 0)\n\t\t\t+ (m_segmentParams != null ? m_segmentParams.estimateMemorySize() : 0);\n\n\t\tif (m_vertexAttributes != null) {\n\t\t\tfor (int i = 0; i < m_vertexAttributes.length; i++) {\n\t\t\t\tsize += m_vertexAttributes[i].estimateMemorySize();\n\t\t\t}\n\t\t}\n\n\t\tif (m_accelerators != null) {\n\t\t\tsize += m_accelerators.estimateMemorySize();\n\t\t}\n\n\t\treturn size;\n\t}", "code_tokens": ["@", "Override", "public", "long", "estimateMemorySize", "(", ")", "{", "long", "size", "=", "SIZE_OF_MULTI_PATH_IMPL", "+", "+", "(", "m_envelope", "!=", "null", "?", "m_envelope", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_moveToPoint", "!=", "null", "?", "m_moveToPoint", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_cachedRingAreas2D", "!=", "null", "?", "m_cachedRingAreas2D", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_paths", "!=", "null", "?", "m_paths", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_pathFlags", "!=", "null", "?", "m_pathFlags", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_segmentFlags", "!=", "null", "?", "m_segmentFlags", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_segmentParamIndex", "!=", "null", "?", "m_segmentParamIndex", ".", "estimateMemorySize", "(", ")", ":", "0", ")", "+", "(", "m_segmentParams", "!=", "null", "?", "m_segmentParams", ".", "estimateMemorySize", "(", ")", ":", "0", ")", ";", "if", "(", "m_vertexAttributes", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_vertexAttributes", ".", "length", ";", "i", "++", ")", "{", "size", "+=", "m_vertexAttributes", "[", "i", "]", ".", "estimateMemorySize", "(", ")", ";", "}", "}", "if", "(", "m_accelerators", "!=", "null", ")", "{", "size", "+=", "m_accelerators", ".", "estimateMemorySize", "(", ")", ";", "}", "return", "size", ";", "}"], "docstring": "XXX;", "docstring_tokens": ["XXX", ";"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L62-L86", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl._initPathStartPoint", "original_string": "protected void _initPathStartPoint() {\n\t\t_touch();\n\t\tif (m_moveToPoint == null)\n\t\t\tm_moveToPoint = new Point(m_description);\n\t\telse\n\t\t\tm_moveToPoint.assignVertexDescription(m_description);\n\t}", "language": "java", "code": "protected void _initPathStartPoint() {\n\t\t_touch();\n\t\tif (m_moveToPoint == null)\n\t\t\tm_moveToPoint = new Point(m_description);\n\t\telse\n\t\t\tm_moveToPoint.assignVertexDescription(m_description);\n\t}", "code_tokens": ["protected", "void", "_initPathStartPoint", "(", ")", "{", "_touch", "(", ")", ";", "if", "(", "m_moveToPoint", "==", "null", ")", "m_moveToPoint", "=", "new", "Point", "(", "m_description", ")", ";", "else", "m_moveToPoint", ".", "assignVertexDescription", "(", "m_description", ")", ";", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L125-L131", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.startPath", "original_string": "public void startPath(double x, double y) {\n\t\tPoint2D endPoint = new Point2D();\n\t\tendPoint.x = x;\n\t\tendPoint.y = y;\n\t\tstartPath(endPoint);\n\t}", "language": "java", "code": "public void startPath(double x, double y) {\n\t\tPoint2D endPoint = new Point2D();\n\t\tendPoint.x = x;\n\t\tendPoint.y = y;\n\t\tstartPath(endPoint);\n\t}", "code_tokens": ["public", "void", "startPath", "(", "double", "x", ",", "double", "y", ")", "{", "Point2D", "endPoint", "=", "new", "Point2D", "(", ")", ";", "endPoint", ".", "x", "=", "x", ";", "endPoint", ".", "y", "=", "y", ";", "startPath", "(", "endPoint", ")", ";", "}"], "docstring": "Starts a new Path at the Point.", "docstring_tokens": ["Starts", "a", "new", "Path", "at", "the", "Point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L137-L142", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.startPath", "original_string": "public void startPath(Point3D point) {\n\t\t_initPathStartPoint();\n\t\tm_moveToPoint.setXYZ(point);\n\t\tassignVertexDescription(m_moveToPoint.getDescription());\n\t\tm_bPathStarted = true;\n\t}", "language": "java", "code": "public void startPath(Point3D point) {\n\t\t_initPathStartPoint();\n\t\tm_moveToPoint.setXYZ(point);\n\t\tassignVertexDescription(m_moveToPoint.getDescription());\n\t\tm_bPathStarted = true;\n\t}", "code_tokens": ["public", "void", "startPath", "(", "Point3D", "point", ")", "{", "_initPathStartPoint", "(", ")", ";", "m_moveToPoint", ".", "setXYZ", "(", "point", ")", ";", "assignVertexDescription", "(", "m_moveToPoint", ".", "getDescription", "(", ")", ")", ";", "m_bPathStarted", "=", "true", ";", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L152-L157", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.startPath", "original_string": "public void startPath(Point point) {\n\t\tif (point.isEmpty())\n\t\t\tthrow new IllegalArgumentException();// throw new\n\t\t\t\t\t\t\t\t\t\t\t\t\t// IllegalArgumentException();\n\n\t\tmergeVertexDescription(point.getDescription());\n\t\t_initPathStartPoint();\n\t\tpoint.copyTo(m_moveToPoint);\n\n\t\t// TODO check MultiPathImpl.cpp comment\n\t\t// \"//the description will be merged later\"\n\t\t// assignVertexDescription(m_moveToPoint.getDescription());\n\t\tm_bPathStarted = true;\n\t}", "language": "java", "code": "public void startPath(Point point) {\n\t\tif (point.isEmpty())\n\t\t\tthrow new IllegalArgumentException();// throw new\n\t\t\t\t\t\t\t\t\t\t\t\t\t// IllegalArgumentException();\n\n\t\tmergeVertexDescription(point.getDescription());\n\t\t_initPathStartPoint();\n\t\tpoint.copyTo(m_moveToPoint);\n\n\t\t// TODO check MultiPathImpl.cpp comment\n\t\t// \"//the description will be merged later\"\n\t\t// assignVertexDescription(m_moveToPoint.getDescription());\n\t\tm_bPathStarted = true;\n\t}", "code_tokens": ["public", "void", "startPath", "(", "Point", "point", ")", "{", "if", "(", "point", ".", "isEmpty", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "// throw new", "// IllegalArgumentException();", "mergeVertexDescription", "(", "point", ".", "getDescription", "(", ")", ")", ";", "_initPathStartPoint", "(", ")", ";", "point", ".", "copyTo", "(", "m_moveToPoint", ")", ";", "// TODO check MultiPathImpl.cpp comment", "// \"//the description will be merged later\"", "// assignVertexDescription(m_moveToPoint.getDescription());", "m_bPathStarted", "=", "true", ";", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L160-L173", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl._beforeNewSegment", "original_string": "protected void _beforeNewSegment(int resizeBy) {\n\t\t// Called for each new segment being added.\n\t\tif (m_bPathStarted) {\n\t\t\t_initPathStartPoint();// make sure the m_movetoPoint exists and has\n\t\t\t\t\t\t\t\t\t// right vertex description\n\n\t\t\t// The new path is started. Need to grow m_parts and m_pathFlags.\n\t\t\tif (m_paths == null) {\n\t\t\t\tm_paths = (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t\t.createIndexStream(2);\n\t\t\t\tm_paths.write(0, 0);\n\t\t\t\tm_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t\t.createByteStream(2, (byte) 0);\n\t\t\t} else {\n\t\t\t\t// _ASSERT(m_parts.size() >= 2);\n\t\t\t\tm_paths.resize(m_paths.size() + 1, 0);\n\t\t\t\tm_pathFlags.resize(m_pathFlags.size() + 1, 0);\n\t\t\t}\n\n\t\t\tif (m_bPolygon) {\n\t\t\t\t// Mark the path as closed\n\t\t\t\tm_pathFlags.write(m_pathFlags.size() - 2,\n\t\t\t\t\t\t(byte) PathFlags.enumClosed);\n\t\t\t}\n\n\t\t\tresizeBy++; // +1 for the StartPath point.\n\t\t}\n\n\t\tint oldcount = m_pointCount;\n\t\tm_paths.write(m_paths.size() - 1, m_pointCount + resizeBy); // The\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// NotifyModified\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// will\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// update\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m_pointCount\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// with this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// value.\n\t\t_resizeImpl(oldcount + resizeBy);\n\t\tm_pathFlags.write(m_paths.size() - 1, (byte) 0);\n\n\t\tif (m_bPathStarted) {\n\t\t\tsetPointByVal(oldcount, m_moveToPoint);// setPoint(oldcount,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// m_moveToPoint); //finally\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set the start point to\n\t\t\t\t\t\t\t\t\t\t\t\t\t// the geometry\n\t\t\tm_bPathStarted = false;\n\t\t}\n\t}", "language": "java", "code": "protected void _beforeNewSegment(int resizeBy) {\n\t\t// Called for each new segment being added.\n\t\tif (m_bPathStarted) {\n\t\t\t_initPathStartPoint();// make sure the m_movetoPoint exists and has\n\t\t\t\t\t\t\t\t\t// right vertex description\n\n\t\t\t// The new path is started. Need to grow m_parts and m_pathFlags.\n\t\t\tif (m_paths == null) {\n\t\t\t\tm_paths = (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t\t.createIndexStream(2);\n\t\t\t\tm_paths.write(0, 0);\n\t\t\t\tm_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t\t.createByteStream(2, (byte) 0);\n\t\t\t} else {\n\t\t\t\t// _ASSERT(m_parts.size() >= 2);\n\t\t\t\tm_paths.resize(m_paths.size() + 1, 0);\n\t\t\t\tm_pathFlags.resize(m_pathFlags.size() + 1, 0);\n\t\t\t}\n\n\t\t\tif (m_bPolygon) {\n\t\t\t\t// Mark the path as closed\n\t\t\t\tm_pathFlags.write(m_pathFlags.size() - 2,\n\t\t\t\t\t\t(byte) PathFlags.enumClosed);\n\t\t\t}\n\n\t\t\tresizeBy++; // +1 for the StartPath point.\n\t\t}\n\n\t\tint oldcount = m_pointCount;\n\t\tm_paths.write(m_paths.size() - 1, m_pointCount + resizeBy); // The\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// NotifyModified\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// will\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// update\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m_pointCount\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// with this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// value.\n\t\t_resizeImpl(oldcount + resizeBy);\n\t\tm_pathFlags.write(m_paths.size() - 1, (byte) 0);\n\n\t\tif (m_bPathStarted) {\n\t\t\tsetPointByVal(oldcount, m_moveToPoint);// setPoint(oldcount,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// m_moveToPoint); //finally\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set the start point to\n\t\t\t\t\t\t\t\t\t\t\t\t\t// the geometry\n\t\t\tm_bPathStarted = false;\n\t\t}\n\t}", "code_tokens": ["protected", "void", "_beforeNewSegment", "(", "int", "resizeBy", ")", "{", "// Called for each new segment being added.", "if", "(", "m_bPathStarted", ")", "{", "_initPathStartPoint", "(", ")", ";", "// make sure the m_movetoPoint exists and has", "// right vertex description", "// The new path is started. Need to grow m_parts and m_pathFlags.", "if", "(", "m_paths", "==", "null", ")", "{", "m_paths", "=", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "2", ")", ";", "m_paths", ".", "write", "(", "0", ",", "0", ")", ";", "m_pathFlags", "=", "(", "AttributeStreamOfInt8", ")", "AttributeStreamBase", ".", "createByteStream", "(", "2", ",", "(", "byte", ")", "0", ")", ";", "}", "else", "{", "// _ASSERT(m_parts.size() >= 2);", "m_paths", ".", "resize", "(", "m_paths", ".", "size", "(", ")", "+", "1", ",", "0", ")", ";", "m_pathFlags", ".", "resize", "(", "m_pathFlags", ".", "size", "(", ")", "+", "1", ",", "0", ")", ";", "}", "if", "(", "m_bPolygon", ")", "{", "// Mark the path as closed", "m_pathFlags", ".", "write", "(", "m_pathFlags", ".", "size", "(", ")", "-", "2", ",", "(", "byte", ")", "PathFlags", ".", "enumClosed", ")", ";", "}", "resizeBy", "++", ";", "// +1 for the StartPath point.", "}", "int", "oldcount", "=", "m_pointCount", ";", "m_paths", ".", "write", "(", "m_paths", ".", "size", "(", ")", "-", "1", ",", "m_pointCount", "+", "resizeBy", ")", ";", "// The", "// NotifyModified", "// will", "// update", "// the", "// m_pointCount", "// with this", "// value.", "_resizeImpl", "(", "oldcount", "+", "resizeBy", ")", ";", "m_pathFlags", ".", "write", "(", "m_paths", ".", "size", "(", ")", "-", "1", ",", "(", "byte", ")", "0", ")", ";", "if", "(", "m_bPathStarted", ")", "{", "setPointByVal", "(", "oldcount", ",", "m_moveToPoint", ")", ";", "// setPoint(oldcount,", "// m_moveToPoint); //finally", "// set the start point to", "// the geometry", "m_bPathStarted", "=", "false", ";", "}", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L176-L223", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl._initSegmentData", "original_string": "protected void _initSegmentData(int sz) {\n\t\tif (m_segmentParamIndex == null) {\n\t\t\tm_segmentFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t.createByteStream(m_pointCount,\n\t\t\t\t\t\t\t(byte) SegmentFlags.enumLineSeg);\n\t\t\tm_segmentParamIndex = (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t.createIndexStream(m_pointCount, -1);\n\t\t}\n\n\t\tint size = m_curveParamwritePoint + sz;\n\t\tif (m_segmentParams == null) {\n\t\t\tm_segmentParams = (AttributeStreamOfDbl) AttributeStreamBase\n\t\t\t\t\t.createAttributeStreamWithPersistence(\n\t\t\t\t\t\t\tVertexDescription.Persistence.enumDouble, size);\n\t\t} else {\n\t\t\tm_segmentParams.resize(size, 0);\n\t\t}\n\t}", "language": "java", "code": "protected void _initSegmentData(int sz) {\n\t\tif (m_segmentParamIndex == null) {\n\t\t\tm_segmentFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t.createByteStream(m_pointCount,\n\t\t\t\t\t\t\t(byte) SegmentFlags.enumLineSeg);\n\t\t\tm_segmentParamIndex = (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t.createIndexStream(m_pointCount, -1);\n\t\t}\n\n\t\tint size = m_curveParamwritePoint + sz;\n\t\tif (m_segmentParams == null) {\n\t\t\tm_segmentParams = (AttributeStreamOfDbl) AttributeStreamBase\n\t\t\t\t\t.createAttributeStreamWithPersistence(\n\t\t\t\t\t\t\tVertexDescription.Persistence.enumDouble, size);\n\t\t} else {\n\t\t\tm_segmentParams.resize(size, 0);\n\t\t}\n\t}", "code_tokens": ["protected", "void", "_initSegmentData", "(", "int", "sz", ")", "{", "if", "(", "m_segmentParamIndex", "==", "null", ")", "{", "m_segmentFlags", "=", "(", "AttributeStreamOfInt8", ")", "AttributeStreamBase", ".", "createByteStream", "(", "m_pointCount", ",", "(", "byte", ")", "SegmentFlags", ".", "enumLineSeg", ")", ";", "m_segmentParamIndex", "=", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "m_pointCount", ",", "-", "1", ")", ";", "}", "int", "size", "=", "m_curveParamwritePoint", "+", "sz", ";", "if", "(", "m_segmentParams", "==", "null", ")", "{", "m_segmentParams", "=", "(", "AttributeStreamOfDbl", ")", "AttributeStreamBase", ".", "createAttributeStreamWithPersistence", "(", "VertexDescription", ".", "Persistence", ".", "enumDouble", ",", "size", ")", ";", "}", "else", "{", "m_segmentParams", ".", "resize", "(", "size", ",", "0", ")", ";", "}", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L264-L281", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.bezierTo", "original_string": "public void bezierTo(Point2D controlPoint1, Point2D controlPoint2,\n\t\t\tPoint2D endPoint) {\n\t\t_beforeNewSegment(1);\n\t\tsetXY(m_pointCount - 1, endPoint);\n\t\tdouble z;\n\t\t_initSegmentData(6);\n\t\tm_pathFlags.setBits(m_pathFlags.size() - 1,\n\t\t\t\t(byte) PathFlags.enumHasNonlinearSegments);\n\t\tm_segmentParamIndex.write(m_pointCount - 2, m_curveParamwritePoint);\n\t\tm_curveParamwritePoint += 6;\n\t\tint curveIndex = m_curveParamwritePoint;\n\t\tm_segmentParams.write(curveIndex, controlPoint1.x);\n\t\tm_segmentParams.write(curveIndex + 1, controlPoint1.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 2, z);\n\t\tm_segmentParams.write(curveIndex + 3, controlPoint2.x);\n\t\tm_segmentParams.write(curveIndex + 4, controlPoint2.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 5, z);\n\t\t_finishBezierTo();\n\t}", "language": "java", "code": "public void bezierTo(Point2D controlPoint1, Point2D controlPoint2,\n\t\t\tPoint2D endPoint) {\n\t\t_beforeNewSegment(1);\n\t\tsetXY(m_pointCount - 1, endPoint);\n\t\tdouble z;\n\t\t_initSegmentData(6);\n\t\tm_pathFlags.setBits(m_pathFlags.size() - 1,\n\t\t\t\t(byte) PathFlags.enumHasNonlinearSegments);\n\t\tm_segmentParamIndex.write(m_pointCount - 2, m_curveParamwritePoint);\n\t\tm_curveParamwritePoint += 6;\n\t\tint curveIndex = m_curveParamwritePoint;\n\t\tm_segmentParams.write(curveIndex, controlPoint1.x);\n\t\tm_segmentParams.write(curveIndex + 1, controlPoint1.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 2, z);\n\t\tm_segmentParams.write(curveIndex + 3, controlPoint2.x);\n\t\tm_segmentParams.write(curveIndex + 4, controlPoint2.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 5, z);\n\t\t_finishBezierTo();\n\t}", "code_tokens": ["public", "void", "bezierTo", "(", "Point2D", "controlPoint1", ",", "Point2D", "controlPoint2", ",", "Point2D", "endPoint", ")", "{", "_beforeNewSegment", "(", "1", ")", ";", "setXY", "(", "m_pointCount", "-", "1", ",", "endPoint", ")", ";", "double", "z", ";", "_initSegmentData", "(", "6", ")", ";", "m_pathFlags", ".", "setBits", "(", "m_pathFlags", ".", "size", "(", ")", "-", "1", ",", "(", "byte", ")", "PathFlags", ".", "enumHasNonlinearSegments", ")", ";", "m_segmentParamIndex", ".", "write", "(", "m_pointCount", "-", "2", ",", "m_curveParamwritePoint", ")", ";", "m_curveParamwritePoint", "+=", "6", ";", "int", "curveIndex", "=", "m_curveParamwritePoint", ";", "m_segmentParams", ".", "write", "(", "curveIndex", ",", "controlPoint1", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "1", ",", "controlPoint1", ".", "y", ")", ";", "z", "=", "0", ";", "// TODO: calculate me.", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "2", ",", "z", ")", ";", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "3", ",", "controlPoint2", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "4", ",", "controlPoint2", ".", "y", ")", ";", "z", "=", "0", ";", "// TODO: calculate me.", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "5", ",", "z", ")", ";", "_finishBezierTo", "(", ")", ";", "}"], "docstring": "adds a Cubic Bezier Segment to the current Path. The Bezier Segment\nconnects the current last Point and the given endPoint.", "docstring_tokens": ["adds", "a", "Cubic", "Bezier", "Segment", "to", "the", "current", "Path", ".", "The", "Bezier", "Segment", "connects", "the", "current", "last", "Point", "and", "the", "given", "endPoint", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L297-L317", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.openPath", "original_string": "public void openPath(int pathIndex) {\n\t\t_touch();\n\t\tif (m_bPolygon)\n\t\t\tthrow GeometryException.GeometryInternalError();// do not call this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// method on a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polygon\n\n\t\tint pathCount = getPathCount();\n\t\tif (pathIndex > getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (m_pathFlags == null)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tm_pathFlags.clearBits(pathIndex, (byte) PathFlags.enumClosed);\n\t}", "language": "java", "code": "public void openPath(int pathIndex) {\n\t\t_touch();\n\t\tif (m_bPolygon)\n\t\t\tthrow GeometryException.GeometryInternalError();// do not call this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// method on a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polygon\n\n\t\tint pathCount = getPathCount();\n\t\tif (pathIndex > getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (m_pathFlags == null)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\tm_pathFlags.clearBits(pathIndex, (byte) PathFlags.enumClosed);\n\t}", "code_tokens": ["public", "void", "openPath", "(", "int", "pathIndex", ")", "{", "_touch", "(", ")", ";", "if", "(", "m_bPolygon", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "// do not call this", "// method on a", "// polygon", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "pathIndex", ">", "getPathCount", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "m_pathFlags", "==", "null", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "m_pathFlags", ".", "clearBits", "(", "pathIndex", ",", "(", "byte", ")", "PathFlags", ".", "enumClosed", ")", ";", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L320-L335", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.openAllPathsAndDuplicateStartVertex", "original_string": "public void openAllPathsAndDuplicateStartVertex() {\n\t\t_touch();\n\t\tif (m_bPolygon)\n\t\t\tthrow GeometryException.GeometryInternalError();// do not call this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// method on a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polygon\n\n\t\tif (m_pathFlags == null)// if (!m_pathFlags)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t_verifyAllStreams();\n\n\t\tint closedPathCount = 0;\n\t\tint pathCount = getPathCount();\n\t\tfor (int i = 0; i < pathCount; i++) {\n\t\t\tif (m_pathFlags.read(i) == (byte) PathFlags.enumClosed) {\n\t\t\t\tclosedPathCount++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tif (m_vertexAttributes[iattr] != null) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(iattr);// int\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// semantics\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m_description._getSemanticsImpl(iattr);\n\t\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tint newSize = comp * (m_pointCount + closedPathCount);\n\t\t\t\tm_vertexAttributes[iattr].resize(newSize);\n\n\t\t\t\tint offset = closedPathCount;\n\t\t\t\tint ipath = pathCount;\n\t\t\t\tfor (int i = m_pointCount - 1; i >= 0; i--) {\n\t\t\t\t\tif (i + 1 == m_paths.read(ipath)) {\n\t\t\t\t\t\tipath--;\n\t\t\t\t\t\tif (m_pathFlags.read(ipath) == (byte) PathFlags.enumClosed) {\n\t\t\t\t\t\t\tint istart = m_paths.read(ipath);\n\n\t\t\t\t\t\t\tfor (int c = 0; c < comp; c++) {\n\t\t\t\t\t\t\t\tdouble v = m_vertexAttributes[iattr]\n\t\t\t\t\t\t\t\t\t\t.readAsDbl(comp * istart + c);\n\t\t\t\t\t\t\t\tm_vertexAttributes[iattr].writeAsDbl(comp\n\t\t\t\t\t\t\t\t\t\t* (offset + i) + c, v);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (--offset == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int c = 0; c < comp; c++) {\n\t\t\t\t\t\tdouble v = m_vertexAttributes[iattr].readAsDbl(comp * i\n\t\t\t\t\t\t\t\t+ c);\n\t\t\t\t\t\tm_vertexAttributes[iattr].writeAsDbl(comp\n\t\t\t\t\t\t\t\t* (offset + i) + c, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint offset = closedPathCount;\n\t\tfor (int ipath = pathCount; ipath > 0; ipath--) {\n\t\t\tint iend = m_paths.read(ipath);\n\t\t\tm_paths.write(ipath, iend + offset);\n\n\t\t\tif (m_pathFlags.read(ipath - 1) == (byte) PathFlags.enumClosed) {\n\t\t\t\tm_pathFlags.clearBits(ipath - 1, (byte) PathFlags.enumClosed);\n\n\t\t\t\tif (--offset == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_pointCount += closedPathCount;\n\t}", "language": "java", "code": "public void openAllPathsAndDuplicateStartVertex() {\n\t\t_touch();\n\t\tif (m_bPolygon)\n\t\t\tthrow GeometryException.GeometryInternalError();// do not call this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// method on a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polygon\n\n\t\tif (m_pathFlags == null)// if (!m_pathFlags)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t_verifyAllStreams();\n\n\t\tint closedPathCount = 0;\n\t\tint pathCount = getPathCount();\n\t\tfor (int i = 0; i < pathCount; i++) {\n\t\t\tif (m_pathFlags.read(i) == (byte) PathFlags.enumClosed) {\n\t\t\t\tclosedPathCount++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tif (m_vertexAttributes[iattr] != null) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(iattr);// int\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// semantics\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m_description._getSemanticsImpl(iattr);\n\t\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tint newSize = comp * (m_pointCount + closedPathCount);\n\t\t\t\tm_vertexAttributes[iattr].resize(newSize);\n\n\t\t\t\tint offset = closedPathCount;\n\t\t\t\tint ipath = pathCount;\n\t\t\t\tfor (int i = m_pointCount - 1; i >= 0; i--) {\n\t\t\t\t\tif (i + 1 == m_paths.read(ipath)) {\n\t\t\t\t\t\tipath--;\n\t\t\t\t\t\tif (m_pathFlags.read(ipath) == (byte) PathFlags.enumClosed) {\n\t\t\t\t\t\t\tint istart = m_paths.read(ipath);\n\n\t\t\t\t\t\t\tfor (int c = 0; c < comp; c++) {\n\t\t\t\t\t\t\t\tdouble v = m_vertexAttributes[iattr]\n\t\t\t\t\t\t\t\t\t\t.readAsDbl(comp * istart + c);\n\t\t\t\t\t\t\t\tm_vertexAttributes[iattr].writeAsDbl(comp\n\t\t\t\t\t\t\t\t\t\t* (offset + i) + c, v);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (--offset == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int c = 0; c < comp; c++) {\n\t\t\t\t\t\tdouble v = m_vertexAttributes[iattr].readAsDbl(comp * i\n\t\t\t\t\t\t\t\t+ c);\n\t\t\t\t\t\tm_vertexAttributes[iattr].writeAsDbl(comp\n\t\t\t\t\t\t\t\t* (offset + i) + c, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint offset = closedPathCount;\n\t\tfor (int ipath = pathCount; ipath > 0; ipath--) {\n\t\t\tint iend = m_paths.read(ipath);\n\t\t\tm_paths.write(ipath, iend + offset);\n\n\t\t\tif (m_pathFlags.read(ipath - 1) == (byte) PathFlags.enumClosed) {\n\t\t\t\tm_pathFlags.clearBits(ipath - 1, (byte) PathFlags.enumClosed);\n\n\t\t\t\tif (--offset == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_pointCount += closedPathCount;\n\t}", "code_tokens": ["public", "void", "openAllPathsAndDuplicateStartVertex", "(", ")", "{", "_touch", "(", ")", ";", "if", "(", "m_bPolygon", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "// do not call this", "// method on a", "// polygon", "if", "(", "m_pathFlags", "==", "null", ")", "// if (!m_pathFlags)", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "int", "closedPathCount", "=", "0", ";", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pathCount", ";", "i", "++", ")", "{", "if", "(", "m_pathFlags", ".", "read", "(", "i", ")", "==", "(", "byte", ")", "PathFlags", ".", "enumClosed", ")", "{", "closedPathCount", "++", ";", "}", "}", "for", "(", "int", "iattr", "=", "0", ",", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "if", "(", "m_vertexAttributes", "[", "iattr", "]", "!=", "null", ")", "{", "int", "semantics", "=", "m_description", ".", "_getSemanticsImpl", "(", "iattr", ")", ";", "// int", "// semantics", "// =", "// m_description._getSemanticsImpl(iattr);", "int", "comp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "int", "newSize", "=", "comp", "*", "(", "m_pointCount", "+", "closedPathCount", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "resize", "(", "newSize", ")", ";", "int", "offset", "=", "closedPathCount", ";", "int", "ipath", "=", "pathCount", ";", "for", "(", "int", "i", "=", "m_pointCount", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "if", "(", "i", "+", "1", "==", "m_paths", ".", "read", "(", "ipath", ")", ")", "{", "ipath", "--", ";", "if", "(", "m_pathFlags", ".", "read", "(", "ipath", ")", "==", "(", "byte", ")", "PathFlags", ".", "enumClosed", ")", "{", "int", "istart", "=", "m_paths", ".", "read", "(", "ipath", ")", ";", "for", "(", "int", "c", "=", "0", ";", "c", "<", "comp", ";", "c", "++", ")", "{", "double", "v", "=", "m_vertexAttributes", "[", "iattr", "]", ".", "readAsDbl", "(", "comp", "*", "istart", "+", "c", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "writeAsDbl", "(", "comp", "*", "(", "offset", "+", "i", ")", "+", "c", ",", "v", ")", ";", "}", "if", "(", "--", "offset", "==", "0", ")", "break", ";", "}", "}", "for", "(", "int", "c", "=", "0", ";", "c", "<", "comp", ";", "c", "++", ")", "{", "double", "v", "=", "m_vertexAttributes", "[", "iattr", "]", ".", "readAsDbl", "(", "comp", "*", "i", "+", "c", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "writeAsDbl", "(", "comp", "*", "(", "offset", "+", "i", ")", "+", "c", ",", "v", ")", ";", "}", "}", "}", "}", "int", "offset", "=", "closedPathCount", ";", "for", "(", "int", "ipath", "=", "pathCount", ";", "ipath", ">", "0", ";", "ipath", "--", ")", "{", "int", "iend", "=", "m_paths", ".", "read", "(", "ipath", ")", ";", "m_paths", ".", "write", "(", "ipath", ",", "iend", "+", "offset", ")", ";", "if", "(", "m_pathFlags", ".", "read", "(", "ipath", "-", "1", ")", "==", "(", "byte", ")", "PathFlags", ".", "enumClosed", ")", "{", "m_pathFlags", ".", "clearBits", "(", "ipath", "-", "1", ",", "(", "byte", ")", "PathFlags", ".", "enumClosed", ")", ";", "if", "(", "--", "offset", "==", "0", ")", "{", "break", ";", "}", "}", "}", "m_pointCount", "+=", "closedPathCount", ";", "}"], "docstring": "Major Changes on 16th of January", "docstring_tokens": ["Major", "Changes", "on", "16th", "of", "January"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L382-L457", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.closeAllPaths", "original_string": "public void closeAllPaths() {\n\t\t_touch();\n\t\tif (m_bPolygon || isEmptyImpl())\n\t\t\treturn;\n\n\t\tm_bPathStarted = false;\n\n\t\tfor (int ipath = 0, npart = m_paths.size() - 1; ipath < npart; ipath++) {\n\t\t\tif (isClosedPath(ipath))\n\t\t\t\tcontinue;\n\n\t\t\tbyte pf = m_pathFlags.read(ipath);\n\t\t\tm_pathFlags.write(ipath, (byte) (pf | PathFlags.enumClosed));\n\t\t\t// if (m_segmentFlags)\n\t\t\t// {\n\t\t\t// m_segmentFlags.write(m_pointCount - 1,\n\t\t\t// (byte)SegmentFlags.LineSeg));\n\t\t\t// m_segmentParamIndex.write(m_pointCount - 1, -1);\n\t\t\t// }\n\t\t}\n\t}", "language": "java", "code": "public void closeAllPaths() {\n\t\t_touch();\n\t\tif (m_bPolygon || isEmptyImpl())\n\t\t\treturn;\n\n\t\tm_bPathStarted = false;\n\n\t\tfor (int ipath = 0, npart = m_paths.size() - 1; ipath < npart; ipath++) {\n\t\t\tif (isClosedPath(ipath))\n\t\t\t\tcontinue;\n\n\t\t\tbyte pf = m_pathFlags.read(ipath);\n\t\t\tm_pathFlags.write(ipath, (byte) (pf | PathFlags.enumClosed));\n\t\t\t// if (m_segmentFlags)\n\t\t\t// {\n\t\t\t// m_segmentFlags.write(m_pointCount - 1,\n\t\t\t// (byte)SegmentFlags.LineSeg));\n\t\t\t// m_segmentParamIndex.write(m_pointCount - 1, -1);\n\t\t\t// }\n\t\t}\n\t}", "code_tokens": ["public", "void", "closeAllPaths", "(", ")", "{", "_touch", "(", ")", ";", "if", "(", "m_bPolygon", "||", "isEmptyImpl", "(", ")", ")", "return", ";", "m_bPathStarted", "=", "false", ";", "for", "(", "int", "ipath", "=", "0", ",", "npart", "=", "m_paths", ".", "size", "(", ")", "-", "1", ";", "ipath", "<", "npart", ";", "ipath", "++", ")", "{", "if", "(", "isClosedPath", "(", "ipath", ")", ")", "continue", ";", "byte", "pf", "=", "m_pathFlags", ".", "read", "(", "ipath", ")", ";", "m_pathFlags", ".", "write", "(", "ipath", ",", "(", "byte", ")", "(", "pf", "|", "PathFlags", ".", "enumClosed", ")", ")", ";", "// if (m_segmentFlags)", "// {", "// m_segmentFlags.write(m_pointCount - 1,", "// (byte)SegmentFlags.LineSeg));", "// m_segmentParamIndex.write(m_pointCount - 1, -1);", "// }", "}", "}"], "docstring": "Closes all open curves by adding an implicit line segment from the end\npoint to the start point.", "docstring_tokens": ["Closes", "all", "open", "curves", "by", "adding", "an", "implicit", "line", "segment", "from", "the", "end", "point", "to", "the", "start", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L483-L503", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.closePathWithBezier", "original_string": "public void closePathWithBezier(Point2D controlPoint1, Point2D controlPoint2) {\n\t\t_touch();\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"Invalid call. This operation cannot be performed on an empty geometry.\");\n\n\t\tm_bPathStarted = false;\n\n\t\tint pathIndex = m_paths.size() - 2;\n\t\tbyte pf = m_pathFlags.read(pathIndex);\n\t\tm_pathFlags\n\t\t\t\t.write(pathIndex,\n\t\t\t\t\t\t(byte) (pf | PathFlags.enumClosed | PathFlags.enumHasNonlinearSegments));\n\t\t_initSegmentData(6);\n\n\t\tbyte oldType = m_segmentFlags\n\t\t\t\t.read((byte) ((m_pointCount - 1) & SegmentFlags.enumSegmentMask));\n\t\tm_segmentFlags.write(m_pointCount - 1,\n\t\t\t\t(byte) (SegmentFlags.enumBezierSeg));\n\n\t\tint curveIndex = m_curveParamwritePoint;\n\t\tif (getSegmentDataSize(oldType) < getSegmentDataSize((byte) SegmentFlags.enumBezierSeg)) {\n\t\t\tm_segmentParamIndex.write(m_pointCount - 1, m_curveParamwritePoint);\n\t\t\tm_curveParamwritePoint += 6;\n\t\t} else {\n\t\t\t// there was a closing bezier curve or an arc here. We can reuse the\n\t\t\t// storage.\n\t\t\tcurveIndex = m_segmentParamIndex.read(m_pointCount - 1);\n\t\t}\n\n\t\tdouble z;\n\t\tm_segmentParams.write(curveIndex, controlPoint1.x);\n\t\tm_segmentParams.write(curveIndex + 1, controlPoint1.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 2, z);\n\n\t\tm_segmentParams.write(curveIndex + 3, controlPoint2.x);\n\t\tm_segmentParams.write(curveIndex + 4, controlPoint2.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 5, z);\n\t}", "language": "java", "code": "public void closePathWithBezier(Point2D controlPoint1, Point2D controlPoint2) {\n\t\t_touch();\n\t\tif (isEmptyImpl())\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"Invalid call. This operation cannot be performed on an empty geometry.\");\n\n\t\tm_bPathStarted = false;\n\n\t\tint pathIndex = m_paths.size() - 2;\n\t\tbyte pf = m_pathFlags.read(pathIndex);\n\t\tm_pathFlags\n\t\t\t\t.write(pathIndex,\n\t\t\t\t\t\t(byte) (pf | PathFlags.enumClosed | PathFlags.enumHasNonlinearSegments));\n\t\t_initSegmentData(6);\n\n\t\tbyte oldType = m_segmentFlags\n\t\t\t\t.read((byte) ((m_pointCount - 1) & SegmentFlags.enumSegmentMask));\n\t\tm_segmentFlags.write(m_pointCount - 1,\n\t\t\t\t(byte) (SegmentFlags.enumBezierSeg));\n\n\t\tint curveIndex = m_curveParamwritePoint;\n\t\tif (getSegmentDataSize(oldType) < getSegmentDataSize((byte) SegmentFlags.enumBezierSeg)) {\n\t\t\tm_segmentParamIndex.write(m_pointCount - 1, m_curveParamwritePoint);\n\t\t\tm_curveParamwritePoint += 6;\n\t\t} else {\n\t\t\t// there was a closing bezier curve or an arc here. We can reuse the\n\t\t\t// storage.\n\t\t\tcurveIndex = m_segmentParamIndex.read(m_pointCount - 1);\n\t\t}\n\n\t\tdouble z;\n\t\tm_segmentParams.write(curveIndex, controlPoint1.x);\n\t\tm_segmentParams.write(curveIndex + 1, controlPoint1.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 2, z);\n\n\t\tm_segmentParams.write(curveIndex + 3, controlPoint2.x);\n\t\tm_segmentParams.write(curveIndex + 4, controlPoint2.y);\n\t\tz = 0;// TODO: calculate me.\n\t\tm_segmentParams.write(curveIndex + 5, z);\n\t}", "code_tokens": ["public", "void", "closePathWithBezier", "(", "Point2D", "controlPoint1", ",", "Point2D", "controlPoint2", ")", "{", "_touch", "(", ")", ";", "if", "(", "isEmptyImpl", "(", ")", ")", "throw", "new", "GeometryException", "(", "\"Invalid call. This operation cannot be performed on an empty geometry.\"", ")", ";", "m_bPathStarted", "=", "false", ";", "int", "pathIndex", "=", "m_paths", ".", "size", "(", ")", "-", "2", ";", "byte", "pf", "=", "m_pathFlags", ".", "read", "(", "pathIndex", ")", ";", "m_pathFlags", ".", "write", "(", "pathIndex", ",", "(", "byte", ")", "(", "pf", "|", "PathFlags", ".", "enumClosed", "|", "PathFlags", ".", "enumHasNonlinearSegments", ")", ")", ";", "_initSegmentData", "(", "6", ")", ";", "byte", "oldType", "=", "m_segmentFlags", ".", "read", "(", "(", "byte", ")", "(", "(", "m_pointCount", "-", "1", ")", "&", "SegmentFlags", ".", "enumSegmentMask", ")", ")", ";", "m_segmentFlags", ".", "write", "(", "m_pointCount", "-", "1", ",", "(", "byte", ")", "(", "SegmentFlags", ".", "enumBezierSeg", ")", ")", ";", "int", "curveIndex", "=", "m_curveParamwritePoint", ";", "if", "(", "getSegmentDataSize", "(", "oldType", ")", "<", "getSegmentDataSize", "(", "(", "byte", ")", "SegmentFlags", ".", "enumBezierSeg", ")", ")", "{", "m_segmentParamIndex", ".", "write", "(", "m_pointCount", "-", "1", ",", "m_curveParamwritePoint", ")", ";", "m_curveParamwritePoint", "+=", "6", ";", "}", "else", "{", "// there was a closing bezier curve or an arc here. We can reuse the", "// storage.", "curveIndex", "=", "m_segmentParamIndex", ".", "read", "(", "m_pointCount", "-", "1", ")", ";", "}", "double", "z", ";", "m_segmentParams", ".", "write", "(", "curveIndex", ",", "controlPoint1", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "1", ",", "controlPoint1", ".", "y", ")", ";", "z", "=", "0", ";", "// TODO: calculate me.", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "2", ",", "z", ")", ";", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "3", ",", "controlPoint2", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "4", ",", "controlPoint2", ".", "y", ")", ";", "z", "=", "0", ";", "// TODO: calculate me.", "m_segmentParams", ".", "write", "(", "curveIndex", "+", "5", ",", "z", ")", ";", "}"], "docstring": "Closes last path of the MultiPathImpl with the Bezier Segment.\n\nThe start point of the Bezier is the last point of the path and the last\npoint of the bezier is the first point of the path.", "docstring_tokens": ["Closes", "last", "path", "of", "the", "MultiPathImpl", "with", "the", "Bezier", "Segment", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L524-L564", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.addSegment", "original_string": "public void addSegment(Segment segment, boolean bStartNewPath) {\n\t\tmergeVertexDescription(segment.getDescription());\n\t\tif (segment.getType() == Type.Line) {\n\t\t\tPoint point = new Point();\n\t\t\tif (bStartNewPath || isEmpty()) {\n\t\t\t\tsegment.queryStart(point);\n\t\t\t\tstartPath(point);\n\t\t\t}\n\n\t\t\tsegment.queryEnd(point);\n\t\t\tlineTo(point);\n\t\t} else {\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\t}", "language": "java", "code": "public void addSegment(Segment segment, boolean bStartNewPath) {\n\t\tmergeVertexDescription(segment.getDescription());\n\t\tif (segment.getType() == Type.Line) {\n\t\t\tPoint point = new Point();\n\t\t\tif (bStartNewPath || isEmpty()) {\n\t\t\t\tsegment.queryStart(point);\n\t\t\t\tstartPath(point);\n\t\t\t}\n\n\t\t\tsegment.queryEnd(point);\n\t\t\tlineTo(point);\n\t\t} else {\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\t}", "code_tokens": ["public", "void", "addSegment", "(", "Segment", "segment", ",", "boolean", "bStartNewPath", ")", "{", "mergeVertexDescription", "(", "segment", ".", "getDescription", "(", ")", ")", ";", "if", "(", "segment", ".", "getType", "(", ")", "==", "Type", ".", "Line", ")", "{", "Point", "point", "=", "new", "Point", "(", ")", ";", "if", "(", "bStartNewPath", "||", "isEmpty", "(", ")", ")", "{", "segment", ".", "queryStart", "(", "point", ")", ";", "startPath", "(", "point", ")", ";", "}", "segment", ".", "queryEnd", "(", "point", ")", ";", "lineTo", "(", "point", ")", ";", "}", "else", "{", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L599-L613", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.addEnvelope", "original_string": "public void addEnvelope(Envelope2D envSrc, boolean bReverse) {\n\t\tboolean bWasEmpty = m_pointCount == 0;\n\n\t\tstartPath(envSrc.xmin, envSrc.ymin);\n\t\tif (bReverse) {\n\t\t\tlineTo(envSrc.xmax, envSrc.ymin);\n\t\t\tlineTo(envSrc.xmax, envSrc.ymax);\n\t\t\tlineTo(envSrc.xmin, envSrc.ymax);\n\t\t} else {\n\t\t\tlineTo(envSrc.xmin, envSrc.ymax);\n\t\t\tlineTo(envSrc.xmax, envSrc.ymax);\n\t\t\tlineTo(envSrc.xmax, envSrc.ymin);\n\t\t}\n\n\t\tclosePathWithLine();\n\t\tm_bPathStarted = false;\n\n\t\tif (bWasEmpty && !bReverse) {\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we no(sic?)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the polypath\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// is envelope\n\t\t}\n\t}", "language": "java", "code": "public void addEnvelope(Envelope2D envSrc, boolean bReverse) {\n\t\tboolean bWasEmpty = m_pointCount == 0;\n\n\t\tstartPath(envSrc.xmin, envSrc.ymin);\n\t\tif (bReverse) {\n\t\t\tlineTo(envSrc.xmax, envSrc.ymin);\n\t\t\tlineTo(envSrc.xmax, envSrc.ymax);\n\t\t\tlineTo(envSrc.xmin, envSrc.ymax);\n\t\t} else {\n\t\t\tlineTo(envSrc.xmin, envSrc.ymax);\n\t\t\tlineTo(envSrc.xmax, envSrc.ymax);\n\t\t\tlineTo(envSrc.xmax, envSrc.ymin);\n\t\t}\n\n\t\tclosePathWithLine();\n\t\tm_bPathStarted = false;\n\n\t\tif (bWasEmpty && !bReverse) {\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we no(sic?)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the polypath\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// is envelope\n\t\t}\n\t}", "code_tokens": ["public", "void", "addEnvelope", "(", "Envelope2D", "envSrc", ",", "boolean", "bReverse", ")", "{", "boolean", "bWasEmpty", "=", "m_pointCount", "==", "0", ";", "startPath", "(", "envSrc", ".", "xmin", ",", "envSrc", ".", "ymin", ")", ";", "if", "(", "bReverse", ")", "{", "lineTo", "(", "envSrc", ".", "xmax", ",", "envSrc", ".", "ymin", ")", ";", "lineTo", "(", "envSrc", ".", "xmax", ",", "envSrc", ".", "ymax", ")", ";", "lineTo", "(", "envSrc", ".", "xmin", ",", "envSrc", ".", "ymax", ")", ";", "}", "else", "{", "lineTo", "(", "envSrc", ".", "xmin", ",", "envSrc", ".", "ymax", ")", ";", "lineTo", "(", "envSrc", ".", "xmax", ",", "envSrc", ".", "ymax", ")", ";", "lineTo", "(", "envSrc", ".", "xmax", ",", "envSrc", ".", "ymin", ")", ";", "}", "closePathWithLine", "(", ")", ";", "m_bPathStarted", "=", "false", ";", "if", "(", "bWasEmpty", "&&", "!", "bReverse", ")", "{", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyIsEnvelope", ",", "false", ")", ";", "// now we no(sic?)", "// the polypath", "// is envelope", "}", "}"], "docstring": "adds a rectangular closed Path to the MultiPathImpl.\n\n@param envSrc\nis the source rectangle.\n@param bReverse\nCreates reversed path.", "docstring_tokens": ["adds", "a", "rectangular", "closed", "Path", "to", "the", "MultiPathImpl", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L624-L646", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.addEnvelope", "original_string": "public void addEnvelope(Envelope envSrc, boolean bReverse) {\n\t\tif (envSrc.isEmpty())\n\t\t\treturn;\n\n\t\tboolean bWasEmpty = m_pointCount == 0;\n\t\tPoint pt = new Point(m_description);// getDescription());\n\t\tfor (int i = 0, n = 4; i < n; i++) {\n\t\t\tint j = bReverse ? n - i - 1 : i;\n\n\t\t\tenvSrc.queryCornerByVal(j, pt);\n\t\t\tif (i == 0)\n\t\t\t\tstartPath(pt);\n\t\t\telse\n\t\t\t\tlineTo(pt);\n\t\t}\n\n\t\tclosePathWithLine();\n\t\tm_bPathStarted = false;\n\n\t\tif (bWasEmpty && !bReverse)\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we know the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polypath is\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// envelope\n\t}", "language": "java", "code": "public void addEnvelope(Envelope envSrc, boolean bReverse) {\n\t\tif (envSrc.isEmpty())\n\t\t\treturn;\n\n\t\tboolean bWasEmpty = m_pointCount == 0;\n\t\tPoint pt = new Point(m_description);// getDescription());\n\t\tfor (int i = 0, n = 4; i < n; i++) {\n\t\t\tint j = bReverse ? n - i - 1 : i;\n\n\t\t\tenvSrc.queryCornerByVal(j, pt);\n\t\t\tif (i == 0)\n\t\t\t\tstartPath(pt);\n\t\t\telse\n\t\t\t\tlineTo(pt);\n\t\t}\n\n\t\tclosePathWithLine();\n\t\tm_bPathStarted = false;\n\n\t\tif (bWasEmpty && !bReverse)\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we know the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polypath is\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// envelope\n\t}", "code_tokens": ["public", "void", "addEnvelope", "(", "Envelope", "envSrc", ",", "boolean", "bReverse", ")", "{", "if", "(", "envSrc", ".", "isEmpty", "(", ")", ")", "return", ";", "boolean", "bWasEmpty", "=", "m_pointCount", "==", "0", ";", "Point", "pt", "=", "new", "Point", "(", "m_description", ")", ";", "// getDescription());", "for", "(", "int", "i", "=", "0", ",", "n", "=", "4", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "j", "=", "bReverse", "?", "n", "-", "i", "-", "1", ":", "i", ";", "envSrc", ".", "queryCornerByVal", "(", "j", ",", "pt", ")", ";", "if", "(", "i", "==", "0", ")", "startPath", "(", "pt", ")", ";", "else", "lineTo", "(", "pt", ")", ";", "}", "closePathWithLine", "(", ")", ";", "m_bPathStarted", "=", "false", ";", "if", "(", "bWasEmpty", "&&", "!", "bReverse", ")", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyIsEnvelope", ",", "false", ")", ";", "// now we know the", "// polypath is", "// envelope", "}"], "docstring": "adds a rectangular closed Path to the MultiPathImpl.\n\n@param envSrc\nis the source rectangle.\n@param bReverse\nCreates reversed path.", "docstring_tokens": ["adds", "a", "rectangular", "closed", "Path", "to", "the", "MultiPathImpl", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L657-L680", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.add", "original_string": "public void add(MultiPathImpl src, boolean bReversePaths) {\n\t\tfor (int i = 0; i < src.getPathCount(); i++)\n\t\t\taddPath(src, i, !bReversePaths);\n\t}", "language": "java", "code": "public void add(MultiPathImpl src, boolean bReversePaths) {\n\t\tfor (int i = 0; i < src.getPathCount(); i++)\n\t\t\taddPath(src, i, !bReversePaths);\n\t}", "code_tokens": ["public", "void", "add", "(", "MultiPathImpl", "src", ",", "boolean", "bReversePaths", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "src", ".", "getPathCount", "(", ")", ";", "i", "++", ")", "addPath", "(", "src", ",", "i", ",", "!", "bReversePaths", ")", ";", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L683-L686", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.reversePath", "original_string": "public void reversePath(int pathIndex) {\n\t\t_verifyAllStreams();\n\t\tint pathCount = getPathCount();\n\t\tif (pathIndex >= pathCount)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tint reversedPathStart = getPathStart(pathIndex);\n\t\tint reversedPathSize = getPathSize(pathIndex);\n\t\tint offset = isClosedPath(pathIndex) ? 1 : 0;\n\n\t\t// TODO: a bug for the non linear segments here.\n\t\t// There could be an issue here if someone explicity closes the path\n\t\t// with the same start/end point.\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tif (m_vertexAttributes[iattr] != null) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(iattr);\n\t\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tm_vertexAttributes[iattr].reverseRange(comp\n\t\t\t\t\t\t* (reversedPathStart + offset), comp\n\t\t\t\t\t\t* (reversedPathSize - offset), comp);\n\t\t\t}\n\t\t}\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "language": "java", "code": "public void reversePath(int pathIndex) {\n\t\t_verifyAllStreams();\n\t\tint pathCount = getPathCount();\n\t\tif (pathIndex >= pathCount)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tint reversedPathStart = getPathStart(pathIndex);\n\t\tint reversedPathSize = getPathSize(pathIndex);\n\t\tint offset = isClosedPath(pathIndex) ? 1 : 0;\n\n\t\t// TODO: a bug for the non linear segments here.\n\t\t// There could be an issue here if someone explicity closes the path\n\t\t// with the same start/end point.\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tif (m_vertexAttributes[iattr] != null) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(iattr);\n\t\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tm_vertexAttributes[iattr].reverseRange(comp\n\t\t\t\t\t\t* (reversedPathStart + offset), comp\n\t\t\t\t\t\t* (reversedPathSize - offset), comp);\n\t\t\t}\n\t\t}\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "code_tokens": ["public", "void", "reversePath", "(", "int", "pathIndex", ")", "{", "_verifyAllStreams", "(", ")", ";", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "pathIndex", ">=", "pathCount", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "int", "reversedPathStart", "=", "getPathStart", "(", "pathIndex", ")", ";", "int", "reversedPathSize", "=", "getPathSize", "(", "pathIndex", ")", ";", "int", "offset", "=", "isClosedPath", "(", "pathIndex", ")", "?", "1", ":", "0", ";", "// TODO: a bug for the non linear segments here.", "// There could be an issue here if someone explicity closes the path", "// with the same start/end point.", "for", "(", "int", "iattr", "=", "0", ",", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "if", "(", "m_vertexAttributes", "[", "iattr", "]", "!=", "null", ")", "{", "int", "semantics", "=", "m_description", ".", "_getSemanticsImpl", "(", "iattr", ")", ";", "int", "comp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "reverseRange", "(", "comp", "*", "(", "reversedPathStart", "+", "offset", ")", ",", "comp", "*", "(", "reversedPathSize", "-", "offset", ")", ",", "comp", ")", ";", "}", "}", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "}"], "docstring": "Reviewed vs. Native Jan 11, 2011", "docstring_tokens": ["Reviewed", "vs", ".", "Native", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L832-L856", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.removePath", "original_string": "public void removePath(int pathIndex) {\n\t\t_verifyAllStreams();\n\t\tint pathCount = getPathCount();\n\n\t\tif (pathIndex < 0)\n\t\t\tpathIndex = pathCount - 1;\n\n\t\tif (pathIndex >= pathCount)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tboolean bDirtyRingAreas2D = _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);\n\n\t\tint removedPathStart = getPathStart(pathIndex);\n\t\tint removedPathSize = getPathSize(pathIndex);\n\n\t\t// Remove the attribute values for the path\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tif (m_vertexAttributes[iattr] != null) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(iattr);\n\t\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tm_vertexAttributes[iattr].eraseRange(comp * removedPathStart,\n\t\t\t\t\t\tcomp * removedPathSize, comp * m_pointCount);\n\t\t\t}\n\t\t}\n\n\t\t// Change the start of each path after the removed path\n\t\tfor (int i = pathIndex + 1; i <= pathCount; i++) {\n\t\t\tint istart = m_paths.read(i);\n\t\t\tm_paths.write(i - 1, istart - removedPathSize);\n\t\t}\n\n\t\tif (m_pathFlags == null) {\n\t\t\tfor (int i = pathIndex + 1; i <= pathCount; i++) {\n\t\t\t\tbyte flags = m_pathFlags.read(i);\n\t\t\t\tm_pathFlags.write(i - 1, flags);\n\t\t\t}\n\t\t}\n\n\t\tm_paths.resize(pathCount);\n\t\tm_pathFlags.resize(pathCount);\n\t\tm_pointCount -= removedPathSize;\n\t\tm_reservedPointCount -= removedPathSize;\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "language": "java", "code": "public void removePath(int pathIndex) {\n\t\t_verifyAllStreams();\n\t\tint pathCount = getPathCount();\n\n\t\tif (pathIndex < 0)\n\t\t\tpathIndex = pathCount - 1;\n\n\t\tif (pathIndex >= pathCount)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tboolean bDirtyRingAreas2D = _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);\n\n\t\tint removedPathStart = getPathStart(pathIndex);\n\t\tint removedPathSize = getPathSize(pathIndex);\n\n\t\t// Remove the attribute values for the path\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tif (m_vertexAttributes[iattr] != null) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(iattr);\n\t\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tm_vertexAttributes[iattr].eraseRange(comp * removedPathStart,\n\t\t\t\t\t\tcomp * removedPathSize, comp * m_pointCount);\n\t\t\t}\n\t\t}\n\n\t\t// Change the start of each path after the removed path\n\t\tfor (int i = pathIndex + 1; i <= pathCount; i++) {\n\t\t\tint istart = m_paths.read(i);\n\t\t\tm_paths.write(i - 1, istart - removedPathSize);\n\t\t}\n\n\t\tif (m_pathFlags == null) {\n\t\t\tfor (int i = pathIndex + 1; i <= pathCount; i++) {\n\t\t\t\tbyte flags = m_pathFlags.read(i);\n\t\t\t\tm_pathFlags.write(i - 1, flags);\n\t\t\t}\n\t\t}\n\n\t\tm_paths.resize(pathCount);\n\t\tm_pathFlags.resize(pathCount);\n\t\tm_pointCount -= removedPathSize;\n\t\tm_reservedPointCount -= removedPathSize;\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "code_tokens": ["public", "void", "removePath", "(", "int", "pathIndex", ")", "{", "_verifyAllStreams", "(", ")", ";", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "pathIndex", "<", "0", ")", "pathIndex", "=", "pathCount", "-", "1", ";", "if", "(", "pathIndex", ">=", "pathCount", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "boolean", "bDirtyRingAreas2D", "=", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ")", ";", "int", "removedPathStart", "=", "getPathStart", "(", "pathIndex", ")", ";", "int", "removedPathSize", "=", "getPathSize", "(", "pathIndex", ")", ";", "// Remove the attribute values for the path", "for", "(", "int", "iattr", "=", "0", ",", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "if", "(", "m_vertexAttributes", "[", "iattr", "]", "!=", "null", ")", "{", "int", "semantics", "=", "m_description", ".", "_getSemanticsImpl", "(", "iattr", ")", ";", "int", "comp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "eraseRange", "(", "comp", "*", "removedPathStart", ",", "comp", "*", "removedPathSize", ",", "comp", "*", "m_pointCount", ")", ";", "}", "}", "// Change the start of each path after the removed path", "for", "(", "int", "i", "=", "pathIndex", "+", "1", ";", "i", "<=", "pathCount", ";", "i", "++", ")", "{", "int", "istart", "=", "m_paths", ".", "read", "(", "i", ")", ";", "m_paths", ".", "write", "(", "i", "-", "1", ",", "istart", "-", "removedPathSize", ")", ";", "}", "if", "(", "m_pathFlags", "==", "null", ")", "{", "for", "(", "int", "i", "=", "pathIndex", "+", "1", ";", "i", "<=", "pathCount", ";", "i", "++", ")", "{", "byte", "flags", "=", "m_pathFlags", ".", "read", "(", "i", ")", ";", "m_pathFlags", ".", "write", "(", "i", "-", "1", ",", "flags", ")", ";", "}", "}", "m_paths", ".", "resize", "(", "pathCount", ")", ";", "m_pathFlags", ".", "resize", "(", "pathCount", ")", ";", "m_pointCount", "-=", "removedPathSize", ";", "m_reservedPointCount", "-=", "removedPathSize", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "}"], "docstring": "TODO: Nonlinearsegments", "docstring_tokens": ["TODO", ":", "Nonlinearsegments"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L860-L904", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.insertPath", "original_string": "public void insertPath(int pathIndex, MultiPathImpl src, int srcPathIndex,\n\t\t\tboolean bForward) {\n\t\tif (src == this)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (srcPathIndex >= src.getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tint oldPathCount = getPathCount();\n\t\tif (pathIndex > oldPathCount)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (pathIndex < 0)\n\t\t\tpathIndex = oldPathCount;\n\n\t\tif (srcPathIndex < 0)\n\t\t\tsrcPathIndex = src.getPathCount() - 1;\n\n\t\tm_bPathStarted = false;\n\n\t\tmergeVertexDescription(src.m_description);// merge attributes from the\n\t\t\t\t\t\t\t\t\t\t\t\t\t// source\n\n\t\tsrc._verifyAllStreams();// the source need to be correct.\n\n\t\tint srcPathIndexStart = src.getPathStart(srcPathIndex);\n\t\tint srcPathSize = src.getPathSize(srcPathIndex);\n\t\tint oldPointCount = m_pointCount;\n\t\tint offset = src.isClosedPath(srcPathIndex) && !bForward ? 1 : 0;\n\n\t\t_resizeImpl(m_pointCount + srcPathSize);\n\t\t_verifyAllStreams();\n\t\tint pathIndexStart = pathIndex < oldPathCount ? getPathStart(pathIndex)\n\t\t\t\t: oldPointCount;\n\n\t\t// Copy all attribute values.\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tint semantics = m_description._getSemanticsImpl(iattr);\n\t\t\tint isrcAttr = src.m_description.getAttributeIndex(semantics);\n\n\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\n\t\t\tif (isrcAttr >= 0 && src.m_vertexAttributes[isrcAttr] != null) {\n\t\t\t\tif (offset != 0)\n\t\t\t\t\tm_vertexAttributes[iattr].insertRange(\n\t\t\t\t\t\t\tpathIndexStart * comp,\n\t\t\t\t\t\t\tsrc.m_vertexAttributes[isrcAttr], comp\n\t\t\t\t\t\t\t\t\t* srcPathIndexStart, comp, true, comp, comp\n\t\t\t\t\t\t\t\t\t* oldPointCount);\n\t\t\t\tm_vertexAttributes[iattr].insertRange((pathIndexStart + offset)\n\t\t\t\t\t\t* comp, src.m_vertexAttributes[isrcAttr], comp\n\t\t\t\t\t\t* (srcPathIndexStart + offset), comp\n\t\t\t\t\t\t* (srcPathSize - offset), bForward, comp, comp\n\t\t\t\t\t\t* (oldPointCount + offset));\n\t\t\t} else {\n\t\t\t\t// Need to make room for the attributes, so we copy default\n\t\t\t\t// values in\n\n\t\t\t\tdouble v = VertexDescription.getDefaultValue(semantics);\n\t\t\t\tm_vertexAttributes[iattr].insertRange(pathIndexStart * comp, v,\n\t\t\t\t\t\tcomp * srcPathSize, comp * oldPointCount);\n\t\t\t}\n\t\t}\n\n\t\tint newPointCount = oldPointCount + srcPathSize;\n\t\tm_paths.add(newPointCount);\n\n\t\tfor (int ipath = oldPathCount; ipath >= pathIndex + 1; ipath--) {\n\t\t\tint iend = m_paths.read(ipath - 1);\n\t\t\tm_paths.write(ipath, iend + srcPathSize);\n\t\t}\n\n\t\t// ========================== todo: NonLinearSegments =================\n\t\tif (src.hasNonLinearSegments(srcPathIndex)) {\n\n\t\t}\n\n\t\tm_pathFlags.add((byte) 0);\n\n\t\t// _ASSERT(m_pathFlags.size() == m_paths.size());\n\n\t\tfor (int ipath = oldPathCount - 1; ipath >= pathIndex + 1; ipath--) {\n\t\t\tbyte flags = m_pathFlags.read(ipath);\n\t\t\tflags &= ~(byte) PathFlags.enumCalcMask;// remove calculated flags\n\t\t\tm_pathFlags.write(ipath + 1, flags);\n\t\t}\n\n\t\tAttributeStreamOfInt8 srcPathFlags = src.getPathFlagsStreamRef();\n\t\tbyte flags = srcPathFlags.read(srcPathIndex);\n\t\tflags &= ~(byte) PathFlags.enumCalcMask;// remove calculated flags\n\n\t\tif (m_bPolygon)\n\t\t\tflags |= (byte) PathFlags.enumClosed;\n\n\t\tm_pathFlags.write(pathIndex, flags);\n\t}", "language": "java", "code": "public void insertPath(int pathIndex, MultiPathImpl src, int srcPathIndex,\n\t\t\tboolean bForward) {\n\t\tif (src == this)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (srcPathIndex >= src.getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tint oldPathCount = getPathCount();\n\t\tif (pathIndex > oldPathCount)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (pathIndex < 0)\n\t\t\tpathIndex = oldPathCount;\n\n\t\tif (srcPathIndex < 0)\n\t\t\tsrcPathIndex = src.getPathCount() - 1;\n\n\t\tm_bPathStarted = false;\n\n\t\tmergeVertexDescription(src.m_description);// merge attributes from the\n\t\t\t\t\t\t\t\t\t\t\t\t\t// source\n\n\t\tsrc._verifyAllStreams();// the source need to be correct.\n\n\t\tint srcPathIndexStart = src.getPathStart(srcPathIndex);\n\t\tint srcPathSize = src.getPathSize(srcPathIndex);\n\t\tint oldPointCount = m_pointCount;\n\t\tint offset = src.isClosedPath(srcPathIndex) && !bForward ? 1 : 0;\n\n\t\t_resizeImpl(m_pointCount + srcPathSize);\n\t\t_verifyAllStreams();\n\t\tint pathIndexStart = pathIndex < oldPathCount ? getPathStart(pathIndex)\n\t\t\t\t: oldPointCount;\n\n\t\t// Copy all attribute values.\n\t\tfor (int iattr = 0, nattr = m_description.getAttributeCount(); iattr < nattr; iattr++) {\n\t\t\tint semantics = m_description._getSemanticsImpl(iattr);\n\t\t\tint isrcAttr = src.m_description.getAttributeIndex(semantics);\n\n\t\t\tint comp = VertexDescription.getComponentCount(semantics);\n\n\t\t\tif (isrcAttr >= 0 && src.m_vertexAttributes[isrcAttr] != null) {\n\t\t\t\tif (offset != 0)\n\t\t\t\t\tm_vertexAttributes[iattr].insertRange(\n\t\t\t\t\t\t\tpathIndexStart * comp,\n\t\t\t\t\t\t\tsrc.m_vertexAttributes[isrcAttr], comp\n\t\t\t\t\t\t\t\t\t* srcPathIndexStart, comp, true, comp, comp\n\t\t\t\t\t\t\t\t\t* oldPointCount);\n\t\t\t\tm_vertexAttributes[iattr].insertRange((pathIndexStart + offset)\n\t\t\t\t\t\t* comp, src.m_vertexAttributes[isrcAttr], comp\n\t\t\t\t\t\t* (srcPathIndexStart + offset), comp\n\t\t\t\t\t\t* (srcPathSize - offset), bForward, comp, comp\n\t\t\t\t\t\t* (oldPointCount + offset));\n\t\t\t} else {\n\t\t\t\t// Need to make room for the attributes, so we copy default\n\t\t\t\t// values in\n\n\t\t\t\tdouble v = VertexDescription.getDefaultValue(semantics);\n\t\t\t\tm_vertexAttributes[iattr].insertRange(pathIndexStart * comp, v,\n\t\t\t\t\t\tcomp * srcPathSize, comp * oldPointCount);\n\t\t\t}\n\t\t}\n\n\t\tint newPointCount = oldPointCount + srcPathSize;\n\t\tm_paths.add(newPointCount);\n\n\t\tfor (int ipath = oldPathCount; ipath >= pathIndex + 1; ipath--) {\n\t\t\tint iend = m_paths.read(ipath - 1);\n\t\t\tm_paths.write(ipath, iend + srcPathSize);\n\t\t}\n\n\t\t// ========================== todo: NonLinearSegments =================\n\t\tif (src.hasNonLinearSegments(srcPathIndex)) {\n\n\t\t}\n\n\t\tm_pathFlags.add((byte) 0);\n\n\t\t// _ASSERT(m_pathFlags.size() == m_paths.size());\n\n\t\tfor (int ipath = oldPathCount - 1; ipath >= pathIndex + 1; ipath--) {\n\t\t\tbyte flags = m_pathFlags.read(ipath);\n\t\t\tflags &= ~(byte) PathFlags.enumCalcMask;// remove calculated flags\n\t\t\tm_pathFlags.write(ipath + 1, flags);\n\t\t}\n\n\t\tAttributeStreamOfInt8 srcPathFlags = src.getPathFlagsStreamRef();\n\t\tbyte flags = srcPathFlags.read(srcPathIndex);\n\t\tflags &= ~(byte) PathFlags.enumCalcMask;// remove calculated flags\n\n\t\tif (m_bPolygon)\n\t\t\tflags |= (byte) PathFlags.enumClosed;\n\n\t\tm_pathFlags.write(pathIndex, flags);\n\t}", "code_tokens": ["public", "void", "insertPath", "(", "int", "pathIndex", ",", "MultiPathImpl", "src", ",", "int", "srcPathIndex", ",", "boolean", "bForward", ")", "{", "if", "(", "src", "==", "this", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "srcPathIndex", ">=", "src", ".", "getPathCount", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "int", "oldPathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "pathIndex", ">", "oldPathCount", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "pathIndex", "<", "0", ")", "pathIndex", "=", "oldPathCount", ";", "if", "(", "srcPathIndex", "<", "0", ")", "srcPathIndex", "=", "src", ".", "getPathCount", "(", ")", "-", "1", ";", "m_bPathStarted", "=", "false", ";", "mergeVertexDescription", "(", "src", ".", "m_description", ")", ";", "// merge attributes from the", "// source", "src", ".", "_verifyAllStreams", "(", ")", ";", "// the source need to be correct.", "int", "srcPathIndexStart", "=", "src", ".", "getPathStart", "(", "srcPathIndex", ")", ";", "int", "srcPathSize", "=", "src", ".", "getPathSize", "(", "srcPathIndex", ")", ";", "int", "oldPointCount", "=", "m_pointCount", ";", "int", "offset", "=", "src", ".", "isClosedPath", "(", "srcPathIndex", ")", "&&", "!", "bForward", "?", "1", ":", "0", ";", "_resizeImpl", "(", "m_pointCount", "+", "srcPathSize", ")", ";", "_verifyAllStreams", "(", ")", ";", "int", "pathIndexStart", "=", "pathIndex", "<", "oldPathCount", "?", "getPathStart", "(", "pathIndex", ")", ":", "oldPointCount", ";", "// Copy all attribute values.", "for", "(", "int", "iattr", "=", "0", ",", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "int", "semantics", "=", "m_description", ".", "_getSemanticsImpl", "(", "iattr", ")", ";", "int", "isrcAttr", "=", "src", ".", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "int", "comp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "if", "(", "isrcAttr", ">=", "0", "&&", "src", ".", "m_vertexAttributes", "[", "isrcAttr", "]", "!=", "null", ")", "{", "if", "(", "offset", "!=", "0", ")", "m_vertexAttributes", "[", "iattr", "]", ".", "insertRange", "(", "pathIndexStart", "*", "comp", ",", "src", ".", "m_vertexAttributes", "[", "isrcAttr", "]", ",", "comp", "*", "srcPathIndexStart", ",", "comp", ",", "true", ",", "comp", ",", "comp", "*", "oldPointCount", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "insertRange", "(", "(", "pathIndexStart", "+", "offset", ")", "*", "comp", ",", "src", ".", "m_vertexAttributes", "[", "isrcAttr", "]", ",", "comp", "*", "(", "srcPathIndexStart", "+", "offset", ")", ",", "comp", "*", "(", "srcPathSize", "-", "offset", ")", ",", "bForward", ",", "comp", ",", "comp", "*", "(", "oldPointCount", "+", "offset", ")", ")", ";", "}", "else", "{", "// Need to make room for the attributes, so we copy default", "// values in", "double", "v", "=", "VertexDescription", ".", "getDefaultValue", "(", "semantics", ")", ";", "m_vertexAttributes", "[", "iattr", "]", ".", "insertRange", "(", "pathIndexStart", "*", "comp", ",", "v", ",", "comp", "*", "srcPathSize", ",", "comp", "*", "oldPointCount", ")", ";", "}", "}", "int", "newPointCount", "=", "oldPointCount", "+", "srcPathSize", ";", "m_paths", ".", "add", "(", "newPointCount", ")", ";", "for", "(", "int", "ipath", "=", "oldPathCount", ";", "ipath", ">=", "pathIndex", "+", "1", ";", "ipath", "--", ")", "{", "int", "iend", "=", "m_paths", ".", "read", "(", "ipath", "-", "1", ")", ";", "m_paths", ".", "write", "(", "ipath", ",", "iend", "+", "srcPathSize", ")", ";", "}", "// ========================== todo: NonLinearSegments =================", "if", "(", "src", ".", "hasNonLinearSegments", "(", "srcPathIndex", ")", ")", "{", "}", "m_pathFlags", ".", "add", "(", "(", "byte", ")", "0", ")", ";", "// _ASSERT(m_pathFlags.size() == m_paths.size());", "for", "(", "int", "ipath", "=", "oldPathCount", "-", "1", ";", "ipath", ">=", "pathIndex", "+", "1", ";", "ipath", "--", ")", "{", "byte", "flags", "=", "m_pathFlags", ".", "read", "(", "ipath", ")", ";", "flags", "&=", "~", "(", "byte", ")", "PathFlags", ".", "enumCalcMask", ";", "// remove calculated flags", "m_pathFlags", ".", "write", "(", "ipath", "+", "1", ",", "flags", ")", ";", "}", "AttributeStreamOfInt8", "srcPathFlags", "=", "src", ".", "getPathFlagsStreamRef", "(", ")", ";", "byte", "flags", "=", "srcPathFlags", ".", "read", "(", "srcPathIndex", ")", ";", "flags", "&=", "~", "(", "byte", ")", "PathFlags", ".", "enumCalcMask", ";", "// remove calculated flags", "if", "(", "m_bPolygon", ")", "flags", "|=", "(", "byte", ")", "PathFlags", ".", "enumClosed", ";", "m_pathFlags", ".", "write", "(", "pathIndex", ",", "flags", ")", ";", "}"], "docstring": "TODO: Nonlinearsegments", "docstring_tokens": ["TODO", ":", "Nonlinearsegments"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L907-L1002", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPathImpl.java", "func_name": "MultiPathImpl.interpolateAttributes", "original_string": "void interpolateAttributes(int from_path_index, int from_point_index,\n\t\t\tint to_path_index, int to_point_index) {\n\t\tfor (int ipath = from_path_index; ipath < to_path_index - 1; ipath++) {\n\t\t\tif (isClosedPath(ipath))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"cannot interpolate across closed paths\");\n\t\t}\n\n\t\tint nattr = m_description.getAttributeCount();\n\n\t\tif (nattr == 1)\n\t\t\treturn; // only has position\n\n\t\tdouble sub_length = calculateSubLength2D(from_path_index,\n\t\t\t\tfrom_point_index, to_path_index, to_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tfor (int iattr = 1; iattr < nattr; iattr++) {\n\t\t\tint semantics = m_description.getSemantics(iattr);\n\n\t\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\t\tcontinue;\n\n\t\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\t\tinterpolateAttributes_(semantics, from_path_index,\n\t\t\t\t\t\tfrom_point_index, to_path_index, to_point_index,\n\t\t\t\t\t\tsub_length, ordinate);\n\t\t}\n\t}\n\n\t// TODO: Add code for interpolation type (none and angular)\n\tvoid interpolateAttributesForSemantics(int semantics, int from_path_index,\n\t\t\tint from_point_index, int to_path_index, int to_point_index) {\n\t\tif (semantics == VertexDescription.Semantics.POSITION)\n\t\t\treturn;\n\n\t\tif (!hasAttribute(semantics))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"does not have the given attribute\");\n\n\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"not implemented for the given semantics\");\n\n\t\tfor (int ipath = from_path_index; ipath < to_path_index - 1; ipath++) {\n\t\t\tif (isClosedPath(ipath))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"cannot interpolate across closed paths\");\n\t\t}\n\n\t\tdouble sub_length = calculateSubLength2D(from_path_index,\n\t\t\t\tfrom_point_index, to_path_index, to_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\tinterpolateAttributes_(semantics, from_path_index,\n\t\t\t\t\tfrom_point_index, to_path_index, to_point_index,\n\t\t\t\t\tsub_length, ordinate);\n\t}\n\n\tvoid interpolateAttributes(int path_index, int from_point_index,\n\t\t\tint to_point_index) {\n\t\tint nattr = m_description.getAttributeCount();\n\n\t\tif (nattr == 1)\n\t\t\treturn; // only has position\n\n\t\tdouble sub_length = calculateSubLength2D(path_index, from_point_index,\n\t\t\t\tto_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tfor (int iattr = 1; iattr < nattr; iattr++) {\n\t\t\tint semantics = m_description.getSemantics(iattr);\n\n\t\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\t\tcontinue;\n\n\t\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\t\tinterpolateAttributes_(semantics, path_index, from_point_index,\n\t\t\t\t\t\tto_point_index, sub_length, ordinate);\n\t\t}\n\t}\n\n\tvoid interpolateAttributesForSemantics(int semantics, int path_index,\n\t\t\tint from_point_index, int to_point_index) {\n\t\tif (semantics == VertexDescription.Semantics.POSITION)\n\t\t\treturn;\n\n\t\tif (!hasAttribute(semantics))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"does not have the given attribute\");\n\n\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"not implemented for the given semantics\");\n\n\t\tdouble sub_length = calculateSubLength2D(path_index, from_point_index,\n\t\t\t\tto_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\tinterpolateAttributes_(semantics, path_index, from_point_index,\n\t\t\t\t\tto_point_index, sub_length, ordinate);\n\t}\n\n\t// TODO: Add code fore interpolation type (none and angular)\n\tvoid interpolateAttributes_(int semantics, int from_path_index,\n\t\t\tint from_point_index, int to_path_index, int to_point_index,\n\t\t\tdouble sub_length, int ordinate) {\n\t\tSegmentIteratorImpl seg_iter = querySegmentIterator();\n\n\t\tint absolute_from_index = getPathStart(from_path_index)\n\t\t\t\t+ from_point_index;\n\t\tint absolute_to_index = getPathStart(to_path_index) + to_point_index;\n\n\t\tdouble from_attribute = getAttributeAsDbl(semantics,\n\t\t\t\tabsolute_from_index, ordinate);\n\t\tdouble to_attribute = getAttributeAsDbl(semantics, absolute_to_index,\n\t\t\t\tordinate);\n\t\tdouble interpolated_attribute = from_attribute;\n\t\tdouble cumulative_length = 0.0;\n\n\t\tseg_iter.resetToVertex(absolute_from_index);\n\n\t\tdo {\n\t\t\tif (seg_iter.hasNextSegment()) {\n\t\t\t\tseg_iter.nextSegment();\n\n\t\t\t\tif (seg_iter.getStartPointIndex() == absolute_to_index)\n\t\t\t\t\treturn;\n\n\t\t\t\tsetAttribute(semantics, seg_iter.getStartPointIndex(),\n\t\t\t\t\t\tordinate, interpolated_attribute);\n\n\t\t\t\tseg_iter.previousSegment();\n\n\t\t\t\tdo {\n\t\t\t\t\tSegment segment = seg_iter.nextSegment();\n\n\t\t\t\t\tif (seg_iter.getEndPointIndex() == absolute_to_index)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tdouble segment_length = segment.calculateLength2D();\n\t\t\t\t\tcumulative_length += segment_length;\n\t\t\t\t\tdouble t = cumulative_length / sub_length;\n\t\t\t\t\tinterpolated_attribute = MathUtils.lerp(from_attribute,  to_attribute, t);\n\n\t\t\t\t\tif (!seg_iter.isClosingSegment())\n\t\t\t\t\t\tsetAttribute(semantics, seg_iter.getEndPointIndex(),\n\t\t\t\t\t\t\t\tordinate, interpolated_attribute);\n\n\t\t\t\t} while (seg_iter.hasNextSegment());\n\t\t\t}\n\n\t\t} while (seg_iter.nextPath());\n\t}\n\n\tvoid interpolateAttributes_(int semantics, int path_index,\n\t\t\tint from_point_index, int to_point_index, double sub_length,\n\t\t\tint ordinate) {\n\t\tassert (m_bPolygon);\n\t\tSegmentIteratorImpl seg_iter = querySegmentIterator();\n\n\t\tint absolute_from_index = getPathStart(path_index) + from_point_index;\n\t\tint absolute_to_index = getPathStart(path_index) + to_point_index;\n\n\t\tif (absolute_to_index == absolute_from_index)\n\t\t\treturn;\n\n\t\tdouble from_attribute = getAttributeAsDbl(semantics,\n\t\t\t\tabsolute_from_index, ordinate);\n\t\tdouble to_attribute = getAttributeAsDbl(semantics, absolute_to_index,\n\t\t\t\tordinate);\n\t\tdouble cumulative_length = 0.0;\n\n\t\tseg_iter.resetToVertex(absolute_from_index);\n\t\tseg_iter.setCirculator(true);\n\n\t\tdouble prev_interpolated_attribute = from_attribute;\n\n\t\tdo {\n\t\t\tSegment segment = seg_iter.nextSegment();\n\t\t\tsetAttribute(semantics, seg_iter.getStartPointIndex(), ordinate,\n\t\t\t\t\tprev_interpolated_attribute);\n\n\t\t\tdouble segment_length = segment.calculateLength2D();\n\t\t\tcumulative_length += segment_length;\n\t\t\tdouble t = cumulative_length / sub_length;\n\t\t\tprev_interpolated_attribute = MathUtils.lerp(from_attribute, to_attribute, t);\n\n\t\t} while (seg_iter.getEndPointIndex() != absolute_to_index);\n\t}\n\n\t@Override\n\tpublic void setEmpty() {\n\t\tm_curveParamwritePoint = 0;\n\t\tm_bPathStarted = false;\n\t\tm_paths = null;\n\t\tm_pathFlags = null;\n\t\tm_segmentParamIndex = null;\n\t\tm_segmentFlags = null;\n\t\tm_segmentParams = null;\n\t\t_setEmptyImpl();\n\t}\n\n\t@Override\n\tpublic void applyTransformation(Transformation2D transform) {\n\t\tapplyTransformation(transform, -1);\n\t}\n\n\tpublic void applyTransformation(Transformation2D transform, int pathIndex) {\n\t\tif (isEmpty())\n\t\t\treturn;\n\n\t\tif (transform.isIdentity())\n\t\t\treturn;\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint2D ptStart = new Point2D();\n\t\tPoint2D ptControl = new Point2D();\n\n\t\tboolean bHasNonLinear;\n\t\tint fistIdx;\n\t\tint lastIdx;\n\t\tif (pathIndex < 0) {\n\t\t\tbHasNonLinear = hasNonLinearSegments();\n\t\t\tfistIdx = 0;\n\t\t\tlastIdx = m_pointCount;\n\t\t} else {\n\t\t\tbHasNonLinear = hasNonLinearSegments(pathIndex);\n\t\t\tfistIdx = getPathStart(pathIndex);\n\t\t\tlastIdx = getPathEnd(pathIndex);\n\t\t}\n\n\t\tfor (int ipoint = fistIdx; ipoint < lastIdx; ipoint++) {\n\t\t\tptStart.x = points.read(ipoint * 2);\n\t\t\tptStart.y = points.read(ipoint * 2 + 1);\n\n\t\t\tif (bHasNonLinear) {\n\t\t\t\tint segIndex = m_segmentParamIndex.read(ipoint);\n\t\t\t\tif (segIndex >= 0) {\n\t\t\t\t\tint segmentType = (int) m_segmentFlags.read(ipoint);\n\t\t\t\t\tint type = segmentType & SegmentFlags.enumSegmentMask;\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SegmentFlags.enumBezierSeg: {\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 1);\n\t\t\t\t\t\ttransform.transform(ptControl, ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 1, ptControl.y);\n\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex + 3);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 4);\n\t\t\t\t\t\ttransform.transform(ptControl, ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 3, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 4, ptControl.y);\n\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SegmentFlags.enumArcSeg:\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttransform.transform(ptStart, ptStart);\n\t\t\tpoints.write(ipoint * 2, ptStart.x);\n\t\t\tpoints.write(ipoint * 2 + 1, ptStart.y);\n\t\t}\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t\t// REFACTOR: reset the exact envelope only and transform the loose\n\t\t// envelope\n\t}\n\n\t@Override\n\tpublic void applyTransformation(Transformation3D transform) {\n\t\tif (isEmpty())\n\t\t\treturn;\n\n\t\taddAttribute(VertexDescription.Semantics.Z);\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tAttributeStreamOfDbl zs = (AttributeStreamOfDbl) m_vertexAttributes[1];\n\t\tPoint3D ptStart = new Point3D();\n\t\tPoint3D ptControl = new Point3D();\n\t\tboolean bHasNonLinear = hasNonLinearSegments();\n\t\tfor (int ipoint = 0; ipoint < m_pointCount; ipoint++) {\n\t\t\tptStart.x = points.read(ipoint * 2);\n\t\t\tptStart.y = points.read(ipoint * 2 + 1);\n\t\t\tptStart.z = zs.read(ipoint);\n\n\t\t\tif (bHasNonLinear) {\n\t\t\t\tint segIndex = m_segmentParamIndex.read(ipoint);\n\t\t\t\tif (segIndex >= 0) {\n\t\t\t\t\tint segmentType = (int) m_segmentFlags.read(ipoint);\n\t\t\t\t\tint type = segmentType & (int) SegmentFlags.enumSegmentMask;\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SegmentFlags.enumBezierSeg: {\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 1);\n\t\t\t\t\t\tptControl.z = m_segmentParams.read(segIndex + 2);\n\t\t\t\t\t\tptControl = transform.transform(ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 1, ptControl.y);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 1, ptControl.z);\n\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex + 3);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 4);\n\t\t\t\t\t\tptControl.z = m_segmentParams.read(segIndex + 5);\n\t\t\t\t\t\tptControl = transform.transform(ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 3, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 4, ptControl.y);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 5, ptControl.z);\n\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SegmentFlags.enumArcSeg:\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptStart = transform.transform(ptStart);\n\t\t\tpoints.write(ipoint * 2, ptStart.x);\n\t\t\tpoints.write(ipoint * 2 + 1, ptStart.y);\n\t\t\tzs.write(ipoint, ptStart.z);\n\t\t}\n\n\t\t// REFACTOR: reset the exact envelope only and transform the loose\n\t\t// envelope\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}\n\n\t@Override\n\tprotected void _verifyStreamsImpl() {\n\t\tif (m_paths == null) {\n\t\t\tm_paths = (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t.createIndexStream(1, 0);\n\t\t\tm_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t.createByteStream(1, (byte) 0);\n\t\t}\n\n\t\tif (m_segmentFlags != null) {\n\t\t\tm_segmentFlags.resize(m_reservedPointCount,\n\t\t\t\t\t(byte) SegmentFlags.enumLineSeg);\n\t\t\tm_segmentParamIndex.resize(m_reservedPointCount, -1);\n\t\t}\n\t}\n\n\t@Override\n\tvoid _copyToImpl(MultiVertexGeometryImpl dst) {\n\t\tMultiPathImpl dstPoly = (MultiPathImpl) dst;\n\t\tdstPoly.m_bPathStarted = false;\n\t\tdstPoly.m_curveParamwritePoint = m_curveParamwritePoint;\n\t\tdstPoly.m_fill_rule = m_fill_rule;\n\t\t\n\t\tif (m_paths != null)\n\t\t\tdstPoly.m_paths = new AttributeStreamOfInt32(m_paths);\n\t\telse\n\t\t\tdstPoly.m_paths = null;\n\n\t\tif (m_pathFlags != null)\n\t\t\tdstPoly.m_pathFlags = new AttributeStreamOfInt8(m_pathFlags);\n\t\telse\n\t\t\tdstPoly.m_pathFlags = null;\n\n\t\tif (m_segmentParamIndex != null)\n\t\t\tdstPoly.m_segmentParamIndex = new AttributeStreamOfInt32(\n\t\t\t\t\tm_segmentParamIndex);\n\t\telse\n\t\t\tdstPoly.m_segmentParamIndex = null;\n\n\t\tif (m_segmentFlags != null)\n\t\t\tdstPoly.m_segmentFlags = new AttributeStreamOfInt8(m_segmentFlags);\n\t\telse\n\t\t\tdstPoly.m_segmentFlags = null;\n\n\t\tif (m_segmentParams != null)\n\t\t\tdstPoly.m_segmentParams = new AttributeStreamOfDbl(m_segmentParams);\n\t\telse\n\t\t\tdstPoly.m_segmentParams = null;\n\n\t\tdstPoly.m_cachedLength2D = m_cachedLength2D;\n\t\tdstPoly.m_cachedArea2D = m_cachedArea2D;\n\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {\n\t\t\tdstPoly.m_cachedRingAreas2D = (AttributeStreamOfDbl) m_cachedRingAreas2D;\n\t\t} else\n\t\t\tdstPoly.m_cachedRingAreas2D = null;\n\n\t}\n\n\t@Override\n\tpublic double calculateLength2D() {\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyLength2D)) {\n\t\t\treturn m_cachedLength2D;\n\t\t}\n\n\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\tMathUtils.KahanSummator len = new MathUtils.KahanSummator(0);\n\t\twhile (segIter.nextPath()) {\n\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\tlen.add(segIter.nextSegment().calculateLength2D());\n\t\t\t}\n\t\t}\n\n\t\tm_cachedLength2D = len.getResult();\n\t\t_setDirtyFlag(DirtyFlags.DirtyLength2D, false);\n\n\t\treturn len.getResult();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\tif (other == this)\n\t\t\treturn true;\n\n\t\tif (!(other instanceof MultiPathImpl))\n\t\t\treturn false;\n\n\t\tif (!super.equals(other))\n\t\t\treturn false;\n\n\t\tMultiPathImpl otherMultiPath = (MultiPathImpl) other;\n\n\t\tint pathCount = getPathCount();\n\t\tint pathCountOther = otherMultiPath.getPathCount();\n\n\t\tif (pathCount != pathCountOther)\n\t\t\treturn false;\n\n\t\tif (pathCount > 0 && m_paths != null\n\t\t\t\t&& !m_paths.equals(otherMultiPath.m_paths, 0, pathCount + 1))\n\t\t\treturn false;\n\n\t\tif (m_fill_rule != otherMultiPath.m_fill_rule)\n\t\t\treturn false;\n\n\t\t{\n\t\t\t// Note: OGC flags do not participate in the equals operation by\n\t\t\t// design.\n\t\t\t// Because for the polygon pathFlags will have all enum_closed set,\n\t\t\t// we do not need to compare this stream. Only for polyline.\n\t\t\t// Polyline does not have OGC flags set.\n\t\t\tif (!m_bPolygon) {\n\t\t\t\tif (m_pathFlags != null\n\t\t\t\t\t\t&& !m_pathFlags.equals(otherMultiPath.m_pathFlags, 0,\n\t\t\t\t\t\t\t\tpathCount))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t      \n\t\treturn super.equals(other);\n\t}\n\n\t/**\n\t * Returns a SegmentIterator that set to a specific vertex of the\n\t * MultiPathImpl. The call to NextSegment will return the segment that\n\t * starts at the vertex. Call to PreviousSegment will return the segment\n\t * that starts at the previous vertex.\n\t */\n\tpublic SegmentIteratorImpl querySegmentIteratorAtVertex(int startVertexIndex) {\n\t\tif (startVertexIndex < 0 || startVertexIndex >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tSegmentIteratorImpl iter = new SegmentIteratorImpl(this,\n\t\t\t\tstartVertexIndex);\n\t\treturn iter;\n\t}\n\n\t// void QuerySegmentIterator(int fromVertex, SegmentIterator iterator);\n\tpublic SegmentIteratorImpl querySegmentIterator() {\n\t\treturn new SegmentIteratorImpl(this);\n\t}\n\n\t@Override\n\tpublic void _updateXYImpl(boolean bExact) {\n\t\tsuper._updateXYImpl(bExact);\n\t\tboolean bHasCurves = hasNonLinearSegments();\n\t\tif (bHasCurves) {\n\t\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\t\twhile (segIter.nextPath()) {\n\t\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\t\tSegment curve = segIter.nextCurve();\n\t\t\t\t\tif (curve != null) {\n\t\t\t\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\t\t\t\tcurve.queryEnvelope2D(env2D);\n\t\t\t\t\t\tm_envelope.merge(env2D);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tvoid calculateEnvelope2D(Envelope2D env, boolean bExact) {\n\t\tsuper.calculateEnvelope2D(env, bExact);\n\t\tboolean bHasCurves = hasNonLinearSegments();\n\t\tif (bHasCurves) {\n\t\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\t\twhile (segIter.nextPath()) {\n\t\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\t\tSegment curve = segIter.nextCurve();\n\t\t\t\t\tif (curve != null) {\n\t\t\t\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\t\t\t\tcurve.queryEnvelope2D(env2D);\n\t\t\t\t\t\tenv.merge(env2D);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void _notifyModifiedAllImpl() {\n\t\tif (m_paths == null || m_paths.size() == 0)// if (m_paths == null ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t// !m_paths.size())\n\t\t\tm_pointCount = 0;\n\t\telse\n\t\t\tm_pointCount = m_paths.read(m_paths.size() - 1);\n\t}\n\n\t@Override\n\tpublic double calculateArea2D() {\n\t\tif (!m_bPolygon)\n\t\t\treturn 0.0;\n\n\t\t_updateRingAreas2D();\n\n\t\treturn m_cachedArea2D;\n\t}\n\n\t/**\n\t * Returns True if the ring is an exterior ring. Valid only for simple\n\t * polygons.\n\t */\n\tpublic boolean isExteriorRing(int ringIndex) {\n\t\tif (!m_bPolygon)\n\t\t\treturn false;\n\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))\n\t\t\treturn (m_pathFlags.read(ringIndex) & (byte) PathFlags.enumOGCStartPolygon) != 0;\n\n\t\t_updateRingAreas2D();\n\t\treturn m_cachedRingAreas2D.read(ringIndex) > 0;\n\t\t// Should we make a function called _UpdateHasNonLinearSegmentsFlags and\n\t\t// call it here?\n\t}\n\n\tpublic double calculateRingArea2D(int pathIndex) {\n\t\tif (!m_bPolygon)\n\t\t\treturn 0.0;\n\n\t\t_updateRingAreas2D();\n\n\t\treturn m_cachedRingAreas2D.read(pathIndex);\n\t}\n\n\tpublic void _updateRingAreas2D() {\n\t\tif (_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {\n\t\t\tint pathCount = getPathCount();\n\n\t\t\tif (m_cachedRingAreas2D == null)\n\t\t\t\tm_cachedRingAreas2D = new AttributeStreamOfDbl(pathCount);\n\t\t\telse if (m_cachedRingAreas2D.size() != pathCount)\n\t\t\t\tm_cachedRingAreas2D.resize(pathCount);\n\n\t\t\tMathUtils.KahanSummator totalArea = new MathUtils.KahanSummator(0);\n\t\t\tMathUtils.KahanSummator pathArea = new MathUtils.KahanSummator(0);\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tint ipath = 0;\n\t\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\t\twhile (segIter.nextPath()) {\n\t\t\t\tpathArea.reset();\n\t\t\t\tgetXY(getPathStart(segIter.getPathIndex()), pt);// get the area\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// calculation\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// origin to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the origin of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the ring.\n\t\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\t\tpathArea.add(segIter.nextSegment()._calculateArea2DHelper(\n\t\t\t\t\t\t\tpt.x, pt.y));\n\t\t\t\t}\n\n\t\t\t\ttotalArea.add(pathArea.getResult());\n\n\t\t\t\tint i = ipath++;\n\t\t\t\tm_cachedRingAreas2D.write(i, pathArea.getResult());\n\t\t\t}\n\n\t\t\tm_cachedArea2D = totalArea.getResult();\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);\n\t\t}\n\t}\n\n\tint getOGCPolygonCount() {\n\t\tif (!m_bPolygon)\n\t\t\treturn 0;\n\n\t\t_updateOGCFlags();\n\n\t\tint polygonCount = 0;\n\t\tint partCount = getPathCount();\n\t\tfor (int ipart = 0; ipart < partCount; ipart++) {\n\t\t\tif (((int) m_pathFlags.read(ipart) & (int) PathFlags.enumOGCStartPolygon) != 0)\n\t\t\t\tpolygonCount++;\n\t\t}\n\n\t\treturn polygonCount;\n\t}\n\n\tprotected void _updateOGCFlags() {\n\t\tif (_hasDirtyFlag(DirtyFlags.DirtyOGCFlags)) {\n\t\t\t_updateRingAreas2D();\n\n\t\t\tint pathCount = getPathCount();\n\t\t\tif (pathCount > 0 && (m_pathFlags == null || m_pathFlags.size() < pathCount))\n\t\t\t\tm_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t\t.createByteStream(pathCount + 1);\n\n\t\t\tint firstSign = 1;\n\t\t\tfor (int ipath = 0; ipath < pathCount; ipath++) {\n\t\t\t\tdouble area = m_cachedRingAreas2D.read(ipath);\n\t\t\t\tif (ipath == 0)\n\t\t\t\t\tfirstSign = area > 0 ? 1 : -1;\n\t\t\t\tif (area * firstSign > 0.0)\n\t\t\t\t\tm_pathFlags.setBits(ipath,\n\t\t\t\t\t\t\t(byte) PathFlags.enumOGCStartPolygon);\n\t\t\t\telse\n\t\t\t\t\tm_pathFlags.clearBits(ipath,\n\t\t\t\t\t\t\t(byte) PathFlags.enumOGCStartPolygon);\n\t\t\t}\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);\n\t\t}\n\t}\n\n\tpublic int getPathIndexFromPointIndex(int pointIndex) {\n\t\tint positionHint = m_currentPathIndex;// in case of multithreading\n\t\t\t\t\t\t\t\t\t\t\t\t// thiswould simply produce an\n\t\t\t\t\t\t\t\t\t\t\t\t// invalid value\n\t\tint pathCount = getPathCount();\n\n\t\t// Try using the hint position first to get the path index.\n\t\tif (positionHint >= 0 && positionHint < pathCount) {\n\t\t\tif (pointIndex < getPathEnd(positionHint)) {\n\t\t\t\tif (pointIndex >= getPathStart(positionHint))\n\t\t\t\t\treturn positionHint;\n\t\t\t\tpositionHint--;\n\t\t\t} else {\n\t\t\t\tpositionHint++;\n\t\t\t}\n\n\t\t\tif (positionHint >= 0 && positionHint < pathCount) {\n\t\t\t\tif (pointIndex >= getPathStart(positionHint)\n\t\t\t\t\t\t&& pointIndex < getPathEnd(positionHint)) {\n\t\t\t\t\tm_currentPathIndex = positionHint;\n\t\t\t\t\treturn positionHint;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pathCount < 5) {// TODO: time the performance to choose when to use\n\t\t\t\t\t\t\t// linear search.\n\t\t\tfor (int i = 0; i < pathCount; i++) {\n\t\t\t\tif (pointIndex < getPathEnd(i)) {\n\t\t\t\t\tm_currentPathIndex = i;\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new GeometryException(\"corrupted geometry\");\n\t\t}\n\n\t\t// Do binary search:\n\t\tint minPathIndex = 0;\n\t\tint maxPathIndex = pathCount - 1;\n\t\twhile (maxPathIndex > minPathIndex) {\n\t\t\tint mid = minPathIndex + ((maxPathIndex - minPathIndex) >> 1);\n\t\t\tint pathStart = getPathStart(mid);\n\t\t\tif (pointIndex < pathStart)\n\t\t\t\tmaxPathIndex = mid - 1;\n\t\t\telse {\n\t\t\t\tint pathEnd = getPathEnd(mid);\n\t\t\t\tif (pointIndex >= pathEnd)\n\t\t\t\t\tminPathIndex = mid + 1;\n\t\t\t\telse {\n\t\t\t\t\tm_currentPathIndex = mid;\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_currentPathIndex = minPathIndex;\n\t\treturn minPathIndex;\n\t}\n\n\tint getHighestPointIndex(int path_index) {\n\t\tassert (path_index >= 0 && path_index < getPathCount());\n\n\t\tAttributeStreamOfDbl position = (AttributeStreamOfDbl) (getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\t\tAttributeStreamOfInt32 paths = (AttributeStreamOfInt32) (getPathStreamRef());\n\n\t\tint path_end = getPathEnd(path_index);\n\t\tint path_start = getPathStart(path_index);\n\t\tint max_index = -1;\n\t\tPoint2D max_point = new Point2D(), pt = new Point2D();\n\t\tmax_point.y = NumberUtils.negativeInf();\n\t\tmax_point.x = NumberUtils.negativeInf();\n\n\t\tfor (int i = path_start + 0; i < path_end; i++) {\n\t\t\tposition.read(2 * i, pt);\n\t\t\tif (max_point.compare(pt) == -1) {\n\t\t\t\tmax_index = i;\n\t\t\t\tmax_point.setCoords(pt);\n\t\t\t}\n\t\t}\n\n\t\treturn max_index;\n\t}\n\n\t/**\n\t * Returns total segment count in the MultiPathImpl.\n\t */\n\tpublic int getSegmentCount() {\n\t\tint segCount = getPointCount();\n\t\tif (!m_bPolygon) {\n\t\t\tsegCount -= getPathCount();\n\t\t\tfor (int i = 0, n = getPathCount(); i < n; i++)\n\t\t\t\tif (isClosedPath(i))\n\t\t\t\t\tsegCount++;\n\t\t}\n\n\t\treturn segCount;\n\t}\n\n\tpublic int getSegmentCount(int path_index) {\n\t\tint segCount = getPathSize(path_index);\n\t\tif (!isClosedPath(path_index))\n\t\t\tsegCount--;\n\t\treturn segCount;\n\t}\n\n\t// HEADER defintions\n\t@Override\n\tpublic Geometry createInstance() {\n\t\treturn new MultiPathImpl(m_bPolygon, getDescription());\n\t}\n\n\t@Override\n\tpublic int getDimension() {\n\t\treturn m_bPolygon ? 2 : 1;\n\t}\n\n\t@Override\n\tpublic Geometry.Type getType() {\n\t\treturn m_bPolygon ? Type.Polygon : Type.Polyline;\n\t}\n\n\t/**\n\t * Returns True if the class is envelope. THis is not an exact method. Only\n\t * addEnvelope makes this true.\n\t */\n\tpublic boolean isEnvelope() {\n\t\treturn !_hasDirtyFlag(DirtyFlags.DirtyIsEnvelope);\n\t}\n\n\t/**\n\t * Returns a reference to the AttributeStream of MultiPathImpl parts\n\t * (Paths).\n\t * \n\t * For the non empty MultiPathImpl, that stream contains start points of the\n\t * MultiPathImpl curves. In addition, the last element is the total point\n\t * count. The number of vertices in a given part is parts[i + 1] - parts[i].\n\t */\n\tpublic AttributeStreamOfInt32 getPathStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_paths;\n\t}\n\n\t/**\n\t * sets a reference to an AttributeStream of MultiPathImpl paths (Paths).\n\t */\n\tpublic void setPathStreamRef(AttributeStreamOfInt32 paths) {\n\t\tm_paths = paths;\n\t\tnotifyModified(DirtyFlags.DirtyAll);\n\t}\n\n\t/**\n\t * Returns a reference to the AttributeStream of Segment flags (SegmentFlags\n\t * flags). Can be NULL when no non-linear segments are present.\n\t * \n\t * Segment flags indicate what kind of segment originates (starts) on the\n\t * given point. The last vertices of open Path parts has enumNone flag.\n\t */\n\tpublic AttributeStreamOfInt8 getSegmentFlagsStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_segmentFlags;\n\t}\n\n\t/**\n\t * Returns a reference to the AttributeStream of Path flags (PathFlags\n\t * flags).\n\t * \n\t * Each start point of a path has a flag set to indicate if the Path is open\n\t * or closed.\n\t */\n\tpublic AttributeStreamOfInt8 getPathFlagsStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_pathFlags;\n\t}\n\n\t/**\n\t * sets a reference to an AttributeStream of Path flags (PathFlags flags).\n\t */\n\tpublic void setPathFlagsStreamRef(AttributeStreamOfInt8 pathFlags) {\n\t\tm_pathFlags = pathFlags;\n\t\tnotifyModified(DirtyFlags.DirtyAll);\n\t}\n\n\tpublic AttributeStreamOfInt32 getSegmentIndexStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_segmentParamIndex;\n\t}\n\n\tpublic AttributeStreamOfDbl getSegmentDataStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_segmentParams;\n\t}\n\n\tpublic int getPathCount() {\n\t\treturn (m_paths != null) ? m_paths.size() - 1 : 0;\n\t}\n\n\tpublic int getPathEnd(int partIndex) {\n\t\treturn m_paths.read(partIndex + 1);\n\t}\n\n\tpublic int getPathSize(int partIndex) {\n\t\treturn m_paths.read(partIndex + 1) - m_paths.read(partIndex);\n\t}\n\n\tpublic int getPathStart(int partIndex) {\n\t\treturn m_paths.read(partIndex);\n\t}\n\n\t@Override\n\tpublic Object _getImpl() {\n\t\treturn this;\n\t}\n\n\tpublic void setDirtyOGCFlags(boolean bYesNo) {\n\t\t_setDirtyFlag(DirtyFlags.DirtyOGCFlags, bYesNo);\n\t}\n\n\tpublic boolean hasDirtyOGCStartFlags() {\n\t\treturn _hasDirtyFlag(DirtyFlags.DirtyOGCFlags);\n\t}\n\n\tpublic void setDirtyRingAreas2D(boolean bYesNo) {\n\t\t_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, bYesNo);\n\t}\n\n\tpublic boolean hasDirtyRingAreas2D() {\n\t\treturn _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);\n\t}\n\n\tpublic void setRingAreasStreamRef(AttributeStreamOfDbl ringAreas) {\n\t\tm_cachedRingAreas2D = ringAreas;\n\t\t_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);\n\t}\n\n\t// HEADER defintions\n\n\t// // TODO check this against current implementation in native\n\t// public void notifyModified(int flags)\n\t// {\n\t// if(flags == DirtyFlags.DirtyAll)\n\t// {\n\t// m_reservedPointCount = -1;\n\t// _notifyModifiedAllImpl();\n\t// }\n\t// m_flagsMask |= flags;\n\t// _clearAccelerators();\n\t//\n\t//\n\t// // ROHIT's implementation\n\t// // if (m_paths == null || 0 == m_paths.size())\n\t// // m_pointCount = 0;\n\t// // else\n\t// // m_pointCount = m_paths.read(m_paths.size() - 1);\n\t// //\n\t// // super.notifyModified(flags);\n\t// }\n\n\t@Override\n\tpublic boolean _buildRasterizedGeometryAccelerator(double toleranceXY,\n\t\t\tGeometryAccelerationDegree accelDegree) {\n\t\tif (m_accelerators == null)// (!m_accelerators)\n\t\t{\n\t\t\tm_accelerators = new GeometryAccelerators();\n\t\t}\n\n\t\tint rasterSize = RasterizedGeometry2D\n\t\t\t\t.rasterSizeFromAccelerationDegree(accelDegree);\n\t\tRasterizedGeometry2D rgeom = m_accelerators.getRasterizedGeometry();\n\t\tif (rgeom != null) {\n\t\t\tif (rgeom.getToleranceXY() < toleranceXY\n\t\t\t\t\t|| rasterSize > rgeom.getRasterSize()) {\n\t\t\t\tm_accelerators._setRasterizedGeometry(null);\n\t\t\t} else\n\t\t\t\treturn true;\n\t\t}\n\n\t\trgeom = RasterizedGeometry2D.create(this, toleranceXY, rasterSize);\n\t\tm_accelerators._setRasterizedGeometry(rgeom);\n\t\t//rgeom.dbgSaveToBitmap(\"c:/temp/ddd.bmp\");\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\n\t\tif (!isEmptyImpl()) {\n\t\t\tint pathCount = getPathCount();\n\n\t\t\tif (m_paths != null)\n\t\t\t\tm_paths.calculateHashImpl(hashCode, 0, pathCount + 1);\n\n\t\t\tif (m_pathFlags != null)\n\t\t\t\tm_pathFlags.calculateHashImpl(hashCode, 0, pathCount);\n\t\t}\n\n\t\treturn hashCode;\n\t}\n\n\tpublic byte getSegmentFlags(int ivertex) {\n\t\tif (m_segmentFlags != null)\n\t\t\treturn m_segmentFlags.read(ivertex);\n\t\telse\n\t\t\treturn (byte) SegmentFlags.enumLineSeg;\n\t}\n\n\tpublic void getSegment(int startVertexIndex, SegmentBuffer segBuffer,\n\t\t\tboolean bStripAttributes) {\n\t\tint ipath = getPathIndexFromPointIndex(startVertexIndex);\n\t\tif (startVertexIndex == getPathEnd(ipath) - 1 && !isClosedPath(ipath))\n\t\t\tthrow new GeometryException(\"index out of bounds\");\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfInt8 segFlagStream = getSegmentFlagsStreamRef();\n\t\tint segFlag = SegmentFlags.enumLineSeg;\n\t\tif (segFlagStream != null)\n\t\t\tsegFlag = segFlagStream.read(startVertexIndex)\n\t\t\t\t\t& SegmentFlags.enumSegmentMask;\n\n\t\tswitch (segFlag) {\n\t\tcase SegmentFlags.enumLineSeg:\n\t\t\tsegBuffer.createLine();\n\t\t\tbreak;\n\t\tcase SegmentFlags.enumBezierSeg:\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\tcase SegmentFlags.enumArcSeg:\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\tdefault:\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\n\t\tSegment currentSegment = segBuffer.get();\n\t\tif (!bStripAttributes)\n\t\t\tcurrentSegment.assignVertexDescription(m_description);\n\t\telse\n\t\t\tcurrentSegment\n\t\t\t\t\t.assignVertexDescription(VertexDescriptionDesignerImpl\n\t\t\t\t\t\t\t.getDefaultDescriptor2D());\n\n\t\tint endVertexIndex;\n\t\tif (startVertexIndex == getPathEnd(ipath) - 1 && isClosedPath(ipath)) {\n\t\t\tendVertexIndex = getPathStart(ipath);\n\t\t} else\n\t\t\tendVertexIndex = startVertexIndex + 1;\n\n\t\tPoint2D pt = new Point2D();\n\t\tgetXY(startVertexIndex, pt);\n\t\tcurrentSegment.setStartXY(pt);\n\t\tgetXY(endVertexIndex, pt);\n\t\tcurrentSegment.setEndXY(pt);\n\n\t\tif (!bStripAttributes) {\n\t\t\tfor (int i = 1, nattr = m_description.getAttributeCount(); i < nattr; i++) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(i);\n\t\t\t\tint ncomp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tfor (int ord = 0; ord < ncomp; ord++) {\n\t\t\t\t\tdouble vs = getAttributeAsDbl(semantics, startVertexIndex,\n\t\t\t\t\t\t\tord);\n\t\t\t\t\tcurrentSegment.setStartAttribute(semantics, ord, vs);\n\t\t\t\t\tdouble ve = getAttributeAsDbl(semantics, endVertexIndex,\n\t\t\t\t\t\t\tord);\n\t\t\t\t\tcurrentSegment.setEndAttribute(semantics, ord, ve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid queryPathEnvelope2D(int path_index, Envelope2D envelope) {\n\t\tif (path_index >= getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (isEmpty()) {\n\t\t\tenvelope.setEmpty();\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasNonLinearSegments(path_index)) {\n\t\t\tthrow new GeometryException(\"not implemented\");\n\t\t} else {\n\t\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tenv.setEmpty();\n\t\t\tfor (int i = getPathStart(path_index), iend = getPathEnd(path_index); i < iend; i++) {\n\t\t\t\tstream.read(2 * i, pt);\n\t\t\t\tenv.merge(pt);\n\t\t\t}\n\t\t\tenvelope.setCoords(env);\n\t\t}\n\t}\n\n\tpublic void queryLoosePathEnvelope2D(int path_index, Envelope2D envelope) {\n\t\tif (path_index >= getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (isEmpty()) {\n\t\t\tenvelope.setEmpty();\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasNonLinearSegments(path_index)) {\n\t\t\tthrow new GeometryException(\"not implemented\");\n\t\t} else {\n\t\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tenv.setEmpty();\n\t\t\tfor (int i = getPathStart(path_index), iend = getPathEnd(path_index); i < iend; i++) {\n\t\t\t\tstream.read(2 * i, pt);\n\t\t\t\tenv.merge(pt);\n\t\t\t}\n\t\t\tenvelope.setCoords(env);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean _buildQuadTreeAccelerator(GeometryAccelerationDegree d) {\n\t\tif (m_accelerators == null)// (!m_accelerators)\n\t\t{\n\t\t\tm_accelerators = new GeometryAccelerators();\n\t\t}\n\n\t\tif (d == GeometryAccelerationDegree.enumMild || getPointCount() < 16)\n\t\t\treturn false;\n\n\t\tQuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTree(this);\n\t\tm_accelerators._setQuadTree(quad_tree_impl);\n\n\t\treturn true;\n\t}\n\n\tboolean _buildQuadTreeForPathsAccelerator(GeometryAccelerationDegree degree) {\n\t\tif (m_accelerators == null) {\n\t\t\tm_accelerators = new GeometryAccelerators();\n\t\t}\n\n\t\t// TODO: when less than two envelopes - no need to this.\n\n\t\tif (m_accelerators.getQuadTreeForPaths() != null)\n\t\t\treturn true;\n\n\t\tm_accelerators._setQuadTreeForPaths(null);\n\t\tQuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTreeForPaths(this);\n\t\tm_accelerators._setQuadTreeForPaths(quad_tree_impl);\n\n\t\treturn true;\n\t}\n\n\tvoid setFillRule(int rule) {\n\t\tassert (m_bPolygon);\n\t\tm_fill_rule = rule;\n\t}\n\n\tint getFillRule() {\n\t\treturn m_fill_rule;\n\t}\n\n\tvoid clearDirtyOGCFlags() { \n\t\t_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);\n\t}\n}", "language": "java", "code": "void interpolateAttributes(int from_path_index, int from_point_index,\n\t\t\tint to_path_index, int to_point_index) {\n\t\tfor (int ipath = from_path_index; ipath < to_path_index - 1; ipath++) {\n\t\t\tif (isClosedPath(ipath))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"cannot interpolate across closed paths\");\n\t\t}\n\n\t\tint nattr = m_description.getAttributeCount();\n\n\t\tif (nattr == 1)\n\t\t\treturn; // only has position\n\n\t\tdouble sub_length = calculateSubLength2D(from_path_index,\n\t\t\t\tfrom_point_index, to_path_index, to_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tfor (int iattr = 1; iattr < nattr; iattr++) {\n\t\t\tint semantics = m_description.getSemantics(iattr);\n\n\t\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\t\tcontinue;\n\n\t\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\t\tinterpolateAttributes_(semantics, from_path_index,\n\t\t\t\t\t\tfrom_point_index, to_path_index, to_point_index,\n\t\t\t\t\t\tsub_length, ordinate);\n\t\t}\n\t}\n\n\t// TODO: Add code for interpolation type (none and angular)\n\tvoid interpolateAttributesForSemantics(int semantics, int from_path_index,\n\t\t\tint from_point_index, int to_path_index, int to_point_index) {\n\t\tif (semantics == VertexDescription.Semantics.POSITION)\n\t\t\treturn;\n\n\t\tif (!hasAttribute(semantics))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"does not have the given attribute\");\n\n\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"not implemented for the given semantics\");\n\n\t\tfor (int ipath = from_path_index; ipath < to_path_index - 1; ipath++) {\n\t\t\tif (isClosedPath(ipath))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"cannot interpolate across closed paths\");\n\t\t}\n\n\t\tdouble sub_length = calculateSubLength2D(from_path_index,\n\t\t\t\tfrom_point_index, to_path_index, to_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\tinterpolateAttributes_(semantics, from_path_index,\n\t\t\t\t\tfrom_point_index, to_path_index, to_point_index,\n\t\t\t\t\tsub_length, ordinate);\n\t}\n\n\tvoid interpolateAttributes(int path_index, int from_point_index,\n\t\t\tint to_point_index) {\n\t\tint nattr = m_description.getAttributeCount();\n\n\t\tif (nattr == 1)\n\t\t\treturn; // only has position\n\n\t\tdouble sub_length = calculateSubLength2D(path_index, from_point_index,\n\t\t\t\tto_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tfor (int iattr = 1; iattr < nattr; iattr++) {\n\t\t\tint semantics = m_description.getSemantics(iattr);\n\n\t\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\t\tcontinue;\n\n\t\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\t\tinterpolateAttributes_(semantics, path_index, from_point_index,\n\t\t\t\t\t\tto_point_index, sub_length, ordinate);\n\t\t}\n\t}\n\n\tvoid interpolateAttributesForSemantics(int semantics, int path_index,\n\t\t\tint from_point_index, int to_point_index) {\n\t\tif (semantics == VertexDescription.Semantics.POSITION)\n\t\t\treturn;\n\n\t\tif (!hasAttribute(semantics))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"does not have the given attribute\");\n\n\t\tint interpolation = VertexDescription.getInterpolation(semantics);\n\t\tif (interpolation == VertexDescription.Interpolation.ANGULAR)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"not implemented for the given semantics\");\n\n\t\tdouble sub_length = calculateSubLength2D(path_index, from_point_index,\n\t\t\t\tto_point_index);\n\n\t\tif (sub_length == 0.0)\n\t\t\treturn;\n\n\t\tint components = VertexDescription.getComponentCount(semantics);\n\n\t\tfor (int ordinate = 0; ordinate < components; ordinate++)\n\t\t\tinterpolateAttributes_(semantics, path_index, from_point_index,\n\t\t\t\t\tto_point_index, sub_length, ordinate);\n\t}\n\n\t// TODO: Add code fore interpolation type (none and angular)\n\tvoid interpolateAttributes_(int semantics, int from_path_index,\n\t\t\tint from_point_index, int to_path_index, int to_point_index,\n\t\t\tdouble sub_length, int ordinate) {\n\t\tSegmentIteratorImpl seg_iter = querySegmentIterator();\n\n\t\tint absolute_from_index = getPathStart(from_path_index)\n\t\t\t\t+ from_point_index;\n\t\tint absolute_to_index = getPathStart(to_path_index) + to_point_index;\n\n\t\tdouble from_attribute = getAttributeAsDbl(semantics,\n\t\t\t\tabsolute_from_index, ordinate);\n\t\tdouble to_attribute = getAttributeAsDbl(semantics, absolute_to_index,\n\t\t\t\tordinate);\n\t\tdouble interpolated_attribute = from_attribute;\n\t\tdouble cumulative_length = 0.0;\n\n\t\tseg_iter.resetToVertex(absolute_from_index);\n\n\t\tdo {\n\t\t\tif (seg_iter.hasNextSegment()) {\n\t\t\t\tseg_iter.nextSegment();\n\n\t\t\t\tif (seg_iter.getStartPointIndex() == absolute_to_index)\n\t\t\t\t\treturn;\n\n\t\t\t\tsetAttribute(semantics, seg_iter.getStartPointIndex(),\n\t\t\t\t\t\tordinate, interpolated_attribute);\n\n\t\t\t\tseg_iter.previousSegment();\n\n\t\t\t\tdo {\n\t\t\t\t\tSegment segment = seg_iter.nextSegment();\n\n\t\t\t\t\tif (seg_iter.getEndPointIndex() == absolute_to_index)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tdouble segment_length = segment.calculateLength2D();\n\t\t\t\t\tcumulative_length += segment_length;\n\t\t\t\t\tdouble t = cumulative_length / sub_length;\n\t\t\t\t\tinterpolated_attribute = MathUtils.lerp(from_attribute,  to_attribute, t);\n\n\t\t\t\t\tif (!seg_iter.isClosingSegment())\n\t\t\t\t\t\tsetAttribute(semantics, seg_iter.getEndPointIndex(),\n\t\t\t\t\t\t\t\tordinate, interpolated_attribute);\n\n\t\t\t\t} while (seg_iter.hasNextSegment());\n\t\t\t}\n\n\t\t} while (seg_iter.nextPath());\n\t}\n\n\tvoid interpolateAttributes_(int semantics, int path_index,\n\t\t\tint from_point_index, int to_point_index, double sub_length,\n\t\t\tint ordinate) {\n\t\tassert (m_bPolygon);\n\t\tSegmentIteratorImpl seg_iter = querySegmentIterator();\n\n\t\tint absolute_from_index = getPathStart(path_index) + from_point_index;\n\t\tint absolute_to_index = getPathStart(path_index) + to_point_index;\n\n\t\tif (absolute_to_index == absolute_from_index)\n\t\t\treturn;\n\n\t\tdouble from_attribute = getAttributeAsDbl(semantics,\n\t\t\t\tabsolute_from_index, ordinate);\n\t\tdouble to_attribute = getAttributeAsDbl(semantics, absolute_to_index,\n\t\t\t\tordinate);\n\t\tdouble cumulative_length = 0.0;\n\n\t\tseg_iter.resetToVertex(absolute_from_index);\n\t\tseg_iter.setCirculator(true);\n\n\t\tdouble prev_interpolated_attribute = from_attribute;\n\n\t\tdo {\n\t\t\tSegment segment = seg_iter.nextSegment();\n\t\t\tsetAttribute(semantics, seg_iter.getStartPointIndex(), ordinate,\n\t\t\t\t\tprev_interpolated_attribute);\n\n\t\t\tdouble segment_length = segment.calculateLength2D();\n\t\t\tcumulative_length += segment_length;\n\t\t\tdouble t = cumulative_length / sub_length;\n\t\t\tprev_interpolated_attribute = MathUtils.lerp(from_attribute, to_attribute, t);\n\n\t\t} while (seg_iter.getEndPointIndex() != absolute_to_index);\n\t}\n\n\t@Override\n\tpublic void setEmpty() {\n\t\tm_curveParamwritePoint = 0;\n\t\tm_bPathStarted = false;\n\t\tm_paths = null;\n\t\tm_pathFlags = null;\n\t\tm_segmentParamIndex = null;\n\t\tm_segmentFlags = null;\n\t\tm_segmentParams = null;\n\t\t_setEmptyImpl();\n\t}\n\n\t@Override\n\tpublic void applyTransformation(Transformation2D transform) {\n\t\tapplyTransformation(transform, -1);\n\t}\n\n\tpublic void applyTransformation(Transformation2D transform, int pathIndex) {\n\t\tif (isEmpty())\n\t\t\treturn;\n\n\t\tif (transform.isIdentity())\n\t\t\treturn;\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint2D ptStart = new Point2D();\n\t\tPoint2D ptControl = new Point2D();\n\n\t\tboolean bHasNonLinear;\n\t\tint fistIdx;\n\t\tint lastIdx;\n\t\tif (pathIndex < 0) {\n\t\t\tbHasNonLinear = hasNonLinearSegments();\n\t\t\tfistIdx = 0;\n\t\t\tlastIdx = m_pointCount;\n\t\t} else {\n\t\t\tbHasNonLinear = hasNonLinearSegments(pathIndex);\n\t\t\tfistIdx = getPathStart(pathIndex);\n\t\t\tlastIdx = getPathEnd(pathIndex);\n\t\t}\n\n\t\tfor (int ipoint = fistIdx; ipoint < lastIdx; ipoint++) {\n\t\t\tptStart.x = points.read(ipoint * 2);\n\t\t\tptStart.y = points.read(ipoint * 2 + 1);\n\n\t\t\tif (bHasNonLinear) {\n\t\t\t\tint segIndex = m_segmentParamIndex.read(ipoint);\n\t\t\t\tif (segIndex >= 0) {\n\t\t\t\t\tint segmentType = (int) m_segmentFlags.read(ipoint);\n\t\t\t\t\tint type = segmentType & SegmentFlags.enumSegmentMask;\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SegmentFlags.enumBezierSeg: {\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 1);\n\t\t\t\t\t\ttransform.transform(ptControl, ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 1, ptControl.y);\n\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex + 3);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 4);\n\t\t\t\t\t\ttransform.transform(ptControl, ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 3, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 4, ptControl.y);\n\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SegmentFlags.enumArcSeg:\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttransform.transform(ptStart, ptStart);\n\t\t\tpoints.write(ipoint * 2, ptStart.x);\n\t\t\tpoints.write(ipoint * 2 + 1, ptStart.y);\n\t\t}\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t\t// REFACTOR: reset the exact envelope only and transform the loose\n\t\t// envelope\n\t}\n\n\t@Override\n\tpublic void applyTransformation(Transformation3D transform) {\n\t\tif (isEmpty())\n\t\t\treturn;\n\n\t\taddAttribute(VertexDescription.Semantics.Z);\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tAttributeStreamOfDbl zs = (AttributeStreamOfDbl) m_vertexAttributes[1];\n\t\tPoint3D ptStart = new Point3D();\n\t\tPoint3D ptControl = new Point3D();\n\t\tboolean bHasNonLinear = hasNonLinearSegments();\n\t\tfor (int ipoint = 0; ipoint < m_pointCount; ipoint++) {\n\t\t\tptStart.x = points.read(ipoint * 2);\n\t\t\tptStart.y = points.read(ipoint * 2 + 1);\n\t\t\tptStart.z = zs.read(ipoint);\n\n\t\t\tif (bHasNonLinear) {\n\t\t\t\tint segIndex = m_segmentParamIndex.read(ipoint);\n\t\t\t\tif (segIndex >= 0) {\n\t\t\t\t\tint segmentType = (int) m_segmentFlags.read(ipoint);\n\t\t\t\t\tint type = segmentType & (int) SegmentFlags.enumSegmentMask;\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SegmentFlags.enumBezierSeg: {\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 1);\n\t\t\t\t\t\tptControl.z = m_segmentParams.read(segIndex + 2);\n\t\t\t\t\t\tptControl = transform.transform(ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 1, ptControl.y);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 1, ptControl.z);\n\n\t\t\t\t\t\tptControl.x = m_segmentParams.read(segIndex + 3);\n\t\t\t\t\t\tptControl.y = m_segmentParams.read(segIndex + 4);\n\t\t\t\t\t\tptControl.z = m_segmentParams.read(segIndex + 5);\n\t\t\t\t\t\tptControl = transform.transform(ptControl);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 3, ptControl.x);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 4, ptControl.y);\n\t\t\t\t\t\tm_segmentParams.write(segIndex + 5, ptControl.z);\n\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SegmentFlags.enumArcSeg:\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptStart = transform.transform(ptStart);\n\t\t\tpoints.write(ipoint * 2, ptStart.x);\n\t\t\tpoints.write(ipoint * 2 + 1, ptStart.y);\n\t\t\tzs.write(ipoint, ptStart.z);\n\t\t}\n\n\t\t// REFACTOR: reset the exact envelope only and transform the loose\n\t\t// envelope\n\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}\n\n\t@Override\n\tprotected void _verifyStreamsImpl() {\n\t\tif (m_paths == null) {\n\t\t\tm_paths = (AttributeStreamOfInt32) AttributeStreamBase\n\t\t\t\t\t.createIndexStream(1, 0);\n\t\t\tm_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t.createByteStream(1, (byte) 0);\n\t\t}\n\n\t\tif (m_segmentFlags != null) {\n\t\t\tm_segmentFlags.resize(m_reservedPointCount,\n\t\t\t\t\t(byte) SegmentFlags.enumLineSeg);\n\t\t\tm_segmentParamIndex.resize(m_reservedPointCount, -1);\n\t\t}\n\t}\n\n\t@Override\n\tvoid _copyToImpl(MultiVertexGeometryImpl dst) {\n\t\tMultiPathImpl dstPoly = (MultiPathImpl) dst;\n\t\tdstPoly.m_bPathStarted = false;\n\t\tdstPoly.m_curveParamwritePoint = m_curveParamwritePoint;\n\t\tdstPoly.m_fill_rule = m_fill_rule;\n\t\t\n\t\tif (m_paths != null)\n\t\t\tdstPoly.m_paths = new AttributeStreamOfInt32(m_paths);\n\t\telse\n\t\t\tdstPoly.m_paths = null;\n\n\t\tif (m_pathFlags != null)\n\t\t\tdstPoly.m_pathFlags = new AttributeStreamOfInt8(m_pathFlags);\n\t\telse\n\t\t\tdstPoly.m_pathFlags = null;\n\n\t\tif (m_segmentParamIndex != null)\n\t\t\tdstPoly.m_segmentParamIndex = new AttributeStreamOfInt32(\n\t\t\t\t\tm_segmentParamIndex);\n\t\telse\n\t\t\tdstPoly.m_segmentParamIndex = null;\n\n\t\tif (m_segmentFlags != null)\n\t\t\tdstPoly.m_segmentFlags = new AttributeStreamOfInt8(m_segmentFlags);\n\t\telse\n\t\t\tdstPoly.m_segmentFlags = null;\n\n\t\tif (m_segmentParams != null)\n\t\t\tdstPoly.m_segmentParams = new AttributeStreamOfDbl(m_segmentParams);\n\t\telse\n\t\t\tdstPoly.m_segmentParams = null;\n\n\t\tdstPoly.m_cachedLength2D = m_cachedLength2D;\n\t\tdstPoly.m_cachedArea2D = m_cachedArea2D;\n\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {\n\t\t\tdstPoly.m_cachedRingAreas2D = (AttributeStreamOfDbl) m_cachedRingAreas2D;\n\t\t} else\n\t\t\tdstPoly.m_cachedRingAreas2D = null;\n\n\t}\n\n\t@Override\n\tpublic double calculateLength2D() {\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyLength2D)) {\n\t\t\treturn m_cachedLength2D;\n\t\t}\n\n\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\tMathUtils.KahanSummator len = new MathUtils.KahanSummator(0);\n\t\twhile (segIter.nextPath()) {\n\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\tlen.add(segIter.nextSegment().calculateLength2D());\n\t\t\t}\n\t\t}\n\n\t\tm_cachedLength2D = len.getResult();\n\t\t_setDirtyFlag(DirtyFlags.DirtyLength2D, false);\n\n\t\treturn len.getResult();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\tif (other == this)\n\t\t\treturn true;\n\n\t\tif (!(other instanceof MultiPathImpl))\n\t\t\treturn false;\n\n\t\tif (!super.equals(other))\n\t\t\treturn false;\n\n\t\tMultiPathImpl otherMultiPath = (MultiPathImpl) other;\n\n\t\tint pathCount = getPathCount();\n\t\tint pathCountOther = otherMultiPath.getPathCount();\n\n\t\tif (pathCount != pathCountOther)\n\t\t\treturn false;\n\n\t\tif (pathCount > 0 && m_paths != null\n\t\t\t\t&& !m_paths.equals(otherMultiPath.m_paths, 0, pathCount + 1))\n\t\t\treturn false;\n\n\t\tif (m_fill_rule != otherMultiPath.m_fill_rule)\n\t\t\treturn false;\n\n\t\t{\n\t\t\t// Note: OGC flags do not participate in the equals operation by\n\t\t\t// design.\n\t\t\t// Because for the polygon pathFlags will have all enum_closed set,\n\t\t\t// we do not need to compare this stream. Only for polyline.\n\t\t\t// Polyline does not have OGC flags set.\n\t\t\tif (!m_bPolygon) {\n\t\t\t\tif (m_pathFlags != null\n\t\t\t\t\t\t&& !m_pathFlags.equals(otherMultiPath.m_pathFlags, 0,\n\t\t\t\t\t\t\t\tpathCount))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t      \n\t\treturn super.equals(other);\n\t}\n\n\t/**\n\t * Returns a SegmentIterator that set to a specific vertex of the\n\t * MultiPathImpl. The call to NextSegment will return the segment that\n\t * starts at the vertex. Call to PreviousSegment will return the segment\n\t * that starts at the previous vertex.\n\t */\n\tpublic SegmentIteratorImpl querySegmentIteratorAtVertex(int startVertexIndex) {\n\t\tif (startVertexIndex < 0 || startVertexIndex >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tSegmentIteratorImpl iter = new SegmentIteratorImpl(this,\n\t\t\t\tstartVertexIndex);\n\t\treturn iter;\n\t}\n\n\t// void QuerySegmentIterator(int fromVertex, SegmentIterator iterator);\n\tpublic SegmentIteratorImpl querySegmentIterator() {\n\t\treturn new SegmentIteratorImpl(this);\n\t}\n\n\t@Override\n\tpublic void _updateXYImpl(boolean bExact) {\n\t\tsuper._updateXYImpl(bExact);\n\t\tboolean bHasCurves = hasNonLinearSegments();\n\t\tif (bHasCurves) {\n\t\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\t\twhile (segIter.nextPath()) {\n\t\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\t\tSegment curve = segIter.nextCurve();\n\t\t\t\t\tif (curve != null) {\n\t\t\t\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\t\t\t\tcurve.queryEnvelope2D(env2D);\n\t\t\t\t\t\tm_envelope.merge(env2D);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tvoid calculateEnvelope2D(Envelope2D env, boolean bExact) {\n\t\tsuper.calculateEnvelope2D(env, bExact);\n\t\tboolean bHasCurves = hasNonLinearSegments();\n\t\tif (bHasCurves) {\n\t\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\t\twhile (segIter.nextPath()) {\n\t\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\t\tSegment curve = segIter.nextCurve();\n\t\t\t\t\tif (curve != null) {\n\t\t\t\t\t\tEnvelope2D env2D = new Envelope2D();\n\t\t\t\t\t\tcurve.queryEnvelope2D(env2D);\n\t\t\t\t\t\tenv.merge(env2D);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void _notifyModifiedAllImpl() {\n\t\tif (m_paths == null || m_paths.size() == 0)// if (m_paths == null ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t// !m_paths.size())\n\t\t\tm_pointCount = 0;\n\t\telse\n\t\t\tm_pointCount = m_paths.read(m_paths.size() - 1);\n\t}\n\n\t@Override\n\tpublic double calculateArea2D() {\n\t\tif (!m_bPolygon)\n\t\t\treturn 0.0;\n\n\t\t_updateRingAreas2D();\n\n\t\treturn m_cachedArea2D;\n\t}\n\n\t/**\n\t * Returns True if the ring is an exterior ring. Valid only for simple\n\t * polygons.\n\t */\n\tpublic boolean isExteriorRing(int ringIndex) {\n\t\tif (!m_bPolygon)\n\t\t\treturn false;\n\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))\n\t\t\treturn (m_pathFlags.read(ringIndex) & (byte) PathFlags.enumOGCStartPolygon) != 0;\n\n\t\t_updateRingAreas2D();\n\t\treturn m_cachedRingAreas2D.read(ringIndex) > 0;\n\t\t// Should we make a function called _UpdateHasNonLinearSegmentsFlags and\n\t\t// call it here?\n\t}\n\n\tpublic double calculateRingArea2D(int pathIndex) {\n\t\tif (!m_bPolygon)\n\t\t\treturn 0.0;\n\n\t\t_updateRingAreas2D();\n\n\t\treturn m_cachedRingAreas2D.read(pathIndex);\n\t}\n\n\tpublic void _updateRingAreas2D() {\n\t\tif (_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {\n\t\t\tint pathCount = getPathCount();\n\n\t\t\tif (m_cachedRingAreas2D == null)\n\t\t\t\tm_cachedRingAreas2D = new AttributeStreamOfDbl(pathCount);\n\t\t\telse if (m_cachedRingAreas2D.size() != pathCount)\n\t\t\t\tm_cachedRingAreas2D.resize(pathCount);\n\n\t\t\tMathUtils.KahanSummator totalArea = new MathUtils.KahanSummator(0);\n\t\t\tMathUtils.KahanSummator pathArea = new MathUtils.KahanSummator(0);\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tint ipath = 0;\n\t\t\tSegmentIteratorImpl segIter = querySegmentIterator();\n\t\t\twhile (segIter.nextPath()) {\n\t\t\t\tpathArea.reset();\n\t\t\t\tgetXY(getPathStart(segIter.getPathIndex()), pt);// get the area\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// calculation\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// origin to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the origin of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the ring.\n\t\t\t\twhile (segIter.hasNextSegment()) {\n\t\t\t\t\tpathArea.add(segIter.nextSegment()._calculateArea2DHelper(\n\t\t\t\t\t\t\tpt.x, pt.y));\n\t\t\t\t}\n\n\t\t\t\ttotalArea.add(pathArea.getResult());\n\n\t\t\t\tint i = ipath++;\n\t\t\t\tm_cachedRingAreas2D.write(i, pathArea.getResult());\n\t\t\t}\n\n\t\t\tm_cachedArea2D = totalArea.getResult();\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);\n\t\t}\n\t}\n\n\tint getOGCPolygonCount() {\n\t\tif (!m_bPolygon)\n\t\t\treturn 0;\n\n\t\t_updateOGCFlags();\n\n\t\tint polygonCount = 0;\n\t\tint partCount = getPathCount();\n\t\tfor (int ipart = 0; ipart < partCount; ipart++) {\n\t\t\tif (((int) m_pathFlags.read(ipart) & (int) PathFlags.enumOGCStartPolygon) != 0)\n\t\t\t\tpolygonCount++;\n\t\t}\n\n\t\treturn polygonCount;\n\t}\n\n\tprotected void _updateOGCFlags() {\n\t\tif (_hasDirtyFlag(DirtyFlags.DirtyOGCFlags)) {\n\t\t\t_updateRingAreas2D();\n\n\t\t\tint pathCount = getPathCount();\n\t\t\tif (pathCount > 0 && (m_pathFlags == null || m_pathFlags.size() < pathCount))\n\t\t\t\tm_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase\n\t\t\t\t\t\t.createByteStream(pathCount + 1);\n\n\t\t\tint firstSign = 1;\n\t\t\tfor (int ipath = 0; ipath < pathCount; ipath++) {\n\t\t\t\tdouble area = m_cachedRingAreas2D.read(ipath);\n\t\t\t\tif (ipath == 0)\n\t\t\t\t\tfirstSign = area > 0 ? 1 : -1;\n\t\t\t\tif (area * firstSign > 0.0)\n\t\t\t\t\tm_pathFlags.setBits(ipath,\n\t\t\t\t\t\t\t(byte) PathFlags.enumOGCStartPolygon);\n\t\t\t\telse\n\t\t\t\t\tm_pathFlags.clearBits(ipath,\n\t\t\t\t\t\t\t(byte) PathFlags.enumOGCStartPolygon);\n\t\t\t}\n\t\t\t_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);\n\t\t}\n\t}\n\n\tpublic int getPathIndexFromPointIndex(int pointIndex) {\n\t\tint positionHint = m_currentPathIndex;// in case of multithreading\n\t\t\t\t\t\t\t\t\t\t\t\t// thiswould simply produce an\n\t\t\t\t\t\t\t\t\t\t\t\t// invalid value\n\t\tint pathCount = getPathCount();\n\n\t\t// Try using the hint position first to get the path index.\n\t\tif (positionHint >= 0 && positionHint < pathCount) {\n\t\t\tif (pointIndex < getPathEnd(positionHint)) {\n\t\t\t\tif (pointIndex >= getPathStart(positionHint))\n\t\t\t\t\treturn positionHint;\n\t\t\t\tpositionHint--;\n\t\t\t} else {\n\t\t\t\tpositionHint++;\n\t\t\t}\n\n\t\t\tif (positionHint >= 0 && positionHint < pathCount) {\n\t\t\t\tif (pointIndex >= getPathStart(positionHint)\n\t\t\t\t\t\t&& pointIndex < getPathEnd(positionHint)) {\n\t\t\t\t\tm_currentPathIndex = positionHint;\n\t\t\t\t\treturn positionHint;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pathCount < 5) {// TODO: time the performance to choose when to use\n\t\t\t\t\t\t\t// linear search.\n\t\t\tfor (int i = 0; i < pathCount; i++) {\n\t\t\t\tif (pointIndex < getPathEnd(i)) {\n\t\t\t\t\tm_currentPathIndex = i;\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new GeometryException(\"corrupted geometry\");\n\t\t}\n\n\t\t// Do binary search:\n\t\tint minPathIndex = 0;\n\t\tint maxPathIndex = pathCount - 1;\n\t\twhile (maxPathIndex > minPathIndex) {\n\t\t\tint mid = minPathIndex + ((maxPathIndex - minPathIndex) >> 1);\n\t\t\tint pathStart = getPathStart(mid);\n\t\t\tif (pointIndex < pathStart)\n\t\t\t\tmaxPathIndex = mid - 1;\n\t\t\telse {\n\t\t\t\tint pathEnd = getPathEnd(mid);\n\t\t\t\tif (pointIndex >= pathEnd)\n\t\t\t\t\tminPathIndex = mid + 1;\n\t\t\t\telse {\n\t\t\t\t\tm_currentPathIndex = mid;\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_currentPathIndex = minPathIndex;\n\t\treturn minPathIndex;\n\t}\n\n\tint getHighestPointIndex(int path_index) {\n\t\tassert (path_index >= 0 && path_index < getPathCount());\n\n\t\tAttributeStreamOfDbl position = (AttributeStreamOfDbl) (getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\t\tAttributeStreamOfInt32 paths = (AttributeStreamOfInt32) (getPathStreamRef());\n\n\t\tint path_end = getPathEnd(path_index);\n\t\tint path_start = getPathStart(path_index);\n\t\tint max_index = -1;\n\t\tPoint2D max_point = new Point2D(), pt = new Point2D();\n\t\tmax_point.y = NumberUtils.negativeInf();\n\t\tmax_point.x = NumberUtils.negativeInf();\n\n\t\tfor (int i = path_start + 0; i < path_end; i++) {\n\t\t\tposition.read(2 * i, pt);\n\t\t\tif (max_point.compare(pt) == -1) {\n\t\t\t\tmax_index = i;\n\t\t\t\tmax_point.setCoords(pt);\n\t\t\t}\n\t\t}\n\n\t\treturn max_index;\n\t}\n\n\t/**\n\t * Returns total segment count in the MultiPathImpl.\n\t */\n\tpublic int getSegmentCount() {\n\t\tint segCount = getPointCount();\n\t\tif (!m_bPolygon) {\n\t\t\tsegCount -= getPathCount();\n\t\t\tfor (int i = 0, n = getPathCount(); i < n; i++)\n\t\t\t\tif (isClosedPath(i))\n\t\t\t\t\tsegCount++;\n\t\t}\n\n\t\treturn segCount;\n\t}\n\n\tpublic int getSegmentCount(int path_index) {\n\t\tint segCount = getPathSize(path_index);\n\t\tif (!isClosedPath(path_index))\n\t\t\tsegCount--;\n\t\treturn segCount;\n\t}\n\n\t// HEADER defintions\n\t@Override\n\tpublic Geometry createInstance() {\n\t\treturn new MultiPathImpl(m_bPolygon, getDescription());\n\t}\n\n\t@Override\n\tpublic int getDimension() {\n\t\treturn m_bPolygon ? 2 : 1;\n\t}\n\n\t@Override\n\tpublic Geometry.Type getType() {\n\t\treturn m_bPolygon ? Type.Polygon : Type.Polyline;\n\t}\n\n\t/**\n\t * Returns True if the class is envelope. THis is not an exact method. Only\n\t * addEnvelope makes this true.\n\t */\n\tpublic boolean isEnvelope() {\n\t\treturn !_hasDirtyFlag(DirtyFlags.DirtyIsEnvelope);\n\t}\n\n\t/**\n\t * Returns a reference to the AttributeStream of MultiPathImpl parts\n\t * (Paths).\n\t * \n\t * For the non empty MultiPathImpl, that stream contains start points of the\n\t * MultiPathImpl curves. In addition, the last element is the total point\n\t * count. The number of vertices in a given part is parts[i + 1] - parts[i].\n\t */\n\tpublic AttributeStreamOfInt32 getPathStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_paths;\n\t}\n\n\t/**\n\t * sets a reference to an AttributeStream of MultiPathImpl paths (Paths).\n\t */\n\tpublic void setPathStreamRef(AttributeStreamOfInt32 paths) {\n\t\tm_paths = paths;\n\t\tnotifyModified(DirtyFlags.DirtyAll);\n\t}\n\n\t/**\n\t * Returns a reference to the AttributeStream of Segment flags (SegmentFlags\n\t * flags). Can be NULL when no non-linear segments are present.\n\t * \n\t * Segment flags indicate what kind of segment originates (starts) on the\n\t * given point. The last vertices of open Path parts has enumNone flag.\n\t */\n\tpublic AttributeStreamOfInt8 getSegmentFlagsStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_segmentFlags;\n\t}\n\n\t/**\n\t * Returns a reference to the AttributeStream of Path flags (PathFlags\n\t * flags).\n\t * \n\t * Each start point of a path has a flag set to indicate if the Path is open\n\t * or closed.\n\t */\n\tpublic AttributeStreamOfInt8 getPathFlagsStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_pathFlags;\n\t}\n\n\t/**\n\t * sets a reference to an AttributeStream of Path flags (PathFlags flags).\n\t */\n\tpublic void setPathFlagsStreamRef(AttributeStreamOfInt8 pathFlags) {\n\t\tm_pathFlags = pathFlags;\n\t\tnotifyModified(DirtyFlags.DirtyAll);\n\t}\n\n\tpublic AttributeStreamOfInt32 getSegmentIndexStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_segmentParamIndex;\n\t}\n\n\tpublic AttributeStreamOfDbl getSegmentDataStreamRef() {\n\t\tthrowIfEmpty();\n\t\treturn m_segmentParams;\n\t}\n\n\tpublic int getPathCount() {\n\t\treturn (m_paths != null) ? m_paths.size() - 1 : 0;\n\t}\n\n\tpublic int getPathEnd(int partIndex) {\n\t\treturn m_paths.read(partIndex + 1);\n\t}\n\n\tpublic int getPathSize(int partIndex) {\n\t\treturn m_paths.read(partIndex + 1) - m_paths.read(partIndex);\n\t}\n\n\tpublic int getPathStart(int partIndex) {\n\t\treturn m_paths.read(partIndex);\n\t}\n\n\t@Override\n\tpublic Object _getImpl() {\n\t\treturn this;\n\t}\n\n\tpublic void setDirtyOGCFlags(boolean bYesNo) {\n\t\t_setDirtyFlag(DirtyFlags.DirtyOGCFlags, bYesNo);\n\t}\n\n\tpublic boolean hasDirtyOGCStartFlags() {\n\t\treturn _hasDirtyFlag(DirtyFlags.DirtyOGCFlags);\n\t}\n\n\tpublic void setDirtyRingAreas2D(boolean bYesNo) {\n\t\t_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, bYesNo);\n\t}\n\n\tpublic boolean hasDirtyRingAreas2D() {\n\t\treturn _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);\n\t}\n\n\tpublic void setRingAreasStreamRef(AttributeStreamOfDbl ringAreas) {\n\t\tm_cachedRingAreas2D = ringAreas;\n\t\t_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);\n\t}\n\n\t// HEADER defintions\n\n\t// // TODO check this against current implementation in native\n\t// public void notifyModified(int flags)\n\t// {\n\t// if(flags == DirtyFlags.DirtyAll)\n\t// {\n\t// m_reservedPointCount = -1;\n\t// _notifyModifiedAllImpl();\n\t// }\n\t// m_flagsMask |= flags;\n\t// _clearAccelerators();\n\t//\n\t//\n\t// // ROHIT's implementation\n\t// // if (m_paths == null || 0 == m_paths.size())\n\t// // m_pointCount = 0;\n\t// // else\n\t// // m_pointCount = m_paths.read(m_paths.size() - 1);\n\t// //\n\t// // super.notifyModified(flags);\n\t// }\n\n\t@Override\n\tpublic boolean _buildRasterizedGeometryAccelerator(double toleranceXY,\n\t\t\tGeometryAccelerationDegree accelDegree) {\n\t\tif (m_accelerators == null)// (!m_accelerators)\n\t\t{\n\t\t\tm_accelerators = new GeometryAccelerators();\n\t\t}\n\n\t\tint rasterSize = RasterizedGeometry2D\n\t\t\t\t.rasterSizeFromAccelerationDegree(accelDegree);\n\t\tRasterizedGeometry2D rgeom = m_accelerators.getRasterizedGeometry();\n\t\tif (rgeom != null) {\n\t\t\tif (rgeom.getToleranceXY() < toleranceXY\n\t\t\t\t\t|| rasterSize > rgeom.getRasterSize()) {\n\t\t\t\tm_accelerators._setRasterizedGeometry(null);\n\t\t\t} else\n\t\t\t\treturn true;\n\t\t}\n\n\t\trgeom = RasterizedGeometry2D.create(this, toleranceXY, rasterSize);\n\t\tm_accelerators._setRasterizedGeometry(rgeom);\n\t\t//rgeom.dbgSaveToBitmap(\"c:/temp/ddd.bmp\");\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\n\t\tif (!isEmptyImpl()) {\n\t\t\tint pathCount = getPathCount();\n\n\t\t\tif (m_paths != null)\n\t\t\t\tm_paths.calculateHashImpl(hashCode, 0, pathCount + 1);\n\n\t\t\tif (m_pathFlags != null)\n\t\t\t\tm_pathFlags.calculateHashImpl(hashCode, 0, pathCount);\n\t\t}\n\n\t\treturn hashCode;\n\t}\n\n\tpublic byte getSegmentFlags(int ivertex) {\n\t\tif (m_segmentFlags != null)\n\t\t\treturn m_segmentFlags.read(ivertex);\n\t\telse\n\t\t\treturn (byte) SegmentFlags.enumLineSeg;\n\t}\n\n\tpublic void getSegment(int startVertexIndex, SegmentBuffer segBuffer,\n\t\t\tboolean bStripAttributes) {\n\t\tint ipath = getPathIndexFromPointIndex(startVertexIndex);\n\t\tif (startVertexIndex == getPathEnd(ipath) - 1 && !isClosedPath(ipath))\n\t\t\tthrow new GeometryException(\"index out of bounds\");\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfInt8 segFlagStream = getSegmentFlagsStreamRef();\n\t\tint segFlag = SegmentFlags.enumLineSeg;\n\t\tif (segFlagStream != null)\n\t\t\tsegFlag = segFlagStream.read(startVertexIndex)\n\t\t\t\t\t& SegmentFlags.enumSegmentMask;\n\n\t\tswitch (segFlag) {\n\t\tcase SegmentFlags.enumLineSeg:\n\t\t\tsegBuffer.createLine();\n\t\t\tbreak;\n\t\tcase SegmentFlags.enumBezierSeg:\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\tcase SegmentFlags.enumArcSeg:\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\tdefault:\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\n\t\tSegment currentSegment = segBuffer.get();\n\t\tif (!bStripAttributes)\n\t\t\tcurrentSegment.assignVertexDescription(m_description);\n\t\telse\n\t\t\tcurrentSegment\n\t\t\t\t\t.assignVertexDescription(VertexDescriptionDesignerImpl\n\t\t\t\t\t\t\t.getDefaultDescriptor2D());\n\n\t\tint endVertexIndex;\n\t\tif (startVertexIndex == getPathEnd(ipath) - 1 && isClosedPath(ipath)) {\n\t\t\tendVertexIndex = getPathStart(ipath);\n\t\t} else\n\t\t\tendVertexIndex = startVertexIndex + 1;\n\n\t\tPoint2D pt = new Point2D();\n\t\tgetXY(startVertexIndex, pt);\n\t\tcurrentSegment.setStartXY(pt);\n\t\tgetXY(endVertexIndex, pt);\n\t\tcurrentSegment.setEndXY(pt);\n\n\t\tif (!bStripAttributes) {\n\t\t\tfor (int i = 1, nattr = m_description.getAttributeCount(); i < nattr; i++) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(i);\n\t\t\t\tint ncomp = VertexDescription.getComponentCount(semantics);\n\t\t\t\tfor (int ord = 0; ord < ncomp; ord++) {\n\t\t\t\t\tdouble vs = getAttributeAsDbl(semantics, startVertexIndex,\n\t\t\t\t\t\t\tord);\n\t\t\t\t\tcurrentSegment.setStartAttribute(semantics, ord, vs);\n\t\t\t\t\tdouble ve = getAttributeAsDbl(semantics, endVertexIndex,\n\t\t\t\t\t\t\tord);\n\t\t\t\t\tcurrentSegment.setEndAttribute(semantics, ord, ve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid queryPathEnvelope2D(int path_index, Envelope2D envelope) {\n\t\tif (path_index >= getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (isEmpty()) {\n\t\t\tenvelope.setEmpty();\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasNonLinearSegments(path_index)) {\n\t\t\tthrow new GeometryException(\"not implemented\");\n\t\t} else {\n\t\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tenv.setEmpty();\n\t\t\tfor (int i = getPathStart(path_index), iend = getPathEnd(path_index); i < iend; i++) {\n\t\t\t\tstream.read(2 * i, pt);\n\t\t\t\tenv.merge(pt);\n\t\t\t}\n\t\t\tenvelope.setCoords(env);\n\t\t}\n\t}\n\n\tpublic void queryLoosePathEnvelope2D(int path_index, Envelope2D envelope) {\n\t\tif (path_index >= getPathCount())\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (isEmpty()) {\n\t\t\tenvelope.setEmpty();\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasNonLinearSegments(path_index)) {\n\t\t\tthrow new GeometryException(\"not implemented\");\n\t\t} else {\n\t\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tenv.setEmpty();\n\t\t\tfor (int i = getPathStart(path_index), iend = getPathEnd(path_index); i < iend; i++) {\n\t\t\t\tstream.read(2 * i, pt);\n\t\t\t\tenv.merge(pt);\n\t\t\t}\n\t\t\tenvelope.setCoords(env);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean _buildQuadTreeAccelerator(GeometryAccelerationDegree d) {\n\t\tif (m_accelerators == null)// (!m_accelerators)\n\t\t{\n\t\t\tm_accelerators = new GeometryAccelerators();\n\t\t}\n\n\t\tif (d == GeometryAccelerationDegree.enumMild || getPointCount() < 16)\n\t\t\treturn false;\n\n\t\tQuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTree(this);\n\t\tm_accelerators._setQuadTree(quad_tree_impl);\n\n\t\treturn true;\n\t}\n\n\tboolean _buildQuadTreeForPathsAccelerator(GeometryAccelerationDegree degree) {\n\t\tif (m_accelerators == null) {\n\t\t\tm_accelerators = new GeometryAccelerators();\n\t\t}\n\n\t\t// TODO: when less than two envelopes - no need to this.\n\n\t\tif (m_accelerators.getQuadTreeForPaths() != null)\n\t\t\treturn true;\n\n\t\tm_accelerators._setQuadTreeForPaths(null);\n\t\tQuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTreeForPaths(this);\n\t\tm_accelerators._setQuadTreeForPaths(quad_tree_impl);\n\n\t\treturn true;\n\t}\n\n\tvoid setFillRule(int rule) {\n\t\tassert (m_bPolygon);\n\t\tm_fill_rule = rule;\n\t}\n\n\tint getFillRule() {\n\t\treturn m_fill_rule;\n\t}\n\n\tvoid clearDirtyOGCFlags() { \n\t\t_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);\n\t}\n}", "code_tokens": ["void", "interpolateAttributes", "(", "int", "from_path_index", ",", "int", "from_point_index", ",", "int", "to_path_index", ",", "int", "to_point_index", ")", "{", "for", "(", "int", "ipath", "=", "from_path_index", ";", "ipath", "<", "to_path_index", "-", "1", ";", "ipath", "++", ")", "{", "if", "(", "isClosedPath", "(", "ipath", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"cannot interpolate across closed paths\"", ")", ";", "}", "int", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "if", "(", "nattr", "==", "1", ")", "return", ";", "// only has position", "double", "sub_length", "=", "calculateSubLength2D", "(", "from_path_index", ",", "from_point_index", ",", "to_path_index", ",", "to_point_index", ")", ";", "if", "(", "sub_length", "==", "0.0", ")", "return", ";", "for", "(", "int", "iattr", "=", "1", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "int", "semantics", "=", "m_description", ".", "getSemantics", "(", "iattr", ")", ";", "int", "interpolation", "=", "VertexDescription", ".", "getInterpolation", "(", "semantics", ")", ";", "if", "(", "interpolation", "==", "VertexDescription", ".", "Interpolation", ".", "ANGULAR", ")", "continue", ";", "int", "components", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "for", "(", "int", "ordinate", "=", "0", ";", "ordinate", "<", "components", ";", "ordinate", "++", ")", "interpolateAttributes_", "(", "semantics", ",", "from_path_index", ",", "from_point_index", ",", "to_path_index", ",", "to_point_index", ",", "sub_length", ",", "ordinate", ")", ";", "}", "}", "// TODO: Add code for interpolation type (none and angular)", "void", "interpolateAttributesForSemantics", "(", "int", "semantics", ",", "int", "from_path_index", ",", "int", "from_point_index", ",", "int", "to_path_index", ",", "int", "to_point_index", ")", "{", "if", "(", "semantics", "==", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", "return", ";", "if", "(", "!", "hasAttribute", "(", "semantics", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"does not have the given attribute\"", ")", ";", "int", "interpolation", "=", "VertexDescription", ".", "getInterpolation", "(", "semantics", ")", ";", "if", "(", "interpolation", "==", "VertexDescription", ".", "Interpolation", ".", "ANGULAR", ")", "throw", "new", "IllegalArgumentException", "(", "\"not implemented for the given semantics\"", ")", ";", "for", "(", "int", "ipath", "=", "from_path_index", ";", "ipath", "<", "to_path_index", "-", "1", ";", "ipath", "++", ")", "{", "if", "(", "isClosedPath", "(", "ipath", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"cannot interpolate across closed paths\"", ")", ";", "}", "double", "sub_length", "=", "calculateSubLength2D", "(", "from_path_index", ",", "from_point_index", ",", "to_path_index", ",", "to_point_index", ")", ";", "if", "(", "sub_length", "==", "0.0", ")", "return", ";", "int", "components", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "for", "(", "int", "ordinate", "=", "0", ";", "ordinate", "<", "components", ";", "ordinate", "++", ")", "interpolateAttributes_", "(", "semantics", ",", "from_path_index", ",", "from_point_index", ",", "to_path_index", ",", "to_point_index", ",", "sub_length", ",", "ordinate", ")", ";", "}", "void", "interpolateAttributes", "(", "int", "path_index", ",", "int", "from_point_index", ",", "int", "to_point_index", ")", "{", "int", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "if", "(", "nattr", "==", "1", ")", "return", ";", "// only has position", "double", "sub_length", "=", "calculateSubLength2D", "(", "path_index", ",", "from_point_index", ",", "to_point_index", ")", ";", "if", "(", "sub_length", "==", "0.0", ")", "return", ";", "for", "(", "int", "iattr", "=", "1", ";", "iattr", "<", "nattr", ";", "iattr", "++", ")", "{", "int", "semantics", "=", "m_description", ".", "getSemantics", "(", "iattr", ")", ";", "int", "interpolation", "=", "VertexDescription", ".", "getInterpolation", "(", "semantics", ")", ";", "if", "(", "interpolation", "==", "VertexDescription", ".", "Interpolation", ".", "ANGULAR", ")", "continue", ";", "int", "components", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "for", "(", "int", "ordinate", "=", "0", ";", "ordinate", "<", "components", ";", "ordinate", "++", ")", "interpolateAttributes_", "(", "semantics", ",", "path_index", ",", "from_point_index", ",", "to_point_index", ",", "sub_length", ",", "ordinate", ")", ";", "}", "}", "void", "interpolateAttributesForSemantics", "(", "int", "semantics", ",", "int", "path_index", ",", "int", "from_point_index", ",", "int", "to_point_index", ")", "{", "if", "(", "semantics", "==", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", "return", ";", "if", "(", "!", "hasAttribute", "(", "semantics", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"does not have the given attribute\"", ")", ";", "int", "interpolation", "=", "VertexDescription", ".", "getInterpolation", "(", "semantics", ")", ";", "if", "(", "interpolation", "==", "VertexDescription", ".", "Interpolation", ".", "ANGULAR", ")", "throw", "new", "IllegalArgumentException", "(", "\"not implemented for the given semantics\"", ")", ";", "double", "sub_length", "=", "calculateSubLength2D", "(", "path_index", ",", "from_point_index", ",", "to_point_index", ")", ";", "if", "(", "sub_length", "==", "0.0", ")", "return", ";", "int", "components", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "for", "(", "int", "ordinate", "=", "0", ";", "ordinate", "<", "components", ";", "ordinate", "++", ")", "interpolateAttributes_", "(", "semantics", ",", "path_index", ",", "from_point_index", ",", "to_point_index", ",", "sub_length", ",", "ordinate", ")", ";", "}", "// TODO: Add code fore interpolation type (none and angular)", "void", "interpolateAttributes_", "(", "int", "semantics", ",", "int", "from_path_index", ",", "int", "from_point_index", ",", "int", "to_path_index", ",", "int", "to_point_index", ",", "double", "sub_length", ",", "int", "ordinate", ")", "{", "SegmentIteratorImpl", "seg_iter", "=", "querySegmentIterator", "(", ")", ";", "int", "absolute_from_index", "=", "getPathStart", "(", "from_path_index", ")", "+", "from_point_index", ";", "int", "absolute_to_index", "=", "getPathStart", "(", "to_path_index", ")", "+", "to_point_index", ";", "double", "from_attribute", "=", "getAttributeAsDbl", "(", "semantics", ",", "absolute_from_index", ",", "ordinate", ")", ";", "double", "to_attribute", "=", "getAttributeAsDbl", "(", "semantics", ",", "absolute_to_index", ",", "ordinate", ")", ";", "double", "interpolated_attribute", "=", "from_attribute", ";", "double", "cumulative_length", "=", "0.0", ";", "seg_iter", ".", "resetToVertex", "(", "absolute_from_index", ")", ";", "do", "{", "if", "(", "seg_iter", ".", "hasNextSegment", "(", ")", ")", "{", "seg_iter", ".", "nextSegment", "(", ")", ";", "if", "(", "seg_iter", ".", "getStartPointIndex", "(", ")", "==", "absolute_to_index", ")", "return", ";", "setAttribute", "(", "semantics", ",", "seg_iter", ".", "getStartPointIndex", "(", ")", ",", "ordinate", ",", "interpolated_attribute", ")", ";", "seg_iter", ".", "previousSegment", "(", ")", ";", "do", "{", "Segment", "segment", "=", "seg_iter", ".", "nextSegment", "(", ")", ";", "if", "(", "seg_iter", ".", "getEndPointIndex", "(", ")", "==", "absolute_to_index", ")", "return", ";", "double", "segment_length", "=", "segment", ".", "calculateLength2D", "(", ")", ";", "cumulative_length", "+=", "segment_length", ";", "double", "t", "=", "cumulative_length", "/", "sub_length", ";", "interpolated_attribute", "=", "MathUtils", ".", "lerp", "(", "from_attribute", ",", "to_attribute", ",", "t", ")", ";", "if", "(", "!", "seg_iter", ".", "isClosingSegment", "(", ")", ")", "setAttribute", "(", "semantics", ",", "seg_iter", ".", "getEndPointIndex", "(", ")", ",", "ordinate", ",", "interpolated_attribute", ")", ";", "}", "while", "(", "seg_iter", ".", "hasNextSegment", "(", ")", ")", ";", "}", "}", "while", "(", "seg_iter", ".", "nextPath", "(", ")", ")", ";", "}", "void", "interpolateAttributes_", "", "(", "int", "semantics", ",", "int", "path_index", ",", "int", "from_point_index", ",", "int", "to_point_index", ",", "double", "sub_length", ",", "int", "ordinate", ")", "{", "assert", "(", "m_bPolygon", ")", ";", "SegmentIteratorImpl", "seg_iter", "=", "querySegmentIterator", "(", ")", ";", "int", "absolute_from_index", "=", "getPathStart", "(", "path_index", ")", "+", "from_point_index", ";", "int", "absolute_to_index", "=", "getPathStart", "(", "path_index", ")", "+", "to_point_index", ";", "if", "(", "absolute_to_index", "==", "absolute_from_index", ")", "return", ";", "double", "from_attribute", "=", "getAttributeAsDbl", "(", "semantics", ",", "absolute_from_index", ",", "ordinate", ")", ";", "double", "to_attribute", "=", "getAttributeAsDbl", "(", "semantics", ",", "absolute_to_index", ",", "ordinate", ")", ";", "double", "cumulative_length", "=", "0.0", ";", "seg_iter", ".", "resetToVertex", "(", "absolute_from_index", ")", ";", "seg_iter", ".", "setCirculator", "(", "true", ")", ";", "double", "prev_interpolated_attribute", "=", "from_attribute", ";", "do", "{", "Segment", "segment", "=", "seg_iter", ".", "nextSegment", "(", ")", ";", "setAttribute", "(", "semantics", ",", "seg_iter", ".", "getStartPointIndex", "(", ")", ",", "ordinate", ",", "prev_interpolated_attribute", ")", ";", "double", "segment_length", "=", "segment", ".", "calculateLength2D", "(", ")", ";", "cumulative_length", "+=", "segment_length", ";", "double", "t", "=", "cumulative_length", "/", "sub_length", ";", "prev_interpolated_attribute", "=", "MathUtils", ".", "lerp", "(", "from_attribute", ",", "to_attribute", ",", "t", ")", ";", "}", "while", "(", "seg_iter", ".", "getEndPointIndex", "(", ")", "!=", "absolute_to_index", ")", ";", "}", "@", "Override", "public", "void", "setEmpty", "", "(", ")", "{", "m_curveParamwritePoint", "=", "0", ";", "m_bPathStarted", "=", "false", ";", "m_paths", "=", "null", ";", "m_pathFlags", "=", "null", ";", "m_segmentParamIndex", "=", "null", ";", "m_segmentFlags", "=", "null", ";", "m_segmentParams", "=", "null", ";", "_setEmptyImpl", "(", ")", ";", "}", "@", "Override", "public", "void", "applyTransformation", "", "(", "Transformation2D", "transform", ")", "{", "applyTransformation", "(", "transform", ",", "-", "1", ")", ";", "}", "public", "void", "applyTransformation", "", "(", "Transformation2D", "transform", ",", "int", "pathIndex", ")", "{", "if", "(", "isEmpty", "(", ")", ")", "return", ";", "if", "(", "transform", ".", "isIdentity", "(", ")", ")", "return", ";", "_verifyAllStreams", "(", ")", ";", "AttributeStreamOfDbl", "points", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "Point2D", "ptStart", "=", "new", "Point2D", "(", ")", ";", "Point2D", "ptControl", "=", "new", "Point2D", "(", ")", ";", "boolean", "bHasNonLinear", ";", "int", "fistIdx", ";", "int", "lastIdx", ";", "if", "(", "pathIndex", "<", "0", ")", "{", "bHasNonLinear", "=", "hasNonLinearSegments", "(", ")", ";", "fistIdx", "=", "0", ";", "lastIdx", "=", "m_pointCount", ";", "}", "else", "{", "bHasNonLinear", "=", "hasNonLinearSegments", "(", "pathIndex", ")", ";", "fistIdx", "=", "getPathStart", "(", "pathIndex", ")", ";", "lastIdx", "=", "getPathEnd", "(", "pathIndex", ")", ";", "}", "for", "(", "int", "ipoint", "=", "fistIdx", ";", "ipoint", "<", "lastIdx", ";", "ipoint", "++", ")", "{", "ptStart", ".", "x", "=", "points", ".", "read", "(", "ipoint", "*", "2", ")", ";", "ptStart", ".", "y", "=", "points", ".", "read", "(", "ipoint", "*", "2", "+", "1", ")", ";", "if", "(", "bHasNonLinear", ")", "{", "int", "segIndex", "=", "m_segmentParamIndex", ".", "read", "(", "ipoint", ")", ";", "if", "(", "segIndex", ">=", "0", ")", "{", "int", "segmentType", "=", "(", "int", ")", "m_segmentFlags", ".", "read", "(", "ipoint", ")", ";", "int", "type", "=", "segmentType", "&", "SegmentFlags", ".", "enumSegmentMask", ";", "switch", "(", "type", ")", "{", "case", "SegmentFlags", ".", "enumBezierSeg", ":", "{", "ptControl", ".", "x", "=", "m_segmentParams", ".", "read", "(", "segIndex", ")", ";", "ptControl", ".", "y", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "1", ")", ";", "transform", ".", "transform", "(", "ptControl", ",", "ptControl", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", ",", "ptControl", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "1", ",", "ptControl", ".", "y", ")", ";", "ptControl", ".", "x", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "3", ")", ";", "ptControl", ".", "y", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "4", ")", ";", "transform", ".", "transform", "(", "ptControl", ",", "ptControl", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "3", ",", "ptControl", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "4", ",", "ptControl", ".", "y", ")", ";", "}", "break", ";", "case", "SegmentFlags", ".", "enumArcSeg", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "}", "}", "transform", ".", "transform", "(", "ptStart", ",", "ptStart", ")", ";", "points", ".", "write", "(", "ipoint", "*", "2", ",", "ptStart", ".", "x", ")", ";", "points", ".", "write", "(", "ipoint", "*", "2", "+", "1", ",", "ptStart", ".", "y", ")", ";", "}", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "// REFACTOR: reset the exact envelope only and transform the loose", "// envelope", "}", "@", "Override", "public", "void", "applyTransformation", "", "(", "Transformation3D", "transform", ")", "{", "if", "(", "isEmpty", "(", ")", ")", "return", ";", "addAttribute", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "_verifyAllStreams", "(", ")", ";", "AttributeStreamOfDbl", "points", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "AttributeStreamOfDbl", "zs", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "1", "]", ";", "Point3D", "ptStart", "=", "new", "Point3D", "(", ")", ";", "Point3D", "ptControl", "=", "new", "Point3D", "(", ")", ";", "boolean", "bHasNonLinear", "=", "hasNonLinearSegments", "(", ")", ";", "for", "(", "int", "ipoint", "=", "0", ";", "ipoint", "<", "m_pointCount", ";", "ipoint", "++", ")", "{", "ptStart", ".", "x", "=", "points", ".", "read", "(", "ipoint", "*", "2", ")", ";", "ptStart", ".", "y", "=", "points", ".", "read", "(", "ipoint", "*", "2", "+", "1", ")", ";", "ptStart", ".", "z", "=", "zs", ".", "read", "(", "ipoint", ")", ";", "if", "(", "bHasNonLinear", ")", "{", "int", "segIndex", "=", "m_segmentParamIndex", ".", "read", "(", "ipoint", ")", ";", "if", "(", "segIndex", ">=", "0", ")", "{", "int", "segmentType", "=", "(", "int", ")", "m_segmentFlags", ".", "read", "(", "ipoint", ")", ";", "int", "type", "=", "segmentType", "&", "(", "int", ")", "SegmentFlags", ".", "enumSegmentMask", ";", "switch", "(", "type", ")", "{", "case", "SegmentFlags", ".", "enumBezierSeg", ":", "{", "ptControl", ".", "x", "=", "m_segmentParams", ".", "read", "(", "segIndex", ")", ";", "ptControl", ".", "y", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "1", ")", ";", "ptControl", ".", "z", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "2", ")", ";", "ptControl", "=", "transform", ".", "transform", "(", "ptControl", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", ",", "ptControl", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "1", ",", "ptControl", ".", "y", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "1", ",", "ptControl", ".", "z", ")", ";", "ptControl", ".", "x", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "3", ")", ";", "ptControl", ".", "y", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "4", ")", ";", "ptControl", ".", "z", "=", "m_segmentParams", ".", "read", "(", "segIndex", "+", "5", ")", ";", "ptControl", "=", "transform", ".", "transform", "(", "ptControl", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "3", ",", "ptControl", ".", "x", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "4", ",", "ptControl", ".", "y", ")", ";", "m_segmentParams", ".", "write", "(", "segIndex", "+", "5", ",", "ptControl", ".", "z", ")", ";", "}", "break", ";", "case", "SegmentFlags", ".", "enumArcSeg", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "}", "}", "ptStart", "=", "transform", ".", "transform", "(", "ptStart", ")", ";", "points", ".", "write", "(", "ipoint", "*", "2", ",", "ptStart", ".", "x", ")", ";", "points", ".", "write", "(", "ipoint", "*", "2", "+", "1", ",", "ptStart", ".", "y", ")", ";", "zs", ".", "write", "(", "ipoint", ",", "ptStart", ".", "z", ")", ";", "}", "// REFACTOR: reset the exact envelope only and transform the loose", "// envelope", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "}", "@", "Override", "protected", "void", "_verifyStreamsImpl", "", "(", ")", "{", "if", "(", "m_paths", "==", "null", ")", "{", "m_paths", "=", "(", "AttributeStreamOfInt32", ")", "AttributeStreamBase", ".", "createIndexStream", "(", "1", ",", "0", ")", ";", "m_pathFlags", "=", "(", "AttributeStreamOfInt8", ")", "AttributeStreamBase", ".", "createByteStream", "(", "1", ",", "(", "byte", ")", "0", ")", ";", "}", "if", "(", "m_segmentFlags", "!=", "null", ")", "{", "m_segmentFlags", ".", "resize", "(", "m_reservedPointCount", ",", "(", "byte", ")", "SegmentFlags", ".", "enumLineSeg", ")", ";", "m_segmentParamIndex", ".", "resize", "(", "m_reservedPointCount", ",", "-", "1", ")", ";", "}", "}", "@", "Override", "void", "_copyToImpl", "", "(", "MultiVertexGeometryImpl", "dst", ")", "{", "MultiPathImpl", "dstPoly", "=", "(", "MultiPathImpl", ")", "dst", ";", "dstPoly", ".", "m_bPathStarted", "=", "false", ";", "dstPoly", ".", "m_curveParamwritePoint", "=", "m_curveParamwritePoint", ";", "dstPoly", ".", "m_fill_rule", "=", "m_fill_rule", ";", "if", "(", "m_paths", "!=", "null", ")", "dstPoly", ".", "m_paths", "=", "new", "AttributeStreamOfInt32", "(", "m_paths", ")", ";", "else", "dstPoly", ".", "m_paths", "=", "null", ";", "if", "(", "m_pathFlags", "!=", "null", ")", "dstPoly", ".", "m_pathFlags", "=", "new", "AttributeStreamOfInt8", "(", "m_pathFlags", ")", ";", "else", "dstPoly", ".", "m_pathFlags", "=", "null", ";", "if", "(", "m_segmentParamIndex", "!=", "null", ")", "dstPoly", ".", "m_segmentParamIndex", "=", "new", "AttributeStreamOfInt32", "(", "m_segmentParamIndex", ")", ";", "else", "dstPoly", ".", "m_segmentParamIndex", "=", "null", ";", "if", "(", "m_segmentFlags", "!=", "null", ")", "dstPoly", ".", "m_segmentFlags", "=", "new", "AttributeStreamOfInt8", "(", "m_segmentFlags", ")", ";", "else", "dstPoly", ".", "m_segmentFlags", "=", "null", ";", "if", "(", "m_segmentParams", "!=", "null", ")", "dstPoly", ".", "m_segmentParams", "=", "new", "AttributeStreamOfDbl", "(", "m_segmentParams", ")", ";", "else", "dstPoly", ".", "m_segmentParams", "=", "null", ";", "dstPoly", ".", "m_cachedLength2D", "=", "m_cachedLength2D", ";", "dstPoly", ".", "m_cachedArea2D", "=", "m_cachedArea2D", ";", "if", "(", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ")", ")", "{", "dstPoly", ".", "m_cachedRingAreas2D", "=", "(", "AttributeStreamOfDbl", ")", "m_cachedRingAreas2D", ";", "}", "else", "dstPoly", ".", "m_cachedRingAreas2D", "=", "null", ";", "}", "@", "Override", "public", "double", "calculateLength2D", "", "(", ")", "{", "if", "(", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyLength2D", ")", ")", "{", "return", "m_cachedLength2D", ";", "}", "SegmentIteratorImpl", "segIter", "=", "querySegmentIterator", "(", ")", ";", "MathUtils", ".", "KahanSummator", "len", "=", "new", "MathUtils", ".", "KahanSummator", "(", "0", ")", ";", "while", "(", "segIter", ".", "nextPath", "(", ")", ")", "{", "while", "(", "segIter", ".", "hasNextSegment", "(", ")", ")", "{", "len", ".", "add", "(", "segIter", ".", "nextSegment", "(", ")", ".", "calculateLength2D", "(", ")", ")", ";", "}", "}", "m_cachedLength2D", "=", "len", ".", "getResult", "(", ")", ";", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyLength2D", ",", "false", ")", ";", "return", "len", ".", "getResult", "(", ")", ";", "}", "@", "Override", "public", "boolean", "equals", "", "(", "Object", "other", ")", "{", "if", "(", "other", "==", "this", ")", "return", "true", ";", "if", "(", "!", "(", "other", "instanceof", "MultiPathImpl", ")", ")", "return", "false", ";", "if", "(", "!", "super", ".", "equals", "(", "other", ")", ")", "return", "false", ";", "MultiPathImpl", "otherMultiPath", "=", "(", "MultiPathImpl", ")", "other", ";", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "int", "pathCountOther", "=", "otherMultiPath", ".", "getPathCount", "(", ")", ";", "if", "(", "pathCount", "!=", "pathCountOther", ")", "return", "false", ";", "if", "(", "pathCount", ">", "0", "&&", "m_paths", "!=", "null", "&&", "!", "m_paths", ".", "equals", "(", "otherMultiPath", ".", "m_paths", ",", "0", ",", "pathCount", "+", "1", ")", ")", "return", "false", ";", "if", "(", "m_fill_rule", "!=", "otherMultiPath", ".", "m_fill_rule", ")", "return", "false", ";", "{", "// Note: OGC flags do not participate in the equals operation by", "// design.", "// Because for the polygon pathFlags will have all enum_closed set,", "// we do not need to compare this stream. Only for polyline.", "// Polyline does not have OGC flags set.", "if", "(", "!", "m_bPolygon", ")", "{", "if", "(", "m_pathFlags", "!=", "null", "&&", "!", "m_pathFlags", ".", "equals", "(", "otherMultiPath", ".", "m_pathFlags", ",", "0", ",", "pathCount", ")", ")", "return", "false", ";", "}", "}", "return", "super", ".", "equals", "(", "other", ")", ";", "}", "/**\n\t * Returns a SegmentIterator that set to a specific vertex of the\n\t * MultiPathImpl. The call to NextSegment will return the segment that\n\t * starts at the vertex. Call to PreviousSegment will return the segment\n\t * that starts at the previous vertex.\n\t */", "public", "SegmentIteratorImpl", "querySegmentIteratorAtVertex", "", "(", "int", "startVertexIndex", ")", "{", "if", "(", "startVertexIndex", "<", "0", "||", "startVertexIndex", ">=", "getPointCount", "(", ")", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "SegmentIteratorImpl", "iter", "=", "new", "SegmentIteratorImpl", "(", "this", ",", "startVertexIndex", ")", ";", "return", "iter", ";", "}", "// void QuerySegmentIterator(int fromVertex, SegmentIterator iterator);", "public", "SegmentIteratorImpl", "querySegmentIterator", "", "(", ")", "{", "return", "new", "SegmentIteratorImpl", "(", "this", ")", ";", "}", "@", "Override", "public", "void", "_updateXYImpl", "", "(", "boolean", "bExact", ")", "{", "super", ".", "_updateXYImpl", "(", "bExact", ")", ";", "boolean", "bHasCurves", "=", "hasNonLinearSegments", "(", ")", ";", "if", "(", "bHasCurves", ")", "{", "SegmentIteratorImpl", "segIter", "=", "querySegmentIterator", "(", ")", ";", "while", "(", "segIter", ".", "nextPath", "(", ")", ")", "{", "while", "(", "segIter", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "curve", "=", "segIter", ".", "nextCurve", "(", ")", ";", "if", "(", "curve", "!=", "null", ")", "{", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "curve", ".", "queryEnvelope2D", "(", "env2D", ")", ";", "m_envelope", ".", "merge", "(", "env2D", ")", ";", "}", "else", "break", ";", "}", "}", "}", "}", "@", "Override", "void", "calculateEnvelope2D", "", "(", "Envelope2D", "env", ",", "boolean", "bExact", ")", "{", "super", ".", "calculateEnvelope2D", "(", "env", ",", "bExact", ")", ";", "boolean", "bHasCurves", "=", "hasNonLinearSegments", "(", ")", ";", "if", "(", "bHasCurves", ")", "{", "SegmentIteratorImpl", "segIter", "=", "querySegmentIterator", "(", ")", ";", "while", "(", "segIter", ".", "nextPath", "(", ")", ")", "{", "while", "(", "segIter", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "curve", "=", "segIter", ".", "nextCurve", "(", ")", ";", "if", "(", "curve", "!=", "null", ")", "{", "Envelope2D", "env2D", "=", "new", "Envelope2D", "(", ")", ";", "curve", ".", "queryEnvelope2D", "(", "env2D", ")", ";", "env", ".", "merge", "(", "env2D", ")", ";", "}", "else", "break", ";", "}", "}", "}", "}", "@", "Override", "public", "void", "_notifyModifiedAllImpl", "", "(", ")", "{", "if", "(", "m_paths", "==", "null", "||", "m_paths", ".", "size", "(", ")", "==", "0", ")", "// if (m_paths == null ||", "// !m_paths.size())", "m_pointCount", "=", "0", ";", "else", "m_pointCount", "=", "m_paths", ".", "read", "(", "m_paths", ".", "size", "(", ")", "-", "1", ")", ";", "}", "@", "Override", "public", "double", "calculateArea2D", "", "(", ")", "{", "if", "(", "!", "m_bPolygon", ")", "return", "0.0", ";", "_updateRingAreas2D", "(", ")", ";", "return", "m_cachedArea2D", ";", "}", "/**\n\t * Returns True if the ring is an exterior ring. Valid only for simple\n\t * polygons.\n\t */", "public", "boolean", "isExteriorRing", "", "(", "int", "ringIndex", ")", "{", "if", "(", "!", "m_bPolygon", ")", "return", "false", ";", "if", "(", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ")", ")", "return", "(", "m_pathFlags", ".", "read", "(", "ringIndex", ")", "&", "(", "byte", ")", "PathFlags", ".", "enumOGCStartPolygon", ")", "!=", "0", ";", "_updateRingAreas2D", "(", ")", ";", "return", "m_cachedRingAreas2D", ".", "read", "(", "ringIndex", ")", ">", "0", ";", "// Should we make a function called _UpdateHasNonLinearSegmentsFlags and", "// call it here?", "}", "public", "double", "calculateRingArea2D", "", "(", "int", "pathIndex", ")", "{", "if", "(", "!", "m_bPolygon", ")", "return", "0.0", ";", "_updateRingAreas2D", "(", ")", ";", "return", "m_cachedRingAreas2D", ".", "read", "(", "pathIndex", ")", ";", "}", "public", "void", "_updateRingAreas2D", "", "(", ")", "{", "if", "(", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ")", ")", "{", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "m_cachedRingAreas2D", "==", "null", ")", "m_cachedRingAreas2D", "=", "new", "AttributeStreamOfDbl", "(", "pathCount", ")", ";", "else", "if", "(", "m_cachedRingAreas2D", ".", "size", "(", ")", "!=", "pathCount", ")", "m_cachedRingAreas2D", ".", "resize", "(", "pathCount", ")", ";", "MathUtils", ".", "KahanSummator", "totalArea", "=", "new", "MathUtils", ".", "KahanSummator", "(", "0", ")", ";", "MathUtils", ".", "KahanSummator", "pathArea", "=", "new", "MathUtils", ".", "KahanSummator", "(", "0", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "int", "ipath", "=", "0", ";", "SegmentIteratorImpl", "segIter", "=", "querySegmentIterator", "(", ")", ";", "while", "(", "segIter", ".", "nextPath", "(", ")", ")", "{", "pathArea", ".", "reset", "(", ")", ";", "getXY", "(", "getPathStart", "(", "segIter", ".", "getPathIndex", "(", ")", ")", ",", "pt", ")", ";", "// get the area", "// calculation", "// origin to be", "// the origin of", "// the ring.", "while", "(", "segIter", ".", "hasNextSegment", "(", ")", ")", "{", "pathArea", ".", "add", "(", "segIter", ".", "nextSegment", "(", ")", ".", "_calculateArea2DHelper", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ")", ";", "}", "totalArea", ".", "add", "(", "pathArea", ".", "getResult", "(", ")", ")", ";", "int", "i", "=", "ipath", "++", ";", "m_cachedRingAreas2D", ".", "write", "(", "i", ",", "pathArea", ".", "getResult", "(", ")", ")", ";", "}", "m_cachedArea2D", "=", "totalArea", ".", "getResult", "(", ")", ";", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ",", "false", ")", ";", "}", "}", "int", "getOGCPolygonCount", "", "(", ")", "{", "if", "(", "!", "m_bPolygon", ")", "return", "0", ";", "_updateOGCFlags", "(", ")", ";", "int", "polygonCount", "=", "0", ";", "int", "partCount", "=", "getPathCount", "(", ")", ";", "for", "(", "int", "ipart", "=", "0", ";", "ipart", "<", "partCount", ";", "ipart", "++", ")", "{", "if", "(", "(", "(", "int", ")", "m_pathFlags", ".", "read", "(", "ipart", ")", "&", "(", "int", ")", "PathFlags", ".", "enumOGCStartPolygon", ")", "!=", "0", ")", "polygonCount", "++", ";", "}", "return", "polygonCount", ";", "}", "protected", "void", "_updateOGCFlags", "", "(", ")", "{", "if", "(", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ")", ")", "{", "_updateRingAreas2D", "(", ")", ";", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "pathCount", ">", "0", "&&", "(", "m_pathFlags", "==", "null", "||", "m_pathFlags", ".", "size", "(", ")", "<", "pathCount", ")", ")", "m_pathFlags", "=", "(", "AttributeStreamOfInt8", ")", "AttributeStreamBase", ".", "createByteStream", "(", "pathCount", "+", "1", ")", ";", "int", "firstSign", "=", "1", ";", "for", "(", "int", "ipath", "=", "0", ";", "ipath", "<", "pathCount", ";", "ipath", "++", ")", "{", "double", "area", "=", "m_cachedRingAreas2D", ".", "read", "(", "ipath", ")", ";", "if", "(", "ipath", "==", "0", ")", "firstSign", "=", "area", ">", "0", "?", "1", ":", "-", "1", ";", "if", "(", "area", "*", "firstSign", ">", "0.0", ")", "m_pathFlags", ".", "setBits", "(", "ipath", ",", "(", "byte", ")", "PathFlags", ".", "enumOGCStartPolygon", ")", ";", "else", "m_pathFlags", ".", "clearBits", "(", "ipath", ",", "(", "byte", ")", "PathFlags", ".", "enumOGCStartPolygon", ")", ";", "}", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ",", "false", ")", ";", "}", "}", "public", "int", "getPathIndexFromPointIndex", "", "(", "int", "pointIndex", ")", "{", "int", "positionHint", "=", "m_currentPathIndex", ";", "// in case of multithreading", "// thiswould simply produce an", "// invalid value", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "// Try using the hint position first to get the path index.", "if", "(", "positionHint", ">=", "0", "&&", "positionHint", "<", "pathCount", ")", "{", "if", "(", "pointIndex", "<", "getPathEnd", "(", "positionHint", ")", ")", "{", "if", "(", "pointIndex", ">=", "getPathStart", "(", "positionHint", ")", ")", "return", "positionHint", ";", "positionHint", "--", ";", "}", "else", "{", "positionHint", "++", ";", "}", "if", "(", "positionHint", ">=", "0", "&&", "positionHint", "<", "pathCount", ")", "{", "if", "(", "pointIndex", ">=", "getPathStart", "(", "positionHint", ")", "&&", "pointIndex", "<", "getPathEnd", "(", "positionHint", ")", ")", "{", "m_currentPathIndex", "=", "positionHint", ";", "return", "positionHint", ";", "}", "}", "}", "if", "(", "pathCount", "<", "5", ")", "{", "// TODO: time the performance to choose when to use", "// linear search.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pathCount", ";", "i", "++", ")", "{", "if", "(", "pointIndex", "<", "getPathEnd", "(", "i", ")", ")", "{", "m_currentPathIndex", "=", "i", ";", "return", "i", ";", "}", "}", "throw", "new", "GeometryException", "(", "\"corrupted geometry\"", ")", ";", "}", "// Do binary search:", "int", "minPathIndex", "=", "0", ";", "int", "maxPathIndex", "=", "pathCount", "-", "1", ";", "while", "(", "maxPathIndex", ">", "minPathIndex", ")", "{", "int", "mid", "=", "minPathIndex", "+", "(", "(", "maxPathIndex", "-", "minPathIndex", ")", ">>", "1", ")", ";", "int", "pathStart", "=", "getPathStart", "(", "mid", ")", ";", "if", "(", "pointIndex", "<", "pathStart", ")", "maxPathIndex", "=", "mid", "-", "1", ";", "else", "{", "int", "pathEnd", "=", "getPathEnd", "(", "mid", ")", ";", "if", "(", "pointIndex", ">=", "pathEnd", ")", "minPathIndex", "=", "mid", "+", "1", ";", "else", "{", "m_currentPathIndex", "=", "mid", ";", "return", "mid", ";", "}", "}", "}", "m_currentPathIndex", "=", "minPathIndex", ";", "return", "minPathIndex", ";", "}", "int", "getHighestPointIndex", "", "(", "int", "path_index", ")", "{", "assert", "(", "path_index", ">=", "0", "&&", "path_index", "<", "getPathCount", "(", ")", ")", ";", "AttributeStreamOfDbl", "position", "=", "(", "AttributeStreamOfDbl", ")", "(", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ")", ";", "AttributeStreamOfInt32", "paths", "=", "(", "AttributeStreamOfInt32", ")", "(", "getPathStreamRef", "(", ")", ")", ";", "int", "path_end", "=", "getPathEnd", "(", "path_index", ")", ";", "int", "path_start", "=", "getPathStart", "(", "path_index", ")", ";", "int", "max_index", "=", "-", "1", ";", "Point2D", "max_point", "=", "new", "Point2D", "(", ")", ",", "pt", "=", "new", "Point2D", "(", ")", ";", "max_point", ".", "y", "=", "NumberUtils", ".", "negativeInf", "(", ")", ";", "max_point", ".", "x", "=", "NumberUtils", ".", "negativeInf", "(", ")", ";", "for", "(", "int", "i", "=", "path_start", "+", "0", ";", "i", "<", "path_end", ";", "i", "++", ")", "{", "position", ".", "read", "(", "2", "*", "i", ",", "pt", ")", ";", "if", "(", "max_point", ".", "compare", "(", "pt", ")", "==", "-", "1", ")", "{", "max_index", "=", "i", ";", "max_point", ".", "setCoords", "(", "pt", ")", ";", "}", "}", "return", "max_index", ";", "}", "/**\n\t * Returns total segment count in the MultiPathImpl.\n\t */", "public", "int", "getSegmentCount", "", "(", ")", "{", "int", "segCount", "=", "getPointCount", "(", ")", ";", "if", "(", "!", "m_bPolygon", ")", "{", "segCount", "-=", "getPathCount", "(", ")", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "getPathCount", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "if", "(", "isClosedPath", "(", "i", ")", ")", "segCount", "++", ";", "}", "return", "segCount", ";", "}", "public", "int", "getSegmentCount", "", "(", "int", "path_index", ")", "{", "int", "segCount", "=", "getPathSize", "(", "path_index", ")", ";", "if", "(", "!", "isClosedPath", "(", "path_index", ")", ")", "segCount", "--", ";", "return", "segCount", ";", "}", "// HEADER defintions", "@", "Override", "public", "Geometry", "createInstance", "", "(", ")", "{", "return", "new", "MultiPathImpl", "(", "m_bPolygon", ",", "getDescription", "(", ")", ")", ";", "}", "@", "Override", "public", "int", "getDimension", "", "(", ")", "{", "return", "m_bPolygon", "?", "2", ":", "1", ";", "}", "@", "Override", "public", "Geometry", ".", "Type", "getType", "", "(", ")", "{", "return", "m_bPolygon", "?", "Type", ".", "Polygon", ":", "Type", ".", "Polyline", ";", "}", "/**\n\t * Returns True if the class is envelope. THis is not an exact method. Only\n\t * addEnvelope makes this true.\n\t */", "public", "boolean", "isEnvelope", "", "(", ")", "{", "return", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyIsEnvelope", ")", ";", "}", "/**\n\t * Returns a reference to the AttributeStream of MultiPathImpl parts\n\t * (Paths).\n\t * \n\t * For the non empty MultiPathImpl, that stream contains start points of the\n\t * MultiPathImpl curves. In addition, the last element is the total point\n\t * count. The number of vertices in a given part is parts[i + 1] - parts[i].\n\t */", "public", "AttributeStreamOfInt32", "getPathStreamRef", "", "(", ")", "{", "throwIfEmpty", "(", ")", ";", "return", "m_paths", ";", "}", "/**\n\t * sets a reference to an AttributeStream of MultiPathImpl paths (Paths).\n\t */", "public", "void", "setPathStreamRef", "", "(", "AttributeStreamOfInt32", "paths", ")", "{", "m_paths", "=", "paths", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyAll", ")", ";", "}", "/**\n\t * Returns a reference to the AttributeStream of Segment flags (SegmentFlags\n\t * flags). Can be NULL when no non-linear segments are present.\n\t * \n\t * Segment flags indicate what kind of segment originates (starts) on the\n\t * given point. The last vertices of open Path parts has enumNone flag.\n\t */", "public", "AttributeStreamOfInt8", "getSegmentFlagsStreamRef", "", "(", ")", "{", "throwIfEmpty", "(", ")", ";", "return", "m_segmentFlags", ";", "}", "/**\n\t * Returns a reference to the AttributeStream of Path flags (PathFlags\n\t * flags).\n\t * \n\t * Each start point of a path has a flag set to indicate if the Path is open\n\t * or closed.\n\t */", "public", "AttributeStreamOfInt8", "getPathFlagsStreamRef", "", "(", ")", "{", "throwIfEmpty", "(", ")", ";", "return", "m_pathFlags", ";", "}", "/**\n\t * sets a reference to an AttributeStream of Path flags (PathFlags flags).\n\t */", "public", "void", "setPathFlagsStreamRef", "", "(", "AttributeStreamOfInt8", "pathFlags", ")", "{", "m_pathFlags", "=", "pathFlags", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyAll", ")", ";", "}", "public", "AttributeStreamOfInt32", "getSegmentIndexStreamRef", "", "(", ")", "{", "throwIfEmpty", "(", ")", ";", "return", "m_segmentParamIndex", ";", "}", "public", "AttributeStreamOfDbl", "getSegmentDataStreamRef", "", "(", ")", "{", "throwIfEmpty", "(", ")", ";", "return", "m_segmentParams", ";", "}", "public", "int", "getPathCount", "", "(", ")", "{", "return", "(", "m_paths", "!=", "null", ")", "?", "m_paths", ".", "size", "(", ")", "-", "1", ":", "0", ";", "}", "public", "int", "getPathEnd", "", "(", "int", "partIndex", ")", "{", "return", "m_paths", ".", "read", "(", "partIndex", "+", "1", ")", ";", "}", "public", "int", "getPathSize", "", "(", "int", "partIndex", ")", "{", "return", "m_paths", ".", "read", "(", "partIndex", "+", "1", ")", "-", "m_paths", ".", "read", "(", "partIndex", ")", ";", "}", "public", "int", "getPathStart", "", "(", "int", "partIndex", ")", "{", "return", "m_paths", ".", "read", "(", "partIndex", ")", ";", "}", "@", "Override", "public", "Object", "_getImpl", "", "(", ")", "{", "return", "this", ";", "}", "public", "void", "setDirtyOGCFlags", "", "(", "boolean", "bYesNo", ")", "{", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ",", "bYesNo", ")", ";", "}", "public", "boolean", "hasDirtyOGCStartFlags", "", "(", ")", "{", "return", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ")", ";", "}", "public", "void", "setDirtyRingAreas2D", "", "(", "boolean", "bYesNo", ")", "{", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ",", "bYesNo", ")", ";", "}", "public", "boolean", "hasDirtyRingAreas2D", "", "(", ")", "{", "return", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ")", ";", "}", "public", "void", "setRingAreasStreamRef", "", "(", "AttributeStreamOfDbl", "ringAreas", ")", "{", "m_cachedRingAreas2D", "=", "ringAreas", ";", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyRingAreas2D", ",", "false", ")", ";", "}", "// HEADER defintions", "// // TODO check this against current implementation in native", "// public void notifyModified(int flags)", "// {", "// if(flags == DirtyFlags.DirtyAll)", "// {", "// m_reservedPointCount = -1;", "// _notifyModifiedAllImpl();", "// }", "// m_flagsMask |= flags;", "// _clearAccelerators();", "//", "//", "// // ROHIT's implementation", "// // if (m_paths == null || 0 == m_paths.size())", "// // m_pointCount = 0;", "// // else", "// // m_pointCount = m_paths.read(m_paths.size() - 1);", "// //", "// // super.notifyModified(flags);", "// }", "@", "Override", "public", "boolean", "_buildRasterizedGeometryAccelerator", "", "(", "double", "toleranceXY", ",", "GeometryAccelerationDegree", "accelDegree", ")", "{", "if", "(", "m_accelerators", "==", "null", ")", "// (!m_accelerators)", "{", "m_accelerators", "=", "new", "GeometryAccelerators", "(", ")", ";", "}", "int", "rasterSize", "=", "RasterizedGeometry2D", ".", "rasterSizeFromAccelerationDegree", "(", "accelDegree", ")", ";", "RasterizedGeometry2D", "rgeom", "=", "m_accelerators", ".", "getRasterizedGeometry", "(", ")", ";", "if", "(", "rgeom", "!=", "null", ")", "{", "if", "(", "rgeom", ".", "getToleranceXY", "(", ")", "<", "toleranceXY", "||", "rasterSize", ">", "rgeom", ".", "getRasterSize", "(", ")", ")", "{", "m_accelerators", ".", "_setRasterizedGeometry", "(", "null", ")", ";", "}", "else", "return", "true", ";", "}", "rgeom", "=", "RasterizedGeometry2D", ".", "create", "(", "this", ",", "toleranceXY", ",", "rasterSize", ")", ";", "m_accelerators", ".", "_setRasterizedGeometry", "(", "rgeom", ")", ";", "//rgeom.dbgSaveToBitmap(\"c:/temp/ddd.bmp\");", "return", "true", ";", "}", "@", "Override", "public", "int", "hashCode", "", "(", ")", "{", "int", "hashCode", "=", "super", ".", "hashCode", "(", ")", ";", "if", "(", "!", "isEmptyImpl", "(", ")", ")", "{", "int", "pathCount", "=", "getPathCount", "(", ")", ";", "if", "(", "m_paths", "!=", "null", ")", "m_paths", ".", "calculateHashImpl", "(", "hashCode", ",", "0", ",", "pathCount", "+", "1", ")", ";", "if", "(", "m_pathFlags", "!=", "null", ")", "m_pathFlags", ".", "calculateHashImpl", "(", "hashCode", ",", "0", ",", "pathCount", ")", ";", "}", "return", "hashCode", ";", "}", "public", "byte", "getSegmentFlags", "", "(", "int", "ivertex", ")", "{", "if", "(", "m_segmentFlags", "!=", "null", ")", "return", "m_segmentFlags", ".", "read", "(", "ivertex", ")", ";", "else", "return", "(", "byte", ")", "SegmentFlags", ".", "enumLineSeg", ";", "}", "public", "void", "getSegment", "", "(", "int", "startVertexIndex", ",", "SegmentBuffer", "segBuffer", ",", "boolean", "bStripAttributes", ")", "{", "int", "ipath", "=", "getPathIndexFromPointIndex", "(", "startVertexIndex", ")", ";", "if", "(", "startVertexIndex", "==", "getPathEnd", "(", "ipath", ")", "-", "1", "&&", "!", "isClosedPath", "(", "ipath", ")", ")", "throw", "new", "GeometryException", "(", "\"index out of bounds\"", ")", ";", "_verifyAllStreams", "(", ")", ";", "AttributeStreamOfInt8", "segFlagStream", "=", "getSegmentFlagsStreamRef", "(", ")", ";", "int", "segFlag", "=", "SegmentFlags", ".", "enumLineSeg", ";", "if", "(", "segFlagStream", "!=", "null", ")", "segFlag", "=", "segFlagStream", ".", "read", "(", "startVertexIndex", ")", "&", "SegmentFlags", ".", "enumSegmentMask", ";", "switch", "(", "segFlag", ")", "{", "case", "SegmentFlags", ".", "enumLineSeg", ":", "segBuffer", ".", "createLine", "(", ")", ";", "break", ";", "case", "SegmentFlags", ".", "enumBezierSeg", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "case", "SegmentFlags", ".", "enumArcSeg", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "default", ":", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "Segment", "currentSegment", "=", "segBuffer", ".", "get", "(", ")", ";", "if", "(", "!", "bStripAttributes", ")", "currentSegment", ".", "assignVertexDescription", "(", "m_description", ")", ";", "else", "currentSegment", ".", "assignVertexDescription", "(", "VertexDescriptionDesignerImpl", ".", "getDefaultDescriptor2D", "(", ")", ")", ";", "int", "endVertexIndex", ";", "if", "(", "startVertexIndex", "==", "getPathEnd", "(", "ipath", ")", "-", "1", "&&", "isClosedPath", "(", "ipath", ")", ")", "{", "endVertexIndex", "=", "getPathStart", "(", "ipath", ")", ";", "}", "else", "endVertexIndex", "=", "startVertexIndex", "+", "1", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "getXY", "(", "startVertexIndex", ",", "pt", ")", ";", "currentSegment", ".", "setStartXY", "(", "pt", ")", ";", "getXY", "(", "endVertexIndex", ",", "pt", ")", ";", "currentSegment", ".", "setEndXY", "(", "pt", ")", ";", "if", "(", "!", "bStripAttributes", ")", "{", "for", "(", "int", "i", "=", "1", ",", "nattr", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "i", "<", "nattr", ";", "i", "++", ")", "{", "int", "semantics", "=", "m_description", ".", "_getSemanticsImpl", "(", "i", ")", ";", "int", "ncomp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "for", "(", "int", "ord", "=", "0", ";", "ord", "<", "ncomp", ";", "ord", "++", ")", "{", "double", "vs", "=", "getAttributeAsDbl", "(", "semantics", ",", "startVertexIndex", ",", "ord", ")", ";", "currentSegment", ".", "setStartAttribute", "(", "semantics", ",", "ord", ",", "vs", ")", ";", "double", "ve", "=", "getAttributeAsDbl", "(", "semantics", ",", "endVertexIndex", ",", "ord", ")", ";", "currentSegment", ".", "setEndAttribute", "(", "semantics", ",", "ord", ",", "ve", ")", ";", "}", "}", "}", "}", "void", "queryPathEnvelope2D", "", "(", "int", "path_index", ",", "Envelope2D", "envelope", ")", "{", "if", "(", "path_index", ">=", "getPathCount", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "isEmpty", "(", ")", ")", "{", "envelope", ".", "setEmpty", "(", ")", ";", "return", ";", "}", "if", "(", "hasNonLinearSegments", "(", "path_index", ")", ")", "{", "throw", "new", "GeometryException", "(", "\"not implemented\"", ")", ";", "}", "else", "{", "AttributeStreamOfDbl", "stream", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "setEmpty", "(", ")", ";", "for", "(", "int", "i", "=", "getPathStart", "(", "path_index", ")", ",", "iend", "=", "getPathEnd", "(", "path_index", ")", ";", "i", "<", "iend", ";", "i", "++", ")", "{", "stream", ".", "read", "(", "2", "*", "i", ",", "pt", ")", ";", "env", ".", "merge", "(", "pt", ")", ";", "}", "envelope", ".", "setCoords", "(", "env", ")", ";", "}", "}", "public", "void", "queryLoosePathEnvelope2D", "", "(", "int", "path_index", ",", "Envelope2D", "envelope", ")", "{", "if", "(", "path_index", ">=", "getPathCount", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "isEmpty", "(", ")", ")", "{", "envelope", ".", "setEmpty", "(", ")", ";", "return", ";", "}", "if", "(", "hasNonLinearSegments", "(", "path_index", ")", ")", "{", "throw", "new", "GeometryException", "(", "\"not implemented\"", ")", ";", "}", "else", "{", "AttributeStreamOfDbl", "stream", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "setEmpty", "(", ")", ";", "for", "(", "int", "i", "=", "getPathStart", "(", "path_index", ")", ",", "iend", "=", "getPathEnd", "(", "path_index", ")", ";", "i", "<", "iend", ";", "i", "++", ")", "{", "stream", ".", "read", "(", "2", "*", "i", ",", "pt", ")", ";", "env", ".", "merge", "(", "pt", ")", ";", "}", "envelope", ".", "setCoords", "(", "env", ")", ";", "}", "}", "@", "Override", "public", "boolean", "_buildQuadTreeAccelerator", "", "(", "GeometryAccelerationDegree", "d", ")", "{", "if", "(", "m_accelerators", "==", "null", ")", "// (!m_accelerators)", "{", "m_accelerators", "=", "new", "GeometryAccelerators", "(", ")", ";", "}", "if", "(", "d", "==", "GeometryAccelerationDegree", ".", "enumMild", "||", "getPointCount", "(", ")", "<", "16", ")", "return", "false", ";", "QuadTreeImpl", "quad_tree_impl", "=", "InternalUtils", ".", "buildQuadTree", "(", "this", ")", ";", "m_accelerators", ".", "_setQuadTree", "(", "quad_tree_impl", ")", ";", "return", "true", ";", "}", "boolean", "_buildQuadTreeForPathsAccelerator", "", "(", "GeometryAccelerationDegree", "degree", ")", "{", "if", "(", "m_accelerators", "==", "null", ")", "{", "m_accelerators", "=", "new", "GeometryAccelerators", "(", ")", ";", "}", "// TODO: when less than two envelopes - no need to this.", "if", "(", "m_accelerators", ".", "getQuadTreeForPaths", "(", ")", "!=", "null", ")", "return", "true", ";", "m_accelerators", ".", "_setQuadTreeForPaths", "(", "null", ")", ";", "QuadTreeImpl", "quad_tree_impl", "=", "InternalUtils", ".", "buildQuadTreeForPaths", "(", "this", ")", ";", "m_accelerators", ".", "_setQuadTreeForPaths", "(", "quad_tree_impl", ")", ";", "return", "true", ";", "}", "void", "setFillRule", "", "(", "int", "rule", ")", "{", "assert", "(", "m_bPolygon", ")", ";", "m_fill_rule", "=", "rule", ";", "}", "int", "getFillRule", "", "(", ")", "{", "return", "m_fill_rule", ";", "}", "void", "clearDirtyOGCFlags", "", "(", ")", "{", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ",", "false", ")", ";", "}", "}", "", "", "", "", ""], "docstring": "TODO: Add code fore interpolation type (none and angular)", "docstring_tokens": ["TODO", ":", "Add", "code", "fore", "interpolation", "type", "(", "none", "and", "angular", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPathImpl.java#L1497-L2618", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorIntersectionCursor.java", "func_name": "OperatorIntersectionCursor.prepareVector_", "original_string": "GeometryCursor prepareVector_(VertexDescription descr, int dimensionMask,\n\t\t\tGeometry[] res_vec) {\n\t\tint inext = 0;\n\t\tif ((dimensionMask & 1) != 0) {\n\t\t\tif (res_vec[0] == null)\n\t\t\t\tres_vec[0] = new MultiPoint(descr);\n\t\t\tinext++;\n\t\t} else {\n\t\t\tfor (int i = 0; i < res_vec.length - 1; i++)\n\t\t\t\tres_vec[i] = res_vec[i + 1];\n\t\t}\n\n\t\tif ((dimensionMask & 2) != 0) {\n\t\t\tif (res_vec[inext] == null)\n\t\t\t\tres_vec[inext] = new Polyline(descr);\n\t\t\tinext++;\n\t\t} else {\n\t\t\tfor (int i = inext; i < res_vec.length - 1; i++)\n\t\t\t\tres_vec[i] = res_vec[i + 1];\n\t\t}\n\n\t\tif ((dimensionMask & 4) != 0) {\n\t\t\tif (res_vec[inext] == null)\n\t\t\t\tres_vec[inext] = new Polygon(descr);\n\t\t\tinext++;\n\t\t} else {\n\t\t\tfor (int i = inext; i < res_vec.length - 1; i++)\n\t\t\t\tres_vec[i] = res_vec[i + 1];\n\t\t}\n\t\t\n\t\tif (inext != 3) {\n\t\t\tGeometry[] r = new Geometry[inext];\n\t\t\tfor (int i = 0; i < inext; i++)\n\t\t\t\tr[i] = res_vec[i];\n\n\t\t\treturn new SimpleGeometryCursor(r);\n\t\t} else {\n\t\t\treturn new SimpleGeometryCursor(res_vec);\n\t\t}\n\t}", "language": "java", "code": "GeometryCursor prepareVector_(VertexDescription descr, int dimensionMask,\n\t\t\tGeometry[] res_vec) {\n\t\tint inext = 0;\n\t\tif ((dimensionMask & 1) != 0) {\n\t\t\tif (res_vec[0] == null)\n\t\t\t\tres_vec[0] = new MultiPoint(descr);\n\t\t\tinext++;\n\t\t} else {\n\t\t\tfor (int i = 0; i < res_vec.length - 1; i++)\n\t\t\t\tres_vec[i] = res_vec[i + 1];\n\t\t}\n\n\t\tif ((dimensionMask & 2) != 0) {\n\t\t\tif (res_vec[inext] == null)\n\t\t\t\tres_vec[inext] = new Polyline(descr);\n\t\t\tinext++;\n\t\t} else {\n\t\t\tfor (int i = inext; i < res_vec.length - 1; i++)\n\t\t\t\tres_vec[i] = res_vec[i + 1];\n\t\t}\n\n\t\tif ((dimensionMask & 4) != 0) {\n\t\t\tif (res_vec[inext] == null)\n\t\t\t\tres_vec[inext] = new Polygon(descr);\n\t\t\tinext++;\n\t\t} else {\n\t\t\tfor (int i = inext; i < res_vec.length - 1; i++)\n\t\t\t\tres_vec[i] = res_vec[i + 1];\n\t\t}\n\t\t\n\t\tif (inext != 3) {\n\t\t\tGeometry[] r = new Geometry[inext];\n\t\t\tfor (int i = 0; i < inext; i++)\n\t\t\t\tr[i] = res_vec[i];\n\n\t\t\treturn new SimpleGeometryCursor(r);\n\t\t} else {\n\t\t\treturn new SimpleGeometryCursor(res_vec);\n\t\t}\n\t}", "code_tokens": ["GeometryCursor", "prepareVector_", "(", "VertexDescription", "descr", ",", "int", "dimensionMask", ",", "Geometry", "[", "]", "res_vec", ")", "{", "int", "inext", "=", "0", ";", "if", "(", "(", "dimensionMask", "&", "1", ")", "!=", "0", ")", "{", "if", "(", "res_vec", "[", "0", "]", "==", "null", ")", "res_vec", "[", "0", "]", "=", "new", "MultiPoint", "(", "descr", ")", ";", "inext", "++", ";", "}", "else", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "res_vec", ".", "length", "-", "1", ";", "i", "++", ")", "res_vec", "[", "i", "]", "=", "res_vec", "[", "i", "+", "1", "]", ";", "}", "if", "(", "(", "dimensionMask", "&", "2", ")", "!=", "0", ")", "{", "if", "(", "res_vec", "[", "inext", "]", "==", "null", ")", "res_vec", "[", "inext", "]", "=", "new", "Polyline", "(", "descr", ")", ";", "inext", "++", ";", "}", "else", "{", "for", "(", "int", "i", "=", "inext", ";", "i", "<", "res_vec", ".", "length", "-", "1", ";", "i", "++", ")", "res_vec", "[", "i", "]", "=", "res_vec", "[", "i", "+", "1", "]", ";", "}", "if", "(", "(", "dimensionMask", "&", "4", ")", "!=", "0", ")", "{", "if", "(", "res_vec", "[", "inext", "]", "==", "null", ")", "res_vec", "[", "inext", "]", "=", "new", "Polygon", "(", "descr", ")", ";", "inext", "++", ";", "}", "else", "{", "for", "(", "int", "i", "=", "inext", ";", "i", "<", "res_vec", ".", "length", "-", "1", ";", "i", "++", ")", "res_vec", "[", "i", "]", "=", "res_vec", "[", "i", "+", "1", "]", ";", "}", "if", "(", "inext", "!=", "3", ")", "{", "Geometry", "[", "]", "r", "=", "new", "Geometry", "[", "inext", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "inext", ";", "i", "++", ")", "r", "[", "i", "]", "=", "res_vec", "[", "i", "]", ";", "return", "new", "SimpleGeometryCursor", "(", "r", ")", ";", "}", "else", "{", "return", "new", "SimpleGeometryCursor", "(", "res_vec", ")", ";", "}", "}"], "docstring": "as indicated with the dimensionMask", "docstring_tokens": ["as", "indicated", "with", "the", "dimensionMask"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorIntersectionCursor.java#L141-L180", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Clipper.java", "func_name": "Clipper.clip", "original_string": "static Geometry clip(Geometry geometry, Envelope2D extent,\n\t\t\tdouble tolerance, double densify_dist) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn geometry;\n\n\t\tif (extent.isEmpty())\n\t\t\treturn geometry.createInstance(); // return an empty geometry\n\n\t\tint geomtype = geometry.getType().value();\n\n\t\t// Test firstly the simplest geometry types point and envelope.\n\t\t// After that we'll check the envelope intersection for the optimization\n\t\tif (geomtype == Geometry.Type.Point.value()) {\n\t\t\tPoint2D pt = ((Point) geometry).getXY();\n\t\t\tif (extent.contains(pt))\n\t\t\t\treturn geometry;\n\t\t\telse\n\t\t\t\treturn geometry.createInstance(); // return an empty geometry\n\t\t} else if (geomtype == Geometry.Type.Envelope.value()) {\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tgeometry.queryEnvelope2D(env);\n\t\t\tif (env.intersect(extent)) {\n\t\t\t\tEnvelope result_env = new Envelope();\n\t\t\t\tgeometry.copyTo(result_env);\n\t\t\t\tresult_env.setEnvelope2D(env);\n\t\t\t\treturn result_env;\n\t\t\t} else\n\t\t\t\treturn geometry.createInstance(); // return an empty geometry\n\t\t}\n\n\t\t// Test the geometry envelope\n\t\tEnvelope2D env_2D = new Envelope2D();\n\t\tgeometry.queryLooseEnvelope2D(env_2D);\n\t\tif (extent.contains(env_2D))\n\t\t\treturn geometry;// completely inside of bounds\n\t\tif (!extent.isIntersecting(env_2D))\n\t\t\treturn geometry.createInstance();// outside of bounds. return empty\n\t\t\t\t\t\t\t\t\t\t\t\t// geometry.\n\n\t\tMultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geometry\n\t\t\t\t._getImpl();\n\t\tGeometryAccelerators accel = impl._getAccelerators();\n\t\tif (accel != null) {\n\t\t\tRasterizedGeometry2D rgeom = accel.getRasterizedGeometry();\n\t\t\tif (rgeom != null) {\n\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t.queryEnvelopeInGeometry(extent);\n\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\tif (geomtype != Geometry.Type.Polygon.value())\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\t\t\tPolygon poly = new Polygon(geometry.getDescription());\n\t\t\t\t\tpoly.addEnvelope(extent, false);\n\t\t\t\t\treturn poly;\n\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\treturn geometry.createInstance();// outside of bounds.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return empty\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// geometry.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (geomtype) {\n\t\tcase Geometry.GeometryType.MultiPoint: {\n\t\t\tMultiPoint multi_point = (MultiPoint) geometry;\n\t\t\tMultiPoint multi_point_out = null;\n\t\t\tint npoints = multi_point.getPointCount();\n\t\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) ((MultiPointImpl) multi_point\n\t\t\t\t\t._getImpl())\n\t\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\t\t// create the new geometry only if there are points that has been\n\t\t\t// clipped out.\n\t\t\t// If all vertices are inside of the envelope, it returns the input\n\t\t\t// multipoint.\n\t\t\tint ipoints0 = 0;\n\t\t\tfor (int ipoints = 0; ipoints < npoints; ipoints++) {\n\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\txy.read(2 * ipoints, pt);\n\n\t\t\t\tif (!extent.contains(pt)) {// vertex is outside of the envelope\n\t\t\t\t\tif (ipoints0 == 0)\n\t\t\t\t\t\tmulti_point_out = (MultiPoint) multi_point\n\t\t\t\t\t\t\t\t.createInstance();\n\n\t\t\t\t\tif (ipoints0 < ipoints)\n\t\t\t\t\t\tmulti_point_out.add(multi_point, ipoints0, ipoints);\n\n\t\t\t\t\tipoints0 = ipoints + 1;// ipoints0 contains index of vertex\n\t\t\t\t\t\t\t\t\t\t\t// right after the last clipped out\n\t\t\t\t\t\t\t\t\t\t\t// vertex.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add the rest of the batch to the result multipoint (only if\n\t\t\t// something has been already clipped out)\n\t\t\tif (ipoints0 > 0)\n\t\t\t\tmulti_point_out.add(multi_point, ipoints0, npoints);\n\n\t\t\tif (ipoints0 == 0)\n\t\t\t\treturn multi_point;// everything is inside, so return the input\n\t\t\t\t\t\t\t\t\t// geometry\n\t\t\telse\n\t\t\t\treturn multi_point_out;// clipping has happend, return the\n\t\t\t\t\t\t\t\t\t\t// clipped geometry\n\t\t}\n\t\tcase Geometry.GeometryType.Polygon:\n\t\tcase Geometry.GeometryType.Polyline:\n\t\t\treturn clipMultiPath_((MultiPath) geometry, extent, tolerance,\n\t\t\t\t\tdensify_dist);\n\t\tdefault:\n\t\t\tassert (false);\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\t}", "language": "java", "code": "static Geometry clip(Geometry geometry, Envelope2D extent,\n\t\t\tdouble tolerance, double densify_dist) {\n\t\tif (geometry.isEmpty())\n\t\t\treturn geometry;\n\n\t\tif (extent.isEmpty())\n\t\t\treturn geometry.createInstance(); // return an empty geometry\n\n\t\tint geomtype = geometry.getType().value();\n\n\t\t// Test firstly the simplest geometry types point and envelope.\n\t\t// After that we'll check the envelope intersection for the optimization\n\t\tif (geomtype == Geometry.Type.Point.value()) {\n\t\t\tPoint2D pt = ((Point) geometry).getXY();\n\t\t\tif (extent.contains(pt))\n\t\t\t\treturn geometry;\n\t\t\telse\n\t\t\t\treturn geometry.createInstance(); // return an empty geometry\n\t\t} else if (geomtype == Geometry.Type.Envelope.value()) {\n\t\t\tEnvelope2D env = new Envelope2D();\n\t\t\tgeometry.queryEnvelope2D(env);\n\t\t\tif (env.intersect(extent)) {\n\t\t\t\tEnvelope result_env = new Envelope();\n\t\t\t\tgeometry.copyTo(result_env);\n\t\t\t\tresult_env.setEnvelope2D(env);\n\t\t\t\treturn result_env;\n\t\t\t} else\n\t\t\t\treturn geometry.createInstance(); // return an empty geometry\n\t\t}\n\n\t\t// Test the geometry envelope\n\t\tEnvelope2D env_2D = new Envelope2D();\n\t\tgeometry.queryLooseEnvelope2D(env_2D);\n\t\tif (extent.contains(env_2D))\n\t\t\treturn geometry;// completely inside of bounds\n\t\tif (!extent.isIntersecting(env_2D))\n\t\t\treturn geometry.createInstance();// outside of bounds. return empty\n\t\t\t\t\t\t\t\t\t\t\t\t// geometry.\n\n\t\tMultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geometry\n\t\t\t\t._getImpl();\n\t\tGeometryAccelerators accel = impl._getAccelerators();\n\t\tif (accel != null) {\n\t\t\tRasterizedGeometry2D rgeom = accel.getRasterizedGeometry();\n\t\t\tif (rgeom != null) {\n\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t.queryEnvelopeInGeometry(extent);\n\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\tif (geomtype != Geometry.Type.Polygon.value())\n\t\t\t\t\t\tthrow GeometryException.GeometryInternalError();\n\n\t\t\t\t\tPolygon poly = new Polygon(geometry.getDescription());\n\t\t\t\t\tpoly.addEnvelope(extent, false);\n\t\t\t\t\treturn poly;\n\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\treturn geometry.createInstance();// outside of bounds.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return empty\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// geometry.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (geomtype) {\n\t\tcase Geometry.GeometryType.MultiPoint: {\n\t\t\tMultiPoint multi_point = (MultiPoint) geometry;\n\t\t\tMultiPoint multi_point_out = null;\n\t\t\tint npoints = multi_point.getPointCount();\n\t\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) ((MultiPointImpl) multi_point\n\t\t\t\t\t._getImpl())\n\t\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\t\t// create the new geometry only if there are points that has been\n\t\t\t// clipped out.\n\t\t\t// If all vertices are inside of the envelope, it returns the input\n\t\t\t// multipoint.\n\t\t\tint ipoints0 = 0;\n\t\t\tfor (int ipoints = 0; ipoints < npoints; ipoints++) {\n\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\txy.read(2 * ipoints, pt);\n\n\t\t\t\tif (!extent.contains(pt)) {// vertex is outside of the envelope\n\t\t\t\t\tif (ipoints0 == 0)\n\t\t\t\t\t\tmulti_point_out = (MultiPoint) multi_point\n\t\t\t\t\t\t\t\t.createInstance();\n\n\t\t\t\t\tif (ipoints0 < ipoints)\n\t\t\t\t\t\tmulti_point_out.add(multi_point, ipoints0, ipoints);\n\n\t\t\t\t\tipoints0 = ipoints + 1;// ipoints0 contains index of vertex\n\t\t\t\t\t\t\t\t\t\t\t// right after the last clipped out\n\t\t\t\t\t\t\t\t\t\t\t// vertex.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add the rest of the batch to the result multipoint (only if\n\t\t\t// something has been already clipped out)\n\t\t\tif (ipoints0 > 0)\n\t\t\t\tmulti_point_out.add(multi_point, ipoints0, npoints);\n\n\t\t\tif (ipoints0 == 0)\n\t\t\t\treturn multi_point;// everything is inside, so return the input\n\t\t\t\t\t\t\t\t\t// geometry\n\t\t\telse\n\t\t\t\treturn multi_point_out;// clipping has happend, return the\n\t\t\t\t\t\t\t\t\t\t// clipped geometry\n\t\t}\n\t\tcase Geometry.GeometryType.Polygon:\n\t\tcase Geometry.GeometryType.Polyline:\n\t\t\treturn clipMultiPath_((MultiPath) geometry, extent, tolerance,\n\t\t\t\t\tdensify_dist);\n\t\tdefault:\n\t\t\tassert (false);\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\t}\n\t}", "code_tokens": ["static", "Geometry", "clip", "(", "Geometry", "geometry", ",", "Envelope2D", "extent", ",", "double", "tolerance", ",", "double", "densify_dist", ")", "{", "if", "(", "geometry", ".", "isEmpty", "(", ")", ")", "return", "geometry", ";", "if", "(", "extent", ".", "isEmpty", "(", ")", ")", "return", "geometry", ".", "createInstance", "(", ")", ";", "// return an empty geometry", "int", "geomtype", "=", "geometry", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "// Test firstly the simplest geometry types point and envelope.", "// After that we'll check the envelope intersection for the optimization", "if", "(", "geomtype", "==", "Geometry", ".", "Type", ".", "Point", ".", "value", "(", ")", ")", "{", "Point2D", "pt", "=", "(", "(", "Point", ")", "geometry", ")", ".", "getXY", "(", ")", ";", "if", "(", "extent", ".", "contains", "(", "pt", ")", ")", "return", "geometry", ";", "else", "return", "geometry", ".", "createInstance", "(", ")", ";", "// return an empty geometry", "}", "else", "if", "(", "geomtype", "==", "Geometry", ".", "Type", ".", "Envelope", ".", "value", "(", ")", ")", "{", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "geometry", ".", "queryEnvelope2D", "(", "env", ")", ";", "if", "(", "env", ".", "intersect", "(", "extent", ")", ")", "{", "Envelope", "result_env", "=", "new", "Envelope", "(", ")", ";", "geometry", ".", "copyTo", "(", "result_env", ")", ";", "result_env", ".", "setEnvelope2D", "(", "env", ")", ";", "return", "result_env", ";", "}", "else", "return", "geometry", ".", "createInstance", "(", ")", ";", "// return an empty geometry", "}", "// Test the geometry envelope", "Envelope2D", "env_2D", "=", "new", "Envelope2D", "(", ")", ";", "geometry", ".", "queryLooseEnvelope2D", "(", "env_2D", ")", ";", "if", "(", "extent", ".", "contains", "(", "env_2D", ")", ")", "return", "geometry", ";", "// completely inside of bounds", "if", "(", "!", "extent", ".", "isIntersecting", "(", "env_2D", ")", ")", "return", "geometry", ".", "createInstance", "(", ")", ";", "// outside of bounds. return empty", "// geometry.", "MultiVertexGeometryImpl", "impl", "=", "(", "MultiVertexGeometryImpl", ")", "geometry", ".", "_getImpl", "(", ")", ";", "GeometryAccelerators", "accel", "=", "impl", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "RasterizedGeometry2D", "rgeom", "=", "accel", ".", "getRasterizedGeometry", "(", ")", ";", "if", "(", "rgeom", "!=", "null", ")", "{", "RasterizedGeometry2D", ".", "HitType", "hit", "=", "rgeom", ".", "queryEnvelopeInGeometry", "(", "extent", ")", ";", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Inside", ")", "{", "if", "(", "geomtype", "!=", "Geometry", ".", "Type", ".", "Polygon", ".", "value", "(", ")", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "Polygon", "poly", "=", "new", "Polygon", "(", "geometry", ".", "getDescription", "(", ")", ")", ";", "poly", ".", "addEnvelope", "(", "extent", ",", "false", ")", ";", "return", "poly", ";", "}", "else", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Outside", ")", "{", "return", "geometry", ".", "createInstance", "(", ")", ";", "// outside of bounds.", "// return empty", "// geometry.", "}", "}", "}", "switch", "(", "geomtype", ")", "{", "case", "Geometry", ".", "GeometryType", ".", "MultiPoint", ":", "{", "MultiPoint", "multi_point", "=", "(", "MultiPoint", ")", "geometry", ";", "MultiPoint", "multi_point_out", "=", "null", ";", "int", "npoints", "=", "multi_point", ".", "getPointCount", "(", ")", ";", "AttributeStreamOfDbl", "xy", "=", "(", "AttributeStreamOfDbl", ")", "(", "(", "MultiPointImpl", ")", "multi_point", ".", "_getImpl", "(", ")", ")", ".", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "// create the new geometry only if there are points that has been", "// clipped out.", "// If all vertices are inside of the envelope, it returns the input", "// multipoint.", "int", "ipoints0", "=", "0", ";", "for", "(", "int", "ipoints", "=", "0", ";", "ipoints", "<", "npoints", ";", "ipoints", "++", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "xy", ".", "read", "(", "2", "*", "ipoints", ",", "pt", ")", ";", "if", "(", "!", "extent", ".", "contains", "(", "pt", ")", ")", "{", "// vertex is outside of the envelope", "if", "(", "ipoints0", "==", "0", ")", "multi_point_out", "=", "(", "MultiPoint", ")", "multi_point", ".", "createInstance", "(", ")", ";", "if", "(", "ipoints0", "<", "ipoints", ")", "multi_point_out", ".", "add", "(", "multi_point", ",", "ipoints0", ",", "ipoints", ")", ";", "ipoints0", "=", "ipoints", "+", "1", ";", "// ipoints0 contains index of vertex", "// right after the last clipped out", "// vertex.", "}", "}", "// add the rest of the batch to the result multipoint (only if", "// something has been already clipped out)", "if", "(", "ipoints0", ">", "0", ")", "multi_point_out", ".", "add", "(", "multi_point", ",", "ipoints0", ",", "npoints", ")", ";", "if", "(", "ipoints0", "==", "0", ")", "return", "multi_point", ";", "// everything is inside, so return the input", "// geometry", "else", "return", "multi_point_out", ";", "// clipping has happend, return the", "// clipped geometry", "}", "case", "Geometry", ".", "GeometryType", ".", "Polygon", ":", "case", "Geometry", ".", "GeometryType", ".", "Polyline", ":", "return", "clipMultiPath_", "(", "(", "MultiPath", ")", "geometry", ",", "extent", ",", "tolerance", ",", "densify_dist", ")", ";", "default", ":", "assert", "(", "false", ")", ";", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "}", "}"], "docstring": "corner_is_inside);", "docstring_tokens": ["corner_is_inside", ")", ";"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Clipper.java#L1134-L1247", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IntervalTreeImpl.java", "func_name": "IntervalTreeImpl.querySortedEndPointIndices_", "original_string": "private void querySortedEndPointIndices_(AttributeStreamOfInt32 end_indices) {\n\t\tint size = (!m_b_envelopes_ref ? m_intervals.size() : m_envelopes_ref.size());\n\n\t\tfor (int i = 0; i < 2 * size; i++)\n\t\t\tend_indices.add(i);\n\n\t\tsortEndIndices_(end_indices, 0, 2 * size);\n\t}", "language": "java", "code": "private void querySortedEndPointIndices_(AttributeStreamOfInt32 end_indices) {\n\t\tint size = (!m_b_envelopes_ref ? m_intervals.size() : m_envelopes_ref.size());\n\n\t\tfor (int i = 0; i < 2 * size; i++)\n\t\t\tend_indices.add(i);\n\n\t\tsortEndIndices_(end_indices, 0, 2 * size);\n\t}", "code_tokens": ["private", "void", "querySortedEndPointIndices_", "(", "AttributeStreamOfInt32", "end_indices", ")", "{", "int", "size", "=", "(", "!", "m_b_envelopes_ref", "?", "m_intervals", ".", "size", "(", ")", ":", "m_envelopes_ref", ".", "size", "(", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "2", "*", "size", ";", "i", "++", ")", "end_indices", ".", "(", "i", ")", ";", "sortEndIndices_", "(", "end_indices", ",", "0", ",", "2", "*", "size", ")", ";", "}"], "docstring": "/* m_tertiary_nodes\n0: m_discriminant_index_1\n1: m_secondary\n2: m_lptr\n3: m_rptr\n4: m_pptr", "docstring_tokens": ["/", "*", "m_tertiary_nodes", "0", ":", "m_discriminant_index_1", "1", ":", "m_secondary", "2", ":", "m_lptr", "3", ":", "m_rptr", "4", ":", "m_pptr"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IntervalTreeImpl.java#L215-L222", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepComparator.java", "func_name": "SweepComparator.tryGetCachedEdge_", "original_string": "SimpleEdge tryGetCachedEdge_(int value) {\n\t\tSimpleEdge se = m_simple_edges_cache.get((value & NumberUtils.intMax())\n\t\t\t\t% m_simple_edges_cache.size());\n\t\tif (se != null) {\n\t\t\tif (se.m_value == value)\n\t\t\t\treturn se;\n\t\t\telse {\n\t\t\t\t// int i = 0;\n\t\t\t\t// cache collision\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}", "language": "java", "code": "SimpleEdge tryGetCachedEdge_(int value) {\n\t\tSimpleEdge se = m_simple_edges_cache.get((value & NumberUtils.intMax())\n\t\t\t\t% m_simple_edges_cache.size());\n\t\tif (se != null) {\n\t\t\tif (se.m_value == value)\n\t\t\t\treturn se;\n\t\t\telse {\n\t\t\t\t// int i = 0;\n\t\t\t\t// cache collision\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["SimpleEdge", "tryGetCachedEdge_", "(", "int", "value", ")", "{", "SimpleEdge", "se", "=", "m_simple_edges_cache", ".", "get", "(", "(", "value", "&", "NumberUtils", ".", "intMax", "(", ")", ")", "%", "m_simple_edges_cache", ".", "size", "(", ")", ")", ";", "if", "(", "se", "!=", "null", ")", "{", "if", "(", "se", ".", "m_value", "==", "value", ")", "return", "se", ";", "else", "{", "// int i = 0;", "// cache collision", "}", "}", "return", "null", ";", "}"], "docstring": "Returns a cached edge for the given value. May return NULL.", "docstring_tokens": ["Returns", "a", "cached", "edge", "for", "the", "given", "value", ".", "May", "return", "NULL", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepComparator.java#L82-L94", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepComparator.java", "func_name": "SweepComparator.tryDeleteCachedEdge_", "original_string": "void tryDeleteCachedEdge_(int value) {\n\t\tint ind = (value & NumberUtils.intMax()) % m_simple_edges_cache.size();\n\t\tSimpleEdge se = m_simple_edges_cache.get(ind);\n\t\tif (se != null && se.m_value == value) {// this value is cached\n\t\t\tm_simple_edges_recycle.add(se);\n\t\t\tm_simple_edges_cache.set(ind, null);\n\t\t} else {\n\t\t\t// The value has not been cached\n\t\t}\n\t}", "language": "java", "code": "void tryDeleteCachedEdge_(int value) {\n\t\tint ind = (value & NumberUtils.intMax()) % m_simple_edges_cache.size();\n\t\tSimpleEdge se = m_simple_edges_cache.get(ind);\n\t\tif (se != null && se.m_value == value) {// this value is cached\n\t\t\tm_simple_edges_recycle.add(se);\n\t\t\tm_simple_edges_cache.set(ind, null);\n\t\t} else {\n\t\t\t// The value has not been cached\n\t\t}\n\t}", "code_tokens": ["void", "tryDeleteCachedEdge_", "(", "int", "value", ")", "{", "int", "ind", "=", "(", "value", "&", "NumberUtils", ".", "intMax", "(", ")", ")", "%", "m_simple_edges_cache", ".", "size", "(", ")", ";", "SimpleEdge", "se", "=", "m_simple_edges_cache", ".", "get", "(", "ind", ")", ";", "if", "(", "se", "!=", "null", "&&", "se", ".", "m_value", "==", "value", ")", "{", "// this value is cached", "m_simple_edges_recycle", ".", "add", "(", "se", ")", ";", "m_simple_edges_cache", ".", "set", "(", "ind", ",", "null", ")", ";", "}", "else", "{", "// The value has not been cached", "}", "}"], "docstring": "Removes cached edge from the cache for the given value.", "docstring_tokens": ["Removes", "cached", "edge", "from", "the", "cache", "for", "the", "given", "value", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepComparator.java#L97-L106", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepComparator.java", "func_name": "SweepComparator.tryCreateCachedEdge_", "original_string": "SimpleEdge tryCreateCachedEdge_(int value) {\n\t\tint ind = (value & NumberUtils.intMax()) % m_simple_edges_cache.size();\n\t\tSimpleEdge se = m_simple_edges_cache.get(ind);\n\t\tif (se == null) {\n\t\t\tif (m_simple_edges_recycle.isEmpty()) {\n\t\t\t\t// assert(m_simple_edges_buffer.size() <\n\t\t\t\t// m_simple_edges_buffer.capacity());//should never happen\n\t\t\t\t// assert(m_simple_edges_buffer.size() <\n\t\t\t\t// m_simple_edges_cache.size());//should never happen\n\t\t\t\tm_simple_edges_buffer.add(new SimpleEdge());\n\t\t\t\tse = m_simple_edges_buffer\n\t\t\t\t\t\t.get(m_simple_edges_buffer.size() - 1);\n\t\t\t} else {\n\t\t\t\tse = m_simple_edges_recycle\n\t\t\t\t\t\t.get(m_simple_edges_recycle.size() - 1);\n\t\t\t\tm_simple_edges_recycle\n\t\t\t\t\t\t.remove(m_simple_edges_recycle.size() - 1);\n\t\t\t}\n\n\t\t\tse.m_value = value;\n\t\t\tm_simple_edges_cache.set(ind, se);\n\t\t\treturn se;\n\t\t} else {\n\t\t\tassert (se.m_value != value);// do not call TryCreateCachedEdge\n\t\t\t\t\t\t\t\t\t\t\t// twice.\n\t\t}\n\n\t\treturn null;\n\t}", "language": "java", "code": "SimpleEdge tryCreateCachedEdge_(int value) {\n\t\tint ind = (value & NumberUtils.intMax()) % m_simple_edges_cache.size();\n\t\tSimpleEdge se = m_simple_edges_cache.get(ind);\n\t\tif (se == null) {\n\t\t\tif (m_simple_edges_recycle.isEmpty()) {\n\t\t\t\t// assert(m_simple_edges_buffer.size() <\n\t\t\t\t// m_simple_edges_buffer.capacity());//should never happen\n\t\t\t\t// assert(m_simple_edges_buffer.size() <\n\t\t\t\t// m_simple_edges_cache.size());//should never happen\n\t\t\t\tm_simple_edges_buffer.add(new SimpleEdge());\n\t\t\t\tse = m_simple_edges_buffer\n\t\t\t\t\t\t.get(m_simple_edges_buffer.size() - 1);\n\t\t\t} else {\n\t\t\t\tse = m_simple_edges_recycle\n\t\t\t\t\t\t.get(m_simple_edges_recycle.size() - 1);\n\t\t\t\tm_simple_edges_recycle\n\t\t\t\t\t\t.remove(m_simple_edges_recycle.size() - 1);\n\t\t\t}\n\n\t\t\tse.m_value = value;\n\t\t\tm_simple_edges_cache.set(ind, se);\n\t\t\treturn se;\n\t\t} else {\n\t\t\tassert (se.m_value != value);// do not call TryCreateCachedEdge\n\t\t\t\t\t\t\t\t\t\t\t// twice.\n\t\t}\n\n\t\treturn null;\n\t}", "code_tokens": ["SimpleEdge", "tryCreateCachedEdge_", "(", "int", "value", ")", "{", "int", "ind", "=", "(", "value", "&", "NumberUtils", ".", "intMax", "(", ")", ")", "%", "m_simple_edges_cache", ".", "size", "(", ")", ";", "SimpleEdge", "se", "=", "m_simple_edges_cache", ".", "get", "(", "ind", ")", ";", "if", "(", "se", "==", "null", ")", "{", "if", "(", "m_simple_edges_recycle", ".", "isEmpty", "(", ")", ")", "{", "// assert(m_simple_edges_buffer.size() <", "// m_simple_edges_buffer.capacity());//should never happen", "// assert(m_simple_edges_buffer.size() <", "// m_simple_edges_cache.size());//should never happen", "m_simple_edges_buffer", ".", "add", "(", "new", "SimpleEdge", "(", ")", ")", ";", "se", "=", "m_simple_edges_buffer", ".", "get", "(", "m_simple_edges_buffer", ".", "size", "(", ")", "-", "1", ")", ";", "}", "else", "{", "se", "=", "m_simple_edges_recycle", ".", "get", "(", "m_simple_edges_recycle", ".", "size", "(", ")", "-", "1", ")", ";", "m_simple_edges_recycle", ".", "remove", "(", "m_simple_edges_recycle", ".", "size", "(", ")", "-", "1", ")", ";", "}", "se", ".", "m_value", "=", "value", ";", "m_simple_edges_cache", ".", "set", "(", "ind", ",", "se", ")", ";", "return", "se", ";", "}", "else", "{", "assert", "(", "se", ".", "m_value", "!=", "value", ")", ";", "// do not call TryCreateCachedEdge", "// twice.", "}", "return", "null", ";", "}"], "docstring": "Creates a cached edge. May fail and return NULL.", "docstring_tokens": ["Creates", "a", "cached", "edge", ".", "May", "fail", "and", "return", "NULL", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepComparator.java#L109-L137", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepComparator.java", "func_name": "SweepComparator.compareTwoSegments_", "original_string": "int compareTwoSegments_(Segment seg_1, Segment seg_2) {\n\t\tint res = seg_1._isIntersecting(seg_2, m_tolerance, true);\n\t\tif (res != 0) {\n\t\t\tif (res == 2)\n\t\t\t\treturn errorCoincident();\n\t\t\telse\n\t\t\t\treturn errorCracking();\n\t\t}\n\n\t\tPoint2D start_1 = seg_1.getStartXY();\n\t\tPoint2D end1 = seg_1.getEndXY();\n\t\tPoint2D start2 = seg_2.getStartXY();\n\t\tPoint2D end2 = seg_2.getEndXY();\n\t\tPoint2D ptSweep = new Point2D();\n\t\tptSweep.setCoords(m_sweep_x, m_sweep_y);\n\t\tif (start_1.isEqual(start2) && m_sweep_y == start_1.y) {\n\t\t\tassert (start_1.compare(end1) < 0 && start2.compare(end2) < 0);\n\t\t\tif (end1.compare(end2) < 0)\n\t\t\t\tptSweep.setCoords(end1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(end2);\n\t\t} else if (start_1.isEqual(end2) && m_sweep_y == start_1.y) {\n\t\t\tassert (start_1.compare(end1) < 0 && start2.compare(end2) > 0);\n\t\t\tif (end1.compare(start2) < 0)\n\t\t\t\tptSweep.setCoords(end1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(start2);\n\t\t} else if (start2.isEqual(end1) && m_sweep_y == start2.y) {\n\t\t\tassert (end1.compare(start_1) < 0 && start2.compare(end2) < 0);\n\t\t\tif (start_1.compare(end2) < 0)\n\t\t\t\tptSweep.setCoords(start_1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(end2);\n\t\t} else if (end1.isEqual(end2) && m_sweep_y == end1.y) {\n\t\t\tassert (start_1.compare(end1) > 0 && start2.compare(end2) > 0);\n\t\t\tif (start_1.compare(start2) < 0)\n\t\t\t\tptSweep.setCoords(start_1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(start2);\n\t\t}\n\n\t\tdouble xleft = seg_1.intersectionOfYMonotonicWithAxisX(ptSweep.y,\n\t\t\t\tptSweep.x);\n\t\tdouble xright = seg_2.intersectionOfYMonotonicWithAxisX(ptSweep.y,\n\t\t\t\tptSweep.x);\n\t\tassert (xleft != xright);\n\t\treturn xleft < xright ? -1 : 1;\n\t}", "language": "java", "code": "int compareTwoSegments_(Segment seg_1, Segment seg_2) {\n\t\tint res = seg_1._isIntersecting(seg_2, m_tolerance, true);\n\t\tif (res != 0) {\n\t\t\tif (res == 2)\n\t\t\t\treturn errorCoincident();\n\t\t\telse\n\t\t\t\treturn errorCracking();\n\t\t}\n\n\t\tPoint2D start_1 = seg_1.getStartXY();\n\t\tPoint2D end1 = seg_1.getEndXY();\n\t\tPoint2D start2 = seg_2.getStartXY();\n\t\tPoint2D end2 = seg_2.getEndXY();\n\t\tPoint2D ptSweep = new Point2D();\n\t\tptSweep.setCoords(m_sweep_x, m_sweep_y);\n\t\tif (start_1.isEqual(start2) && m_sweep_y == start_1.y) {\n\t\t\tassert (start_1.compare(end1) < 0 && start2.compare(end2) < 0);\n\t\t\tif (end1.compare(end2) < 0)\n\t\t\t\tptSweep.setCoords(end1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(end2);\n\t\t} else if (start_1.isEqual(end2) && m_sweep_y == start_1.y) {\n\t\t\tassert (start_1.compare(end1) < 0 && start2.compare(end2) > 0);\n\t\t\tif (end1.compare(start2) < 0)\n\t\t\t\tptSweep.setCoords(end1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(start2);\n\t\t} else if (start2.isEqual(end1) && m_sweep_y == start2.y) {\n\t\t\tassert (end1.compare(start_1) < 0 && start2.compare(end2) < 0);\n\t\t\tif (start_1.compare(end2) < 0)\n\t\t\t\tptSweep.setCoords(start_1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(end2);\n\t\t} else if (end1.isEqual(end2) && m_sweep_y == end1.y) {\n\t\t\tassert (start_1.compare(end1) > 0 && start2.compare(end2) > 0);\n\t\t\tif (start_1.compare(start2) < 0)\n\t\t\t\tptSweep.setCoords(start_1);\n\t\t\telse\n\t\t\t\tptSweep.setCoords(start2);\n\t\t}\n\n\t\tdouble xleft = seg_1.intersectionOfYMonotonicWithAxisX(ptSweep.y,\n\t\t\t\tptSweep.x);\n\t\tdouble xright = seg_2.intersectionOfYMonotonicWithAxisX(ptSweep.y,\n\t\t\t\tptSweep.x);\n\t\tassert (xleft != xright);\n\t\treturn xleft < xright ? -1 : 1;\n\t}", "code_tokens": ["int", "compareTwoSegments_", "(", "Segment", "seg_1", ",", "Segment", "seg_2", ")", "{", "int", "res", "=", "seg_1", ".", "_isIntersecting", "(", "seg_2", ",", "m_tolerance", ",", "true", ")", ";", "if", "(", "res", "!=", "0", ")", "{", "if", "(", "res", "==", "2", ")", "return", "errorCoincident", "(", ")", ";", "else", "return", "errorCracking", "(", ")", ";", "}", "Point2D", "start_1", "=", "seg_1", ".", "getStartXY", "(", ")", ";", "Point2D", "end1", "=", "seg_1", ".", "getEndXY", "(", ")", ";", "Point2D", "start2", "=", "seg_2", ".", "getStartXY", "(", ")", ";", "Point2D", "end2", "=", "seg_2", ".", "getEndXY", "(", ")", ";", "Point2D", "ptSweep", "=", "new", "Point2D", "(", ")", ";", "ptSweep", ".", "setCoords", "(", "m_sweep_x", ",", "m_sweep_y", ")", ";", "if", "(", "start_1", ".", "isEqual", "(", "start2", ")", "&&", "m_sweep_y", "==", "start_1", ".", "y", ")", "{", "assert", "(", "start_1", ".", "compare", "(", "end1", ")", "<", "0", "&&", "start2", ".", "compare", "(", "end2", ")", "<", "0", ")", ";", "if", "(", "end1", ".", "compare", "(", "end2", ")", "<", "0", ")", "ptSweep", ".", "setCoords", "(", "end1", ")", ";", "else", "ptSweep", ".", "setCoords", "(", "end2", ")", ";", "}", "else", "if", "(", "start_1", ".", "isEqual", "(", "end2", ")", "&&", "m_sweep_y", "==", "start_1", ".", "y", ")", "{", "assert", "(", "start_1", ".", "compare", "(", "end1", ")", "<", "0", "&&", "start2", ".", "compare", "(", "end2", ")", ">", "0", ")", ";", "if", "(", "end1", ".", "compare", "(", "start2", ")", "<", "0", ")", "ptSweep", ".", "setCoords", "(", "end1", ")", ";", "else", "ptSweep", ".", "setCoords", "(", "start2", ")", ";", "}", "else", "if", "(", "start2", ".", "isEqual", "(", "end1", ")", "&&", "m_sweep_y", "==", "start2", ".", "y", ")", "{", "assert", "(", "end1", ".", "compare", "(", "start_1", ")", "<", "0", "&&", "start2", ".", "compare", "(", "end2", ")", "<", "0", ")", ";", "if", "(", "start_1", ".", "compare", "(", "end2", ")", "<", "0", ")", "ptSweep", ".", "setCoords", "(", "start_1", ")", ";", "else", "ptSweep", ".", "setCoords", "(", "end2", ")", ";", "}", "else", "if", "(", "end1", ".", "isEqual", "(", "end2", ")", "&&", "m_sweep_y", "==", "end1", ".", "y", ")", "{", "assert", "(", "start_1", ".", "compare", "(", "end1", ")", ">", "0", "&&", "start2", ".", "compare", "(", "end2", ")", ">", "0", ")", ";", "if", "(", "start_1", ".", "compare", "(", "start2", ")", "<", "0", ")", "ptSweep", ".", "setCoords", "(", "start_1", ")", ";", "else", "ptSweep", ".", "setCoords", "(", "start2", ")", ";", "}", "double", "xleft", "=", "seg_1", ".", "intersectionOfYMonotonicWithAxisX", "(", "ptSweep", ".", "y", ",", "ptSweep", ".", "x", ")", ";", "double", "xright", "=", "seg_2", ".", "intersectionOfYMonotonicWithAxisX", "(", "ptSweep", ".", "y", ",", "ptSweep", ".", "x", ")", ";", "assert", "(", "xleft", "!=", "xright", ")", ";", "return", "xleft", "<", "xright", "?", "-", "1", ":", "1", ";", "}"], "docstring": "is set.", "docstring_tokens": ["is", "set", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepComparator.java#L162-L209", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepComparator.java", "func_name": "SweepComparator.setSweepY", "original_string": "void setSweepY(double y, double x) {\n\t\t// _ASSERT(m_sweep_y != y || m_sweep_x != x);\n\t\tm_sweep_y = y;\n\t\tm_sweep_x = x;\n\t\tm_prev_1 = -1;\n\t\tm_prev_2 = -1;\n\t\tm_vertex_1 = -1;\n\t\tm_vertex_2 = -1;\n\t}", "language": "java", "code": "void setSweepY(double y, double x) {\n\t\t// _ASSERT(m_sweep_y != y || m_sweep_x != x);\n\t\tm_sweep_y = y;\n\t\tm_sweep_x = x;\n\t\tm_prev_1 = -1;\n\t\tm_prev_2 = -1;\n\t\tm_vertex_1 = -1;\n\t\tm_vertex_2 = -1;\n\t}", "code_tokens": ["void", "setSweepY", "(", "double", "y", ",", "double", "x", ")", "{", "// _ASSERT(m_sweep_y != y || m_sweep_x != x);", "m_sweep_y", "=", "y", ";", "m_sweep_x", "=", "x", ";", "m_prev_1", "=", "-", "1", ";", "m_prev_2", "=", "-", "1", ";", "m_vertex_1", "=", "-", "1", ";", "m_vertex_2", "=", "-", "1", ";", "}"], "docstring": "Sets new sweep line position.", "docstring_tokens": ["Sets", "new", "sweep", "line", "position", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepComparator.java#L574-L582", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SweepComparator.java", "func_name": "SweepComparator.compare", "original_string": "@Override\n\tint compare(Treap treap, int left, int node) {\n\t\t// Compares two segments on a sweep line passing through m_sweep_y,\n\t\t// m_sweep_x.\n\t\tif (m_b_intersection_detected)\n\t\t\treturn -1;\n\n\t\tint right = treap.getElement(node);\n\t\tm_current_node = node;\n\t\treturn compareSegments(left, left, right, right);\n\t}", "language": "java", "code": "@Override\n\tint compare(Treap treap, int left, int node) {\n\t\t// Compares two segments on a sweep line passing through m_sweep_y,\n\t\t// m_sweep_x.\n\t\tif (m_b_intersection_detected)\n\t\t\treturn -1;\n\n\t\tint right = treap.getElement(node);\n\t\tm_current_node = node;\n\t\treturn compareSegments(left, left, right, right);\n\t}", "code_tokens": ["@", "Override", "int", "compare", "(", "Treap", "treap", ",", "int", "left", ",", "int", "node", ")", "{", "// Compares two segments on a sweep line passing through m_sweep_y,", "// m_sweep_x.", "if", "(", "m_b_intersection_detected", ")", "return", "-", "1", ";", "int", "right", "=", "treap", ".", "getElement", "(", "node", ")", ";", "m_current_node", "=", "node", ";", "return", "compareSegments", "(", "left", ",", "left", ",", "right", ",", "right", ")", ";", "}"], "docstring": "intersection at the same time.", "docstring_tokens": ["intersection", "at", "the", "same", "time", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SweepComparator.java#L587-L597", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.setFromPoints", "original_string": "public void setFromPoints(Point2D[] points) {\n\t\tif (points == null || points.length == 0) {\n\t\t\tsetEmpty();\n\t\t\treturn;\n\t\t}\n\n\t\tPoint2D pt = points[0];\n\t\tsetCoords(pt.x, pt.y);\n\t\tfor (int i = 1; i < points.length; i++) {\n\t\t\tPoint2D pt2d = points[i];\n\t\t\tmergeNE(pt2d.x, pt2d.y);\n\t\t}\n\t}", "language": "java", "code": "public void setFromPoints(Point2D[] points) {\n\t\tif (points == null || points.length == 0) {\n\t\t\tsetEmpty();\n\t\t\treturn;\n\t\t}\n\n\t\tPoint2D pt = points[0];\n\t\tsetCoords(pt.x, pt.y);\n\t\tfor (int i = 1; i < points.length; i++) {\n\t\t\tPoint2D pt2d = points[i];\n\t\t\tmergeNE(pt2d.x, pt2d.y);\n\t\t}\n\t}", "code_tokens": ["public", "void", "setFromPoints", "(", "Point2D", "[", "]", "points", ")", "{", "if", "(", "points", "==", "null", "||", "points", ".", "length", "==", "0", ")", "{", "setEmpty", "(", ")", ";", "return", ";", "}", "Point2D", "pt", "=", "points", "[", "0", "]", ";", "setCoords", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "for", "(", "int", "i", "=", "1", ";", "i", "<", "points", ".", "length", ";", "i", "++", ")", "{", "Point2D", "pt2d", "=", "points", "[", "i", "]", ";", "mergeNE", "(", "pt2d", ".", "x", ",", "pt2d", ".", "y", ")", ";", "}", "}"], "docstring": "Sets the envelope from the array of points. The envelope will be set to\nempty if the array is null.\n@param points The points to set the envelope from. No element in the array can be null.", "docstring_tokens": ["Sets", "the", "envelope", "from", "the", "array", "of", "points", ".", "The", "envelope", "will", "be", "set", "to", "empty", "if", "the", "array", "is", "null", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L136-L148", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.mergeNE", "original_string": "public void mergeNE(double x, double y) {\n\t\tif (xmin > x)\n\t\t\txmin = x;\n\t\telse if (xmax < x)\n\t\t\txmax = x;\n\n\t\tif (ymin > y)\n\t\t\tymin = y;\n\t\telse if (ymax < y)\n\t\t\tymax = y;\n\t}", "language": "java", "code": "public void mergeNE(double x, double y) {\n\t\tif (xmin > x)\n\t\t\txmin = x;\n\t\telse if (xmax < x)\n\t\t\txmax = x;\n\n\t\tif (ymin > y)\n\t\t\tymin = y;\n\t\telse if (ymax < y)\n\t\t\tymax = y;\n\t}", "code_tokens": ["public", "void", "mergeNE", "(", "double", "x", ",", "double", "y", ")", "{", "if", "(", "xmin", ">", "x", ")", "xmin", "=", "x", ";", "else", "if", "(", "xmax", "<", "x", ")", "xmax", "=", "x", ";", "if", "(", "ymin", ">", "y", ")", "ymin", "=", "y", ";", "else", "if", "(", "ymax", "<", "y", ")", "ymax", "=", "y", ";", "}"], "docstring": "Merges a point with this envelope without checking if the envelope is\nempty. Use with care.\n@param x The x coord of the point\n@param y the y coord in the point", "docstring_tokens": ["Merges", "a", "point", "with", "this", "envelope", "without", "checking", "if", "the", "envelope", "is", "empty", ".", "Use", "with", "care", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L205-L215", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.isIntersecting", "original_string": "public boolean isIntersecting(Envelope2D other) {\n\t\t// No need to check if empty, this will work for empty envelopes too\n\t\t// (IEEE math)\n\t\treturn ((xmin <= other.xmin) ? xmax >= other.xmin : other.xmax >= xmin)\n\t\t\t\t&& // check that x projections overlap\n\t\t\t\t((ymin <= other.ymin) ? ymax >= other.ymin : other.ymax >= ymin); // check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t}", "language": "java", "code": "public boolean isIntersecting(Envelope2D other) {\n\t\t// No need to check if empty, this will work for empty envelopes too\n\t\t// (IEEE math)\n\t\treturn ((xmin <= other.xmin) ? xmax >= other.xmin : other.xmax >= xmin)\n\t\t\t\t&& // check that x projections overlap\n\t\t\t\t((ymin <= other.ymin) ? ymax >= other.ymin : other.ymax >= ymin); // check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t}", "code_tokens": ["public", "boolean", "isIntersecting", "(", "Envelope2D", "other", ")", "{", "// No need to check if empty, this will work for empty envelopes too", "// (IEEE math)", "return", "(", "(", "xmin", "<=", "other", ".", "xmin", ")", "?", "xmax", ">=", "other", ".", "xmin", ":", "other", ".", "xmax", ">=", "xmin", ")", "&&", "// check that x projections overlap", "(", "(", "ymin", "<=", "other", ".", "ymin", ")", "?", "ymax", ">=", "other", ".", "ymin", ":", "other", ".", "ymax", ">=", "ymin", ")", ";", "// check", "// that", "// y", "// projections", "// overlap", "}"], "docstring": "Checks if this envelope intersects the other.\n@param other The other envelope.\n@return True if this envelope intersects the other.", "docstring_tokens": ["Checks", "if", "this", "envelope", "intersects", "the", "other", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L267-L277", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.isIntersectingNE", "original_string": "public boolean isIntersectingNE(Envelope2D other) {\n\t\treturn ((xmin <= other.xmin) ? xmax >= other.xmin : other.xmax >= xmin)\n\t\t\t\t&& // check that x projections overlap\n\t\t\t\t((ymin <= other.ymin) ? ymax >= other.ymin : other.ymax >= ymin); // check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t}", "language": "java", "code": "public boolean isIntersectingNE(Envelope2D other) {\n\t\treturn ((xmin <= other.xmin) ? xmax >= other.xmin : other.xmax >= xmin)\n\t\t\t\t&& // check that x projections overlap\n\t\t\t\t((ymin <= other.ymin) ? ymax >= other.ymin : other.ymax >= ymin); // check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t}", "code_tokens": ["public", "boolean", "isIntersectingNE", "(", "Envelope2D", "other", ")", "{", "return", "(", "(", "xmin", "<=", "other", ".", "xmin", ")", "?", "xmax", ">=", "other", ".", "xmin", ":", "other", ".", "xmax", ">=", "xmin", ")", "&&", "// check that x projections overlap", "(", "(", "ymin", "<=", "other", ".", "ymin", ")", "?", "ymax", ">=", "other", ".", "ymin", ":", "other", ".", "ymax", ">=", "ymin", ")", ";", "// check", "// that", "// y", "// projections", "// overlap", "}"], "docstring": "Checks if this envelope intersects the other assuming neither one is empty.\n@param other The other envelope.\n@return True if this envelope intersects the other. Assumes this and\nother envelopes are not empty.", "docstring_tokens": ["Checks", "if", "this", "envelope", "intersects", "the", "other", "assuming", "neither", "one", "is", "empty", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L285-L293", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.isIntersecting", "original_string": "public boolean isIntersecting(double xmin_, double ymin_, double xmax_, double ymax_) {\n\t\t// No need to check if empty, this will work for empty geoms too (IEEE\n\t\t// math)\n\t\treturn ((xmin <= xmin_) ? xmax >= xmin_ : xmax_ >= xmin) && // check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that x\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t\t\t\t((ymin <= ymin_) ? ymax >= ymin_ : ymax_ >= ymin); // check that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t}", "language": "java", "code": "public boolean isIntersecting(double xmin_, double ymin_, double xmax_, double ymax_) {\n\t\t// No need to check if empty, this will work for empty geoms too (IEEE\n\t\t// math)\n\t\treturn ((xmin <= xmin_) ? xmax >= xmin_ : xmax_ >= xmin) && // check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that x\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t\t\t\t((ymin <= ymin_) ? ymax >= ymin_ : ymax_ >= ymin); // check that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// projections\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overlap\n\t}", "code_tokens": ["public", "boolean", "isIntersecting", "(", "double", "xmin_", ",", "double", "ymin_", ",", "double", "xmax_", ",", "double", "ymax_", ")", "{", "// No need to check if empty, this will work for empty geoms too (IEEE", "// math)", "return", "(", "(", "xmin", "<=", "xmin_", ")", "?", "xmax", ">=", "xmin_", ":", "xmax_", ">=", "xmin", ")", "&&", "// check", "// that x", "// projections", "// overlap", "(", "(", "ymin", "<=", "ymin_", ")", "?", "ymax", ">=", "ymin_", ":", "ymax_", ">=", "ymin", ")", ";", "// check that", "// y", "// projections", "// overlap", "}"], "docstring": "Checks if this envelope intersects the other.\n@param xmin_\n@param ymin_\n@param xmax_\n@param ymax_\n@return True if this envelope intersects the other.", "docstring_tokens": ["Checks", "if", "this", "envelope", "intersects", "the", "other", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L303-L314", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.intersect", "original_string": "public boolean intersect(Envelope2D other) {\n\t\tif (isEmpty() || other.isEmpty()) {\n\t\t\tsetEmpty();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (other.xmin > xmin)\n\t\t\txmin = other.xmin;\n\n\t\tif (other.xmax < xmax)\n\t\t\txmax = other.xmax;\n\n\t\tif (other.ymin > ymin)\n\t\t\tymin = other.ymin;\n\n\t\tif (other.ymax < ymax)\n\t\t\tymax = other.ymax;\n\n\t\tboolean bIntersecting = xmin <= xmax && ymin <= ymax;\n\n\t\tif (!bIntersecting)\n\t\t\tsetEmpty();\n\n\t\treturn bIntersecting;\n\t}", "language": "java", "code": "public boolean intersect(Envelope2D other) {\n\t\tif (isEmpty() || other.isEmpty()) {\n\t\t\tsetEmpty();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (other.xmin > xmin)\n\t\t\txmin = other.xmin;\n\n\t\tif (other.xmax < xmax)\n\t\t\txmax = other.xmax;\n\n\t\tif (other.ymin > ymin)\n\t\t\tymin = other.ymin;\n\n\t\tif (other.ymax < ymax)\n\t\t\tymax = other.ymax;\n\n\t\tboolean bIntersecting = xmin <= xmax && ymin <= ymax;\n\n\t\tif (!bIntersecting)\n\t\t\tsetEmpty();\n\n\t\treturn bIntersecting;\n\t}", "code_tokens": ["public", "boolean", "intersect", "(", "Envelope2D", "other", ")", "{", "if", "(", "isEmpty", "(", ")", "||", "other", ".", "isEmpty", "(", ")", ")", "{", "setEmpty", "(", ")", ";", "return", "false", ";", "}", "if", "(", "other", ".", "xmin", ">", "xmin", ")", "xmin", "=", "other", ".", "xmin", ";", "if", "(", "other", ".", "xmax", "<", "xmax", ")", "xmax", "=", "other", ".", "xmax", ";", "if", "(", "other", ".", "ymin", ">", "ymin", ")", "ymin", "=", "other", ".", "ymin", ";", "if", "(", "other", ".", "ymax", "<", "ymax", ")", "ymax", "=", "other", ".", "ymax", ";", "boolean", "bIntersecting", "=", "xmin", "<=", "xmax", "&&", "ymin", "<=", "ymax", ";", "if", "(", "!", "bIntersecting", ")", "setEmpty", "(", ")", ";", "return", "bIntersecting", ";", "}"], "docstring": "Intersects this envelope with the other and stores result in this\nenvelope.\n@param other The other envelope.\n@return True if this envelope intersects the other, otherwise sets this\nenvelope to empty state and returns False.", "docstring_tokens": ["Intersects", "this", "envelope", "with", "the", "other", "and", "stores", "result", "in", "this", "envelope", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L323-L347", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.queryCorner", "original_string": "public Point2D queryCorner(int index) {\n\t\tswitch (index) {\n\t\tcase 0:\n\t\t\treturn Point2D.construct(xmin, ymin);\n\t\tcase 1:\n\t\t\treturn Point2D.construct(xmin, ymax);\n\t\tcase 2:\n\t\t\treturn Point2D.construct(xmax, ymax);\n\t\tcase 3:\n\t\t\treturn Point2D.construct(xmax, ymin);\n\t\tdefault:\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t}\n\t}", "language": "java", "code": "public Point2D queryCorner(int index) {\n\t\tswitch (index) {\n\t\tcase 0:\n\t\t\treturn Point2D.construct(xmin, ymin);\n\t\tcase 1:\n\t\t\treturn Point2D.construct(xmin, ymax);\n\t\tcase 2:\n\t\t\treturn Point2D.construct(xmax, ymax);\n\t\tcase 3:\n\t\t\treturn Point2D.construct(xmax, ymin);\n\t\tdefault:\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t}\n\t}", "code_tokens": ["public", "Point2D", "queryCorner", "(", "int", "index", ")", "{", "switch", "(", "index", ")", "{", "case", "0", ":", "return", "Point2D", ".", "construct", "(", "xmin", ",", "ymin", ")", ";", "case", "1", ":", "return", "Point2D", ".", "construct", "(", "xmin", ",", "ymax", ")", ";", "case", "2", ":", "return", "Point2D", ".", "construct", "(", "xmax", ",", "ymax", ")", ";", "case", "3", ":", "return", "Point2D", ".", "construct", "(", "xmax", ",", "ymin", ")", ";", "default", ":", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "}", "}"], "docstring": "Queries a corner of the envelope.\n\n@param index\nIndicates a corner of the envelope.\n<p>\n0 means lower left or (xmin, ymin)\n<p>\n1 means upper left or (xmin, ymax)\n<p>\n2 means upper right or (xmax, ymax)\n<p>\n3 means lower right or (xmax, ymin)\n@return Point at a corner of the envelope.", "docstring_tokens": ["Queries", "a", "corner", "of", "the", "envelope", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L365-L379", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.queryCorners", "original_string": "public void queryCorners(Point2D[] corners) {\n\t\tif ((corners == null) || (corners.length < 4))\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (corners[0] != null)\n\t\t\tcorners[0].setCoords(xmin, ymin);\n\t\telse\n\t\t\tcorners[0] = new Point2D(xmin, ymin);\n\n\t\tif (corners[1] != null)\n\t\t\tcorners[1].setCoords(xmin, ymax);\n\t\telse\n\t\t\tcorners[1] = new Point2D(xmin, ymax);\n\n\t\tif (corners[2] != null)\n\t\t\tcorners[2].setCoords(xmax, ymax);\n\t\telse\n\t\t\tcorners[2] = new Point2D(xmax, ymax);\n\n\t\tif (corners[3] != null)\n\t\t\tcorners[3].setCoords(xmax, ymin);\n\t\telse\n\t\t\tcorners[3] = new Point2D(xmax, ymin);\n\t}", "language": "java", "code": "public void queryCorners(Point2D[] corners) {\n\t\tif ((corners == null) || (corners.length < 4))\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (corners[0] != null)\n\t\t\tcorners[0].setCoords(xmin, ymin);\n\t\telse\n\t\t\tcorners[0] = new Point2D(xmin, ymin);\n\n\t\tif (corners[1] != null)\n\t\t\tcorners[1].setCoords(xmin, ymax);\n\t\telse\n\t\t\tcorners[1] = new Point2D(xmin, ymax);\n\n\t\tif (corners[2] != null)\n\t\t\tcorners[2].setCoords(xmax, ymax);\n\t\telse\n\t\t\tcorners[2] = new Point2D(xmax, ymax);\n\n\t\tif (corners[3] != null)\n\t\t\tcorners[3].setCoords(xmax, ymin);\n\t\telse\n\t\t\tcorners[3] = new Point2D(xmax, ymin);\n\t}", "code_tokens": ["public", "void", "queryCorners", "(", "Point2D", "[", "]", "corners", ")", "{", "if", "(", "(", "corners", "==", "null", ")", "||", "(", "corners", ".", "length", "<", "4", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "corners", "[", "0", "]", "!=", "null", ")", "corners", "[", "0", "]", ".", "setCoords", "(", "xmin", ",", "ymin", ")", ";", "else", "corners", "[", "0", "]", "=", "new", "Point2D", "(", "xmin", ",", "ymin", ")", ";", "if", "(", "corners", "[", "1", "]", "!=", "null", ")", "corners", "[", "1", "]", ".", "setCoords", "(", "xmin", ",", "ymax", ")", ";", "else", "corners", "[", "1", "]", "=", "new", "Point2D", "(", "xmin", ",", "ymax", ")", ";", "if", "(", "corners", "[", "2", "]", "!=", "null", ")", "corners", "[", "2", "]", ".", "setCoords", "(", "xmax", ",", "ymax", ")", ";", "else", "corners", "[", "2", "]", "=", "new", "Point2D", "(", "xmax", ",", "ymax", ")", ";", "if", "(", "corners", "[", "3", "]", "!=", "null", ")", "corners", "[", "3", "]", ".", "setCoords", "(", "xmax", ",", "ymin", ")", ";", "else", "corners", "[", "3", "]", "=", "new", "Point2D", "(", "xmax", ",", "ymin", ")", ";", "}"], "docstring": "Queries corners into a given array. The array length must be at least\n4. Starts from the lower left corner and goes clockwise.\n@param corners The array of four points.", "docstring_tokens": ["Queries", "corners", "into", "a", "given", "array", ".", "The", "array", "length", "must", "be", "at", "least", "4", ".", "Starts", "from", "the", "lower", "left", "corner", "and", "goes", "clockwise", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L386-L408", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.move", "original_string": "public void move(double dx, double dy) {\n\t\tif (isEmpty())\n\t\t\treturn;\n\t\txmin += dx;\n\t\tymin += dy;\n\t\txmax += dx;\n\t\tymax += dy;\n\t}", "language": "java", "code": "public void move(double dx, double dy) {\n\t\tif (isEmpty())\n\t\t\treturn;\n\t\txmin += dx;\n\t\tymin += dy;\n\t\txmax += dx;\n\t\tymax += dy;\n\t}", "code_tokens": ["public", "void", "move", "(", "double", "dx", ",", "double", "dy", ")", "{", "if", "(", "isEmpty", "(", ")", ")", "return", ";", "xmin", "+=", "dx", ";", "ymin", "+=", "dy", ";", "xmax", "+=", "dx", ";", "ymax", "+=", "dy", ";", "}"], "docstring": "Moves the Envelope by given distance.\n@param dx\n@param dy", "docstring_tokens": ["Moves", "the", "Envelope", "by", "given", "distance", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L519-L526", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.contains", "original_string": "public boolean contains(Envelope2D other) {// Note: Will return False, if\n\t\t\t\t\t\t\t\t\t\t\t\t// either envelope is empty.\n\t\treturn other.xmin >= xmin && other.xmax <= xmax && other.ymin >= ymin\n\t\t\t\t&& other.ymax <= ymax;\n\t}", "language": "java", "code": "public boolean contains(Envelope2D other) {// Note: Will return False, if\n\t\t\t\t\t\t\t\t\t\t\t\t// either envelope is empty.\n\t\treturn other.xmin >= xmin && other.xmax <= xmax && other.ymin >= ymin\n\t\t\t\t&& other.ymax <= ymax;\n\t}", "code_tokens": ["public", "boolean", "contains", "(", "Envelope2D", "other", ")", "{", "// Note: Will return False, if", "// either envelope is empty.", "return", "other", ".", "xmin", ">=", "xmin", "&&", "other", ".", "xmax", "<=", "xmax", "&&", "other", ".", "ymin", ">=", "ymin", "&&", "other", ".", "ymax", "<=", "ymax", ";", "}"], "docstring": "Returns True if the envelope contains the other envelope (boundary\ninclusive).\n@param other The other envelope.\n@return True if this contains the other.", "docstring_tokens": ["Returns", "True", "if", "the", "envelope", "contains", "the", "other", "envelope", "(", "boundary", "inclusive", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L643-L647", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.containsExclusive", "original_string": "public boolean containsExclusive(double x, double y) {\n\t\t// Note: This will return False, if envelope is empty, thus no need to\n\t\t// call is_empty().\n\t\treturn x > xmin && x < xmax && y > ymin && y < ymax;\n\t}", "language": "java", "code": "public boolean containsExclusive(double x, double y) {\n\t\t// Note: This will return False, if envelope is empty, thus no need to\n\t\t// call is_empty().\n\t\treturn x > xmin && x < xmax && y > ymin && y < ymax;\n\t}", "code_tokens": ["public", "boolean", "containsExclusive", "(", "double", "x", ",", "double", "y", ")", "{", "// Note: This will return False, if envelope is empty, thus no need to", "// call is_empty().", "return", "x", ">", "xmin", "&&", "x", "<", "xmax", "&&", "y", ">", "ymin", "&&", "y", "<", "ymax", ";", "}"], "docstring": "Returns True if the envelope contains the point (boundary exclusive).\n@param x\n@param y\n@return True if this contains the point.", "docstring_tokens": ["Returns", "True", "if", "the", "envelope", "contains", "the", "point", "(", "boundary", "exclusive", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L655-L659", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.containsExclusive", "original_string": "boolean containsExclusive(Envelope2D other) {\n\t\t// Note: This will return False, if either envelope is empty, thus no\n\t\t// need to call is_empty().\n\t\treturn other.xmin > xmin && other.xmax < xmax && other.ymin > ymin\n\t\t\t\t&& other.ymax < ymax;\n\t}", "language": "java", "code": "boolean containsExclusive(Envelope2D other) {\n\t\t// Note: This will return False, if either envelope is empty, thus no\n\t\t// need to call is_empty().\n\t\treturn other.xmin > xmin && other.xmax < xmax && other.ymin > ymin\n\t\t\t\t&& other.ymax < ymax;\n\t}", "code_tokens": ["boolean", "containsExclusive", "(", "Envelope2D", "other", ")", "{", "// Note: This will return False, if either envelope is empty, thus no", "// need to call is_empty().", "return", "other", ".", "xmin", ">", "xmin", "&&", "other", ".", "xmax", "<", "xmax", "&&", "other", ".", "ymin", ">", "ymin", "&&", "other", ".", "ymax", "<", "ymax", ";", "}"], "docstring": "Returns True if the envelope contains the other envelope (boundary\nexclusive).\n@param other The other envelope\n@return True if this contains the other, boundary exclusive.", "docstring_tokens": ["Returns", "True", "if", "the", "envelope", "contains", "the", "other", "envelope", "(", "boundary", "exclusive", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L674-L679", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D._boundaryDistance", "original_string": "double _boundaryDistance(Point2D pt) {\n\t\tif (isEmpty())\n\t\t\treturn NumberUtils.NaN();\n\n\t\tif (pt.x == xmin)\n\t\t\treturn pt.y - ymin;\n\n\t\tdouble height = ymax - ymin;\n\t\tdouble width = xmax - xmin;\n\n\t\tif (pt.y == ymax)\n\t\t\treturn height + pt.x - xmin;\n\n\t\tif (pt.x == xmax)\n\t\t\treturn height + width + ymax - pt.y;\n\n\t\tif (pt.y == ymin)\n\t\t\treturn height * 2.0 + width + xmax - pt.x;\n\n\t\treturn _boundaryDistance(_snapToBoundary(pt));\n\t}", "language": "java", "code": "double _boundaryDistance(Point2D pt) {\n\t\tif (isEmpty())\n\t\t\treturn NumberUtils.NaN();\n\n\t\tif (pt.x == xmin)\n\t\t\treturn pt.y - ymin;\n\n\t\tdouble height = ymax - ymin;\n\t\tdouble width = xmax - xmin;\n\n\t\tif (pt.y == ymax)\n\t\t\treturn height + pt.x - xmin;\n\n\t\tif (pt.x == xmax)\n\t\t\treturn height + width + ymax - pt.y;\n\n\t\tif (pt.y == ymin)\n\t\t\treturn height * 2.0 + width + xmax - pt.x;\n\n\t\treturn _boundaryDistance(_snapToBoundary(pt));\n\t}", "code_tokens": ["double", "_boundaryDistance", "(", "Point2D", "pt", ")", "{", "if", "(", "isEmpty", "(", ")", ")", "return", "NumberUtils", ".", "NaN", "(", ")", ";", "if", "(", "pt", ".", "x", "==", "xmin", ")", "return", "pt", ".", "y", "-", "ymin", ";", "double", "height", "=", "ymax", "-", "ymin", ";", "double", "width", "=", "xmax", "-", "xmin", ";", "if", "(", "pt", ".", "y", "==", "ymax", ")", "return", "height", "+", "pt", ".", "x", "-", "xmin", ";", "if", "(", "pt", ".", "x", "==", "xmax", ")", "return", "height", "+", "width", "+", "ymax", "-", "pt", ".", "y", ";", "if", "(", "pt", ".", "y", "==", "ymin", ")", "return", "height", "*", "2.0", "+", "width", "+", "xmax", "-", "pt", ".", "x", ";", "return", "_boundaryDistance", "(", "_snapToBoundary", "(", "pt", ")", ")", ";", "}"], "docstring": "function).", "docstring_tokens": ["function", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L769-L789", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D._envelopeSide", "original_string": "int _envelopeSide(Point2D pt) {\n\n\t\tif (isEmpty())\n\t\t\treturn -1;\n\n\t\tdouble boundaryDist = _boundaryDistance(pt);\n\t\tdouble height = ymax - ymin;\n\t\tdouble width = xmax - xmin;\n\n\t\tif (boundaryDist < height)\n\t\t\treturn 0;\n\n\t\tif ((boundaryDist -= height) < width)\n\t\t\treturn 1;\n\n\t\treturn boundaryDist - width < height ? 2 : 3;\n\t}", "language": "java", "code": "int _envelopeSide(Point2D pt) {\n\n\t\tif (isEmpty())\n\t\t\treturn -1;\n\n\t\tdouble boundaryDist = _boundaryDistance(pt);\n\t\tdouble height = ymax - ymin;\n\t\tdouble width = xmax - xmin;\n\n\t\tif (boundaryDist < height)\n\t\t\treturn 0;\n\n\t\tif ((boundaryDist -= height) < width)\n\t\t\treturn 1;\n\n\t\treturn boundaryDist - width < height ? 2 : 3;\n\t}", "code_tokens": ["int", "_envelopeSide", "(", "Point2D", "pt", ")", "{", "if", "(", "isEmpty", "(", ")", ")", "return", "-", "1", ";", "double", "boundaryDist", "=", "_boundaryDistance", "(", "pt", ")", ";", "double", "height", "=", "ymax", "-", "ymin", ";", "double", "width", "=", "xmax", "-", "xmin", ";", "if", "(", "boundaryDist", "<", "height", ")", "return", "0", ";", "if", "(", "(", "boundaryDist", "-=", "height", ")", "<", "width", ")", "return", "1", ";", "return", "boundaryDist", "-", "width", "<", "height", "?", "2", ":", "3", ";", "}"], "docstring": "returns 0,..3 depending on which side pt lies.", "docstring_tokens": ["returns", "0", "..", "3", "depending", "on", "which", "side", "pt", "lies", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L792-L808", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.clipLine", "original_string": "int clipLine(Point2D p0, Point2D p1, int lineExtension, double[] segParams,\n\t\t\tdouble[] boundaryDistances) {\n\t\tif (boundaryDistances != null) {\n\t\t\tboundaryDistances[0] = -1.0;\n\t\t\tboundaryDistances[1] = -1.0;\n\t\t}\n\n\t\tdouble[] tOld = new double[2];// LOCALREFCLASS1(ArrayOf(double), int,\n\t\t\t\t\t\t\t\t\t\t// tOld, 2);\n\t\tint modified = 0;\n\n\t\tPoint2D delta = new Point2D(p1.x - p0.x, p1.y - p0.y);\n\n\t\tif (delta.x == 0.0 && delta.y == 0.0) // input line degenerates to a\n\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t{\n\t\t\tsegParams[0] = 0.0;\n\t\t\tsegParams[1] = 0.0;\n\t\t\treturn contains(p0) ? 4 : 0;\n\t\t}\n\n\t\tsegParams[0] = ((lineExtension & 1) != 0) ? NumberUtils.negativeInf()\n\t\t\t\t: 0.0;\n\t\tsegParams[1] = ((lineExtension & 2) != 0) ? NumberUtils.positiveInf()\n\t\t\t\t: 1.0;\n\t\ttOld[0] = segParams[0];\n\t\ttOld[1] = segParams[1];\n\n\t\tif (clipLineAuxiliary(delta.x, xmin - p0.x, segParams)\n\t\t\t\t&& clipLineAuxiliary(-delta.x, p0.x - xmax, segParams)\n\t\t\t\t&& clipLineAuxiliary(delta.y, ymin - p0.y, segParams)\n\t\t\t\t&& clipLineAuxiliary(-delta.y, p0.y - ymax, segParams)) {\n\t\t\tif (segParams[1] < tOld[1]) {\n\t\t\t\tp1.scaleAdd(segParams[1], delta, p0);\n\t\t\t\t_snapToBoundary(p1); // needed for accuracy\n\t\t\t\tmodified |= 2;\n\n\t\t\t\tif (boundaryDistances != null)\n\t\t\t\t\tboundaryDistances[1] = _boundaryDistance(p1);\n\t\t\t}\n\t\t\tif (segParams[0] > tOld[0]) {\n\t\t\t\tp0.scaleAdd(segParams[0], delta, p0);\n\t\t\t\t_snapToBoundary(p0); // needed for accuracy\n\t\t\t\tmodified |= 1;\n\n\t\t\t\tif (boundaryDistances != null)\n\t\t\t\t\tboundaryDistances[0] = _boundaryDistance(p0);\n\t\t\t}\n\t\t}\n\n\t\treturn modified;\n\t}", "language": "java", "code": "int clipLine(Point2D p0, Point2D p1, int lineExtension, double[] segParams,\n\t\t\tdouble[] boundaryDistances) {\n\t\tif (boundaryDistances != null) {\n\t\t\tboundaryDistances[0] = -1.0;\n\t\t\tboundaryDistances[1] = -1.0;\n\t\t}\n\n\t\tdouble[] tOld = new double[2];// LOCALREFCLASS1(ArrayOf(double), int,\n\t\t\t\t\t\t\t\t\t\t// tOld, 2);\n\t\tint modified = 0;\n\n\t\tPoint2D delta = new Point2D(p1.x - p0.x, p1.y - p0.y);\n\n\t\tif (delta.x == 0.0 && delta.y == 0.0) // input line degenerates to a\n\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t{\n\t\t\tsegParams[0] = 0.0;\n\t\t\tsegParams[1] = 0.0;\n\t\t\treturn contains(p0) ? 4 : 0;\n\t\t}\n\n\t\tsegParams[0] = ((lineExtension & 1) != 0) ? NumberUtils.negativeInf()\n\t\t\t\t: 0.0;\n\t\tsegParams[1] = ((lineExtension & 2) != 0) ? NumberUtils.positiveInf()\n\t\t\t\t: 1.0;\n\t\ttOld[0] = segParams[0];\n\t\ttOld[1] = segParams[1];\n\n\t\tif (clipLineAuxiliary(delta.x, xmin - p0.x, segParams)\n\t\t\t\t&& clipLineAuxiliary(-delta.x, p0.x - xmax, segParams)\n\t\t\t\t&& clipLineAuxiliary(delta.y, ymin - p0.y, segParams)\n\t\t\t\t&& clipLineAuxiliary(-delta.y, p0.y - ymax, segParams)) {\n\t\t\tif (segParams[1] < tOld[1]) {\n\t\t\t\tp1.scaleAdd(segParams[1], delta, p0);\n\t\t\t\t_snapToBoundary(p1); // needed for accuracy\n\t\t\t\tmodified |= 2;\n\n\t\t\t\tif (boundaryDistances != null)\n\t\t\t\t\tboundaryDistances[1] = _boundaryDistance(p1);\n\t\t\t}\n\t\t\tif (segParams[0] > tOld[0]) {\n\t\t\t\tp0.scaleAdd(segParams[0], delta, p0);\n\t\t\t\t_snapToBoundary(p0); // needed for accuracy\n\t\t\t\tmodified |= 1;\n\n\t\t\t\tif (boundaryDistances != null)\n\t\t\t\t\tboundaryDistances[0] = _boundaryDistance(p0);\n\t\t\t}\n\t\t}\n\n\t\treturn modified;\n\t}", "code_tokens": ["int", "clipLine", "(", "Point2D", "p0", ",", "Point2D", "p1", ",", "int", "lineExtension", ",", "double", "[", "]", "segParams", ",", "double", "[", "]", "boundaryDistances", ")", "{", "if", "(", "boundaryDistances", "!=", "null", ")", "{", "boundaryDistances", "[", "0", "]", "=", "-", "1.0", ";", "boundaryDistances", "[", "1", "]", "=", "-", "1.0", ";", "}", "double", "[", "]", "tOld", "=", "new", "double", "[", "2", "]", ";", "// LOCALREFCLASS1(ArrayOf(double), int,", "// tOld, 2);", "int", "modified", "=", "0", ";", "Point2D", "delta", "=", "new", "Point2D", "(", "p1", ".", "x", "-", "p0", ".", "x", ",", "p1", ".", "y", "-", "p0", ".", "y", ")", ";", "if", "(", "delta", ".", "x", "==", "0.0", "&&", "delta", ".", "y", "==", "0.0", ")", "// input line degenerates to a", "// point", "{", "segParams", "[", "0", "]", "=", "0.0", ";", "segParams", "[", "1", "]", "=", "0.0", ";", "return", "contains", "(", "p0", ")", "?", "4", ":", "0", ";", "}", "segParams", "[", "0", "]", "=", "(", "(", "lineExtension", "&", "1", ")", "!=", "0", ")", "?", "NumberUtils", ".", "negativeInf", "(", ")", ":", "0.0", ";", "segParams", "[", "1", "]", "=", "(", "(", "lineExtension", "&", "2", ")", "!=", "0", ")", "?", "NumberUtils", ".", "positiveInf", "(", ")", ":", "1.0", ";", "tOld", "[", "0", "]", "=", "segParams", "[", "0", "]", ";", "tOld", "[", "1", "]", "=", "segParams", "[", "1", "]", ";", "if", "(", "clipLineAuxiliary", "(", "delta", ".", "x", ",", "xmin", "-", "p0", ".", "x", ",", "segParams", ")", "&&", "clipLineAuxiliary", "(", "-", "delta", ".", "x", ",", "p0", ".", "x", "-", "xmax", ",", "segParams", ")", "&&", "clipLineAuxiliary", "(", "delta", ".", "y", ",", "ymin", "-", "p0", ".", "y", ",", "segParams", ")", "&&", "clipLineAuxiliary", "(", "-", "delta", ".", "y", ",", "p0", ".", "y", "-", "ymax", ",", "segParams", ")", ")", "{", "if", "(", "segParams", "[", "1", "]", "<", "tOld", "[", "1", "]", ")", "{", "p1", ".", "scaleAdd", "(", "segParams", "[", "1", "]", ",", "delta", ",", "p0", ")", ";", "_snapToBoundary", "(", "p1", ")", ";", "// needed for accuracy", "modified", "|=", "2", ";", "if", "(", "boundaryDistances", "!=", "null", ")", "boundaryDistances", "[", "1", "]", "=", "_boundaryDistance", "(", "p1", ")", ";", "}", "if", "(", "segParams", "[", "0", "]", ">", "tOld", "[", "0", "]", ")", "{", "p0", ".", "scaleAdd", "(", "segParams", "[", "0", "]", ",", "delta", ",", "p0", ")", ";", "_snapToBoundary", "(", "p0", ")", ";", "// needed for accuracy", "modified", "|=", "1", ";", "if", "(", "boundaryDistances", "!=", "null", ")", "boundaryDistances", "[", "0", "]", "=", "_boundaryDistance", "(", "p0", ")", ";", "}", "}", "return", "modified", ";", "}"], "docstring": "4 - the segment is complitely inside of the clipping window", "docstring_tokens": ["4", "-", "the", "segment", "is", "complitely", "inside", "of", "the", "clipping", "window"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L996-L1047", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.sqrDistance", "original_string": "public double sqrDistance(Envelope2D other)\n\t{\n\t\tdouble dx = 0;\n\t\tdouble dy = 0;\n\t\tdouble nn;\n\n\t\tnn = xmin - other.xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin - other.ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\tnn = other.xmin - xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = other.ymin - ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\treturn dx * dx + dy * dy;\n\t}", "language": "java", "code": "public double sqrDistance(Envelope2D other)\n\t{\n\t\tdouble dx = 0;\n\t\tdouble dy = 0;\n\t\tdouble nn;\n\n\t\tnn = xmin - other.xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin - other.ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\tnn = other.xmin - xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = other.ymin - ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\treturn dx * dx + dy * dy;\n\t}", "code_tokens": ["public", "double", "sqrDistance", "(", "Envelope2D", "other", ")", "{", "double", "dx", "=", "0", ";", "double", "dy", "=", "0", ";", "double", "nn", ";", "nn", "=", "xmin", "-", "other", ".", "xmax", ";", "if", "(", "nn", ">", "dx", ")", "dx", "=", "nn", ";", "nn", "=", "ymin", "-", "other", ".", "ymax", ";", "if", "(", "nn", ">", "dy", ")", "dy", "=", "nn", ";", "nn", "=", "other", ".", "xmin", "-", "xmax", ";", "if", "(", "nn", ">", "dx", ")", "dx", "=", "nn", ";", "nn", "=", "other", ".", "ymin", "-", "ymax", ";", "if", "(", "nn", ">", "dy", ")", "dy", "=", "nn", ";", "return", "dx", "*", "dx", "+", "dy", "*", "dy", ";", "}"], "docstring": "Calculates minimum squared distance from this envelope to the other.\nReturns 0 for empty envelopes.\n@param other The other envelope.\n@return Returns the squared distance", "docstring_tokens": ["Calculates", "minimum", "squared", "distance", "from", "this", "envelope", "to", "the", "other", ".", "Returns", "0", "for", "empty", "envelopes", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L1126-L1149", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.sqrDistance", "original_string": "public double sqrDistance(double xmin_, double ymin_, double xmax_, double ymax_)\n\t{\n\t\tdouble dx = 0;\n\t\tdouble dy = 0;\n\t\tdouble nn;\n\n\t\tnn = xmin - xmax_;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin - ymax_;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\tnn = xmin_ - xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin_ - ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\treturn dx * dx + dy * dy;\n\t}", "language": "java", "code": "public double sqrDistance(double xmin_, double ymin_, double xmax_, double ymax_)\n\t{\n\t\tdouble dx = 0;\n\t\tdouble dy = 0;\n\t\tdouble nn;\n\n\t\tnn = xmin - xmax_;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin - ymax_;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\tnn = xmin_ - xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin_ - ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\treturn dx * dx + dy * dy;\n\t}", "code_tokens": ["public", "double", "sqrDistance", "(", "double", "xmin_", ",", "double", "ymin_", ",", "double", "xmax_", ",", "double", "ymax_", ")", "{", "double", "dx", "=", "0", ";", "double", "dy", "=", "0", ";", "double", "nn", ";", "nn", "=", "xmin", "-", "xmax_", ";", "if", "(", "nn", ">", "dx", ")", "dx", "=", "nn", ";", "nn", "=", "ymin", "-", "ymax_", ";", "if", "(", "nn", ">", "dy", ")", "dy", "=", "nn", ";", "nn", "=", "xmin_", "-", "xmax", ";", "if", "(", "nn", ">", "dx", ")", "dx", "=", "nn", ";", "nn", "=", "ymin_", "-", "ymax", ";", "if", "(", "nn", ">", "dy", ")", "dy", "=", "nn", ";", "return", "dx", "*", "dx", "+", "dy", "*", "dy", ";", "}"], "docstring": "Calculates minimum squared distance from this envelope to the other.\nReturns 0 for empty envelopes.\n@param xmin_\n@param ymin_\n@param xmax_\n@param ymax_\n@return Returns the squared distance.", "docstring_tokens": ["Calculates", "minimum", "squared", "distance", "from", "this", "envelope", "to", "the", "other", ".", "Returns", "0", "for", "empty", "envelopes", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L1160-L1183", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.sqrMaxDistance", "original_string": "public double sqrMaxDistance(Envelope2D other) {\n\t\tif (isEmpty() || other.isEmpty())\n\t\t\treturn NumberUtils.TheNaN;\n\n\t\tdouble dist = 0;\n\t\tPoint2D[] points = new Point2D[4];\n\t\tqueryCorners(points);\n\t\tPoint2D[] points_o = new Point2D[4];\n\t\tother.queryCorners(points_o);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tdouble d = Point2D.sqrDistance(points[i], points_o[j]);\n\t\t\t\tif (d > dist) {\n\t\t\t\t\tdist = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dist;\n\t}", "language": "java", "code": "public double sqrMaxDistance(Envelope2D other) {\n\t\tif (isEmpty() || other.isEmpty())\n\t\t\treturn NumberUtils.TheNaN;\n\n\t\tdouble dist = 0;\n\t\tPoint2D[] points = new Point2D[4];\n\t\tqueryCorners(points);\n\t\tPoint2D[] points_o = new Point2D[4];\n\t\tother.queryCorners(points_o);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tdouble d = Point2D.sqrDistance(points[i], points_o[j]);\n\t\t\t\tif (d > dist) {\n\t\t\t\t\tdist = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dist;\n\t}", "code_tokens": ["public", "double", "sqrMaxDistance", "(", "Envelope2D", "other", ")", "{", "if", "(", "isEmpty", "(", ")", "||", "other", ".", "isEmpty", "(", ")", ")", "return", "NumberUtils", ".", "TheNaN", ";", "double", "dist", "=", "0", ";", "Point2D", "[", "]", "points", "=", "new", "Point2D", "[", "4", "]", ";", "queryCorners", "(", "points", ")", ";", "Point2D", "[", "]", "points_o", "=", "new", "Point2D", "[", "4", "]", ";", "other", ".", "queryCorners", "(", "points_o", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "4", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "4", ";", "j", "++", ")", "{", "double", "d", "=", "Point2D", ".", "sqrDistance", "(", "points", "[", "i", "]", ",", "points_o", "[", "j", "]", ")", ";", "if", "(", "d", ">", "dist", ")", "{", "dist", "=", "d", ";", "}", "}", "}", "return", "dist", ";", "}"], "docstring": "Returns squared max distance between two bounding boxes. This is furthest distance between points on the two envelopes.\n\n@param other The bounding box to calculate the max distance two.\n@return Squared distance value.", "docstring_tokens": ["Returns", "squared", "max", "distance", "between", "two", "bounding", "boxes", ".", "This", "is", "furthest", "distance", "between", "points", "on", "the", "two", "envelopes", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L1191-L1210", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.sqrDistance", "original_string": "public double sqrDistance(Point2D pt2D)\n\t{\n\t\tdouble dx = 0;\n\t\tdouble dy = 0;\n\t\tdouble nn;\n\n\t\tnn = xmin - pt2D.x;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin - pt2D.y;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\tnn = pt2D.x - xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = pt2D.y - ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\treturn dx * dx + dy * dy;\n\t}", "language": "java", "code": "public double sqrDistance(Point2D pt2D)\n\t{\n\t\tdouble dx = 0;\n\t\tdouble dy = 0;\n\t\tdouble nn;\n\n\t\tnn = xmin - pt2D.x;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = ymin - pt2D.y;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\tnn = pt2D.x - xmax;\n\t\tif (nn > dx)\n\t\t\tdx = nn;\n\n\t\tnn = pt2D.y - ymax;\n\t\tif (nn > dy)\n\t\t\tdy = nn;\n\n\t\treturn dx * dx + dy * dy;\n\t}", "code_tokens": ["public", "double", "sqrDistance", "(", "Point2D", "pt2D", ")", "{", "double", "dx", "=", "0", ";", "double", "dy", "=", "0", ";", "double", "nn", ";", "nn", "=", "xmin", "-", "pt2D", ".", "x", ";", "if", "(", "nn", ">", "dx", ")", "dx", "=", "nn", ";", "nn", "=", "ymin", "-", "pt2D", ".", "y", ";", "if", "(", "nn", ">", "dy", ")", "dy", "=", "nn", ";", "nn", "=", "pt2D", ".", "x", "-", "xmax", ";", "if", "(", "nn", ">", "dx", ")", "dx", "=", "nn", ";", "nn", "=", "pt2D", ".", "y", "-", "ymax", ";", "if", "(", "nn", ">", "dy", ")", "dy", "=", "nn", ";", "return", "dx", "*", "dx", "+", "dy", "*", "dy", ";", "}"], "docstring": "Calculates minimum squared distance from this envelope to the point.\nReturns 0 for empty envelopes.\n@param pt2D The point.\n@return Returns the squared distance", "docstring_tokens": ["Calculates", "minimum", "squared", "distance", "from", "this", "envelope", "to", "the", "point", ".", "Returns", "0", "for", "empty", "envelopes", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L1218-L1241", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.getXY", "original_string": "@Override\n\tpublic Point2D getXY(int index) {\n\t\tPoint2D pt = new Point2D();\n\t\tgetXY(index, pt);\n\t\treturn pt;\n\t}", "language": "java", "code": "@Override\n\tpublic Point2D getXY(int index) {\n\t\tPoint2D pt = new Point2D();\n\t\tgetXY(index, pt);\n\t\treturn pt;\n\t}", "code_tokens": ["@", "Override", "public", "Point2D", "getXY", "(", "int", "index", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "getXY", "(", "index", ",", "pt", ")", ";", "return", "pt", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L239-L244", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setXY", "original_string": "@Override\n\tpublic void setXY(int index, Point2D pt) {\n\t\tif (index < 0 || index >= m_pointCount)\n\t\t\t// TODO exception\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\t// AttributeStreamOfDbl v = (AttributeStreamOfDbl)\n\t\t// m_vertexAttributes[0];\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tv.write(index * 2, pt);\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "language": "java", "code": "@Override\n\tpublic void setXY(int index, Point2D pt) {\n\t\tif (index < 0 || index >= m_pointCount)\n\t\t\t// TODO exception\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\t// AttributeStreamOfDbl v = (AttributeStreamOfDbl)\n\t\t// m_vertexAttributes[0];\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tv.write(index * 2, pt);\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "code_tokens": ["@", "Override", "public", "void", "setXY", "(", "int", "index", ",", "Point2D", "pt", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">=", "m_pointCount", ")", "// TODO exception", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "// AttributeStreamOfDbl v = (AttributeStreamOfDbl)", "// m_vertexAttributes[0];", "AttributeStreamOfDbl", "v", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "v", ".", "write", "(", "index", "*", "2", ",", "pt", ")", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L259-L271", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setXY", "original_string": "public void setXY(int index, double x, double y) {\n\t\tif (index < 0 || index >= m_pointCount)\n\t\t\t// TODO exc\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\t// AttributeStreamOfDbl v = (AttributeStreamOfDbl)\n\t\t// m_vertexAttributes[0];\n\t\t// TODO ask sergey about casts\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tv.write(index * 2, x);\n\t\tv.write(index * 2 + 1, y);\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "language": "java", "code": "public void setXY(int index, double x, double y) {\n\t\tif (index < 0 || index >= m_pointCount)\n\t\t\t// TODO exc\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\t// AttributeStreamOfDbl v = (AttributeStreamOfDbl)\n\t\t// m_vertexAttributes[0];\n\t\t// TODO ask sergey about casts\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tv.write(index * 2, x);\n\t\tv.write(index * 2 + 1, y);\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t}", "code_tokens": ["public", "void", "setXY", "(", "int", "index", ",", "double", "x", ",", "double", "y", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">=", "m_pointCount", ")", "// TODO exc", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "// AttributeStreamOfDbl v = (AttributeStreamOfDbl)", "// m_vertexAttributes[0];", "// TODO ask sergey about casts", "AttributeStreamOfDbl", "v", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "v", ".", "write", "(", "index", "*", "2", ",", "x", ")", ";", "v", ".", "write", "(", "index", "*", "2", "+", "1", ",", "y", ")", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L274-L287", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.getXYZ", "original_string": "@Override\n\tpublic Point3D getXYZ(int index) {\n\t\tif (index < 0 || index >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint3D pt = new Point3D();\n\t\tpt.x = v.read(index * 2);\n\t\tpt.y = v.read(index * 2 + 1);\n\n\t\t// TODO check excluded if statement componenet\n\t\tif (hasAttribute(Semantics.Z))// && (m_vertexAttributes[1] != null))\n\t\t\tpt.z = m_vertexAttributes[1].readAsDbl(index);\n\t\telse\n\t\t\tpt.z = VertexDescription.getDefaultValue(Semantics.Z);\n\n\t\treturn pt;\n\t}", "language": "java", "code": "@Override\n\tpublic Point3D getXYZ(int index) {\n\t\tif (index < 0 || index >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint3D pt = new Point3D();\n\t\tpt.x = v.read(index * 2);\n\t\tpt.y = v.read(index * 2 + 1);\n\n\t\t// TODO check excluded if statement componenet\n\t\tif (hasAttribute(Semantics.Z))// && (m_vertexAttributes[1] != null))\n\t\t\tpt.z = m_vertexAttributes[1].readAsDbl(index);\n\t\telse\n\t\t\tpt.z = VertexDescription.getDefaultValue(Semantics.Z);\n\n\t\treturn pt;\n\t}", "code_tokens": ["@", "Override", "public", "Point3D", "getXYZ", "(", "int", "index", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">=", "getPointCount", "(", ")", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "AttributeStreamOfDbl", "v", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "Point3D", "pt", "=", "new", "Point3D", "(", ")", ";", "pt", ".", "x", "=", "v", ".", "read", "(", "index", "*", "2", ")", ";", "pt", ".", "y", "=", "v", ".", "read", "(", "index", "*", "2", "+", "1", ")", ";", "// TODO check excluded if statement componenet", "if", "(", "hasAttribute", "(", "Semantics", ".", "Z", ")", ")", "// && (m_vertexAttributes[1] != null))", "pt", ".", "z", "=", "m_vertexAttributes", "[", "1", "]", ".", "readAsDbl", "(", "index", ")", ";", "else", "pt", ".", "z", "=", "VertexDescription", ".", "getDefaultValue", "(", "Semantics", ".", "Z", ")", ";", "return", "pt", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L290-L308", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setXYZ", "original_string": "@Override\n\tpublic void setXYZ(int index, Point3D pt) {\n\t\tif (index < 0 || index >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\taddAttribute(Semantics.Z);\n\n\t\t_verifyAllStreams();\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tv.write(index * 2, pt.x);\n\t\tv.write(index * 2 + 1, pt.y);\n\t\tm_vertexAttributes[1].writeAsDbl(index, pt.z);\n\t}", "language": "java", "code": "@Override\n\tpublic void setXYZ(int index, Point3D pt) {\n\t\tif (index < 0 || index >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\taddAttribute(Semantics.Z);\n\n\t\t_verifyAllStreams();\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tv.write(index * 2, pt.x);\n\t\tv.write(index * 2 + 1, pt.y);\n\t\tm_vertexAttributes[1].writeAsDbl(index, pt.z);\n\t}", "code_tokens": ["@", "Override", "public", "void", "setXYZ", "(", "int", "index", ",", "Point3D", "pt", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">=", "getPointCount", "(", ")", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "addAttribute", "(", "Semantics", ".", "Z", ")", ";", "_verifyAllStreams", "(", ")", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "AttributeStreamOfDbl", "v", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "v", ".", "write", "(", "index", "*", "2", ",", "pt", ".", "x", ")", ";", "v", ".", "write", "(", "index", "*", "2", "+", "1", ",", "pt", ".", "y", ")", ";", "m_vertexAttributes", "[", "1", "]", ".", "writeAsDbl", "(", "index", ",", "pt", ".", "z", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L311-L324", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.getAttributeAsDbl", "original_string": "@Override\n\tpublic double getAttributeAsDbl(int semantics, int offset, int ordinate) {\n\t\tif (offset < 0 || offset >= m_pointCount)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ordinate >= ncomps)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\t// TODO check if statement\n\t\tif (attributeIndex >= 0)// && m_vertexAttributes[attributeIndex] !=\n\t\t\t\t\t\t\t\t// null) {\n\t\t{\n\t\t\treturn m_vertexAttributes[attributeIndex].readAsDbl(offset * ncomps\n\t\t\t\t\t+ ordinate);\n\t\t}\n\t\treturn VertexDescription.getDefaultValue(semantics);\n\t}", "language": "java", "code": "@Override\n\tpublic double getAttributeAsDbl(int semantics, int offset, int ordinate) {\n\t\tif (offset < 0 || offset >= m_pointCount)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ordinate >= ncomps)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\t// TODO check if statement\n\t\tif (attributeIndex >= 0)// && m_vertexAttributes[attributeIndex] !=\n\t\t\t\t\t\t\t\t// null) {\n\t\t{\n\t\t\treturn m_vertexAttributes[attributeIndex].readAsDbl(offset * ncomps\n\t\t\t\t\t+ ordinate);\n\t\t}\n\t\treturn VertexDescription.getDefaultValue(semantics);\n\t}", "code_tokens": ["@", "Override", "public", "double", "getAttributeAsDbl", "(", "int", "semantics", ",", "int", "offset", ",", "int", "ordinate", ")", "{", "if", "(", "offset", "<", "0", "||", "offset", ">=", "m_pointCount", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "if", "(", "ordinate", ">=", "ncomps", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "int", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "// TODO check if statement", "if", "(", "attributeIndex", ">=", "0", ")", "// && m_vertexAttributes[attributeIndex] !=", "// null) {", "{", "return", "m_vertexAttributes", "[", "attributeIndex", "]", ".", "readAsDbl", "(", "offset", "*", "ncomps", "+", "ordinate", ")", ";", "}", "return", "VertexDescription", ".", "getDefaultValue", "(", "semantics", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L327-L346", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setAttribute", "original_string": "@Override\n\tpublic void setAttribute(int semantics, int offset, int ordinate,\n\t\t\tdouble value) {\n\t\tif (offset < 0 || offset >= m_pointCount)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ordinate >= ncomps)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\taddAttribute(semantics);\n\t\t_verifyAllStreams();\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t\tm_vertexAttributes[attributeIndex].writeAsDbl(offset * ncomps\n\t\t\t\t+ ordinate, value);\n\t}", "language": "java", "code": "@Override\n\tpublic void setAttribute(int semantics, int offset, int ordinate,\n\t\t\tdouble value) {\n\t\tif (offset < 0 || offset >= m_pointCount)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\tint ncomps = VertexDescription.getComponentCount(semantics);\n\t\tif (ordinate >= ncomps)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\taddAttribute(semantics);\n\t\t_verifyAllStreams();\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tnotifyModified(DirtyFlags.DirtyCoordinates);\n\t\tm_vertexAttributes[attributeIndex].writeAsDbl(offset * ncomps\n\t\t\t\t+ ordinate, value);\n\t}", "code_tokens": ["@", "Override", "public", "void", "setAttribute", "(", "int", "semantics", ",", "int", "offset", ",", "int", "ordinate", ",", "double", "value", ")", "{", "if", "(", "offset", "<", "0", "||", "offset", ">=", "m_pointCount", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "if", "(", "ordinate", ">=", "ncomps", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "addAttribute", "(", "semantics", ")", ";", "_verifyAllStreams", "(", ")", ";", "int", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyCoordinates", ")", ";", "m_vertexAttributes", "[", "attributeIndex", "]", ".", "writeAsDbl", "(", "offset", "*", "ncomps", "+", "ordinate", ",", "value", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L355-L371", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setAttribute", "original_string": "@Override\n\tpublic void setAttribute(int semantics, int offset, int ordinate, int value) {\n\t\tsetAttribute(semantics, offset, ordinate, (double) value);\n\t}", "language": "java", "code": "@Override\n\tpublic void setAttribute(int semantics, int offset, int ordinate, int value) {\n\t\tsetAttribute(semantics, offset, ordinate, (double) value);\n\t}", "code_tokens": ["@", "Override", "public", "void", "setAttribute", "(", "int", "semantics", ",", "int", "offset", ",", "int", "ordinate", ",", "int", "value", ")", "{", "setAttribute", "(", "semantics", ",", "offset", ",", "ordinate", ",", "(", "double", ")", "value", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L374-L377", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setAttributeStreamRef", "original_string": "public void setAttributeStreamRef(int semantics, AttributeStreamBase stream) {\n\t\t// int test1 = VertexDescription.getPersistence(semantics);\n\t\t// int test2 = stream.getPersistence();\n\n\t\tif ((stream != null)\n\t\t\t\t&& VertexDescription.getPersistence(semantics) != stream\n\t\t\t\t\t\t.getPersistence())// input stream has wrong persistence\n\t\t\tthrow new IllegalArgumentException();\n\n\t\t// Do not check for the stream size here to allow several streams to be\n\t\t// attached before the point count is changed.\n\t\taddAttribute(semantics);\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tif (m_vertexAttributes == null)\n\t\t\tm_vertexAttributes = new AttributeStreamBase[m_description\n\t\t\t\t\t.getAttributeCount()];\n\n\t\tm_vertexAttributes[attributeIndex] = stream;\n\t\tnotifyModified(DirtyFlags.DirtyAll);\n\t}", "language": "java", "code": "public void setAttributeStreamRef(int semantics, AttributeStreamBase stream) {\n\t\t// int test1 = VertexDescription.getPersistence(semantics);\n\t\t// int test2 = stream.getPersistence();\n\n\t\tif ((stream != null)\n\t\t\t\t&& VertexDescription.getPersistence(semantics) != stream\n\t\t\t\t\t\t.getPersistence())// input stream has wrong persistence\n\t\t\tthrow new IllegalArgumentException();\n\n\t\t// Do not check for the stream size here to allow several streams to be\n\t\t// attached before the point count is changed.\n\t\taddAttribute(semantics);\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\t\tif (m_vertexAttributes == null)\n\t\t\tm_vertexAttributes = new AttributeStreamBase[m_description\n\t\t\t\t\t.getAttributeCount()];\n\n\t\tm_vertexAttributes[attributeIndex] = stream;\n\t\tnotifyModified(DirtyFlags.DirtyAll);\n\t}", "code_tokens": ["public", "void", "setAttributeStreamRef", "(", "int", "semantics", ",", "AttributeStreamBase", "stream", ")", "{", "// int test1 = VertexDescription.getPersistence(semantics);", "// int test2 = stream.getPersistence();", "if", "(", "(", "stream", "!=", "null", ")", "&&", "VertexDescription", ".", "getPersistence", "(", "semantics", ")", "!=", "stream", ".", "getPersistence", "(", ")", ")", "// input stream has wrong persistence", "throw", "new", "IllegalArgumentException", "(", ")", ";", "// Do not check for the stream size here to allow several streams to be", "// attached before the point count is changed.", "addAttribute", "(", "semantics", ")", ";", "int", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "if", "(", "m_vertexAttributes", "==", "null", ")", "m_vertexAttributes", "=", "new", "AttributeStreamBase", "[", "m_description", ".", "getAttributeCount", "(", ")", "]", ";", "m_vertexAttributes", "[", "attributeIndex", "]", "=", "stream", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyAll", ")", ";", "}"], "docstring": "Sets a reference to the given AttributeStream of the Geometry. Once the\nbuffer has been obtained, the vertices of the Geometry can be manipulated\ndirectly. The AttributeStream parameters are not checked for the size. <br>\nIf the attribute is missing, it will be added. <br>\nNote, that this method does not change the vertex count in the Geometry. <br>\nThe stream can have more elements, than the Geometry point count, but\nonly necessary part will be saved when exporting to a ESRI shape or other\nformat. @param semantics Semantics of the attribute to assign the stream\nto. @param stream The input AttributeStream that will be assigned by\nreference. If one changes the stream later through the reference, one has\nto call NotifyStreamChanged. \\exception Throws invalid_argument exception\nif the input stream type does not match that of the semantics\npersistence.", "docstring_tokens": ["Sets", "a", "reference", "to", "the", "given", "AttributeStream", "of", "the", "Geometry", ".", "Once", "the", "buffer", "has", "been", "obtained", "the", "vertices", "of", "the", "Geometry", "can", "be", "manipulated", "directly", ".", "The", "AttributeStream", "parameters", "are", "not", "checked", "for", "the", "size", ".", "<br", ">", "If", "the", "attribute", "is", "missing", "it", "will", "be", "added", ".", "<br", ">", "Note", "that", "this", "method", "does", "not", "change", "the", "vertex", "count", "in", "the", "Geometry", ".", "<br", ">", "The", "stream", "can", "have", "more", "elements", "than", "the", "Geometry", "point", "count", "but", "only", "necessary", "part", "will", "be", "saved", "when", "exporting", "to", "a", "ESRI", "shape", "or", "other", "format", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L404-L423", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.queryInterval", "original_string": "@Override\n\tpublic Envelope1D queryInterval(int semantics, int ordinate) {\n\t\tEnvelope1D env = new Envelope1D();\n\t\tif (isEmptyImpl()) {\n\t\t\tenv.setEmpty();\n\t\t\treturn env;\n\t\t}\n\n\t\t_updateAllDirtyIntervals(true);\n\t\treturn m_envelope.queryInterval(semantics, ordinate);\n\t}", "language": "java", "code": "@Override\n\tpublic Envelope1D queryInterval(int semantics, int ordinate) {\n\t\tEnvelope1D env = new Envelope1D();\n\t\tif (isEmptyImpl()) {\n\t\t\tenv.setEmpty();\n\t\t\treturn env;\n\t\t}\n\n\t\t_updateAllDirtyIntervals(true);\n\t\treturn m_envelope.queryInterval(semantics, ordinate);\n\t}", "code_tokens": ["@", "Override", "public", "Envelope1D", "queryInterval", "(", "int", "semantics", ",", "int", "ordinate", ")", "{", "Envelope1D", "env", "=", "new", "Envelope1D", "(", ")", ";", "if", "(", "isEmptyImpl", "(", ")", ")", "{", "env", ".", "setEmpty", "(", ")", ";", "return", "env", ";", "}", "_updateAllDirtyIntervals", "(", "true", ")", ";", "return", "m_envelope", ".", "queryInterval", "(", "semantics", ",", "ordinate", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L520-L530", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.setEnvelope", "original_string": "public void setEnvelope(Envelope env) {\n\t\tif (!m_description.equals(env.getDescription()))\n\t\t\tthrow new IllegalArgumentException();\n\n\t\t// m_envelope = (Envelope) env.clone();\n\t\tm_envelope = (Envelope) env.createInstance();\n\t\tenv.copyTo(m_envelope);\n\t\t_setDirtyFlag(DirtyFlags.DirtyIntervals, false);\n\t}", "language": "java", "code": "public void setEnvelope(Envelope env) {\n\t\tif (!m_description.equals(env.getDescription()))\n\t\t\tthrow new IllegalArgumentException();\n\n\t\t// m_envelope = (Envelope) env.clone();\n\t\tm_envelope = (Envelope) env.createInstance();\n\t\tenv.copyTo(m_envelope);\n\t\t_setDirtyFlag(DirtyFlags.DirtyIntervals, false);\n\t}", "code_tokens": ["public", "void", "setEnvelope", "(", "Envelope", "env", ")", "{", "if", "(", "!", "m_description", ".", "equals", "(", "env", ".", "getDescription", "(", ")", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "// m_envelope = (Envelope) env.clone();", "m_envelope", "=", "(", "Envelope", ")", "env", ".", "createInstance", "(", ")", ";", "env", ".", "copyTo", "(", "m_envelope", ")", ";", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyIntervals", ",", "false", ")", ";", "}"], "docstring": "Sets the envelope of the Geometry. The Envelope description must match\nthat of the Geometry.", "docstring_tokens": ["Sets", "the", "envelope", "of", "the", "Geometry", ".", "The", "Envelope", "description", "must", "match", "that", "of", "the", "Geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L600-L608", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl._copyToUnsafe", "original_string": "void _copyToUnsafe(MultiVertexGeometryImpl dst) {\n\t\t_verifyAllStreams();\n\t\tdst.m_description = m_description;\n\t\tdst.m_vertexAttributes = null;\n\t\tint nattrib = m_description.getAttributeCount();\n\t\tAttributeStreamBase[] cloneAttributes = null;\n\t\tif (m_vertexAttributes != null) {\n\t\t\tcloneAttributes = new AttributeStreamBase[nattrib];\n\t\t\tfor (int i = 0; i < nattrib; i++) {\n\t\t\t\tif (m_vertexAttributes[i] != null) {\n\t\t\t\t\tint ncomps = VertexDescription\n\t\t\t\t\t\t\t.getComponentCount(m_description\n\t\t\t\t\t\t\t\t\t._getSemanticsImpl(i));\n\t\t\t\t\tcloneAttributes[i] = m_vertexAttributes[i]\n\t\t\t\t\t\t\t.restrictedClone(getPointCount() * ncomps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m_envelope != null) {\n\t\t\tdst.m_envelope = (Envelope) m_envelope.createInstance();\n\t\t\tm_envelope.copyTo(dst.m_envelope);\n\t\t\t// dst.m_envelope = (Envelope) m_envelope.clone();\n\t\t} else\n\t\t\tdst.m_envelope = null;\n\n\t\tdst.m_pointCount = m_pointCount;\n\t\tdst.m_flagsMask = m_flagsMask;\n\t\tdst.m_vertexAttributes = cloneAttributes;\n\n\t\ttry {\n\t\t\t_copyToImpl(dst); // copy child props\n\t\t} catch (Exception ex) {\n\t\t\tdst.setEmpty();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}", "language": "java", "code": "void _copyToUnsafe(MultiVertexGeometryImpl dst) {\n\t\t_verifyAllStreams();\n\t\tdst.m_description = m_description;\n\t\tdst.m_vertexAttributes = null;\n\t\tint nattrib = m_description.getAttributeCount();\n\t\tAttributeStreamBase[] cloneAttributes = null;\n\t\tif (m_vertexAttributes != null) {\n\t\t\tcloneAttributes = new AttributeStreamBase[nattrib];\n\t\t\tfor (int i = 0; i < nattrib; i++) {\n\t\t\t\tif (m_vertexAttributes[i] != null) {\n\t\t\t\t\tint ncomps = VertexDescription\n\t\t\t\t\t\t\t.getComponentCount(m_description\n\t\t\t\t\t\t\t\t\t._getSemanticsImpl(i));\n\t\t\t\t\tcloneAttributes[i] = m_vertexAttributes[i]\n\t\t\t\t\t\t\t.restrictedClone(getPointCount() * ncomps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m_envelope != null) {\n\t\t\tdst.m_envelope = (Envelope) m_envelope.createInstance();\n\t\t\tm_envelope.copyTo(dst.m_envelope);\n\t\t\t// dst.m_envelope = (Envelope) m_envelope.clone();\n\t\t} else\n\t\t\tdst.m_envelope = null;\n\n\t\tdst.m_pointCount = m_pointCount;\n\t\tdst.m_flagsMask = m_flagsMask;\n\t\tdst.m_vertexAttributes = cloneAttributes;\n\n\t\ttry {\n\t\t\t_copyToImpl(dst); // copy child props\n\t\t} catch (Exception ex) {\n\t\t\tdst.setEmpty();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}", "code_tokens": ["void", "_copyToUnsafe", "(", "MultiVertexGeometryImpl", "dst", ")", "{", "_verifyAllStreams", "(", ")", ";", "dst", ".", "m_description", "=", "m_description", ";", "dst", ".", "m_vertexAttributes", "=", "null", ";", "int", "nattrib", "=", "m_description", ".", "getAttributeCount", "(", ")", ";", "AttributeStreamBase", "[", "]", "cloneAttributes", "=", "null", ";", "if", "(", "m_vertexAttributes", "!=", "null", ")", "{", "cloneAttributes", "=", "new", "AttributeStreamBase", "[", "nattrib", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nattrib", ";", "i", "++", ")", "{", "if", "(", "m_vertexAttributes", "[", "i", "]", "!=", "null", ")", "{", "int", "ncomps", "=", "VertexDescription", ".", "getComponentCount", "(", "m_description", ".", "_getSemanticsImpl", "(", "i", ")", ")", ";", "cloneAttributes", "[", "i", "]", "=", "m_vertexAttributes", "[", "i", "]", ".", "restrictedClone", "(", "getPointCount", "(", ")", "*", "ncomps", ")", ";", "}", "}", "}", "if", "(", "m_envelope", "!=", "null", ")", "{", "dst", ".", "m_envelope", "=", "(", "Envelope", ")", "m_envelope", ".", "createInstance", "(", ")", ";", "m_envelope", ".", "copyTo", "(", "dst", ".", "m_envelope", ")", ";", "// dst.m_envelope = (Envelope) m_envelope.clone();", "}", "else", "dst", ".", "m_envelope", "=", "null", ";", "dst", ".", "m_pointCount", "=", "m_pointCount", ";", "dst", ".", "m_flagsMask", "=", "m_flagsMask", ";", "dst", ".", "m_vertexAttributes", "=", "cloneAttributes", ";", "try", "{", "_copyToImpl", "(", "dst", ")", ";", "// copy child props", "}", "catch", "(", "Exception", "ex", ")", "{", "dst", ".", "setEmpty", "(", ")", ";", "throw", "new", "RuntimeException", "(", "ex", ")", ";", "}", "}"], "docstring": "Does not check geometry type. Used to copy Polygon to Polyline", "docstring_tokens": ["Does", "not", "check", "geometry", "type", ".", "Used", "to", "copy", "Polygon", "to", "Polyline"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L620-L656", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl._attributeStreamIsAllocated", "original_string": "public boolean _attributeStreamIsAllocated(int semantics) {\n\t\tthrowIfEmpty();\n\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\n\t\tif (attributeIndex >= 0 && m_vertexAttributes[attributeIndex] != null)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "public boolean _attributeStreamIsAllocated(int semantics) {\n\t\tthrowIfEmpty();\n\n\t\tint attributeIndex = m_description.getAttributeIndex(semantics);\n\n\t\tif (attributeIndex >= 0 && m_vertexAttributes[attributeIndex] != null)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["public", "boolean", "_attributeStreamIsAllocated", "(", "int", "semantics", ")", "{", "throwIfEmpty", "(", ")", ";", "int", "attributeIndex", "=", "m_description", ".", "getAttributeIndex", "(", "semantics", ")", ";", "if", "(", "attributeIndex", ">=", "0", "&&", "m_vertexAttributes", "[", "attributeIndex", "]", "!=", "null", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L659-L668", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.notifyModified", "original_string": "public void notifyModified(int flags) {\n\t\tif (flags == DirtyFlags.DirtyAll) {\n\t\t\tm_reservedPointCount = -1;// forget the reserved point number\n\t\t\t_notifyModifiedAllImpl();\n\t\t}\n\t\tm_flagsMask |= flags;\n\n\t\t_clearAccelerators();\n\t\t_touch();\n\t}", "language": "java", "code": "public void notifyModified(int flags) {\n\t\tif (flags == DirtyFlags.DirtyAll) {\n\t\t\tm_reservedPointCount = -1;// forget the reserved point number\n\t\t\t_notifyModifiedAllImpl();\n\t\t}\n\t\tm_flagsMask |= flags;\n\n\t\t_clearAccelerators();\n\t\t_touch();\n\t}", "code_tokens": ["public", "void", "notifyModified", "(", "int", "flags", ")", "{", "if", "(", "flags", "==", "DirtyFlags", ".", "DirtyAll", ")", "{", "m_reservedPointCount", "=", "-", "1", ";", "// forget the reserved point number", "_notifyModifiedAllImpl", "(", ")", ";", "}", "m_flagsMask", "|=", "flags", ";", "_clearAccelerators", "(", ")", ";", "_touch", "(", ")", ";", "}"], "docstring": "Notifies the Geometry of changes made to the vertices so that it could\nreset cached structures.", "docstring_tokens": ["Notifies", "the", "Geometry", "of", "changes", "made", "to", "the", "vertices", "so", "that", "it", "could", "reset", "cached", "structures", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L683-L692", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl._updateXYImpl", "original_string": "public void _updateXYImpl(boolean bExact) {\n\t\tm_envelope.setEmpty();\n\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint2D pt = new Point2D();\n\t\tfor (int i = 0; i < m_pointCount; i++) {\n\t\t\tstream.read(2 * i, pt);\n\t\t\tm_envelope.merge(pt);\n\t\t}\n\t}", "language": "java", "code": "public void _updateXYImpl(boolean bExact) {\n\t\tm_envelope.setEmpty();\n\t\tAttributeStreamOfDbl stream = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint2D pt = new Point2D();\n\t\tfor (int i = 0; i < m_pointCount; i++) {\n\t\t\tstream.read(2 * i, pt);\n\t\t\tm_envelope.merge(pt);\n\t\t}\n\t}", "code_tokens": ["public", "void", "_updateXYImpl", "(", "boolean", "bExact", ")", "{", "m_envelope", ".", "setEmpty", "(", ")", ";", "AttributeStreamOfDbl", "stream", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_pointCount", ";", "i", "++", ")", "{", "stream", ".", "read", "(", "2", "*", "i", ",", "pt", ")", ";", "m_envelope", ".", "merge", "(", "pt", ")", ";", "}", "}"], "docstring": "\\internal Updates x, y intervals.", "docstring_tokens": ["\\", "internal", "Updates", "x", "y", "intervals", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L747-L755", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl._verifyAllStreamsImpl", "original_string": "protected void _verifyAllStreamsImpl() {\n\t\t// This method checks that the streams are of correct size.\n\t\t// It resizes the streams to ensure they are not shorter than\n\t\t// m_PointCount\n\t\t// _ASSERT(_HasDirtyFlag(enum_value1(DirtyFlags,\n\t\t// DirtyVerifiedStreams)));\n\t\tif (m_reservedPointCount < m_pointCount) // an optimization to skip this\n\t\t\t\t\t\t\t\t\t\t\t\t\t// expensive loop when\n\t\t\t\t\t\t\t\t\t\t\t\t\t// adding point by point\n\t\t{\n\t\t\tif (m_vertexAttributes == null)\n\t\t\t\tm_vertexAttributes = new AttributeStreamBase[m_description\n\t\t\t\t\t\t.getAttributeCount()];\n\n\t\t\tm_reservedPointCount = NumberUtils.intMax();\n\t\t\tfor (int attributeIndex = 0; attributeIndex < m_description\n\t\t\t\t\t.getAttributeCount(); attributeIndex++) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(attributeIndex);\n\t\t\t\tif (m_vertexAttributes[attributeIndex] != null) {\n\t\t\t\t\tint ncomp = VertexDescription.getComponentCount(semantics);\n\t\t\t\t\tint size = m_vertexAttributes[attributeIndex].virtualSize()\n\t\t\t\t\t\t\t/ ncomp;\n\t\t\t\t\tif (size < m_pointCount) {\n\t\t\t\t\t\tsize = (m_reservedPointCount > m_pointCount + 5) ? (m_pointCount * 5 + 3) / 4\n\t\t\t\t\t\t\t\t: m_pointCount;// reserve 25% more than user\n\t\t\t\t\t\t\t\t\t\t\t\t// asks\n\t\t\t\t\t\tm_vertexAttributes[attributeIndex].resize(size * ncomp,\n\t\t\t\t\t\t\t\tVertexDescription.getDefaultValue(semantics));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (size < m_reservedPointCount)\n\t\t\t\t\t\tm_reservedPointCount = size;\n\t\t\t\t} else {\n\t\t\t\t\tm_vertexAttributes[attributeIndex] = AttributeStreamBase\n\t\t\t\t\t\t\t.createAttributeStreamWithSemantics(semantics,\n\t\t\t\t\t\t\t\t\tm_pointCount);\n\t\t\t\t\tm_reservedPointCount = m_pointCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_verifyStreamsImpl();\n\n\t\t_setDirtyFlag(DirtyFlags.DirtyVerifiedStreams, false);\n\t}", "language": "java", "code": "protected void _verifyAllStreamsImpl() {\n\t\t// This method checks that the streams are of correct size.\n\t\t// It resizes the streams to ensure they are not shorter than\n\t\t// m_PointCount\n\t\t// _ASSERT(_HasDirtyFlag(enum_value1(DirtyFlags,\n\t\t// DirtyVerifiedStreams)));\n\t\tif (m_reservedPointCount < m_pointCount) // an optimization to skip this\n\t\t\t\t\t\t\t\t\t\t\t\t\t// expensive loop when\n\t\t\t\t\t\t\t\t\t\t\t\t\t// adding point by point\n\t\t{\n\t\t\tif (m_vertexAttributes == null)\n\t\t\t\tm_vertexAttributes = new AttributeStreamBase[m_description\n\t\t\t\t\t\t.getAttributeCount()];\n\n\t\t\tm_reservedPointCount = NumberUtils.intMax();\n\t\t\tfor (int attributeIndex = 0; attributeIndex < m_description\n\t\t\t\t\t.getAttributeCount(); attributeIndex++) {\n\t\t\t\tint semantics = m_description._getSemanticsImpl(attributeIndex);\n\t\t\t\tif (m_vertexAttributes[attributeIndex] != null) {\n\t\t\t\t\tint ncomp = VertexDescription.getComponentCount(semantics);\n\t\t\t\t\tint size = m_vertexAttributes[attributeIndex].virtualSize()\n\t\t\t\t\t\t\t/ ncomp;\n\t\t\t\t\tif (size < m_pointCount) {\n\t\t\t\t\t\tsize = (m_reservedPointCount > m_pointCount + 5) ? (m_pointCount * 5 + 3) / 4\n\t\t\t\t\t\t\t\t: m_pointCount;// reserve 25% more than user\n\t\t\t\t\t\t\t\t\t\t\t\t// asks\n\t\t\t\t\t\tm_vertexAttributes[attributeIndex].resize(size * ncomp,\n\t\t\t\t\t\t\t\tVertexDescription.getDefaultValue(semantics));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (size < m_reservedPointCount)\n\t\t\t\t\t\tm_reservedPointCount = size;\n\t\t\t\t} else {\n\t\t\t\t\tm_vertexAttributes[attributeIndex] = AttributeStreamBase\n\t\t\t\t\t\t\t.createAttributeStreamWithSemantics(semantics,\n\t\t\t\t\t\t\t\t\tm_pointCount);\n\t\t\t\t\tm_reservedPointCount = m_pointCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_verifyStreamsImpl();\n\n\t\t_setDirtyFlag(DirtyFlags.DirtyVerifiedStreams, false);\n\t}", "code_tokens": ["protected", "void", "_verifyAllStreamsImpl", "(", ")", "{", "// This method checks that the streams are of correct size.", "// It resizes the streams to ensure they are not shorter than", "// m_PointCount", "// _ASSERT(_HasDirtyFlag(enum_value1(DirtyFlags,", "// DirtyVerifiedStreams)));", "if", "(", "m_reservedPointCount", "<", "m_pointCount", ")", "// an optimization to skip this", "// expensive loop when", "// adding point by point", "{", "if", "(", "m_vertexAttributes", "==", "null", ")", "m_vertexAttributes", "=", "new", "AttributeStreamBase", "[", "m_description", ".", "getAttributeCount", "(", ")", "]", ";", "m_reservedPointCount", "=", "NumberUtils", ".", "intMax", "(", ")", ";", "for", "(", "int", "attributeIndex", "=", "0", ";", "attributeIndex", "<", "m_description", ".", "getAttributeCount", "(", ")", ";", "attributeIndex", "++", ")", "{", "int", "semantics", "=", "m_description", ".", "_getSemanticsImpl", "(", "attributeIndex", ")", ";", "if", "(", "m_vertexAttributes", "[", "attributeIndex", "]", "!=", "null", ")", "{", "int", "ncomp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "int", "size", "=", "m_vertexAttributes", "[", "attributeIndex", "]", ".", "virtualSize", "(", ")", "/", "ncomp", ";", "if", "(", "size", "<", "m_pointCount", ")", "{", "size", "=", "(", "m_reservedPointCount", ">", "m_pointCount", "+", "5", ")", "?", "(", "m_pointCount", "*", "5", "+", "3", ")", "/", "4", ":", "m_pointCount", ";", "// reserve 25% more than user", "// asks", "m_vertexAttributes", "[", "attributeIndex", "]", ".", "resize", "(", "size", "*", "ncomp", ",", "VertexDescription", ".", "getDefaultValue", "(", "semantics", ")", ")", ";", "}", "if", "(", "size", "<", "m_reservedPointCount", ")", "m_reservedPointCount", "=", "size", ";", "}", "else", "{", "m_vertexAttributes", "[", "attributeIndex", "]", "=", "AttributeStreamBase", ".", "createAttributeStreamWithSemantics", "(", "semantics", ",", "m_pointCount", ")", ";", "m_reservedPointCount", "=", "m_pointCount", ";", "}", "}", "}", "_verifyStreamsImpl", "(", ")", ";", "_setDirtyFlag", "(", "DirtyFlags", ".", "DirtyVerifiedStreams", ",", "false", ")", ";", "}"], "docstring": "\\internal Verifies all streams (calls _VerifyStream for every attribute).", "docstring_tokens": ["\\", "internal", "Verifies", "all", "streams", "(", "calls", "_VerifyStream", "for", "every", "attribute", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L771-L814", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl._resizeImpl", "original_string": "void _resizeImpl(int pointCount) {\n\t\tif (pointCount < 0)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (pointCount == m_pointCount)\n\t\t\treturn;\n\n\t\tm_pointCount = pointCount;\n\t\tnotifyModified(DirtyFlags.DirtyAllInternal);\n\t}", "language": "java", "code": "void _resizeImpl(int pointCount) {\n\t\tif (pointCount < 0)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tif (pointCount == m_pointCount)\n\t\t\treturn;\n\n\t\tm_pointCount = pointCount;\n\t\tnotifyModified(DirtyFlags.DirtyAllInternal);\n\t}", "code_tokens": ["void", "_resizeImpl", "(", "int", "pointCount", ")", "{", "if", "(", "pointCount", "<", "0", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "pointCount", "==", "m_pointCount", ")", "return", ";", "m_pointCount", "=", "pointCount", ";", "notifyModified", "(", "DirtyFlags", ".", "DirtyAllInternal", ")", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L817-L826", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.queryCoordinates", "original_string": "int queryCoordinates(Point2D[] dst, int dstSize, int beginIndex,\n\t\t\tint endIndex) {\n\t\tint endIndexC = endIndex < 0 ? m_pointCount : endIndex;\n\t\tendIndexC = Math.min(endIndexC, beginIndex + dstSize);\n\n\t\tif (beginIndex < 0 || beginIndex >= m_pointCount\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tint j = 0;\n\t\tdouble[] dstArray = new double[dst.length * 2];\n\t\txy.readRange(2 * beginIndex, (endIndexC - beginIndex) * 2, dstArray, j, true);\n\n\t\tfor (int i = 0; i < dst.length; i++) {\n\t\t\tdst[i] = new Point2D(dstArray[i * 2], dstArray[i * 2 + 1]);\n\t\t}\n\n\t\t// for (int i = beginIndex; i < endIndexC; i++, j++)\n\t\t// {\n\t\t// xy.read(2 * i, dst[j]);\n\t\t// }\n\n\t\treturn endIndexC;\n\t}", "language": "java", "code": "int queryCoordinates(Point2D[] dst, int dstSize, int beginIndex,\n\t\t\tint endIndex) {\n\t\tint endIndexC = endIndex < 0 ? m_pointCount : endIndex;\n\t\tendIndexC = Math.min(endIndexC, beginIndex + dstSize);\n\n\t\tif (beginIndex < 0 || beginIndex >= m_pointCount\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tint j = 0;\n\t\tdouble[] dstArray = new double[dst.length * 2];\n\t\txy.readRange(2 * beginIndex, (endIndexC - beginIndex) * 2, dstArray, j, true);\n\n\t\tfor (int i = 0; i < dst.length; i++) {\n\t\t\tdst[i] = new Point2D(dstArray[i * 2], dstArray[i * 2 + 1]);\n\t\t}\n\n\t\t// for (int i = beginIndex; i < endIndexC; i++, j++)\n\t\t// {\n\t\t// xy.read(2 * i, dst[j]);\n\t\t// }\n\n\t\treturn endIndexC;\n\t}", "code_tokens": ["int", "queryCoordinates", "(", "Point2D", "[", "]", "dst", ",", "int", "dstSize", ",", "int", "beginIndex", ",", "int", "endIndex", ")", "{", "int", "endIndexC", "=", "endIndex", "<", "0", "?", "m_pointCount", ":", "endIndex", ";", "endIndexC", "=", "Math", ".", "min", "(", "endIndexC", ",", "beginIndex", "+", "dstSize", ")", ";", "if", "(", "beginIndex", "<", "0", "||", "beginIndex", ">=", "m_pointCount", "||", "endIndexC", "<", "beginIndex", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "AttributeStreamOfDbl", "xy", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "int", "j", "=", "0", ";", "double", "[", "]", "dstArray", "=", "new", "double", "[", "dst", ".", "length", "*", "2", "]", ";", "xy", ".", "readRange", "(", "2", "*", "beginIndex", ",", "(", "endIndexC", "-", "beginIndex", ")", "*", "2", ",", "dstArray", ",", "j", ",", "true", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "dst", ".", "length", ";", "i", "++", ")", "{", "dst", "[", "i", "]", "=", "new", "Point2D", "(", "dstArray", "[", "i", "*", "2", "]", ",", "dstArray", "[", "i", "*", "2", "+", "1", "]", ")", ";", "}", "// for (int i = beginIndex; i < endIndexC; i++, j++)", "// {", "// xy.read(2 * i, dst[j]);", "// }", "return", "endIndexC", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L829-L853", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.QueryCoordinates", "original_string": "int QueryCoordinates(Point3D[] dst, int dstSize, int beginIndex,\n\t\t\tint endIndex) {\n\t\tint endIndexC = endIndex < 0 ? m_pointCount : endIndex;\n\t\tendIndexC = Math.min(endIndexC, beginIndex + dstSize);\n\n\t\tif (beginIndex < 0 || beginIndex >= m_pointCount\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\t// TODO replace geometry exc\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tAttributeStreamOfDbl z = null;\n\t\tdouble v = VertexDescription\n\t\t\t\t.getDefaultValue(VertexDescription.Semantics.Z);\n\t\tboolean bHasZ = hasAttribute(VertexDescription.Semantics.Z);\n\t\tif (bHasZ)\n\t\t\tz = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.Z);\n\t\tint j = 0;\n\t\tfor (int i = beginIndex; i < endIndexC; i++, j++) {\n\t\t\tdst[j].x = xy.read(2 * i);\n\t\t\tdst[j].y = xy.read(2 * i + 1);\n\t\t\tdst[j].z = bHasZ ? z.read(i) : v;\n\n\t\t\tdst[j] = getXYZ(i);\n\t\t}\n\n\t\treturn endIndexC;\n\t}", "language": "java", "code": "int QueryCoordinates(Point3D[] dst, int dstSize, int beginIndex,\n\t\t\tint endIndex) {\n\t\tint endIndexC = endIndex < 0 ? m_pointCount : endIndex;\n\t\tendIndexC = Math.min(endIndexC, beginIndex + dstSize);\n\n\t\tif (beginIndex < 0 || beginIndex >= m_pointCount\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\t// TODO replace geometry exc\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tAttributeStreamOfDbl z = null;\n\t\tdouble v = VertexDescription\n\t\t\t\t.getDefaultValue(VertexDescription.Semantics.Z);\n\t\tboolean bHasZ = hasAttribute(VertexDescription.Semantics.Z);\n\t\tif (bHasZ)\n\t\t\tz = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.Z);\n\t\tint j = 0;\n\t\tfor (int i = beginIndex; i < endIndexC; i++, j++) {\n\t\t\tdst[j].x = xy.read(2 * i);\n\t\t\tdst[j].y = xy.read(2 * i + 1);\n\t\t\tdst[j].z = bHasZ ? z.read(i) : v;\n\n\t\t\tdst[j] = getXYZ(i);\n\t\t}\n\n\t\treturn endIndexC;\n\t}", "code_tokens": ["int", "QueryCoordinates", "(", "Point3D", "[", "]", "dst", ",", "int", "dstSize", ",", "int", "beginIndex", ",", "int", "endIndex", ")", "{", "int", "endIndexC", "=", "endIndex", "<", "0", "?", "m_pointCount", ":", "endIndex", ";", "endIndexC", "=", "Math", ".", "min", "(", "endIndexC", ",", "beginIndex", "+", "dstSize", ")", ";", "if", "(", "beginIndex", "<", "0", "||", "beginIndex", ">=", "m_pointCount", "||", "endIndexC", "<", "beginIndex", ")", "// TODO replace geometry exc", "throw", "new", "IllegalArgumentException", "(", ")", ";", "AttributeStreamOfDbl", "xy", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "AttributeStreamOfDbl", "z", "=", "null", ";", "double", "v", "=", "VertexDescription", ".", "getDefaultValue", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "boolean", "bHasZ", "=", "hasAttribute", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "if", "(", "bHasZ", ")", "z", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "int", "j", "=", "0", ";", "for", "(", "int", "i", "=", "beginIndex", ";", "i", "<", "endIndexC", ";", "i", "++", ",", "j", "++", ")", "{", "dst", "[", "j", "]", ".", "x", "=", "xy", ".", "read", "(", "2", "*", "i", ")", ";", "dst", "[", "j", "]", ".", "y", "=", "xy", ".", "read", "(", "2", "*", "i", "+", "1", ")", ";", "dst", "[", "j", "]", ".", "z", "=", "bHasZ", "?", "z", ".", "read", "(", "i", ")", ":", "v", ";", "dst", "[", "j", "]", "=", "getXYZ", "(", "i", ")", ";", "}", "return", "endIndexC", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L856-L883", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.getIsSimple", "original_string": "public int getIsSimple(double tolerance) {\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyIsKnownSimple)) {\n\t\t\tif (!_hasDirtyFlag(DirtyFlags.IsWeakSimple)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (m_simpleTolerance >= tolerance) {\n\t\t\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))\n\t\t\t\t\treturn 2;\n\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\t\treturn -1;\n\t}", "language": "java", "code": "public int getIsSimple(double tolerance) {\n\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyIsKnownSimple)) {\n\t\t\tif (!_hasDirtyFlag(DirtyFlags.IsWeakSimple)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (m_simpleTolerance >= tolerance) {\n\t\t\t\tif (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))\n\t\t\t\t\treturn 2;\n\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\t\treturn -1;\n\t}", "code_tokens": ["public", "int", "getIsSimple", "(", "double", "tolerance", ")", "{", "if", "(", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyIsKnownSimple", ")", ")", "{", "if", "(", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "IsWeakSimple", ")", ")", "{", "return", "0", ";", "}", "if", "(", "m_simpleTolerance", ">=", "tolerance", ")", "{", "if", "(", "!", "_hasDirtyFlag", "(", "DirtyFlags", ".", "DirtyOGCFlags", ")", ")", "return", "2", ";", "return", "1", ";", "}", "return", "-", "1", ";", "}", "return", "-", "1", ";", "}"], "docstring": "and valid ring ordering)", "docstring_tokens": ["and", "valid", "ring", "ordering", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L893-L908", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.getPoint", "original_string": "@Override\n\tpublic Point getPoint(int index) {\n\t\tif (index < 0 || index >= m_pointCount)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\n\t\tPoint outPoint = new Point();\n\t\toutPoint.assignVertexDescription(m_description);\n\t\tif (outPoint.isEmpty())\n\t\t\toutPoint._setToDefault();\n\n\t\tfor (int attributeIndex = 0; attributeIndex < m_description\n\t\t\t\t.getAttributeCount(); attributeIndex++) {\n\t\t\tint semantics = m_description.getSemantics(attributeIndex);\n\t\t\tfor (int icomp = 0, ncomp = VertexDescription\n\t\t\t\t\t.getComponentCount(semantics); icomp < ncomp; icomp++) {\n\t\t\t\tdouble v = m_vertexAttributes[attributeIndex].readAsDbl(ncomp\n\t\t\t\t\t\t* index + icomp);\n\t\t\t\toutPoint.setAttribute(semantics, icomp, v);\n\t\t\t}\n\t\t}\n\t\treturn outPoint;\n\t}", "language": "java", "code": "@Override\n\tpublic Point getPoint(int index) {\n\t\tif (index < 0 || index >= m_pointCount)\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\n\t\tPoint outPoint = new Point();\n\t\toutPoint.assignVertexDescription(m_description);\n\t\tif (outPoint.isEmpty())\n\t\t\toutPoint._setToDefault();\n\n\t\tfor (int attributeIndex = 0; attributeIndex < m_description\n\t\t\t\t.getAttributeCount(); attributeIndex++) {\n\t\t\tint semantics = m_description.getSemantics(attributeIndex);\n\t\t\tfor (int icomp = 0, ncomp = VertexDescription\n\t\t\t\t\t.getComponentCount(semantics); icomp < ncomp; icomp++) {\n\t\t\t\tdouble v = m_vertexAttributes[attributeIndex].readAsDbl(ncomp\n\t\t\t\t\t\t* index + icomp);\n\t\t\t\toutPoint.setAttribute(semantics, icomp, v);\n\t\t\t}\n\t\t}\n\t\treturn outPoint;\n\t}", "code_tokens": ["@", "Override", "public", "Point", "getPoint", "(", "int", "index", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">=", "m_pointCount", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "Point", "outPoint", "=", "new", "Point", "(", ")", ";", "outPoint", ".", "assignVertexDescription", "(", "m_description", ")", ";", "if", "(", "outPoint", ".", "isEmpty", "(", ")", ")", "outPoint", ".", "_setToDefault", "(", ")", ";", "for", "(", "int", "attributeIndex", "=", "0", ";", "attributeIndex", "<", "m_description", ".", "getAttributeCount", "(", ")", ";", "attributeIndex", "++", ")", "{", "int", "semantics", "=", "m_description", ".", "getSemantics", "(", "attributeIndex", ")", ";", "for", "(", "int", "icomp", "=", "0", ",", "ncomp", "=", "VertexDescription", ".", "getComponentCount", "(", "semantics", ")", ";", "icomp", "<", "ncomp", ";", "icomp", "++", ")", "{", "double", "v", "=", "m_vertexAttributes", "[", "attributeIndex", "]", ".", "readAsDbl", "(", "ncomp", "*", "index", "+", "icomp", ")", ";", "outPoint", ".", "setAttribute", "(", "semantics", ",", "icomp", ",", "v", ")", ";", "}", "}", "return", "outPoint", ";", "}"], "docstring": "////////////////// METHODS To REMOVE ///////////////////////", "docstring_tokens": ["//////////////////", "METHODS", "To", "REMOVE", "///////////////////////"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L985-L1008", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorBufferCursor.java", "func_name": "OperatorBufferCursor.buffer", "original_string": "Geometry buffer(Geometry geom, double distance) {\n\t\treturn m_bufferer.buffer(geom, distance, m_Spatial_reference,\n\t\t\t\tm_max_deviation, m_max_vertices_in_full_circle, m_progress_tracker);\n\t}", "language": "java", "code": "Geometry buffer(Geometry geom, double distance) {\n\t\treturn m_bufferer.buffer(geom, distance, m_Spatial_reference,\n\t\t\t\tm_max_deviation, m_max_vertices_in_full_circle, m_progress_tracker);\n\t}", "code_tokens": ["Geometry", "buffer", "(", "Geometry", "geom", ",", "double", "distance", ")", "{", "return", "m_bufferer", ".", "buffer", "(", "geom", ",", "distance", ",", "m_Spatial_reference", ",", "m_max_deviation", ",", "m_max_vertices_in_full_circle", ",", "m_progress_tracker", ")", ";", "}"], "docstring": "virtual bool IsRecycling() OVERRIDE { return false; }", "docstring_tokens": ["virtual", "bool", "IsRecycling", "()", "OVERRIDE", "{", "return", "false", ";", "}"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorBufferCursor.java#L78-L81", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Cracker.java", "func_name": "Cracker.needsCracking", "original_string": "static boolean needsCracking(boolean allowCoincident, EditShape shape, double tolerance,\n\t\t\tNonSimpleResult result, ProgressTracker progress_tracker) {\n\t\tif (!canBeCracked(shape))\n\t\t\treturn false;\n\n\t\tCracker cracker = new Cracker(progress_tracker);\n\t\tcracker.m_shape = shape;\n\t\tcracker.m_tolerance = tolerance;\n\t\tcracker.m_bAllowCoincident = allowCoincident;\n\t\tif (cracker.needsCrackingImpl_()) {\n\t\t\tif (result != null)\n\t\t\t\tresult.Assign(cracker.m_non_simple_result);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Now swap the coordinates to catch horizontal cases.\n\t\tTransformation2D transform = new Transformation2D();\n\t\ttransform.setSwapCoordinates();\n\t\tshape.applyTransformation(transform);\n\n\t\tcracker = new Cracker(progress_tracker);\n\t\tcracker.m_shape = shape;\n\t\tcracker.m_tolerance = tolerance;\n\t\tcracker.m_bAllowCoincident = allowCoincident;\n\t\tboolean b_res = cracker.needsCrackingImpl_();\n\n\t\ttransform.setSwapCoordinates();\n\t\tshape.applyTransformation(transform);// restore shape\n\n\t\tif (b_res) {\n\t\t\tif (result != null)\n\t\t\t\tresult.Assign(cracker.m_non_simple_result);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "static boolean needsCracking(boolean allowCoincident, EditShape shape, double tolerance,\n\t\t\tNonSimpleResult result, ProgressTracker progress_tracker) {\n\t\tif (!canBeCracked(shape))\n\t\t\treturn false;\n\n\t\tCracker cracker = new Cracker(progress_tracker);\n\t\tcracker.m_shape = shape;\n\t\tcracker.m_tolerance = tolerance;\n\t\tcracker.m_bAllowCoincident = allowCoincident;\n\t\tif (cracker.needsCrackingImpl_()) {\n\t\t\tif (result != null)\n\t\t\t\tresult.Assign(cracker.m_non_simple_result);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Now swap the coordinates to catch horizontal cases.\n\t\tTransformation2D transform = new Transformation2D();\n\t\ttransform.setSwapCoordinates();\n\t\tshape.applyTransformation(transform);\n\n\t\tcracker = new Cracker(progress_tracker);\n\t\tcracker.m_shape = shape;\n\t\tcracker.m_tolerance = tolerance;\n\t\tcracker.m_bAllowCoincident = allowCoincident;\n\t\tboolean b_res = cracker.needsCrackingImpl_();\n\n\t\ttransform.setSwapCoordinates();\n\t\tshape.applyTransformation(transform);// restore shape\n\n\t\tif (b_res) {\n\t\t\tif (result != null)\n\t\t\t\tresult.Assign(cracker.m_non_simple_result);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["static", "boolean", "needsCracking", "(", "boolean", "allowCoincident", ",", "EditShape", "shape", ",", "double", "tolerance", ",", "NonSimpleResult", "result", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "!", "canBeCracked", "(", "shape", ")", ")", "return", "false", ";", "Cracker", "cracker", "=", "new", "Cracker", "(", "progress_tracker", ")", ";", "cracker", ".", "m_shape", "=", "shape", ";", "cracker", ".", "m_tolerance", "=", "tolerance", ";", "cracker", ".", "m_bAllowCoincident", "=", "allowCoincident", ";", "if", "(", "cracker", ".", "needsCrackingImpl_", "(", ")", ")", "{", "if", "(", "result", "!=", "null", ")", "result", ".", "Assign", "(", "cracker", ".", "m_non_simple_result", ")", ";", "return", "true", ";", "}", "// Now swap the coordinates to catch horizontal cases.", "Transformation2D", "transform", "=", "new", "Transformation2D", "(", ")", ";", "transform", ".", "setSwapCoordinates", "(", ")", ";", "shape", ".", "applyTransformation", "(", "transform", ")", ";", "cracker", "=", "new", "Cracker", "(", "progress_tracker", ")", ";", "cracker", ".", "m_shape", "=", "shape", ";", "cracker", ".", "m_tolerance", "=", "tolerance", ";", "cracker", ".", "m_bAllowCoincident", "=", "allowCoincident", ";", "boolean", "b_res", "=", "cracker", ".", "needsCrackingImpl_", "(", ")", ";", "transform", ".", "setSwapCoordinates", "(", ")", ";", "shape", ".", "applyTransformation", "(", "transform", ")", ";", "// restore shape", "if", "(", "b_res", ")", "{", "if", "(", "result", "!=", "null", ")", "result", ".", "Assign", "(", "cracker", ".", "m_non_simple_result", ")", ";", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Used for IsSimple.", "docstring_tokens": ["Used", "for", "IsSimple", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Cracker.java#L515-L551", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java", "func_name": "OGCGeometry.isSimpleRelaxed", "original_string": "public boolean isSimpleRelaxed() {\n\t\tOperatorSimplify op = (OperatorSimplify) OperatorFactoryLocal\n\t\t\t\t.getInstance().getOperator(Operator.Type.Simplify);\n\t\treturn op.isSimpleAsFeature(getEsriGeometry(), esriSR, true, null, null);\n\t}", "language": "java", "code": "public boolean isSimpleRelaxed() {\n\t\tOperatorSimplify op = (OperatorSimplify) OperatorFactoryLocal\n\t\t\t\t.getInstance().getOperator(Operator.Type.Simplify);\n\t\treturn op.isSimpleAsFeature(getEsriGeometry(), esriSR, true, null, null);\n\t}", "code_tokens": ["public", "boolean", "isSimpleRelaxed", "(", ")", "{", "OperatorSimplify", "op", "=", "(", "OperatorSimplify", ")", "OperatorFactoryLocal", ".", "getInstance", "(", ")", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Simplify", ")", ";", "return", "op", ".", "isSimpleAsFeature", "(", "getEsriGeometry", "(", ")", ",", "esriSR", ",", "true", ",", "null", ",", "null", ")", ";", "}"], "docstring": "Extension method - checks if geometry is simple for Geodatabase.\n\n@return Returns true if geometry is simple, false otherwise.\n\nNote: If isSimpleRelaxed is true, then isSimple is either true or false. Geodatabase has more relaxed requirements for simple geometries than OGC.", "docstring_tokens": ["Extension", "method", "-", "checks", "if", "geometry", "is", "simple", "for", "Geodatabase", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java#L199-L203", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java", "func_name": "OGCGeometry.makeSimpleRelaxed", "original_string": "public OGCGeometry makeSimpleRelaxed(boolean forceProcessing) {\n\t\tOperatorSimplify op = (OperatorSimplify) OperatorFactoryLocal\n\t\t\t\t.getInstance().getOperator(Operator.Type.Simplify);\n\t\treturn OGCGeometry.createFromEsriGeometry(\n\t\t\t\top.execute(getEsriGeometry(), esriSR, forceProcessing, null),\n\t\t\t\tesriSR);\n\t}", "language": "java", "code": "public OGCGeometry makeSimpleRelaxed(boolean forceProcessing) {\n\t\tOperatorSimplify op = (OperatorSimplify) OperatorFactoryLocal\n\t\t\t\t.getInstance().getOperator(Operator.Type.Simplify);\n\t\treturn OGCGeometry.createFromEsriGeometry(\n\t\t\t\top.execute(getEsriGeometry(), esriSR, forceProcessing, null),\n\t\t\t\tesriSR);\n\t}", "code_tokens": ["public", "OGCGeometry", "makeSimpleRelaxed", "(", "boolean", "forceProcessing", ")", "{", "OperatorSimplify", "op", "=", "(", "OperatorSimplify", ")", "OperatorFactoryLocal", ".", "getInstance", "(", ")", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Simplify", ")", ";", "return", "OGCGeometry", ".", "createFromEsriGeometry", "(", "op", ".", "execute", "(", "getEsriGeometry", "(", ")", ",", "esriSR", ",", "forceProcessing", ",", "null", ")", ",", "esriSR", ")", ";", "}"], "docstring": "Makes a simple geometry for Geodatabase.\n\n@return Returns simplified geometry.\n\nNote: isSimpleRelaxed should return true after this operation.", "docstring_tokens": ["Makes", "a", "simple", "geometry", "for", "Geodatabase", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java#L219-L225", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java", "func_name": "OGCGeometry.Equals", "original_string": "public boolean Equals(OGCGeometry another) {\n\t\tif (this == another)\n\t\t\treturn !isEmpty();\n\t\t\n\t\tif (another == null)\n\t\t\treturn false;\n\t\t\n\t\tif (another.geometryType() == OGCConcreteGeometryCollection.TYPE) {\n\t\t\treturn another.Equals(this);\n\t\t}\n\t\t\n\t\tcom.esri.core.geometry.Geometry geom1 = getEsriGeometry();\n\t\tcom.esri.core.geometry.Geometry geom2 = another.getEsriGeometry();\n\t\treturn com.esri.core.geometry.GeometryEngine.equals(geom1, geom2,\n\t\t\t\tgetEsriSpatialReference());\n\t}", "language": "java", "code": "public boolean Equals(OGCGeometry another) {\n\t\tif (this == another)\n\t\t\treturn !isEmpty();\n\t\t\n\t\tif (another == null)\n\t\t\treturn false;\n\t\t\n\t\tif (another.geometryType() == OGCConcreteGeometryCollection.TYPE) {\n\t\t\treturn another.Equals(this);\n\t\t}\n\t\t\n\t\tcom.esri.core.geometry.Geometry geom1 = getEsriGeometry();\n\t\tcom.esri.core.geometry.Geometry geom2 = another.getEsriGeometry();\n\t\treturn com.esri.core.geometry.GeometryEngine.equals(geom1, geom2,\n\t\t\t\tgetEsriSpatialReference());\n\t}", "code_tokens": ["public", "boolean", "Equals", "(", "OGCGeometry", "another", ")", "{", "if", "(", "this", "==", "another", ")", "return", "!", "isEmpty", "(", ")", ";", "if", "(", "another", "==", "null", ")", "return", "false", ";", "if", "(", "another", ".", "geometryType", "(", ")", "==", "OGCConcreteGeometryCollection", ".", "TYPE", ")", "{", "return", "another", ".", "Equals", "(", "this", ")", ";", "}", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Geometry", "geom1", "=", "getEsriGeometry", "(", ")", ";", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Geometry", "geom2", "=", "another", ".", "getEsriGeometry", "(", ")", ";", "return", "com", ".", "esri", ".", "core", ".", "geometry", ".", "GeometryEngine", ".", "equals", "(", "geom1", ",", "geom2", ",", "getEsriSpatialReference", "(", ")", ")", ";", "}"], "docstring": "OGC equals. Performs topological comparison with tolerance.\nThis is different from equals(Object), that uses exact comparison.", "docstring_tokens": ["OGC", "equals", ".", "Performs", "topological", "comparison", "with", "tolerance", ".", "This", "is", "different", "from", "equals", "(", "Object", ")", "that", "uses", "exact", "comparison", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java#L254-L269", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java", "func_name": "OGCGeometry.distance", "original_string": "public double distance(OGCGeometry another) {\n\t\tif (this == another) {\n\t\t\treturn isEmpty() ? Double.NaN : 0;\n\t\t}\n\t\t\n\t\tif (another.geometryType() == OGCConcreteGeometryCollection.TYPE) {\n\t\t\treturn another.distance(this);\n\t\t}\n\n\t\tcom.esri.core.geometry.Geometry geom1 = getEsriGeometry();\n\t\tcom.esri.core.geometry.Geometry geom2 = another.getEsriGeometry();\n\t\treturn com.esri.core.geometry.GeometryEngine.distance(geom1, geom2,\n\t\t\t\tgetEsriSpatialReference());\n\t}", "language": "java", "code": "public double distance(OGCGeometry another) {\n\t\tif (this == another) {\n\t\t\treturn isEmpty() ? Double.NaN : 0;\n\t\t}\n\t\t\n\t\tif (another.geometryType() == OGCConcreteGeometryCollection.TYPE) {\n\t\t\treturn another.distance(this);\n\t\t}\n\n\t\tcom.esri.core.geometry.Geometry geom1 = getEsriGeometry();\n\t\tcom.esri.core.geometry.Geometry geom2 = another.getEsriGeometry();\n\t\treturn com.esri.core.geometry.GeometryEngine.distance(geom1, geom2,\n\t\t\t\tgetEsriSpatialReference());\n\t}", "code_tokens": ["public", "double", "distance", "(", "OGCGeometry", "another", ")", "{", "if", "(", "this", "==", "another", ")", "{", "return", "isEmpty", "(", ")", "?", "Double", ".", "NaN", ":", "0", ";", "}", "if", "(", "another", ".", "geometryType", "(", ")", "==", "OGCConcreteGeometryCollection", ".", "TYPE", ")", "{", "return", "another", ".", "distance", "(", "this", ")", ";", "}", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Geometry", "geom1", "=", "getEsriGeometry", "(", ")", ";", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Geometry", "geom2", "=", "another", ".", "getEsriGeometry", "(", ")", ";", "return", "com", ".", "esri", ".", "core", ".", "geometry", ".", "GeometryEngine", ".", "distance", "(", "geom1", ",", "geom2", ",", "getEsriSpatialReference", "(", ")", ")", ";", "}"], "docstring": "analysis", "docstring_tokens": ["analysis"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java#L359-L372", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java", "func_name": "OGCGeometry.simplifyBunch_", "original_string": "private OGCGeometry simplifyBunch_(GeometryCursor gc) {\n\t\t// Combines geometries into multipoint, polyline, and polygon types,\n\t\t// simplifying them and unioning them,\n\t\t// then produces OGCGeometry from the result.\n\t\t// Can produce OGCConcreteGoemetryCollection\n\t\tMultiPoint dstMultiPoint = null;\n\t\tArrayList<Geometry> dstPolylines = new ArrayList<Geometry>();\n\t\tArrayList<Geometry> dstPolygons = new ArrayList<Geometry>();\n\t\tfor (com.esri.core.geometry.Geometry g = gc.next(); g != null; g = gc\n\t\t\t\t.next()) {\n\t\t\tswitch (g.getType()) {\n\t\t\tcase Point:\n\t\t\t\tif (dstMultiPoint == null)\n\t\t\t\t\tdstMultiPoint = new MultiPoint();\n\t\t\t\tdstMultiPoint.add((Point) g);\n\t\t\t\tbreak;\n\t\t\tcase MultiPoint:\n\t\t\t\tif (dstMultiPoint == null)\n\t\t\t\t\tdstMultiPoint = new MultiPoint();\n\t\t\t\tdstMultiPoint.add((MultiPoint) g, 0, -1);\n\t\t\t\tbreak;\n\t\t\tcase Polyline:\n\t\t\t\tdstPolylines.add((Polyline) g.copy());\n\t\t\t\tbreak;\n\t\t\tcase Polygon:\n\t\t\t\tdstPolygons.add((Polygon) g.copy());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Geometry> result = new ArrayList<Geometry>(3);\n\t\tif (dstMultiPoint != null) {\n\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(dstMultiPoint,\n\t\t\t\t\tesriSR, true, null);\n\t\t\tresult.add(resMP);\n\t\t}\n\n\t\tif (dstPolylines.size() > 0) {\n\t\t\tif (dstPolylines.size() == 1) {\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tdstPolylines.get(0), esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t} else {\n\t\t\t\tGeometryCursor res = OperatorUnion.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(dstPolylines), esriSR, null);\n\t\t\t\tGeometry resPolyline = res.next();\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tresPolyline, esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t}\n\t\t}\n\n\t\tif (dstPolygons.size() > 0) {\n\t\t\tif (dstPolygons.size() == 1) {\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tdstPolygons.get(0), esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t} else {\n\t\t\t\tGeometryCursor res = OperatorUnion.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(dstPolygons), esriSR, null);\n\t\t\t\tGeometry resPolygon = res.next();\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tresPolygon, esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t}\n\t\t}\n\n\t\treturn OGCGeometry.createFromEsriCursor(\n\t\t\t\tnew SimpleGeometryCursor(result), esriSR);\n\t}", "language": "java", "code": "private OGCGeometry simplifyBunch_(GeometryCursor gc) {\n\t\t// Combines geometries into multipoint, polyline, and polygon types,\n\t\t// simplifying them and unioning them,\n\t\t// then produces OGCGeometry from the result.\n\t\t// Can produce OGCConcreteGoemetryCollection\n\t\tMultiPoint dstMultiPoint = null;\n\t\tArrayList<Geometry> dstPolylines = new ArrayList<Geometry>();\n\t\tArrayList<Geometry> dstPolygons = new ArrayList<Geometry>();\n\t\tfor (com.esri.core.geometry.Geometry g = gc.next(); g != null; g = gc\n\t\t\t\t.next()) {\n\t\t\tswitch (g.getType()) {\n\t\t\tcase Point:\n\t\t\t\tif (dstMultiPoint == null)\n\t\t\t\t\tdstMultiPoint = new MultiPoint();\n\t\t\t\tdstMultiPoint.add((Point) g);\n\t\t\t\tbreak;\n\t\t\tcase MultiPoint:\n\t\t\t\tif (dstMultiPoint == null)\n\t\t\t\t\tdstMultiPoint = new MultiPoint();\n\t\t\t\tdstMultiPoint.add((MultiPoint) g, 0, -1);\n\t\t\t\tbreak;\n\t\t\tcase Polyline:\n\t\t\t\tdstPolylines.add((Polyline) g.copy());\n\t\t\t\tbreak;\n\t\t\tcase Polygon:\n\t\t\t\tdstPolygons.add((Polygon) g.copy());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Geometry> result = new ArrayList<Geometry>(3);\n\t\tif (dstMultiPoint != null) {\n\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(dstMultiPoint,\n\t\t\t\t\tesriSR, true, null);\n\t\t\tresult.add(resMP);\n\t\t}\n\n\t\tif (dstPolylines.size() > 0) {\n\t\t\tif (dstPolylines.size() == 1) {\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tdstPolylines.get(0), esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t} else {\n\t\t\t\tGeometryCursor res = OperatorUnion.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(dstPolylines), esriSR, null);\n\t\t\t\tGeometry resPolyline = res.next();\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tresPolyline, esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t}\n\t\t}\n\n\t\tif (dstPolygons.size() > 0) {\n\t\t\tif (dstPolygons.size() == 1) {\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tdstPolygons.get(0), esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t} else {\n\t\t\t\tGeometryCursor res = OperatorUnion.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(dstPolygons), esriSR, null);\n\t\t\t\tGeometry resPolygon = res.next();\n\t\t\t\tGeometry resMP = OperatorSimplifyOGC.local().execute(\n\t\t\t\t\t\tresPolygon, esriSR, true, null);\n\t\t\t\tresult.add(resMP);\n\t\t\t}\n\t\t}\n\n\t\treturn OGCGeometry.createFromEsriCursor(\n\t\t\t\tnew SimpleGeometryCursor(result), esriSR);\n\t}", "code_tokens": ["private", "OGCGeometry", "simplifyBunch_", "(", "GeometryCursor", "gc", ")", "{", "// Combines geometries into multipoint, polyline, and polygon types,", "// simplifying them and unioning them,", "// then produces OGCGeometry from the result.", "// Can produce OGCConcreteGoemetryCollection", "MultiPoint", "dstMultiPoint", "=", "null", ";", "ArrayList", "<", "Geometry", ">", "dstPolylines", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "ArrayList", "<", "Geometry", ">", "dstPolygons", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "for", "(", "com", ".", "esri", ".", "core", ".", "geometry", ".", "Geometry", "g", "=", "gc", ".", "next", "(", ")", ";", "g", "!=", "null", ";", "g", "=", "gc", ".", "next", "(", ")", ")", "{", "switch", "(", "g", ".", "getType", "(", ")", ")", "{", "case", "Point", ":", "if", "(", "dstMultiPoint", "==", "null", ")", "dstMultiPoint", "=", "new", "MultiPoint", "(", ")", ";", "dstMultiPoint", ".", "add", "(", "(", "Point", ")", "g", ")", ";", "break", ";", "case", "MultiPoint", ":", "if", "(", "dstMultiPoint", "==", "null", ")", "dstMultiPoint", "=", "new", "MultiPoint", "(", ")", ";", "dstMultiPoint", ".", "add", "(", "(", "MultiPoint", ")", "g", ",", "0", ",", "-", "1", ")", ";", "break", ";", "case", "Polyline", ":", "dstPolylines", ".", "add", "(", "(", "Polyline", ")", "g", ".", "copy", "(", ")", ")", ";", "break", ";", "case", "Polygon", ":", "dstPolygons", ".", "add", "(", "(", "Polygon", ")", "g", ".", "copy", "(", ")", ")", ";", "break", ";", "default", ":", "throw", "new", "UnsupportedOperationException", "(", ")", ";", "}", "}", "ArrayList", "<", "Geometry", ">", "result", "=", "new", "ArrayList", "<", "Geometry", ">", "(", "3", ")", ";", "if", "(", "dstMultiPoint", "!=", "null", ")", "{", "Geometry", "resMP", "=", "OperatorSimplifyOGC", ".", "local", "(", ")", ".", "execute", "(", "dstMultiPoint", ",", "esriSR", ",", "true", ",", "null", ")", ";", "result", ".", "add", "(", "resMP", ")", ";", "}", "if", "(", "dstPolylines", ".", "size", "(", ")", ">", "0", ")", "{", "if", "(", "dstPolylines", ".", "size", "(", ")", "==", "1", ")", "{", "Geometry", "resMP", "=", "OperatorSimplifyOGC", ".", "local", "(", ")", ".", "execute", "(", "dstPolylines", ".", "get", "(", "0", ")", ",", "esriSR", ",", "true", ",", "null", ")", ";", "result", ".", "add", "(", "resMP", ")", ";", "}", "else", "{", "GeometryCursor", "res", "=", "OperatorUnion", ".", "local", "(", ")", ".", "execute", "(", "new", "SimpleGeometryCursor", "(", "dstPolylines", ")", ",", "esriSR", ",", "null", ")", ";", "Geometry", "resPolyline", "=", "res", ".", "next", "(", ")", ";", "Geometry", "resMP", "=", "OperatorSimplifyOGC", ".", "local", "(", ")", ".", "execute", "(", "resPolyline", ",", "esriSR", ",", "true", ",", "null", ")", ";", "result", ".", "add", "(", "resMP", ")", ";", "}", "}", "if", "(", "dstPolygons", ".", "size", "(", ")", ">", "0", ")", "{", "if", "(", "dstPolygons", ".", "size", "(", ")", "==", "1", ")", "{", "Geometry", "resMP", "=", "OperatorSimplifyOGC", ".", "local", "(", ")", ".", "execute", "(", "dstPolygons", ".", "get", "(", "0", ")", ",", "esriSR", ",", "true", ",", "null", ")", ";", "result", ".", "add", "(", "resMP", ")", ";", "}", "else", "{", "GeometryCursor", "res", "=", "OperatorUnion", ".", "local", "(", ")", ".", "execute", "(", "new", "SimpleGeometryCursor", "(", "dstPolygons", ")", ",", "esriSR", ",", "null", ")", ";", "Geometry", "resPolygon", "=", "res", ".", "next", "(", ")", ";", "Geometry", "resMP", "=", "OperatorSimplifyOGC", ".", "local", "(", ")", ".", "execute", "(", "resPolygon", ",", "esriSR", ",", "true", ",", "null", ")", ";", "result", ".", "add", "(", "resMP", ")", ";", "}", "}", "return", "OGCGeometry", ".", "createFromEsriCursor", "(", "new", "SimpleGeometryCursor", "(", "result", ")", ",", "esriSR", ")", ";", "}"], "docstring": "it produces a single OGCGeometry.", "docstring_tokens": ["it", "produces", "a", "single", "OGCGeometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java#L381-L452", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java", "func_name": "OGCGeometry.createFromEsriCursor", "original_string": "public static OGCGeometry createFromEsriCursor(GeometryCursor gc,\n\t\t\tSpatialReference sr) {\n\t\treturn createFromEsriCursor(gc, sr, false);\n\t}", "language": "java", "code": "public static OGCGeometry createFromEsriCursor(GeometryCursor gc,\n\t\t\tSpatialReference sr) {\n\t\treturn createFromEsriCursor(gc, sr, false);\n\t}", "code_tokens": ["public", "static", "OGCGeometry", "createFromEsriCursor", "(", "GeometryCursor", "gc", ",", "SpatialReference", "sr", ")", "{", "return", "createFromEsriCursor", "(", "gc", ",", "sr", ",", "false", ")", ";", "}"], "docstring": "Create an OGCGeometry instance from the GeometryCursor.\n\n@param gc\n@param sr\n@return Geometry instance created from the geometry cursor.", "docstring_tokens": ["Create", "an", "OGCGeometry", "instance", "from", "the", "GeometryCursor", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ogc/OGCGeometry.java#L563-L566", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.sweep", "original_string": "boolean sweep(EditShape shape, double tolerance) {\n\t\tTransformation2D transform = new Transformation2D();\n\t\ttransform.setSwapCoordinates();\n\t\tshape.applyTransformation(transform);// swap coordinates for the sweep\n\t\t\t\t\t\t\t\t\t\t\t\t// along x\n\t\tsetEditShape_(shape);\n\t\tm_b_cracked = false;\n\t\tm_tolerance = tolerance;\n\t\tm_tolerance_sqr = tolerance * tolerance;\n\n\t\tboolean b_cracked = sweepImpl_();\n\t\tshape.applyTransformation(transform);\n\t\tif (!b_cracked) {\n\t\t\tfillEventQueuePass2();\n\t\t\tb_cracked |= sweepImpl_();\n\t\t}\n\t\t\n\t\tif (m_vertex_cluster_index != -1) {\n\t\t\tm_shape.removeUserIndex(m_vertex_cluster_index);\n\t\t\tm_vertex_cluster_index = -1;\n\t\t}\n\t\t\n\t\tm_shape = null;\n\t\treturn m_b_cracked;\n\t}", "language": "java", "code": "boolean sweep(EditShape shape, double tolerance) {\n\t\tTransformation2D transform = new Transformation2D();\n\t\ttransform.setSwapCoordinates();\n\t\tshape.applyTransformation(transform);// swap coordinates for the sweep\n\t\t\t\t\t\t\t\t\t\t\t\t// along x\n\t\tsetEditShape_(shape);\n\t\tm_b_cracked = false;\n\t\tm_tolerance = tolerance;\n\t\tm_tolerance_sqr = tolerance * tolerance;\n\n\t\tboolean b_cracked = sweepImpl_();\n\t\tshape.applyTransformation(transform);\n\t\tif (!b_cracked) {\n\t\t\tfillEventQueuePass2();\n\t\t\tb_cracked |= sweepImpl_();\n\t\t}\n\t\t\n\t\tif (m_vertex_cluster_index != -1) {\n\t\t\tm_shape.removeUserIndex(m_vertex_cluster_index);\n\t\t\tm_vertex_cluster_index = -1;\n\t\t}\n\t\t\n\t\tm_shape = null;\n\t\treturn m_b_cracked;\n\t}", "code_tokens": ["boolean", "sweep", "(", "EditShape", "shape", ",", "double", "tolerance", ")", "{", "Transformation2D", "transform", "=", "new", "Transformation2D", "(", ")", ";", "transform", ".", "setSwapCoordinates", "(", ")", ";", "shape", ".", "applyTransformation", "(", "transform", ")", ";", "// swap coordinates for the sweep", "// along x", "setEditShape_", "(", "shape", ")", ";", "m_b_cracked", "=", "false", ";", "m_tolerance", "=", "tolerance", ";", "m_tolerance_sqr", "=", "tolerance", "*", "tolerance", ";", "boolean", "b_cracked", "=", "sweepImpl_", "(", ")", ";", "shape", ".", "applyTransformation", "(", "transform", ")", ";", "if", "(", "!", "b_cracked", ")", "{", "fillEventQueuePass2", "(", ")", ";", "b_cracked", "|=", "sweepImpl_", "(", ")", ";", "}", "if", "(", "m_vertex_cluster_index", "!=", "-", "1", ")", "{", "m_shape", ".", "removeUserIndex", "(", "m_vertex_cluster_index", ")", ";", "m_vertex_cluster_index", "=", "-", "1", ";", "}", "m_shape", "=", "null", ";", "return", "m_b_cracked", ";", "}"], "docstring": "For use in Cluster/Cracker loop", "docstring_tokens": ["For", "use", "in", "Cluster", "/", "Cracker", "loop"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L54-L78", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.sweepVertical", "original_string": "boolean sweepVertical(EditShape shape, double tolerance) {\n\t\tsetEditShape_(shape);\n\t\tm_b_cracked = false;\n\t\tm_tolerance = tolerance;\n\t\tm_tolerance_sqr = tolerance * tolerance;\n\t\tm_complications = false;\n\t\tboolean bresult = sweepImpl_();\n\t\tif (!m_complications) {\n\t\t\tint filtered = shape.filterClosePoints(tolerance, true, false);\n\t\t\tm_complications = filtered == 1;\n\t\t\tbresult |= filtered == 1;\n\t\t}\n\t\t\n\t\tif (m_vertex_cluster_index != -1) {\n\t\t\tm_shape.removeUserIndex(m_vertex_cluster_index);\n\t\t\tm_vertex_cluster_index = -1;\n\t\t}\n\t\t\n\t\tm_shape = null;\n\t\treturn bresult;\n\t}", "language": "java", "code": "boolean sweepVertical(EditShape shape, double tolerance) {\n\t\tsetEditShape_(shape);\n\t\tm_b_cracked = false;\n\t\tm_tolerance = tolerance;\n\t\tm_tolerance_sqr = tolerance * tolerance;\n\t\tm_complications = false;\n\t\tboolean bresult = sweepImpl_();\n\t\tif (!m_complications) {\n\t\t\tint filtered = shape.filterClosePoints(tolerance, true, false);\n\t\t\tm_complications = filtered == 1;\n\t\t\tbresult |= filtered == 1;\n\t\t}\n\t\t\n\t\tif (m_vertex_cluster_index != -1) {\n\t\t\tm_shape.removeUserIndex(m_vertex_cluster_index);\n\t\t\tm_vertex_cluster_index = -1;\n\t\t}\n\t\t\n\t\tm_shape = null;\n\t\treturn bresult;\n\t}", "code_tokens": ["boolean", "sweepVertical", "(", "EditShape", "shape", ",", "double", "tolerance", ")", "{", "setEditShape_", "(", "shape", ")", ";", "m_b_cracked", "=", "false", ";", "m_tolerance", "=", "tolerance", ";", "m_tolerance_sqr", "=", "tolerance", "*", "tolerance", ";", "m_complications", "=", "false", ";", "boolean", "bresult", "=", "sweepImpl_", "(", ")", ";", "if", "(", "!", "m_complications", ")", "{", "int", "filtered", "=", "shape", ".", "filterClosePoints", "(", "tolerance", ",", "true", ",", "false", ")", ";", "m_complications", "=", "filtered", "==", "1", ";", "bresult", "|=", "filtered", "==", "1", ";", "}", "if", "(", "m_vertex_cluster_index", "!=", "-", "1", ")", "{", "m_shape", ".", "removeUserIndex", "(", "m_vertex_cluster_index", ")", ";", "m_vertex_cluster_index", "=", "-", "1", ";", "}", "m_shape", "=", "null", ";", "return", "bresult", ";", "}"], "docstring": "Does one pass sweep vertically", "docstring_tokens": ["Does", "one", "pass", "sweep", "vertically"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L81-L101", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.newEdge_", "original_string": "int newEdge_(int origin_vertex) {\n\t\tint edge = m_edges.newElement();\n\t\tint edgeVertices = m_edge_vertices.createList();\n\t\tsetEdgeOriginVertices_(edge, edgeVertices);\n\t\tif (origin_vertex != -1)\n\t\t\tm_edge_vertices.addElement(edgeVertices, origin_vertex);\n\n\t\treturn edge;\n\t}", "language": "java", "code": "int newEdge_(int origin_vertex) {\n\t\tint edge = m_edges.newElement();\n\t\tint edgeVertices = m_edge_vertices.createList();\n\t\tsetEdgeOriginVertices_(edge, edgeVertices);\n\t\tif (origin_vertex != -1)\n\t\t\tm_edge_vertices.addElement(edgeVertices, origin_vertex);\n\n\t\treturn edge;\n\t}", "code_tokens": ["int", "newEdge_", "(", "int", "origin_vertex", ")", "{", "int", "edge", "=", "m_edges", ".", "newElement", "(", ")", ";", "int", "edgeVertices", "=", "m_edge_vertices", ".", "createList", "(", ")", ";", "setEdgeOriginVertices_", "(", "edge", ",", "edgeVertices", ")", ";", "if", "(", "origin_vertex", "!=", "-", "1", ")", "m_edge_vertices", ".", "addElement", "(", "edgeVertices", ",", "origin_vertex", ")", ";", "return", "edge", ";", "}"], "docstring": "Creates a new unattached edge with the given origin.", "docstring_tokens": ["Creates", "a", "new", "unattached", "edge", "with", "the", "given", "origin", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L350-L358", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.mergeClusters_", "original_string": "void mergeClusters_(int cluster_1, int cluster2) {\n\t\t// dbg_check_cluster_(cluster_1);\n\t\t// dbg_check_cluster_(cluster2);\n\t\tint eventQnode = getClusterEventQNode(cluster2);\n\t\tif (eventQnode != -1) {\n\t\t\tm_event_q.deleteNode(eventQnode, -1);\n\t\t\tsetClusterEventQNode_(cluster2, -1);\n\t\t}\n\n\t\tint firstEdge1 = getClusterFirstEdge(cluster_1);\n\t\tint firstEdge2 = getClusterFirstEdge(cluster2);\n\n\t\tif (firstEdge2 != -1) {// scope\n\t\t\tint edge2 = firstEdge2;\n\t\t\tint lastEdge = firstEdge2;\n\t\t\tboolean bForceContinue = false;\n\t\t\t// Delete edges that connect cluster_1 and cluster2.\n\t\t\tdo {\n\t\t\t\t// dbg_check_edge_(edge2);\n\t\t\t\tbForceContinue = false;\n\t\t\t\t// assert(!StridedIndexTypeCollection.isValidElement(getEdgeSweepNode(edge2)));\n\t\t\t\tint end = getEdgeEnd(edge2, cluster2);\n\t\t\t\tint nextEdge2 = getNextEdgeEx(edge2, end);\n\t\t\t\tif (getEdgeCluster(edge2, (end + 1) & 1) == cluster_1) { // Snapping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// clusters\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// are\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// connected\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// with\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// edge\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Delete\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// edge.\n\t\t\t\t\tdisconnectEdge_(edge2);\n\t\t\t\t\tint edgeOrigins2 = getEdgeOriginVertices(edge2);\n\t\t\t\t\tm_edge_vertices.deleteList(edgeOrigins2);\n\t\t\t\t\tdeleteEdge_(edge2);\n\t\t\t\t\tif (edge2 == nextEdge2) {// deleted last edge connecting to\n\t\t\t\t\t\t\t\t\t\t\t\t// the cluster2 (all connections\n\t\t\t\t\t\t\t\t\t\t\t\t// are degenerate)\n\t\t\t\t\t\tfirstEdge2 = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (firstEdge2 == edge2) {\n\t\t\t\t\t\tfirstEdge2 = getClusterFirstEdge(cluster2);\n\t\t\t\t\t\tlastEdge = nextEdge2;\n\t\t\t\t\t\tbForceContinue = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tassert (edge2 != getClusterFirstEdge(cluster_1));\n\t\t\t\t}\n\t\t\t\tedge2 = nextEdge2;\n\t\t\t} while (edge2 != lastEdge || bForceContinue);\n\n\t\t\tif (firstEdge2 != -1) {\n\t\t\t\t// set the cluster to the edge ends\n\t\t\t\tdo {\n\t\t\t\t\tint end = getEdgeEnd(edge2, cluster2);\n\t\t\t\t\tint nextEdge2 = getNextEdgeEx(edge2, end);\n\t\t\t\t\tassert (edge2 != getClusterFirstEdge(cluster_1));\n\t\t\t\t\tsetEdgeCluster_(edge2, end, cluster_1);\n\t\t\t\t\tedge2 = nextEdge2;\n\t\t\t\t} while (edge2 != lastEdge);\n\n\t\t\t\tfirstEdge1 = getClusterFirstEdge(cluster_1);\n\t\t\t\tif (firstEdge1 != -1) {\n\t\t\t\t\tint next1 = getNextEdge(firstEdge1, cluster_1);\n\t\t\t\t\tint next2 = getNextEdge(firstEdge2, cluster_1);\n\t\t\t\t\tif (next1 == firstEdge1) {\n\t\t\t\t\t\tsetClusterFirstEdge_(cluster_1, firstEdge2);\n\t\t\t\t\t\taddEdgeToClusterImpl_(firstEdge1, cluster_1);\n\t\t\t\t\t\tsetClusterFirstEdge_(cluster_1, firstEdge1);\n\t\t\t\t\t} else if (next2 == firstEdge2) {\n\t\t\t\t\t\taddEdgeToClusterImpl_(firstEdge2, cluster_1);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetNextEdge_(firstEdge2, cluster_1, next1);\n\t\t\t\t\tsetPrevEdge_(next1, cluster_1, firstEdge2);\n\t\t\t\t\tsetNextEdge_(firstEdge1, cluster_1, next2);\n\t\t\t\t\tsetPrevEdge_(next2, cluster_1, firstEdge1);\n\t\t\t\t} else {\n\t\t\t\t\tsetClusterFirstEdge_(cluster_1, firstEdge2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint vertices1 = getClusterVertices(cluster_1);\n\t\tint vertices2 = getClusterVertices(cluster2);\n\t\t// Update cluster info on vertices.\n\t\tfor (int vh = m_cluster_vertices.getFirst(vertices2); vh != -1; vh = m_cluster_vertices\n\t\t\t\t.getNext(vh)) {\n\t\t\tint v = m_cluster_vertices.getElement(vh);\n\t\t\tm_shape.setUserIndex(v, m_vertex_cluster_index, cluster_1);\n\t\t}\n\t\tm_cluster_vertices.concatenateLists(vertices1, vertices2);\n\t\tdeleteCluster_(cluster2);\n\t\t// dbg_check_cluster_(cluster_1);\n\t}", "language": "java", "code": "void mergeClusters_(int cluster_1, int cluster2) {\n\t\t// dbg_check_cluster_(cluster_1);\n\t\t// dbg_check_cluster_(cluster2);\n\t\tint eventQnode = getClusterEventQNode(cluster2);\n\t\tif (eventQnode != -1) {\n\t\t\tm_event_q.deleteNode(eventQnode, -1);\n\t\t\tsetClusterEventQNode_(cluster2, -1);\n\t\t}\n\n\t\tint firstEdge1 = getClusterFirstEdge(cluster_1);\n\t\tint firstEdge2 = getClusterFirstEdge(cluster2);\n\n\t\tif (firstEdge2 != -1) {// scope\n\t\t\tint edge2 = firstEdge2;\n\t\t\tint lastEdge = firstEdge2;\n\t\t\tboolean bForceContinue = false;\n\t\t\t// Delete edges that connect cluster_1 and cluster2.\n\t\t\tdo {\n\t\t\t\t// dbg_check_edge_(edge2);\n\t\t\t\tbForceContinue = false;\n\t\t\t\t// assert(!StridedIndexTypeCollection.isValidElement(getEdgeSweepNode(edge2)));\n\t\t\t\tint end = getEdgeEnd(edge2, cluster2);\n\t\t\t\tint nextEdge2 = getNextEdgeEx(edge2, end);\n\t\t\t\tif (getEdgeCluster(edge2, (end + 1) & 1) == cluster_1) { // Snapping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// clusters\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// are\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// connected\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// with\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// edge\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Delete\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// edge.\n\t\t\t\t\tdisconnectEdge_(edge2);\n\t\t\t\t\tint edgeOrigins2 = getEdgeOriginVertices(edge2);\n\t\t\t\t\tm_edge_vertices.deleteList(edgeOrigins2);\n\t\t\t\t\tdeleteEdge_(edge2);\n\t\t\t\t\tif (edge2 == nextEdge2) {// deleted last edge connecting to\n\t\t\t\t\t\t\t\t\t\t\t\t// the cluster2 (all connections\n\t\t\t\t\t\t\t\t\t\t\t\t// are degenerate)\n\t\t\t\t\t\tfirstEdge2 = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (firstEdge2 == edge2) {\n\t\t\t\t\t\tfirstEdge2 = getClusterFirstEdge(cluster2);\n\t\t\t\t\t\tlastEdge = nextEdge2;\n\t\t\t\t\t\tbForceContinue = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tassert (edge2 != getClusterFirstEdge(cluster_1));\n\t\t\t\t}\n\t\t\t\tedge2 = nextEdge2;\n\t\t\t} while (edge2 != lastEdge || bForceContinue);\n\n\t\t\tif (firstEdge2 != -1) {\n\t\t\t\t// set the cluster to the edge ends\n\t\t\t\tdo {\n\t\t\t\t\tint end = getEdgeEnd(edge2, cluster2);\n\t\t\t\t\tint nextEdge2 = getNextEdgeEx(edge2, end);\n\t\t\t\t\tassert (edge2 != getClusterFirstEdge(cluster_1));\n\t\t\t\t\tsetEdgeCluster_(edge2, end, cluster_1);\n\t\t\t\t\tedge2 = nextEdge2;\n\t\t\t\t} while (edge2 != lastEdge);\n\n\t\t\t\tfirstEdge1 = getClusterFirstEdge(cluster_1);\n\t\t\t\tif (firstEdge1 != -1) {\n\t\t\t\t\tint next1 = getNextEdge(firstEdge1, cluster_1);\n\t\t\t\t\tint next2 = getNextEdge(firstEdge2, cluster_1);\n\t\t\t\t\tif (next1 == firstEdge1) {\n\t\t\t\t\t\tsetClusterFirstEdge_(cluster_1, firstEdge2);\n\t\t\t\t\t\taddEdgeToClusterImpl_(firstEdge1, cluster_1);\n\t\t\t\t\t\tsetClusterFirstEdge_(cluster_1, firstEdge1);\n\t\t\t\t\t} else if (next2 == firstEdge2) {\n\t\t\t\t\t\taddEdgeToClusterImpl_(firstEdge2, cluster_1);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetNextEdge_(firstEdge2, cluster_1, next1);\n\t\t\t\t\tsetPrevEdge_(next1, cluster_1, firstEdge2);\n\t\t\t\t\tsetNextEdge_(firstEdge1, cluster_1, next2);\n\t\t\t\t\tsetPrevEdge_(next2, cluster_1, firstEdge1);\n\t\t\t\t} else {\n\t\t\t\t\tsetClusterFirstEdge_(cluster_1, firstEdge2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint vertices1 = getClusterVertices(cluster_1);\n\t\tint vertices2 = getClusterVertices(cluster2);\n\t\t// Update cluster info on vertices.\n\t\tfor (int vh = m_cluster_vertices.getFirst(vertices2); vh != -1; vh = m_cluster_vertices\n\t\t\t\t.getNext(vh)) {\n\t\t\tint v = m_cluster_vertices.getElement(vh);\n\t\t\tm_shape.setUserIndex(v, m_vertex_cluster_index, cluster_1);\n\t\t}\n\t\tm_cluster_vertices.concatenateLists(vertices1, vertices2);\n\t\tdeleteCluster_(cluster2);\n\t\t// dbg_check_cluster_(cluster_1);\n\t}", "code_tokens": ["void", "mergeClusters_", "(", "int", "cluster_1", ",", "int", "cluster2", ")", "{", "// dbg_check_cluster_(cluster_1);", "// dbg_check_cluster_(cluster2);", "int", "eventQnode", "=", "getClusterEventQNode", "(", "cluster2", ")", ";", "if", "(", "eventQnode", "!=", "-", "1", ")", "{", "m_event_q", ".", "deleteNode", "(", "eventQnode", ",", "-", "1", ")", ";", "setClusterEventQNode_", "(", "cluster2", ",", "-", "1", ")", ";", "}", "int", "firstEdge1", "=", "getClusterFirstEdge", "(", "cluster_1", ")", ";", "int", "firstEdge2", "=", "getClusterFirstEdge", "(", "cluster2", ")", ";", "if", "(", "firstEdge2", "!=", "-", "1", ")", "{", "// scope", "int", "edge2", "=", "firstEdge2", ";", "int", "lastEdge", "=", "firstEdge2", ";", "boolean", "bForceContinue", "=", "false", ";", "// Delete edges that connect cluster_1 and cluster2.", "do", "{", "// dbg_check_edge_(edge2);", "bForceContinue", "=", "false", ";", "// assert(!StridedIndexTypeCollection.isValidElement(getEdgeSweepNode(edge2)));", "int", "end", "=", "getEdgeEnd", "(", "edge2", ",", "cluster2", ")", ";", "int", "nextEdge2", "=", "getNextEdgeEx", "(", "edge2", ",", "end", ")", ";", "if", "(", "getEdgeCluster", "(", "edge2", ",", "(", "end", "+", "1", ")", "&", "1", ")", "==", "cluster_1", ")", "{", "// Snapping", "// clusters", "// that", "// are", "// connected", "// with", "// an", "// edge", "// Delete", "// the", "// edge.", "disconnectEdge_", "(", "edge2", ")", ";", "int", "edgeOrigins2", "=", "getEdgeOriginVertices", "(", "edge2", ")", ";", "m_edge_vertices", ".", "deleteList", "(", "edgeOrigins2", ")", ";", "deleteEdge_", "(", "edge2", ")", ";", "if", "(", "edge2", "==", "nextEdge2", ")", "{", "// deleted last edge connecting to", "// the cluster2 (all connections", "// are degenerate)", "firstEdge2", "=", "-", "1", ";", "break", ";", "}", "if", "(", "firstEdge2", "==", "edge2", ")", "{", "firstEdge2", "=", "getClusterFirstEdge", "(", "cluster2", ")", ";", "lastEdge", "=", "nextEdge2", ";", "bForceContinue", "=", "true", ";", "}", "}", "else", "{", "assert", "(", "edge2", "!=", "getClusterFirstEdge", "(", "cluster_1", ")", ")", ";", "}", "edge2", "=", "nextEdge2", ";", "}", "while", "(", "edge2", "!=", "lastEdge", "||", "bForceContinue", ")", ";", "if", "(", "firstEdge2", "!=", "-", "1", ")", "{", "// set the cluster to the edge ends", "do", "{", "int", "end", "=", "getEdgeEnd", "(", "edge2", ",", "cluster2", ")", ";", "int", "nextEdge2", "=", "getNextEdgeEx", "(", "edge2", ",", "end", ")", ";", "assert", "(", "edge2", "!=", "getClusterFirstEdge", "(", "cluster_1", ")", ")", ";", "setEdgeCluster_", "(", "edge2", ",", "end", ",", "cluster_1", ")", ";", "edge2", "=", "nextEdge2", ";", "}", "while", "(", "edge2", "!=", "lastEdge", ")", ";", "firstEdge1", "=", "getClusterFirstEdge", "(", "cluster_1", ")", ";", "if", "(", "firstEdge1", "!=", "-", "1", ")", "{", "int", "next1", "=", "getNextEdge", "(", "firstEdge1", ",", "cluster_1", ")", ";", "int", "next2", "=", "getNextEdge", "(", "firstEdge2", ",", "cluster_1", ")", ";", "if", "(", "next1", "==", "firstEdge1", ")", "{", "setClusterFirstEdge_", "(", "cluster_1", ",", "firstEdge2", ")", ";", "addEdgeToClusterImpl_", "(", "firstEdge1", ",", "cluster_1", ")", ";", "setClusterFirstEdge_", "(", "cluster_1", ",", "firstEdge1", ")", ";", "}", "else", "if", "(", "next2", "==", "firstEdge2", ")", "{", "addEdgeToClusterImpl_", "(", "firstEdge2", ",", "cluster_1", ")", ";", "}", "setNextEdge_", "(", "firstEdge2", ",", "cluster_1", ",", "next1", ")", ";", "setPrevEdge_", "(", "next1", ",", "cluster_1", ",", "firstEdge2", ")", ";", "setNextEdge_", "(", "firstEdge1", ",", "cluster_1", ",", "next2", ")", ";", "setPrevEdge_", "(", "next2", ",", "cluster_1", ",", "firstEdge1", ")", ";", "}", "else", "{", "setClusterFirstEdge_", "(", "cluster_1", ",", "firstEdge2", ")", ";", "}", "}", "}", "int", "vertices1", "=", "getClusterVertices", "(", "cluster_1", ")", ";", "int", "vertices2", "=", "getClusterVertices", "(", "cluster2", ")", ";", "// Update cluster info on vertices.", "for", "(", "int", "vh", "=", "m_cluster_vertices", ".", "getFirst", "(", "vertices2", ")", ";", "vh", "!=", "-", "1", ";", "vh", "=", "m_cluster_vertices", ".", "getNext", "(", "vh", ")", ")", "{", "int", "v", "=", "m_cluster_vertices", ".", "getElement", "(", "vh", ")", ";", "m_shape", ".", "setUserIndex", "(", "v", ",", "m_vertex_cluster_index", ",", "cluster_1", ")", ";", "}", "m_cluster_vertices", ".", "concatenateLists", "(", "vertices1", ",", "vertices2", ")", ";", "deleteCluster_", "(", "cluster2", ")", ";", "// dbg_check_cluster_(cluster_1);", "}"], "docstring": "Merges two coincident clusters into one. The cluster2 becomes invalid.", "docstring_tokens": ["Merges", "two", "coincident", "clusters", "into", "one", ".", "The", "cluster2", "becomes", "invalid", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L412-L510", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.mergeEdges_", "original_string": "void mergeEdges_(int edge1, int edge2) {\n\t\t// dbg_check_edge_(edge1);\n\t\tint cluster_1 = getEdgeCluster(edge1, 0);\n\t\tint cluster2 = getEdgeCluster(edge1, 1);\n\t\tint cluster21 = getEdgeCluster(edge2, 0);\n\t\tint cluster22 = getEdgeCluster(edge2, 1);\n\n\t\tint originVertices1 = getEdgeOriginVertices(edge1);\n\t\tint originVertices2 = getEdgeOriginVertices(edge2);\n\t\tm_edge_vertices.concatenateLists(originVertices1, originVertices2);\n\t\tif (edge2 == getClusterFirstEdge(cluster_1))\n\t\t\tsetClusterFirstEdge_(cluster_1, edge1);\n\t\tif (edge2 == getClusterFirstEdge(cluster2))\n\t\t\tsetClusterFirstEdge_(cluster2, edge1);\n\n\t\tdisconnectEdge_(edge2);// disconnects the edge2 from the clusters.\n\t\tdeleteEdge_(edge2);\n\n\t\tif (!((cluster_1 == cluster21 && cluster2 == cluster22) || (cluster2 == cluster21 && cluster_1 == cluster22))) {\n\t\t\t// Merged edges have different clusters (clusters have not yet been\n\t\t\t// merged)\n\t\t\t// merge clusters before merging the edges\n\t\t\tgetClusterXY(cluster_1, pt_1);\n\t\t\tgetClusterXY(cluster21, pt_2);\n\t\t\tif (pt_1.isEqual(pt_2)) {\n\t\t\t\tif (cluster_1 != cluster21) {\n\t\t\t\t\tmergeClusters_(cluster_1, cluster21);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster21));\n\t\t\t\t}\n\t\t\t\tif (cluster2 != cluster22) {\n\t\t\t\t\tmergeClusters_(cluster2, cluster22);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster22));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cluster2 != cluster21) {\n\t\t\t\t\tmergeClusters_(cluster2, cluster21);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster21));\n\t\t\t\t}\n\t\t\t\tif (cluster_1 != cluster22) {\n\t\t\t\t\tmergeClusters_(cluster_1, cluster22);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster22));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Merged edges have equal clusters.\n\t\t}\n\t\t// dbg_check_edge_(edge1);\n\t}", "language": "java", "code": "void mergeEdges_(int edge1, int edge2) {\n\t\t// dbg_check_edge_(edge1);\n\t\tint cluster_1 = getEdgeCluster(edge1, 0);\n\t\tint cluster2 = getEdgeCluster(edge1, 1);\n\t\tint cluster21 = getEdgeCluster(edge2, 0);\n\t\tint cluster22 = getEdgeCluster(edge2, 1);\n\n\t\tint originVertices1 = getEdgeOriginVertices(edge1);\n\t\tint originVertices2 = getEdgeOriginVertices(edge2);\n\t\tm_edge_vertices.concatenateLists(originVertices1, originVertices2);\n\t\tif (edge2 == getClusterFirstEdge(cluster_1))\n\t\t\tsetClusterFirstEdge_(cluster_1, edge1);\n\t\tif (edge2 == getClusterFirstEdge(cluster2))\n\t\t\tsetClusterFirstEdge_(cluster2, edge1);\n\n\t\tdisconnectEdge_(edge2);// disconnects the edge2 from the clusters.\n\t\tdeleteEdge_(edge2);\n\n\t\tif (!((cluster_1 == cluster21 && cluster2 == cluster22) || (cluster2 == cluster21 && cluster_1 == cluster22))) {\n\t\t\t// Merged edges have different clusters (clusters have not yet been\n\t\t\t// merged)\n\t\t\t// merge clusters before merging the edges\n\t\t\tgetClusterXY(cluster_1, pt_1);\n\t\t\tgetClusterXY(cluster21, pt_2);\n\t\t\tif (pt_1.isEqual(pt_2)) {\n\t\t\t\tif (cluster_1 != cluster21) {\n\t\t\t\t\tmergeClusters_(cluster_1, cluster21);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster21));\n\t\t\t\t}\n\t\t\t\tif (cluster2 != cluster22) {\n\t\t\t\t\tmergeClusters_(cluster2, cluster22);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster22));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cluster2 != cluster21) {\n\t\t\t\t\tmergeClusters_(cluster2, cluster21);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster21));\n\t\t\t\t}\n\t\t\t\tif (cluster_1 != cluster22) {\n\t\t\t\t\tmergeClusters_(cluster_1, cluster22);\n\t\t\t\t\tassert (!m_modified_clusters.hasElement(cluster22));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Merged edges have equal clusters.\n\t\t}\n\t\t// dbg_check_edge_(edge1);\n\t}", "code_tokens": ["void", "mergeEdges_", "(", "int", "edge1", ",", "int", "edge2", ")", "{", "// dbg_check_edge_(edge1);", "int", "cluster_1", "=", "getEdgeCluster", "(", "edge1", ",", "0", ")", ";", "int", "cluster2", "=", "getEdgeCluster", "(", "edge1", ",", "1", ")", ";", "int", "cluster21", "=", "getEdgeCluster", "(", "edge2", ",", "0", ")", ";", "int", "cluster22", "=", "getEdgeCluster", "(", "edge2", ",", "1", ")", ";", "int", "originVertices1", "=", "getEdgeOriginVertices", "(", "edge1", ")", ";", "int", "originVertices2", "=", "getEdgeOriginVertices", "(", "edge2", ")", ";", "m_edge_vertices", ".", "concatenateLists", "(", "originVertices1", ",", "originVertices2", ")", ";", "if", "(", "edge2", "==", "getClusterFirstEdge", "(", "cluster_1", ")", ")", "setClusterFirstEdge_", "(", "cluster_1", ",", "edge1", ")", ";", "if", "(", "edge2", "==", "getClusterFirstEdge", "(", "cluster2", ")", ")", "setClusterFirstEdge_", "(", "cluster2", ",", "edge1", ")", ";", "disconnectEdge_", "(", "edge2", ")", ";", "// disconnects the edge2 from the clusters.", "deleteEdge_", "(", "edge2", ")", ";", "if", "(", "!", "(", "(", "cluster_1", "==", "cluster21", "&&", "cluster2", "==", "cluster22", ")", "||", "(", "cluster2", "==", "cluster21", "&&", "cluster_1", "==", "cluster22", ")", ")", ")", "{", "// Merged edges have different clusters (clusters have not yet been", "// merged)", "// merge clusters before merging the edges", "getClusterXY", "(", "cluster_1", ",", "pt_1", ")", ";", "getClusterXY", "(", "cluster21", ",", "pt_2", ")", ";", "if", "(", "pt_1", ".", "isEqual", "(", "pt_2", ")", ")", "{", "if", "(", "cluster_1", "!=", "cluster21", ")", "{", "mergeClusters_", "(", "cluster_1", ",", "cluster21", ")", ";", "assert", "(", "!", "m_modified_clusters", ".", "hasElement", "(", "cluster21", ")", ")", ";", "}", "if", "(", "cluster2", "!=", "cluster22", ")", "{", "mergeClusters_", "(", "cluster2", ",", "cluster22", ")", ";", "assert", "(", "!", "m_modified_clusters", ".", "hasElement", "(", "cluster22", ")", ")", ";", "}", "}", "else", "{", "if", "(", "cluster2", "!=", "cluster21", ")", "{", "mergeClusters_", "(", "cluster2", ",", "cluster21", ")", ";", "assert", "(", "!", "m_modified_clusters", ".", "hasElement", "(", "cluster21", ")", ")", ";", "}", "if", "(", "cluster_1", "!=", "cluster22", ")", "{", "mergeClusters_", "(", "cluster_1", ",", "cluster22", ")", ";", "assert", "(", "!", "m_modified_clusters", ".", "hasElement", "(", "cluster22", ")", ")", ";", "}", "}", "}", "else", "{", "// Merged edges have equal clusters.", "}", "// dbg_check_edge_(edge1);", "}"], "docstring": "Merges two coincident edges into one. The edge2 becomes invalid.", "docstring_tokens": ["Merges", "two", "coincident", "edges", "into", "one", ".", "The", "edge2", "becomes", "invalid", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L513-L560", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.disconnectEdge_", "original_string": "void disconnectEdge_(int edge) {\n\t\tint cluster_1 = getEdgeCluster(edge, 0);\n\t\tint cluster2 = getEdgeCluster(edge, 1);\n\t\tdisconnectEdgeFromCluster_(edge, cluster_1);\n\t\tdisconnectEdgeFromCluster_(edge, cluster2);\n\t}", "language": "java", "code": "void disconnectEdge_(int edge) {\n\t\tint cluster_1 = getEdgeCluster(edge, 0);\n\t\tint cluster2 = getEdgeCluster(edge, 1);\n\t\tdisconnectEdgeFromCluster_(edge, cluster_1);\n\t\tdisconnectEdgeFromCluster_(edge, cluster2);\n\t}", "code_tokens": ["void", "disconnectEdge_", "(", "int", "edge", ")", "{", "int", "cluster_1", "=", "getEdgeCluster", "(", "edge", ",", "0", ")", ";", "int", "cluster2", "=", "getEdgeCluster", "(", "edge", ",", "1", ")", ";", "disconnectEdgeFromCluster_", "(", "edge", ",", "cluster_1", ")", ";", "disconnectEdgeFromCluster_", "(", "edge", ",", "cluster2", ")", ";", "}"], "docstring": "Disconnects the edge from its clusters.", "docstring_tokens": ["Disconnects", "the", "edge", "from", "its", "clusters", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L563-L568", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.disconnectEdgeFromCluster_", "original_string": "void disconnectEdgeFromCluster_(int edge, int cluster) {\n\t\tint next = getNextEdge(edge, cluster);\n\t\tassert (getPrevEdge(next, cluster) == edge);\n\t\tint prev = getPrevEdge(edge, cluster);\n\t\tassert (getNextEdge(prev, cluster) == edge);\n\t\tint first_edge = getClusterFirstEdge(cluster);\n\t\tif (next != edge) {\n\t\t\tsetNextEdge_(prev, cluster, next);\n\t\t\tsetPrevEdge_(next, cluster, prev);\n\t\t\tif (first_edge == edge)\n\t\t\t\tsetClusterFirstEdge_(cluster, next);\n\t\t} else\n\t\t\tsetClusterFirstEdge_(cluster, -1);\n\t}", "language": "java", "code": "void disconnectEdgeFromCluster_(int edge, int cluster) {\n\t\tint next = getNextEdge(edge, cluster);\n\t\tassert (getPrevEdge(next, cluster) == edge);\n\t\tint prev = getPrevEdge(edge, cluster);\n\t\tassert (getNextEdge(prev, cluster) == edge);\n\t\tint first_edge = getClusterFirstEdge(cluster);\n\t\tif (next != edge) {\n\t\t\tsetNextEdge_(prev, cluster, next);\n\t\t\tsetPrevEdge_(next, cluster, prev);\n\t\t\tif (first_edge == edge)\n\t\t\t\tsetClusterFirstEdge_(cluster, next);\n\t\t} else\n\t\t\tsetClusterFirstEdge_(cluster, -1);\n\t}", "code_tokens": ["void", "disconnectEdgeFromCluster_", "(", "int", "edge", ",", "int", "cluster", ")", "{", "int", "next", "=", "getNextEdge", "(", "edge", ",", "cluster", ")", ";", "assert", "(", "getPrevEdge", "(", "next", ",", "cluster", ")", "==", "edge", ")", ";", "int", "prev", "=", "getPrevEdge", "(", "edge", ",", "cluster", ")", ";", "assert", "(", "getNextEdge", "(", "prev", ",", "cluster", ")", "==", "edge", ")", ";", "int", "first_edge", "=", "getClusterFirstEdge", "(", "cluster", ")", ";", "if", "(", "next", "!=", "edge", ")", "{", "setNextEdge_", "(", "prev", ",", "cluster", ",", "next", ")", ";", "setPrevEdge_", "(", "next", ",", "cluster", ",", "prev", ")", ";", "if", "(", "first_edge", "==", "edge", ")", "setClusterFirstEdge_", "(", "cluster", ",", "next", ")", ";", "}", "else", "setClusterFirstEdge_", "(", "cluster", ",", "-", "1", ")", ";", "}"], "docstring": "Disconnects the edge from a cluster it is connected to.", "docstring_tokens": ["Disconnects", "the", "edge", "from", "a", "cluster", "it", "is", "connected", "to", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L571-L584", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.fillEventQueue", "original_string": "void fillEventQueue() {\n\t\tAttributeStreamOfInt32 event_q = new AttributeStreamOfInt32(0);\n\t\tevent_q.reserve(m_shape.getTotalPointCount());// temporary structure to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// sort and find\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// clusters\n\t\tEditShape.VertexIterator iter = m_shape.queryVertexIterator();\n\t\tfor (int vert = iter.next(); vert != -1; vert = iter.next()) {\n\t\t\tif (m_shape.getUserIndex(vert, m_vertex_cluster_index) != -1)\n\t\t\t\tevent_q.add(vert);\n\t\t}\n\n\t\t// Now we can merge coincident clusters and form the envent structure.\n\n\t\t// sort vertices lexicographically.\n\t\tm_shape.sortVerticesSimpleByY_(event_q, 0, event_q.size());\n\n\t\t// The m_event_q is the event structure for the planesweep algorithm.\n\t\t// We could use any data structure that allows log(n) insertion and\n\t\t// deletion in the sorted order and\n\t\t// allow to iterate through in the sorted order.\n\n\t\tm_event_q.clear();\n\t\t// Populate the event structure\n\t\tm_event_q.setCapacity(event_q.size());\n\t\t{\n\t\t\t// The comparator is used to sort vertices by the m_event_q\n\t\t\tm_event_q.setComparator(new QComparator(m_shape));\n\t\t}\n\n\t\t// create the vertex clusters and fill the event structure m_event_q.\n\t\t// Because most vertices are expected to be non clustered, we create\n\t\t// clusters only for actual clusters to save some memory.\n\t\tPoint2D cluster_pt = new Point2D();\n\t\tcluster_pt.setNaN();\n\t\tint cluster = -1;\n\t\tPoint2D pt = new Point2D();\n\t\tfor (int index = 0, nvertex = event_q.size(); index < nvertex; index++) {\n\t\t\tint vertex = event_q.get(index);\n\t\t\tm_shape.getXY(vertex, pt);\n\t\t\tif (pt.isEqual(cluster_pt)) {\n\t\t\t\tint vertexCluster = m_shape.getUserIndex(vertex,\n\t\t\t\t\t\tm_vertex_cluster_index);\n\t\t\t\tmergeClusters_(cluster, vertexCluster);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcluster = getClusterFromVertex(vertex);\n\t\t\t// add a vertex to the event queue\n\t\t\tm_shape.getXY(vertex, cluster_pt);\n\t\t\tint eventQnode = m_event_q.addBiggestElement(vertex, -1); // this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// does\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// call\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// comparator's\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// compare,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// assuming\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// sorted\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// order.\n\t\t\tsetClusterEventQNode_(cluster, eventQnode);\n\t\t}\n\t}", "language": "java", "code": "void fillEventQueue() {\n\t\tAttributeStreamOfInt32 event_q = new AttributeStreamOfInt32(0);\n\t\tevent_q.reserve(m_shape.getTotalPointCount());// temporary structure to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// sort and find\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// clusters\n\t\tEditShape.VertexIterator iter = m_shape.queryVertexIterator();\n\t\tfor (int vert = iter.next(); vert != -1; vert = iter.next()) {\n\t\t\tif (m_shape.getUserIndex(vert, m_vertex_cluster_index) != -1)\n\t\t\t\tevent_q.add(vert);\n\t\t}\n\n\t\t// Now we can merge coincident clusters and form the envent structure.\n\n\t\t// sort vertices lexicographically.\n\t\tm_shape.sortVerticesSimpleByY_(event_q, 0, event_q.size());\n\n\t\t// The m_event_q is the event structure for the planesweep algorithm.\n\t\t// We could use any data structure that allows log(n) insertion and\n\t\t// deletion in the sorted order and\n\t\t// allow to iterate through in the sorted order.\n\n\t\tm_event_q.clear();\n\t\t// Populate the event structure\n\t\tm_event_q.setCapacity(event_q.size());\n\t\t{\n\t\t\t// The comparator is used to sort vertices by the m_event_q\n\t\t\tm_event_q.setComparator(new QComparator(m_shape));\n\t\t}\n\n\t\t// create the vertex clusters and fill the event structure m_event_q.\n\t\t// Because most vertices are expected to be non clustered, we create\n\t\t// clusters only for actual clusters to save some memory.\n\t\tPoint2D cluster_pt = new Point2D();\n\t\tcluster_pt.setNaN();\n\t\tint cluster = -1;\n\t\tPoint2D pt = new Point2D();\n\t\tfor (int index = 0, nvertex = event_q.size(); index < nvertex; index++) {\n\t\t\tint vertex = event_q.get(index);\n\t\t\tm_shape.getXY(vertex, pt);\n\t\t\tif (pt.isEqual(cluster_pt)) {\n\t\t\t\tint vertexCluster = m_shape.getUserIndex(vertex,\n\t\t\t\t\t\tm_vertex_cluster_index);\n\t\t\t\tmergeClusters_(cluster, vertexCluster);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcluster = getClusterFromVertex(vertex);\n\t\t\t// add a vertex to the event queue\n\t\t\tm_shape.getXY(vertex, cluster_pt);\n\t\t\tint eventQnode = m_event_q.addBiggestElement(vertex, -1); // this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// method\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// does\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// call\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// comparator's\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// compare,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// assuming\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// sorted\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// order.\n\t\t\tsetClusterEventQNode_(cluster, eventQnode);\n\t\t}\n\t}", "code_tokens": ["void", "fillEventQueue", "(", ")", "{", "AttributeStreamOfInt32", "event_q", "=", "new", "AttributeStreamOfInt32", "(", "0", ")", ";", "event_q", ".", "reserve", "(", "m_shape", ".", "getTotalPointCount", "(", ")", ")", ";", "// temporary structure to", "// sort and find", "// clusters", "EditShape", ".", "VertexIterator", "iter", "=", "m_shape", ".", "queryVertexIterator", "(", ")", ";", "for", "(", "int", "vert", "=", "iter", ".", "next", "(", ")", ";", "vert", "!=", "-", "1", ";", "vert", "=", "iter", ".", "next", "(", ")", ")", "{", "if", "(", "m_shape", ".", "getUserIndex", "(", "vert", ",", "m_vertex_cluster_index", ")", "!=", "-", "1", ")", "event_q", ".", "add", "(", "vert", ")", ";", "}", "// Now we can merge coincident clusters and form the envent structure.", "// sort vertices lexicographically.", "m_shape", ".", "sortVerticesSimpleByY_", "(", "event_q", ",", "0", ",", "event_q", ".", "size", "(", ")", ")", ";", "// The m_event_q is the event structure for the planesweep algorithm.", "// We could use any data structure that allows log(n) insertion and", "// deletion in the sorted order and", "// allow to iterate through in the sorted order.", "m_event_q", ".", "clear", "(", ")", ";", "// Populate the event structure", "m_event_q", ".", "setCapacity", "(", "event_q", ".", "size", "(", ")", ")", ";", "{", "// The comparator is used to sort vertices by the m_event_q", "m_event_q", ".", "setComparator", "(", "new", "QComparator", "(", "m_shape", ")", ")", ";", "}", "// create the vertex clusters and fill the event structure m_event_q.", "// Because most vertices are expected to be non clustered, we create", "// clusters only for actual clusters to save some memory.", "Point2D", "cluster_pt", "=", "new", "Point2D", "(", ")", ";", "cluster_pt", ".", "setNaN", "(", ")", ";", "int", "cluster", "=", "-", "1", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "index", "=", "0", ",", "nvertex", "=", "event_q", ".", "size", "(", ")", ";", "index", "<", "nvertex", ";", "index", "++", ")", "{", "int", "vertex", "=", "event_q", ".", "get", "(", "index", ")", ";", "m_shape", ".", "getXY", "(", "vertex", ",", "pt", ")", ";", "if", "(", "pt", ".", "isEqual", "(", "cluster_pt", ")", ")", "{", "int", "vertexCluster", "=", "m_shape", ".", "getUserIndex", "(", "vertex", ",", "m_vertex_cluster_index", ")", ";", "mergeClusters_", "(", "cluster", ",", "vertexCluster", ")", ";", "continue", ";", "}", "cluster", "=", "getClusterFromVertex", "(", "vertex", ")", ";", "// add a vertex to the event queue", "m_shape", ".", "getXY", "(", "vertex", ",", "cluster_pt", ")", ";", "int", "eventQnode", "=", "m_event_q", ".", "addBiggestElement", "(", "vertex", ",", "-", "1", ")", ";", "// this", "// method", "// does", "// not", "// call", "// comparator's", "// compare,", "// assuming", "// sorted", "// order.", "setClusterEventQNode_", "(", "cluster", ",", "eventQnode", ")", ";", "}", "}"], "docstring": "Fills the event queue and merges coincident clusters.", "docstring_tokens": ["Fills", "the", "event", "queue", "and", "merges", "coincident", "clusters", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L1045-L1106", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.getAffectedEdges", "original_string": "void getAffectedEdges(int cluster, AttributeStreamOfInt32 edges) {\n\t\tint first_edge = getClusterFirstEdge(cluster);\n\t\tif (first_edge == -1)\n\t\t\treturn;\n\n\t\tint edge = first_edge;\n\t\tdo {\n\t\t\tint sweepNode = getEdgeSweepNode(edge);\n\t\t\tif (StridedIndexTypeCollection.isValidElement(sweepNode)) {\n\t\t\t\tedges.add(edge);\n\t\t\t}\n\t\t\tedge = getNextEdge(edge, cluster);\n\t\t} while (edge != first_edge);\n\t}", "language": "java", "code": "void getAffectedEdges(int cluster, AttributeStreamOfInt32 edges) {\n\t\tint first_edge = getClusterFirstEdge(cluster);\n\t\tif (first_edge == -1)\n\t\t\treturn;\n\n\t\tint edge = first_edge;\n\t\tdo {\n\t\t\tint sweepNode = getEdgeSweepNode(edge);\n\t\t\tif (StridedIndexTypeCollection.isValidElement(sweepNode)) {\n\t\t\t\tedges.add(edge);\n\t\t\t}\n\t\t\tedge = getNextEdge(edge, cluster);\n\t\t} while (edge != first_edge);\n\t}", "code_tokens": ["void", "getAffectedEdges", "(", "int", "cluster", ",", "AttributeStreamOfInt32", "edges", ")", "{", "int", "first_edge", "=", "getClusterFirstEdge", "(", "cluster", ")", ";", "if", "(", "first_edge", "==", "-", "1", ")", "return", ";", "int", "edge", "=", "first_edge", ";", "do", "{", "int", "sweepNode", "=", "getEdgeSweepNode", "(", "edge", ")", ";", "if", "(", "StridedIndexTypeCollection", ".", "isValidElement", "(", "sweepNode", ")", ")", "{", "edges", ".", "add", "(", "edge", ")", ";", "}", "edge", "=", "getNextEdge", "(", "edge", ",", "cluster", ")", ";", "}", "while", "(", "edge", "!=", "first_edge", ")", ";", "}"], "docstring": "change of cluster coordinate.", "docstring_tokens": ["change", "of", "cluster", "coordinate", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L1145-L1158", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.updateClusterXY", "original_string": "void updateClusterXY(int cluster, Point2D pt) {\n\t\tint vertexList = getClusterVertices(cluster);\n\t\tfor (int vh = m_cluster_vertices.getFirst(vertexList); vh != -1; vh = m_cluster_vertices\n\t\t\t\t.getNext(vh)) {\n\t\t\tint vertex = m_cluster_vertices.getElement(vh);\n\t\t\tm_shape.setXY(vertex, pt);\n\t\t}\n\t}", "language": "java", "code": "void updateClusterXY(int cluster, Point2D pt) {\n\t\tint vertexList = getClusterVertices(cluster);\n\t\tfor (int vh = m_cluster_vertices.getFirst(vertexList); vh != -1; vh = m_cluster_vertices\n\t\t\t\t.getNext(vh)) {\n\t\t\tint vertex = m_cluster_vertices.getElement(vh);\n\t\t\tm_shape.setXY(vertex, pt);\n\t\t}\n\t}", "code_tokens": ["void", "updateClusterXY", "(", "int", "cluster", ",", "Point2D", "pt", ")", "{", "int", "vertexList", "=", "getClusterVertices", "(", "cluster", ")", ";", "for", "(", "int", "vh", "=", "m_cluster_vertices", ".", "getFirst", "(", "vertexList", ")", ";", "vh", "!=", "-", "1", ";", "vh", "=", "m_cluster_vertices", ".", "getNext", "(", "vh", ")", ")", "{", "int", "vertex", "=", "m_cluster_vertices", ".", "getElement", "(", "vh", ")", ";", "m_shape", ".", "setXY", "(", "vertex", ",", "pt", ")", ";", "}", "}"], "docstring": "Updates all vertices of the cluster to new coordinate", "docstring_tokens": ["Updates", "all", "vertices", "of", "the", "cluster", "to", "new", "coordinate"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L1161-L1168", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.splitEdge_", "original_string": "void splitEdge_(int edge1, int edge2, int intersectionCluster,\n\t\t\tSegmentIntersector intersector) {\n\n\t\tdisconnectEdge_(edge1);// disconnects the edge from the clusters. The\n\t\t\t\t\t\t\t\t// edge still remembers the clusters.\n\t\tif (edge2 != -1)\n\t\t\tdisconnectEdge_(edge2);// disconnects the edge from the clusters.\n\t\t\t\t\t\t\t\t\t// The edge still remembers the clusters.\n\n\t\t// Collect all edges that are affected when the clusters change position\n\t\t// due to snapping\n\t\t// The edges are collected in m_edges_to_insert_in_sweep_structure.\n\t\t// Collect the modified clusters in m_modified_clusters.\n\t\tprocessSplitHelper1_(0, edge1, intersector);\n\t\tif (edge2 != -1)\n\t\t\tprocessSplitHelper1_(1, edge2, intersector);\n\n\t\tif (intersectionCluster != -1) {\n\t\t\tintersector.getResultPoint().getXY(pt_1);\n\t\t\tgetClusterXY(intersectionCluster, pt_2);\n\t\t\tif (!pt_2.isEqual(pt_1))\n\t\t\t\tm_modified_clusters.add(intersectionCluster);\n\t\t}\n\n\t\t// remove modified clusters from the event queue. We'll reincert them\n\t\t// later\n\t\tfor (int i = 0, n = m_modified_clusters.size(); i < n; i++) {\n\t\t\tint cluster = m_modified_clusters.get(i);\n\t\t\tint eventQnode = getClusterEventQNode(cluster);\n\t\t\tif (eventQnode != -1) {\n\t\t\t\tm_event_q.deleteNode(eventQnode, -1);\n\t\t\t\tsetClusterEventQNode_(cluster, -1);\n\t\t\t}\n\t\t}\n\n\t\tint edgeOrigins1 = getEdgeOriginVertices(edge1);\n\t\tint edgeOrigins2 = (edge2 != -1) ? getEdgeOriginVertices(edge2) : -1;\n\n\t\t// Adjust the vertex coordinates and split the segments in the the edit\n\t\t// shape.\n\t\tapplyIntersectorToEditShape_(edgeOrigins1, intersector, 0);\n\t\tif (edge2 != -1)\n\t\t\tapplyIntersectorToEditShape_(edgeOrigins2, intersector, 1);\n\n\t\t// Produce clusters, and new edges. The new edges are added to\n\t\t// m_edges_to_insert_in_sweep_structure.\n\t\tcreateEdgesAndClustersFromSplitEdge_(edge1, intersector, 0);\n\t\tif (edge2 != -1)\n\t\t\tcreateEdgesAndClustersFromSplitEdge_(edge2, intersector, 1);\n\n\t\tm_edge_vertices.deleteList(edgeOrigins1);\n\t\tdeleteEdge_(edge1);\n\n\t\tif (edge2 != -1) {\n\t\t\tm_edge_vertices.deleteList(edgeOrigins2);\n\t\t\tdeleteEdge_(edge2);\n\t\t}\n\n\t\t// insert clusters into the event queue and the edges into the sweep\n\t\t// structure.\n\t\tfor (int i = 0, n = m_modified_clusters.size(); i < n; i++) {\n\t\t\tint cluster = m_modified_clusters.get(i);\n\t\t\tif (cluster == m_sweep_point_cluster)\n\t\t\t\tm_b_sweep_point_cluster_was_modified = true;\n\n\t\t\tint eventQnode = getClusterEventQNode(cluster);\n\t\t\tif (eventQnode == -1) {\n\t\t\t\tint vertex = getClusterFirstVertex(cluster);\n\t\t\t\tassert (getClusterFromVertex(vertex) == cluster);\n\n\t\t\t\teventQnode = m_event_q.addUniqueElement(vertex, -1);// O(logN)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// operation\n\t\t\t\tif (eventQnode == -1) {// the cluster is coinciding with another\n\t\t\t\t\t\t\t\t\t\t// one. merge.\n\t\t\t\t\tint existingNode = m_event_q.getDuplicateElement(-1);\n\t\t\t\t\tint v = m_event_q.getElement(existingNode);\n\t\t\t\t\tassert (m_shape.isEqualXY(vertex, v));\n\t\t\t\t\tint existingCluster = getClusterFromVertex(v);\n\t\t\t\t\tmergeClusters_(existingCluster, cluster);\n\t\t\t\t} else {\n\t\t\t\t\tsetClusterEventQNode_(cluster, eventQnode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if already inserted (probably impossible) case\n\t\t\t}\n\t\t}\n\n\t\tm_modified_clusters.clear(false);\n\t}", "language": "java", "code": "void splitEdge_(int edge1, int edge2, int intersectionCluster,\n\t\t\tSegmentIntersector intersector) {\n\n\t\tdisconnectEdge_(edge1);// disconnects the edge from the clusters. The\n\t\t\t\t\t\t\t\t// edge still remembers the clusters.\n\t\tif (edge2 != -1)\n\t\t\tdisconnectEdge_(edge2);// disconnects the edge from the clusters.\n\t\t\t\t\t\t\t\t\t// The edge still remembers the clusters.\n\n\t\t// Collect all edges that are affected when the clusters change position\n\t\t// due to snapping\n\t\t// The edges are collected in m_edges_to_insert_in_sweep_structure.\n\t\t// Collect the modified clusters in m_modified_clusters.\n\t\tprocessSplitHelper1_(0, edge1, intersector);\n\t\tif (edge2 != -1)\n\t\t\tprocessSplitHelper1_(1, edge2, intersector);\n\n\t\tif (intersectionCluster != -1) {\n\t\t\tintersector.getResultPoint().getXY(pt_1);\n\t\t\tgetClusterXY(intersectionCluster, pt_2);\n\t\t\tif (!pt_2.isEqual(pt_1))\n\t\t\t\tm_modified_clusters.add(intersectionCluster);\n\t\t}\n\n\t\t// remove modified clusters from the event queue. We'll reincert them\n\t\t// later\n\t\tfor (int i = 0, n = m_modified_clusters.size(); i < n; i++) {\n\t\t\tint cluster = m_modified_clusters.get(i);\n\t\t\tint eventQnode = getClusterEventQNode(cluster);\n\t\t\tif (eventQnode != -1) {\n\t\t\t\tm_event_q.deleteNode(eventQnode, -1);\n\t\t\t\tsetClusterEventQNode_(cluster, -1);\n\t\t\t}\n\t\t}\n\n\t\tint edgeOrigins1 = getEdgeOriginVertices(edge1);\n\t\tint edgeOrigins2 = (edge2 != -1) ? getEdgeOriginVertices(edge2) : -1;\n\n\t\t// Adjust the vertex coordinates and split the segments in the the edit\n\t\t// shape.\n\t\tapplyIntersectorToEditShape_(edgeOrigins1, intersector, 0);\n\t\tif (edge2 != -1)\n\t\t\tapplyIntersectorToEditShape_(edgeOrigins2, intersector, 1);\n\n\t\t// Produce clusters, and new edges. The new edges are added to\n\t\t// m_edges_to_insert_in_sweep_structure.\n\t\tcreateEdgesAndClustersFromSplitEdge_(edge1, intersector, 0);\n\t\tif (edge2 != -1)\n\t\t\tcreateEdgesAndClustersFromSplitEdge_(edge2, intersector, 1);\n\n\t\tm_edge_vertices.deleteList(edgeOrigins1);\n\t\tdeleteEdge_(edge1);\n\n\t\tif (edge2 != -1) {\n\t\t\tm_edge_vertices.deleteList(edgeOrigins2);\n\t\t\tdeleteEdge_(edge2);\n\t\t}\n\n\t\t// insert clusters into the event queue and the edges into the sweep\n\t\t// structure.\n\t\tfor (int i = 0, n = m_modified_clusters.size(); i < n; i++) {\n\t\t\tint cluster = m_modified_clusters.get(i);\n\t\t\tif (cluster == m_sweep_point_cluster)\n\t\t\t\tm_b_sweep_point_cluster_was_modified = true;\n\n\t\t\tint eventQnode = getClusterEventQNode(cluster);\n\t\t\tif (eventQnode == -1) {\n\t\t\t\tint vertex = getClusterFirstVertex(cluster);\n\t\t\t\tassert (getClusterFromVertex(vertex) == cluster);\n\n\t\t\t\teventQnode = m_event_q.addUniqueElement(vertex, -1);// O(logN)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// operation\n\t\t\t\tif (eventQnode == -1) {// the cluster is coinciding with another\n\t\t\t\t\t\t\t\t\t\t// one. merge.\n\t\t\t\t\tint existingNode = m_event_q.getDuplicateElement(-1);\n\t\t\t\t\tint v = m_event_q.getElement(existingNode);\n\t\t\t\t\tassert (m_shape.isEqualXY(vertex, v));\n\t\t\t\t\tint existingCluster = getClusterFromVertex(v);\n\t\t\t\t\tmergeClusters_(existingCluster, cluster);\n\t\t\t\t} else {\n\t\t\t\t\tsetClusterEventQNode_(cluster, eventQnode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if already inserted (probably impossible) case\n\t\t\t}\n\t\t}\n\n\t\tm_modified_clusters.clear(false);\n\t}", "code_tokens": ["void", "splitEdge_", "(", "int", "edge1", ",", "int", "edge2", ",", "int", "intersectionCluster", ",", "SegmentIntersector", "intersector", ")", "{", "disconnectEdge_", "(", "edge1", ")", ";", "// disconnects the edge from the clusters. The", "// edge still remembers the clusters.", "if", "(", "edge2", "!=", "-", "1", ")", "disconnectEdge_", "(", "edge2", ")", ";", "// disconnects the edge from the clusters.", "// The edge still remembers the clusters.", "// Collect all edges that are affected when the clusters change position", "// due to snapping", "// The edges are collected in m_edges_to_insert_in_sweep_structure.", "// Collect the modified clusters in m_modified_clusters.", "processSplitHelper1_", "(", "0", ",", "edge1", ",", "intersector", ")", ";", "if", "(", "edge2", "!=", "-", "1", ")", "processSplitHelper1_", "(", "1", ",", "edge2", ",", "intersector", ")", ";", "if", "(", "intersectionCluster", "!=", "-", "1", ")", "{", "intersector", ".", "getResultPoint", "(", ")", ".", "getXY", "(", "pt_1", ")", ";", "getClusterXY", "(", "intersectionCluster", ",", "pt_2", ")", ";", "if", "(", "!", "pt_2", ".", "isEqual", "(", "pt_1", ")", ")", "m_modified_clusters", ".", "add", "(", "intersectionCluster", ")", ";", "}", "// remove modified clusters from the event queue. We'll reincert them", "// later", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_modified_clusters", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "cluster", "=", "m_modified_clusters", ".", "get", "(", "i", ")", ";", "int", "eventQnode", "=", "getClusterEventQNode", "(", "cluster", ")", ";", "if", "(", "eventQnode", "!=", "-", "1", ")", "{", "m_event_q", ".", "deleteNode", "(", "eventQnode", ",", "-", "1", ")", ";", "setClusterEventQNode_", "(", "cluster", ",", "-", "1", ")", ";", "}", "}", "int", "edgeOrigins1", "=", "getEdgeOriginVertices", "(", "edge1", ")", ";", "int", "edgeOrigins2", "=", "(", "edge2", "!=", "-", "1", ")", "?", "getEdgeOriginVertices", "(", "edge2", ")", ":", "-", "1", ";", "// Adjust the vertex coordinates and split the segments in the the edit", "// shape.", "applyIntersectorToEditShape_", "(", "edgeOrigins1", ",", "intersector", ",", "0", ")", ";", "if", "(", "edge2", "!=", "-", "1", ")", "applyIntersectorToEditShape_", "(", "edgeOrigins2", ",", "intersector", ",", "1", ")", ";", "// Produce clusters, and new edges. The new edges are added to", "// m_edges_to_insert_in_sweep_structure.", "createEdgesAndClustersFromSplitEdge_", "(", "edge1", ",", "intersector", ",", "0", ")", ";", "if", "(", "edge2", "!=", "-", "1", ")", "createEdgesAndClustersFromSplitEdge_", "(", "edge2", ",", "intersector", ",", "1", ")", ";", "m_edge_vertices", ".", "deleteList", "(", "edgeOrigins1", ")", ";", "deleteEdge_", "(", "edge1", ")", ";", "if", "(", "edge2", "!=", "-", "1", ")", "{", "m_edge_vertices", ".", "deleteList", "(", "edgeOrigins2", ")", ";", "deleteEdge_", "(", "edge2", ")", ";", "}", "// insert clusters into the event queue and the edges into the sweep", "// structure.", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_modified_clusters", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "cluster", "=", "m_modified_clusters", ".", "get", "(", "i", ")", ";", "if", "(", "cluster", "==", "m_sweep_point_cluster", ")", "m_b_sweep_point_cluster_was_modified", "=", "true", ";", "int", "eventQnode", "=", "getClusterEventQNode", "(", "cluster", ")", ";", "if", "(", "eventQnode", "==", "-", "1", ")", "{", "int", "vertex", "=", "getClusterFirstVertex", "(", "cluster", ")", ";", "assert", "(", "getClusterFromVertex", "(", "vertex", ")", "==", "cluster", ")", ";", "eventQnode", "=", "m_event_q", ".", "addUniqueElement", "(", "vertex", ",", "-", "1", ")", ";", "// O(logN)", "// operation", "if", "(", "eventQnode", "==", "-", "1", ")", "{", "// the cluster is coinciding with another", "// one. merge.", "int", "existingNode", "=", "m_event_q", ".", "getDuplicateElement", "(", "-", "1", ")", ";", "int", "v", "=", "m_event_q", ".", "getElement", "(", "existingNode", ")", ";", "assert", "(", "m_shape", ".", "isEqualXY", "(", "vertex", ",", "v", ")", ")", ";", "int", "existingCluster", "=", "getClusterFromVertex", "(", "v", ")", ";", "mergeClusters_", "(", "existingCluster", ",", "cluster", ")", ";", "}", "else", "{", "setClusterEventQNode_", "(", "cluster", ",", "eventQnode", ")", ";", "}", "}", "else", "{", "// if already inserted (probably impossible) case", "}", "}", "m_modified_clusters", ".", "clear", "(", "false", ")", ";", "}"], "docstring": "m_edges_to_insert_in_sweep_structure.", "docstring_tokens": ["m_edges_to_insert_in_sweep_structure", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L1174-L1262", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.getClusterXY", "original_string": "void getClusterXY(int cluster, Point2D ptOut) {\n\t\tint vindex = getClusterVertexIndex(cluster);\n\t\tm_shape.getXYWithIndex(vindex, ptOut);\n\t}", "language": "java", "code": "void getClusterXY(int cluster, Point2D ptOut) {\n\t\tint vindex = getClusterVertexIndex(cluster);\n\t\tm_shape.getXYWithIndex(vindex, ptOut);\n\t}", "code_tokens": ["void", "getClusterXY", "(", "int", "cluster", ",", "Point2D", "ptOut", ")", "{", "int", "vindex", "=", "getClusterVertexIndex", "(", "cluster", ")", ";", "m_shape", ".", "getXYWithIndex", "(", "vindex", ",", "ptOut", ")", ";", "}"], "docstring": "Returns a cluster's xy.", "docstring_tokens": ["Returns", "a", "cluster", "s", "xy", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L1265-L1268", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Clusterer.java", "func_name": "Clusterer.executeNonReciprocal", "original_string": "static boolean executeNonReciprocal(EditShape shape, double tolerance) {\n\t\tClusterer clusterer = new Clusterer();\n\t\tclusterer.m_shape = shape;\n\t\tclusterer.m_tolerance = tolerance;\n\t\tclusterer.m_sqr_tolerance = tolerance * tolerance;\n\t\tclusterer.m_cell_size = 2 * tolerance;\n\t\tclusterer.m_inv_cell_size = 1.0 / clusterer.m_cell_size;\n\t\treturn clusterer.clusterNonReciprocal_();\n\t}", "language": "java", "code": "static boolean executeNonReciprocal(EditShape shape, double tolerance) {\n\t\tClusterer clusterer = new Clusterer();\n\t\tclusterer.m_shape = shape;\n\t\tclusterer.m_tolerance = tolerance;\n\t\tclusterer.m_sqr_tolerance = tolerance * tolerance;\n\t\tclusterer.m_cell_size = 2 * tolerance;\n\t\tclusterer.m_inv_cell_size = 1.0 / clusterer.m_cell_size;\n\t\treturn clusterer.clusterNonReciprocal_();\n\t}", "code_tokens": ["static", "boolean", "executeNonReciprocal", "(", "EditShape", "shape", ",", "double", "tolerance", ")", "{", "Clusterer", "clusterer", "=", "new", "Clusterer", "(", ")", ";", "clusterer", ".", "m_shape", "=", "shape", ";", "clusterer", ".", "m_tolerance", "=", "tolerance", ";", "clusterer", ".", "m_sqr_tolerance", "=", "tolerance", "*", "tolerance", ";", "clusterer", ".", "m_cell_size", "=", "2", "*", "tolerance", ";", "clusterer", ".", "m_inv_cell_size", "=", "1.0", "/", "clusterer", ".", "m_cell_size", ";", "return", "clusterer", ".", "clusterNonReciprocal_", "(", ")", ";", "}"], "docstring": "the tolerance in the first-found-first-clustered order)", "docstring_tokens": ["the", "tolerance", "in", "the", "first", "-", "found", "-", "first", "-", "clustered", "order", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Clusterer.java#L49-L57", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Clusterer.java", "func_name": "Clusterer.isClusterCandidate_", "original_string": "static boolean isClusterCandidate_(double x_1, double y1, double x2,\n\t\t\tdouble y2, double sqr_tolerance) {\n\t\tdouble dx = x_1 - x2;\n\t\tdouble dy = y1 - y2;\n\t\treturn dx * dx + dy * dy <= sqr_tolerance;\n\t}", "language": "java", "code": "static boolean isClusterCandidate_(double x_1, double y1, double x2,\n\t\t\tdouble y2, double sqr_tolerance) {\n\t\tdouble dx = x_1 - x2;\n\t\tdouble dy = y1 - y2;\n\t\treturn dx * dx + dy * dy <= sqr_tolerance;\n\t}", "code_tokens": ["static", "boolean", "isClusterCandidate_", "(", "double", "x_1", ",", "double", "y1", ",", "double", "x2", ",", "double", "y2", ",", "double", "sqr_tolerance", ")", "{", "double", "dx", "=", "x_1", "-", "x2", ";", "double", "dy", "=", "y1", "-", "y2", ";", "return", "dx", "*", "dx", "+", "dy", "*", "dy", "<=", "sqr_tolerance", ";", "}"], "docstring": "makes sure Simplified shape is more robust to transformations.", "docstring_tokens": ["makes", "sure", "Simplified", "shape", "is", "more", "robust", "to", "transformations", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Clusterer.java#L61-L66", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Clusterer.java", "func_name": "Clusterer.mergeVertices", "original_string": "static boolean mergeVertices(Point pt_1, Point pt_2, double w_1,\n\t\t\tint rank_1, double w_2, int rank_2, Point pt_res, double[] w_res,\n\t\t\tint[] rank_res) {\n\t\tassert (!pt_1.isEmpty() && !pt_2.isEmpty());\n\t\tboolean res = pt_1.equals(pt_2);\n\n\t\tif (rank_1 > rank_2) {\n\t\t\tpt_res = pt_1;\n\t\t\tif (w_res != null) {\n\t\t\t\trank_res[0] = rank_1;\n\t\t\t\tw_res[0] = w_1;\n\t\t\t}\n\t\t\treturn res;\n\t\t} else if (rank_2 > rank_1) {\n\t\t\tpt_res = pt_2;\n\t\t\tif (w_res != null) {\n\t\t\t\trank_res[0] = rank_1;\n\t\t\t\tw_res[0] = w_1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpt_res = pt_1;\n\t\tPoint2D pt2d = new Point2D();\n\t\tmergeVertices2D(pt_1.getXY(), pt_2.getXY(), w_1, rank_1, w_2, rank_2,\n\t\t\t\tpt2d, w_res, rank_res);\n\t\tpt_res.setXY(pt2d);\n\t\treturn res;\n\t}", "language": "java", "code": "static boolean mergeVertices(Point pt_1, Point pt_2, double w_1,\n\t\t\tint rank_1, double w_2, int rank_2, Point pt_res, double[] w_res,\n\t\t\tint[] rank_res) {\n\t\tassert (!pt_1.isEmpty() && !pt_2.isEmpty());\n\t\tboolean res = pt_1.equals(pt_2);\n\n\t\tif (rank_1 > rank_2) {\n\t\t\tpt_res = pt_1;\n\t\t\tif (w_res != null) {\n\t\t\t\trank_res[0] = rank_1;\n\t\t\t\tw_res[0] = w_1;\n\t\t\t}\n\t\t\treturn res;\n\t\t} else if (rank_2 > rank_1) {\n\t\t\tpt_res = pt_2;\n\t\t\tif (w_res != null) {\n\t\t\t\trank_res[0] = rank_1;\n\t\t\t\tw_res[0] = w_1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpt_res = pt_1;\n\t\tPoint2D pt2d = new Point2D();\n\t\tmergeVertices2D(pt_1.getXY(), pt_2.getXY(), w_1, rank_1, w_2, rank_2,\n\t\t\t\tpt2d, w_res, rank_res);\n\t\tpt_res.setXY(pt2d);\n\t\treturn res;\n\t}", "code_tokens": ["static", "boolean", "mergeVertices", "(", "Point", "pt_1", ",", "Point", "pt_2", ",", "double", "w_1", ",", "int", "rank_1", ",", "double", "w_2", ",", "int", "rank_2", ",", "Point", "pt_res", ",", "double", "[", "]", "w_res", ",", "int", "[", "]", "rank_res", ")", "{", "assert", "(", "!", "pt_1", ".", "isEmpty", "(", ")", "&&", "!", "pt_2", ".", "isEmpty", "(", ")", ")", ";", "boolean", "res", "=", "pt_1", ".", "equals", "(", "pt_2", ")", ";", "if", "(", "rank_1", ">", "rank_2", ")", "{", "pt_res", "=", "pt_1", ";", "if", "(", "w_res", "!=", "null", ")", "{", "rank_res", "[", "0", "]", "=", "rank_1", ";", "w_res", "[", "0", "]", "=", "w_1", ";", "}", "return", "res", ";", "}", "else", "if", "(", "rank_2", ">", "rank_1", ")", "{", "pt_res", "=", "pt_2", ";", "if", "(", "w_res", "!=", "null", ")", "{", "rank_res", "[", "0", "]", "=", "rank_1", ";", "w_res", "[", "0", "]", "=", "w_1", ";", "}", "return", "res", ";", "}", "pt_res", "=", "pt_1", ";", "Point2D", "pt2d", "=", "new", "Point2D", "(", ")", ";", "mergeVertices2D", "(", "pt_1", ".", "getXY", "(", ")", ",", "pt_2", ".", "getXY", "(", ")", ",", "w_1", ",", "rank_1", ",", "w_2", ",", "rank_2", ",", "pt2d", ",", "w_res", ",", "rank_res", ")", ";", "pt_res", ".", "setXY", "(", "pt2d", ")", ";", "return", "res", ";", "}"], "docstring": "return true if the coordinates has changed.", "docstring_tokens": ["return", "true", "if", "the", "coordinates", "has", "changed", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Clusterer.java#L336-L364", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorDifferenceLocal.java", "func_name": "OperatorDifferenceLocal.pointMinusPolygon_", "original_string": "static Geometry pointMinusPolygon_(Point point, Polygon polygon,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tPolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(\n\t\t\t\tpolygon, point, tolerance);\n\n\t\tif (result == PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn point;\n\n\t\treturn point.createInstance();\n\t}", "language": "java", "code": "static Geometry pointMinusPolygon_(Point point, Polygon polygon,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tPolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(\n\t\t\t\tpolygon, point, tolerance);\n\n\t\tif (result == PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn point;\n\n\t\treturn point.createInstance();\n\t}", "code_tokens": ["static", "Geometry", "pointMinusPolygon_", "(", "Point", "point", ",", "Polygon", "polygon", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon", ",", "point", ",", "tolerance", ")", ";", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "point", ";", "return", "point", ".", "createInstance", "(", ")", ";", "}"], "docstring": "these are special implementations, all others delegate to the topo-graph.", "docstring_tokens": ["these", "are", "special", "implementations", "all", "others", "delegate", "to", "the", "topo", "-", "graph", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorDifferenceLocal.java#L132-L141", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopologicalOperations.java", "func_name": "TopologicalOperations.dissolveCommonEdges_", "original_string": "void dissolveCommonEdges_() {\n\t\tint visitedEdges = m_topo_graph.createUserIndexForHalfEdges();\n\t\tAttributeStreamOfInt32 edgesToDelete = new AttributeStreamOfInt32(0);\n\t\t// Now extract paths that\n\t\tfor (int cluster = m_topo_graph.getFirstCluster(); cluster != -1; cluster = m_topo_graph\n\t\t\t\t.getNextCluster(cluster)) {\n\t\t\tint firstHalfEdge = m_topo_graph.getClusterHalfEdge(cluster);\n\t\t\tint half_edge = firstHalfEdge;\n\t\t\tif (firstHalfEdge == -1)\n\t\t\t\tcontinue;\n\n\t\t\tdo {\n\t\t\t\tint visited = m_topo_graph.getHalfEdgeUserIndex(half_edge,\n\t\t\t\t\t\tvisitedEdges);\n\t\t\t\tif (visited != 1) {\n\t\t\t\t\tint halfEdgeTwin = m_topo_graph.getHalfEdgeTwin(half_edge);\n\t\t\t\t\tm_topo_graph.setHalfEdgeUserIndex(halfEdgeTwin,\n\t\t\t\t\t\t\tvisitedEdges, 1);\n\t\t\t\t\tm_topo_graph.setHalfEdgeUserIndex(half_edge, visitedEdges,\n\t\t\t\t\t\t\t1);\n\t\t\t\t\tint parentage = m_topo_graph\n\t\t\t\t\t\t\t.getHalfEdgeFaceParentage(half_edge);\n\t\t\t\t\tif (isGoodParentage(parentage)) {\n\t\t\t\t\t\tint twinParentage = m_topo_graph\n\t\t\t\t\t\t\t\t.getHalfEdgeFaceParentage(halfEdgeTwin);\n\t\t\t\t\t\tif (isGoodParentage(twinParentage)) {\n\t\t\t\t\t\t\t// This half_edge pair is a border between two faces\n\t\t\t\t\t\t\t// that share the parentage or it is a dangling edge\n\t\t\t\t\t\t\tedgesToDelete.add(half_edge);// remember for\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// subsequent delete\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thalf_edge = m_topo_graph.getHalfEdgeNext(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\t\t\t} while (half_edge != firstHalfEdge);\n\t\t}\n\n\t\tm_topo_graph.deleteUserIndexForHalfEdges(visitedEdges);\n\t\tm_topo_graph.deleteEdgesBreakFaces_(edgesToDelete);\n\t}", "language": "java", "code": "void dissolveCommonEdges_() {\n\t\tint visitedEdges = m_topo_graph.createUserIndexForHalfEdges();\n\t\tAttributeStreamOfInt32 edgesToDelete = new AttributeStreamOfInt32(0);\n\t\t// Now extract paths that\n\t\tfor (int cluster = m_topo_graph.getFirstCluster(); cluster != -1; cluster = m_topo_graph\n\t\t\t\t.getNextCluster(cluster)) {\n\t\t\tint firstHalfEdge = m_topo_graph.getClusterHalfEdge(cluster);\n\t\t\tint half_edge = firstHalfEdge;\n\t\t\tif (firstHalfEdge == -1)\n\t\t\t\tcontinue;\n\n\t\t\tdo {\n\t\t\t\tint visited = m_topo_graph.getHalfEdgeUserIndex(half_edge,\n\t\t\t\t\t\tvisitedEdges);\n\t\t\t\tif (visited != 1) {\n\t\t\t\t\tint halfEdgeTwin = m_topo_graph.getHalfEdgeTwin(half_edge);\n\t\t\t\t\tm_topo_graph.setHalfEdgeUserIndex(halfEdgeTwin,\n\t\t\t\t\t\t\tvisitedEdges, 1);\n\t\t\t\t\tm_topo_graph.setHalfEdgeUserIndex(half_edge, visitedEdges,\n\t\t\t\t\t\t\t1);\n\t\t\t\t\tint parentage = m_topo_graph\n\t\t\t\t\t\t\t.getHalfEdgeFaceParentage(half_edge);\n\t\t\t\t\tif (isGoodParentage(parentage)) {\n\t\t\t\t\t\tint twinParentage = m_topo_graph\n\t\t\t\t\t\t\t\t.getHalfEdgeFaceParentage(halfEdgeTwin);\n\t\t\t\t\t\tif (isGoodParentage(twinParentage)) {\n\t\t\t\t\t\t\t// This half_edge pair is a border between two faces\n\t\t\t\t\t\t\t// that share the parentage or it is a dangling edge\n\t\t\t\t\t\t\tedgesToDelete.add(half_edge);// remember for\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// subsequent delete\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thalf_edge = m_topo_graph.getHalfEdgeNext(m_topo_graph\n\t\t\t\t\t\t.getHalfEdgeTwin(half_edge));\n\t\t\t} while (half_edge != firstHalfEdge);\n\t\t}\n\n\t\tm_topo_graph.deleteUserIndexForHalfEdges(visitedEdges);\n\t\tm_topo_graph.deleteEdgesBreakFaces_(edgesToDelete);\n\t}", "code_tokens": ["void", "dissolveCommonEdges_", "(", ")", "{", "int", "visitedEdges", "=", "m_topo_graph", ".", "createUserIndexForHalfEdges", "(", ")", ";", "AttributeStreamOfInt32", "edgesToDelete", "=", "new", "AttributeStreamOfInt32", "(", "0", ")", ";", "// Now extract paths that", "for", "(", "int", "cluster", "=", "m_topo_graph", ".", "getFirstCluster", "(", ")", ";", "cluster", "!=", "-", "1", ";", "cluster", "=", "m_topo_graph", ".", "getNextCluster", "(", "cluster", ")", ")", "{", "int", "firstHalfEdge", "=", "m_topo_graph", ".", "getClusterHalfEdge", "(", "cluster", ")", ";", "int", "half_edge", "=", "firstHalfEdge", ";", "if", "(", "firstHalfEdge", "==", "-", "1", ")", "continue", ";", "do", "{", "int", "visited", "=", "m_topo_graph", ".", "getHalfEdgeUserIndex", "(", "half_edge", ",", "visitedEdges", ")", ";", "if", "(", "visited", "!=", "1", ")", "{", "int", "halfEdgeTwin", "=", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ";", "m_topo_graph", ".", "setHalfEdgeUserIndex", "(", "halfEdgeTwin", ",", "visitedEdges", ",", "1", ")", ";", "m_topo_graph", ".", "setHalfEdgeUserIndex", "(", "half_edge", ",", "visitedEdges", ",", "1", ")", ";", "int", "parentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "half_edge", ")", ";", "if", "(", "isGoodParentage", "(", "parentage", ")", ")", "{", "int", "twinParentage", "=", "m_topo_graph", ".", "getHalfEdgeFaceParentage", "(", "halfEdgeTwin", ")", ";", "if", "(", "isGoodParentage", "(", "twinParentage", ")", ")", "{", "// This half_edge pair is a border between two faces", "// that share the parentage or it is a dangling edge", "edgesToDelete", ".", "add", "(", "half_edge", ")", ";", "// remember for", "// subsequent delete", "}", "}", "}", "half_edge", "=", "m_topo_graph", ".", "getHalfEdgeNext", "(", "m_topo_graph", ".", "getHalfEdgeTwin", "(", "half_edge", ")", ")", ";", "}", "while", "(", "half_edge", "!=", "firstHalfEdge", ")", ";", "}", "m_topo_graph", ".", "deleteUserIndexForHalfEdges", "(", "visitedEdges", ")", ";", "m_topo_graph", ".", "deleteEdgesBreakFaces_", "(", "edgesToDelete", ")", ";", "}"], "docstring": "dissolved faces. Only face parentage will be uasable.", "docstring_tokens": ["dissolved", "faces", ".", "Only", "face", "parentage", "will", "be", "uasable", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopologicalOperations.java#L214-L255", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopologicalOperations.java", "func_name": "TopologicalOperations.planarSimplify", "original_string": "static MultiVertexGeometry planarSimplify(MultiVertexGeometry input_geom,\n\t\t\tdouble tolerance, boolean use_winding_rule_for_polygons,\n\t\t\tboolean dirty_result, ProgressTracker progress_tracker) {\n\t\tTopologicalOperations topoOps = new TopologicalOperations();\n\t\treturn topoOps.planarSimplifyImpl_(input_geom, tolerance,\n\t\t\t\tuse_winding_rule_for_polygons, dirty_result, progress_tracker);\n\t}", "language": "java", "code": "static MultiVertexGeometry planarSimplify(MultiVertexGeometry input_geom,\n\t\t\tdouble tolerance, boolean use_winding_rule_for_polygons,\n\t\t\tboolean dirty_result, ProgressTracker progress_tracker) {\n\t\tTopologicalOperations topoOps = new TopologicalOperations();\n\t\treturn topoOps.planarSimplifyImpl_(input_geom, tolerance,\n\t\t\t\tuse_winding_rule_for_polygons, dirty_result, progress_tracker);\n\t}", "code_tokens": ["static", "MultiVertexGeometry", "planarSimplify", "(", "MultiVertexGeometry", "input_geom", ",", "double", "tolerance", ",", "boolean", "use_winding_rule_for_polygons", ",", "boolean", "dirty_result", ",", "ProgressTracker", "progress_tracker", ")", "{", "TopologicalOperations", "topoOps", "=", "new", "TopologicalOperations", "(", ")", ";", "return", "topoOps", ".", "planarSimplifyImpl_", "(", "input_geom", ",", "tolerance", ",", "use_winding_rule_for_polygons", ",", "dirty_result", ",", "progress_tracker", ")", ";", "}"], "docstring": "static", "docstring_tokens": ["static"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopologicalOperations.java#L1248-L1254", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopologicalOperations.java", "func_name": "TopologicalOperations.symmetricDifference", "original_string": "public static Geometry symmetricDifference(Geometry geometry_a,\n\t\t\tGeometry geometry_b, SpatialReference sr,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (geometry_a.getDimension() > geometry_b.getDimension())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_a),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (geometry_a.getDimension() < geometry_b.getDimension())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_b),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (geometry_a.isEmpty())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_b),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (geometry_b.isEmpty())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_a),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tEnvelope2D env2D_1 = new Envelope2D();\n\t\tgeometry_a.queryEnvelope2D(env2D_1);\n\t\tEnvelope2D env2D_2 = new Envelope2D();\n\t\tgeometry_b.queryEnvelope2D(env2D_2);\n\t\t// TODO: add optimization here to merge two geometries if the envelopes\n\t\t// do not overlap.\n\n\t\tEnvelope2D envMerged = new Envelope2D();\n\t\tenvMerged.setCoords(env2D_1);\n\t\tenvMerged.merge(env2D_2);\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenvMerged, true);// conservative to have same effect as simplify\n\n\t\tTopologicalOperations topoOps = new TopologicalOperations();\n\t\tEditShape edit_shape = new EditShape();\n\t\tint geom_a = edit_shape\n\t\t\t\t.addGeometry(normalizeInputGeometry_(geometry_a));\n\t\tint geom_b = edit_shape\n\t\t\t\t.addGeometry(normalizeInputGeometry_(geometry_b));\n\t\ttopoOps.setEditShapeCrackAndCluster(edit_shape, tolerance,\n\t\t\t\tprogress_tracker);\n\t\tint result = topoOps.symmetricDifference(geom_a, geom_b);\n\t\tGeometry res_geom = normalizeResult_(edit_shape.getGeometry(result),\n\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (Geometry.isMultiPath(res_geom.getType().value())) {\n\t\t\t((MultiVertexGeometryImpl) res_geom._getImpl()).setIsSimple(\n\t\t\t\t\tGeometryXSimple.Strong, tolerance, false);\n\t\t\tif (res_geom.getType() == Geometry.Type.Polygon)\n\t\t\t\t((MultiPathImpl) res_geom._getImpl())._updateOGCFlags();\n\t\t}\n\n\t\treturn res_geom;\n\t}", "language": "java", "code": "public static Geometry symmetricDifference(Geometry geometry_a,\n\t\t\tGeometry geometry_b, SpatialReference sr,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (geometry_a.getDimension() > geometry_b.getDimension())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_a),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (geometry_a.getDimension() < geometry_b.getDimension())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_b),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (geometry_a.isEmpty())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_b),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (geometry_b.isEmpty())\n\t\t\treturn normalizeResult_(normalizeInputGeometry_(geometry_a),\n\t\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tEnvelope2D env2D_1 = new Envelope2D();\n\t\tgeometry_a.queryEnvelope2D(env2D_1);\n\t\tEnvelope2D env2D_2 = new Envelope2D();\n\t\tgeometry_b.queryEnvelope2D(env2D_2);\n\t\t// TODO: add optimization here to merge two geometries if the envelopes\n\t\t// do not overlap.\n\n\t\tEnvelope2D envMerged = new Envelope2D();\n\t\tenvMerged.setCoords(env2D_1);\n\t\tenvMerged.merge(env2D_2);\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenvMerged, true);// conservative to have same effect as simplify\n\n\t\tTopologicalOperations topoOps = new TopologicalOperations();\n\t\tEditShape edit_shape = new EditShape();\n\t\tint geom_a = edit_shape\n\t\t\t\t.addGeometry(normalizeInputGeometry_(geometry_a));\n\t\tint geom_b = edit_shape\n\t\t\t\t.addGeometry(normalizeInputGeometry_(geometry_b));\n\t\ttopoOps.setEditShapeCrackAndCluster(edit_shape, tolerance,\n\t\t\t\tprogress_tracker);\n\t\tint result = topoOps.symmetricDifference(geom_a, geom_b);\n\t\tGeometry res_geom = normalizeResult_(edit_shape.getGeometry(result),\n\t\t\t\tgeometry_a, geometry_b, '^');\n\n\t\tif (Geometry.isMultiPath(res_geom.getType().value())) {\n\t\t\t((MultiVertexGeometryImpl) res_geom._getImpl()).setIsSimple(\n\t\t\t\t\tGeometryXSimple.Strong, tolerance, false);\n\t\t\tif (res_geom.getType() == Geometry.Type.Polygon)\n\t\t\t\t((MultiPathImpl) res_geom._getImpl())._updateOGCFlags();\n\t\t}\n\n\t\treturn res_geom;\n\t}", "code_tokens": ["public", "static", "Geometry", "symmetricDifference", "(", "Geometry", "geometry_a", ",", "Geometry", "geometry_b", ",", "SpatialReference", "sr", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "geometry_a", ".", "getDimension", "(", ")", ">", "geometry_b", ".", "getDimension", "(", ")", ")", "return", "normalizeResult_", "(", "normalizeInputGeometry_", "(", "geometry_a", ")", ",", "geometry_a", ",", "geometry_b", ",", "'", "'", ")", ";", "if", "(", "geometry_a", ".", "getDimension", "(", ")", "<", "geometry_b", ".", "getDimension", "(", ")", ")", "return", "normalizeResult_", "(", "normalizeInputGeometry_", "(", "geometry_b", ")", ",", "geometry_a", ",", "geometry_b", ",", "'", "'", ")", ";", "if", "(", "geometry_a", ".", "isEmpty", "(", ")", ")", "return", "normalizeResult_", "(", "normalizeInputGeometry_", "(", "geometry_b", ")", ",", "geometry_a", ",", "geometry_b", ",", "'", "'", ")", ";", "if", "(", "geometry_b", ".", "isEmpty", "(", ")", ")", "return", "normalizeResult_", "(", "normalizeInputGeometry_", "(", "geometry_a", ")", ",", "geometry_a", ",", "geometry_b", ",", "'", "'", ")", ";", "Envelope2D", "env2D_1", "=", "new", "Envelope2D", "(", ")", ";", "geometry_a", ".", "queryEnvelope2D", "(", "env2D_1", ")", ";", "Envelope2D", "env2D_2", "=", "new", "Envelope2D", "(", ")", ";", "geometry_b", ".", "queryEnvelope2D", "(", "env2D_2", ")", ";", "// TODO: add optimization here to merge two geometries if the envelopes", "// do not overlap.", "Envelope2D", "envMerged", "=", "new", "Envelope2D", "(", ")", ";", "envMerged", ".", "setCoords", "(", "env2D_1", ")", ";", "envMerged", ".", "merge", "(", "env2D_2", ")", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "sr", ",", "envMerged", ",", "true", ")", ";", "// conservative to have same effect as simplify", "TopologicalOperations", "topoOps", "=", "new", "TopologicalOperations", "(", ")", ";", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "normalizeInputGeometry_", "(", "geometry_a", ")", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "normalizeInputGeometry_", "(", "geometry_b", ")", ")", ";", "topoOps", ".", "setEditShapeCrackAndCluster", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "int", "result", "=", "topoOps", ".", "symmetricDifference", "(", "geom_a", ",", "geom_b", ")", ";", "Geometry", "res_geom", "=", "normalizeResult_", "(", "edit_shape", ".", "getGeometry", "(", "result", ")", ",", "geometry_a", ",", "geometry_b", ",", "'", "'", ")", ";", "if", "(", "Geometry", ".", "isMultiPath", "(", "res_geom", ".", "getType", "(", ")", ".", "value", "(", ")", ")", ")", "{", "(", "(", "MultiVertexGeometryImpl", ")", "res_geom", ".", "_getImpl", "(", ")", ")", ".", "setIsSimple", "(", "GeometryXSimple", ".", "Strong", ",", "tolerance", ",", "false", ")", ";", "if", "(", "res_geom", ".", "getType", "(", ")", "==", "Geometry", ".", "Type", ".", "Polygon", ")", "(", "(", "MultiPathImpl", ")", "res_geom", ".", "_getImpl", "(", ")", ")", ".", "_updateOGCFlags", "(", ")", ";", "}", "return", "res_geom", ";", "}"], "docstring": "static", "docstring_tokens": ["static"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopologicalOperations.java#L1892-L1944", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/JsonParserReader.java", "func_name": "JsonParserReader.createFromStringNNT", "original_string": "public static JsonReader createFromStringNNT(String str) {\n\t\ttry {\n\t\t\tJsonFactory factory = new JsonFactory();\n\t\t\tJsonParser jsonParser = factory.createParser(str);\n\t\n\t\t\treturn new JsonParserReader(jsonParser);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonGeometryException(ex.getMessage());\n\t\t}\n\t}", "language": "java", "code": "public static JsonReader createFromStringNNT(String str) {\n\t\ttry {\n\t\t\tJsonFactory factory = new JsonFactory();\n\t\t\tJsonParser jsonParser = factory.createParser(str);\n\t\n\t\t\treturn new JsonParserReader(jsonParser);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonGeometryException(ex.getMessage());\n\t\t}\n\t}", "code_tokens": ["public", "static", "JsonReader", "createFromStringNNT", "(", "String", "str", ")", "{", "try", "{", "JsonFactory", "factory", "=", "new", "JsonFactory", "(", ")", ";", "JsonParser", "jsonParser", "=", "factory", ".", "createParser", "(", "str", ")", ";", "return", "new", "JsonParserReader", "(", "jsonParser", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "new", "JsonGeometryException", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "docstring": "Creates a JsonReader for the string.\nThe nextToken is not called by this method.", "docstring_tokens": ["Creates", "a", "JsonReader", "for", "the", "string", ".", "The", "nextToken", "is", "not", "called", "by", "this", "method", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/JsonParserReader.java#L62-L72", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Operator.java", "func_name": "Operator.deaccelerateGeometry", "original_string": "public static void deaccelerateGeometry(Geometry geometry) {\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (Geometry.isMultiVertex(gt.value()))\n\t\t{\n\t\t\tGeometryAccelerators accel = ((MultiVertexGeometryImpl) geometry\n\t\t\t\t\t._getImpl())._getAccelerators();\n\t\t\tif (accel != null){\n\t\t\t\taccel._setRasterizedGeometry(null);\n\t\t\t\taccel._setQuadTree(null);\n\t\t\t}\n\t\t}\n\t}", "language": "java", "code": "public static void deaccelerateGeometry(Geometry geometry) {\n\t\tGeometry.Type gt = geometry.getType();\n\t\tif (Geometry.isMultiVertex(gt.value()))\n\t\t{\n\t\t\tGeometryAccelerators accel = ((MultiVertexGeometryImpl) geometry\n\t\t\t\t\t._getImpl())._getAccelerators();\n\t\t\tif (accel != null){\n\t\t\t\taccel._setRasterizedGeometry(null);\n\t\t\t\taccel._setQuadTree(null);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "static", "void", "deaccelerateGeometry", "(", "Geometry", "geometry", ")", "{", "Geometry", ".", "Type", "gt", "=", "geometry", ".", "getType", "(", ")", ";", "if", "(", "Geometry", ".", "isMultiVertex", "(", "gt", ".", "value", "(", ")", ")", ")", "{", "GeometryAccelerators", "accel", "=", "(", "(", "MultiVertexGeometryImpl", ")", "geometry", ".", "_getImpl", "(", ")", ")", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "accel", ".", "_setRasterizedGeometry", "(", "null", ")", ";", "accel", ".", "_setQuadTree", "(", "null", ")", ";", "}", "}", "}"], "docstring": "Removes accelerators from given geometry.\n@param geometry The geometry instance to remove accelerators from.", "docstring_tokens": ["Removes", "accelerators", "from", "given", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Operator.java#L97-L108", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.relate", "original_string": "private static boolean relate(Envelope envelope_a, Envelope envelope_b,\n\t\t\tSpatialReference sr, int relation, ProgressTracker progress_tracker) {\n\t\tif (envelope_a.isEmpty() || envelope_b.isEmpty()) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true; // Always true\n\n\t\t\treturn false; // Always false\n\t\t}\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), env_merged = new Envelope2D();\n\t\tenvelope_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\tenv_merged.setCoords(env_a);\n\t\tenv_merged.merge(env_b);\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv_merged, false);\n\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn envelopeDisjointEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn envelopeContainsEnvelope_(env_b, env_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn envelopeContainsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn envelopeTouchesEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn envelopeOverlapsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn envelopeCrossesEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean relate(Envelope envelope_a, Envelope envelope_b,\n\t\t\tSpatialReference sr, int relation, ProgressTracker progress_tracker) {\n\t\tif (envelope_a.isEmpty() || envelope_b.isEmpty()) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true; // Always true\n\n\t\t\treturn false; // Always false\n\t\t}\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), env_merged = new Envelope2D();\n\t\tenvelope_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\tenv_merged.setCoords(env_a);\n\t\tenv_merged.merge(env_b);\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv_merged, false);\n\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn envelopeDisjointEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn envelopeContainsEnvelope_(env_b, env_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn envelopeContainsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn envelopeTouchesEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn envelopeOverlapsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn envelopeCrossesEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "relate", "(", "Envelope", "envelope_a", ",", "Envelope", "envelope_b", ",", "SpatialReference", "sr", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "envelope_a", ".", "isEmpty", "(", ")", "||", "envelope_b", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "// Always true", "return", "false", ";", "// Always false", "}", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ",", "env_merged", "=", "new", "Envelope2D", "(", ")", ";", "envelope_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_merged", ".", "setCoords", "(", "env_a", ")", ";", "env_merged", ".", "merge", "(", "env_b", ")", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "sr", ",", "env_merged", ",", "false", ")", ";", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "envelopeContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "envelopeContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "envelopeTouchesEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "overlaps", ":", "return", "envelopeOverlapsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "envelopeCrossesEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "relation.", "docstring_tokens": ["relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L331-L383", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.relate", "original_string": "private static boolean relate(Point point_a, Envelope envelope_b,\n\t\t\tSpatialReference sr, int relation, ProgressTracker progress_tracker) {\n\t\tif (point_a.isEmpty() || envelope_b.isEmpty()) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true; // Always true\n\n\t\t\treturn false; // Always false\n\t\t}\n\n\t\tPoint2D pt_a = point_a.getXY();\n\t\tEnvelope2D env_b = new Envelope2D(), env_merged = new Envelope2D();\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\tenv_merged.setCoords(pt_a);\n\t\tenv_merged.merge(env_b);\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv_merged, false);\n\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn pointDisjointEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn pointWithinEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn pointContainsEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn pointEqualsEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn pointTouchesEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean relate(Point point_a, Envelope envelope_b,\n\t\t\tSpatialReference sr, int relation, ProgressTracker progress_tracker) {\n\t\tif (point_a.isEmpty() || envelope_b.isEmpty()) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true; // Always true\n\n\t\t\treturn false; // Always false\n\t\t}\n\n\t\tPoint2D pt_a = point_a.getXY();\n\t\tEnvelope2D env_b = new Envelope2D(), env_merged = new Envelope2D();\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\tenv_merged.setCoords(pt_a);\n\t\tenv_merged.merge(env_b);\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv_merged, false);\n\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn pointDisjointEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn pointWithinEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn pointContainsEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn pointEqualsEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn pointTouchesEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "relate", "(", "Point", "point_a", ",", "Envelope", "envelope_b", ",", "SpatialReference", "sr", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "point_a", ".", "isEmpty", "(", ")", "||", "envelope_b", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "// Always true", "return", "false", ";", "// Always false", "}", "Point2D", "pt_a", "=", "point_a", ".", "getXY", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ",", "env_merged", "=", "new", "Envelope2D", "(", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_merged", ".", "setCoords", "(", "pt_a", ")", ";", "env_merged", ".", "merge", "(", "env_b", ")", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "sr", ",", "env_merged", ",", "false", ")", ";", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "pointDisjointEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "pointWithinEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "pointContainsEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "pointEqualsEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "pointTouchesEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "interior, and exterior of point_a vs envelope_b for the given relation.", "docstring_tokens": ["interior", "and", "exterior", "of", "point_a", "vs", "envelope_b", "for", "the", "given", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L387-L431", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.relate", "original_string": "private static boolean relate(Point point_a, Point point_b,\n\t\t\tSpatialReference sr, int relation, ProgressTracker progress_tracker) {\n\t\tif (point_a.isEmpty() || point_b.isEmpty()) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true; // Always true\n\n\t\t\treturn false; // Always false\n\t\t}\n\n\t\tPoint2D pt_a = point_a.getXY();\n\t\tPoint2D pt_b = point_b.getXY();\n\t\tEnvelope2D env_merged = new Envelope2D();\n\t\tenv_merged.setCoords(pt_a);\n\t\tenv_merged.merge(pt_b);\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv_merged, false);\n\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn pointDisjointPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn pointContainsPoint_(pt_b, pt_a, tolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn pointContainsPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean relate(Point point_a, Point point_b,\n\t\t\tSpatialReference sr, int relation, ProgressTracker progress_tracker) {\n\t\tif (point_a.isEmpty() || point_b.isEmpty()) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true; // Always true\n\n\t\t\treturn false; // Always false\n\t\t}\n\n\t\tPoint2D pt_a = point_a.getXY();\n\t\tPoint2D pt_b = point_b.getXY();\n\t\tEnvelope2D env_merged = new Envelope2D();\n\t\tenv_merged.setCoords(pt_a);\n\t\tenv_merged.merge(pt_b);\n\n\t\tdouble tolerance = InternalUtils.calculateToleranceFromGeometry(sr,\n\t\t\t\tenv_merged, false);\n\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn pointDisjointPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn pointContainsPoint_(pt_b, pt_a, tolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn pointContainsPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "relate", "(", "Point", "point_a", ",", "Point", "point_b", ",", "SpatialReference", "sr", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "point_a", ".", "isEmpty", "(", ")", "||", "point_b", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "// Always true", "return", "false", ";", "// Always false", "}", "Point2D", "pt_a", "=", "point_a", ".", "getXY", "(", ")", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "Envelope2D", "env_merged", "=", "new", "Envelope2D", "(", ")", ";", "env_merged", ".", "setCoords", "(", "pt_a", ")", ";", "env_merged", ".", "merge", "(", "pt_b", ")", ";", "double", "tolerance", "=", "InternalUtils", ".", "calculateToleranceFromGeometry", "(", "sr", ",", "env_merged", ",", "false", ")", ";", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "pointDisjointPoint_", "(", "pt_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "pointContainsPoint_", "(", "pt_b", ",", "pt_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "pointContainsPoint_", "(", "pt_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "pointEqualsPoint_", "(", "pt_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "interior, and exterior of point_a vs point_b for the given relation.", "docstring_tokens": ["interior", "and", "exterior", "of", "point_a", "vs", "point_b", "for", "the", "given", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L435-L471", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonRelatePolygon_", "original_string": "private static boolean polygonRelatePolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn polygonContainsPolygon_(polygon_b, polygon_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polygonEqualsPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polygonOverlapsPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polygonRelatePolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn polygonContainsPolygon_(polygon_b, polygon_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polygonEqualsPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polygonOverlapsPolygon_(polygon_a, polygon_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonRelatePolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polygonDisjointPolygon_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "polygonContainsPolygon_", "(", "polygon_b", ",", "polygon_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polygonContainsPolygon_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "polygonEqualsPolygon_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polygonTouchesPolygon_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "overlaps", ":", "return", "polygonOverlapsPolygon_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L474-L507", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonRelatePolyline_", "original_string": "private static boolean polygonRelatePolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polygonCrossesPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polygonRelatePolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polygonCrossesPolyline_(polygon_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonRelatePolyline_", "(", "Polygon", "polygon_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polygonDisjointPolyline_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polygonContainsPolyline_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polygonTouchesPolyline_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "polygonCrossesPolyline_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L510-L535", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonRelatePoint_", "original_string": "private static boolean polygonRelatePoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointPoint_(polygon_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsPoint_(polygon_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesPoint_(polygon_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polygonRelatePoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointPoint_(polygon_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsPoint_(polygon_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesPoint_(polygon_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonRelatePoint_", "(", "Polygon", "polygon_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polygonDisjointPoint_", "(", "polygon_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polygonContainsPoint_", "(", "polygon_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polygonTouchesPoint_", "(", "polygon_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L538-L559", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonRelateMultiPoint_", "original_string": "private static boolean polygonRelateMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, true, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polygonCrossesMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polygonRelateMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polygonDisjointMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, true, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polygonCrossesMultiPoint_(polygon_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonRelateMultiPoint_", "(", "Polygon", "polygon_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polygonDisjointMultiPoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "true", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polygonContainsMultiPoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polygonTouchesMultiPoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "polygonCrossesMultiPoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L562-L587", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonRelateEnvelope_", "original_string": "private static boolean polygonRelateEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (polygonDisjointEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\tprogress_tracker)) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t} else if (relation == Relation.disjoint) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (relation) {\n\t\tcase Relation.within:\n\t\t\treturn polygonWithinEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polygonEqualsEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polygonOverlapsEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polygonCrossesEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polygonRelateEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (polygonDisjointEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\tprogress_tracker)) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t} else if (relation == Relation.disjoint) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (relation) {\n\t\tcase Relation.within:\n\t\t\treturn polygonWithinEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polygonContainsEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polygonEqualsEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polygonTouchesEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polygonOverlapsEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polygonCrossesEnvelope_(polygon_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonRelateEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "polygonDisjointEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "{", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "return", "false", ";", "}", "else", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "{", "return", "false", ";", "}", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "within", ":", "return", "polygonWithinEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polygonContainsEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "polygonEqualsEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polygonTouchesEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "overlaps", ":", "return", "polygonOverlapsEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "polygonCrossesEnvelope_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L590-L633", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineRelatePolyline_", "original_string": "private static boolean polylineRelatePolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polylineDisjointPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn polylineContainsPolyline_(polyline_b, polyline_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polylineEqualsPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polylineOverlapsPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polylineRelatePolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polylineDisjointPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn polylineContainsPolyline_(polyline_b, polyline_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polylineEqualsPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polylineOverlapsPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineRelatePolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polylineDisjointPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "polylineContainsPolyline_", "(", "polyline_b", ",", "polyline_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polylineContainsPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "polylineEqualsPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polylineTouchesPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "overlaps", ":", "return", "polylineOverlapsPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "polylineCrossesPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L636-L673", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineRelatePoint_", "original_string": "private static boolean polylineRelatePoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polylineDisjointPoint_(polyline_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsPoint_(polyline_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesPoint_(polyline_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polylineRelatePoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polylineDisjointPoint_(polyline_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsPoint_(polyline_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesPoint_(polyline_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineRelatePoint_", "(", "Polyline", "polyline_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polylineDisjointPoint_", "(", "polyline_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polylineContainsPoint_", "(", "polyline_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polylineTouchesPoint_", "(", "polyline_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L676-L697", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineRelateMultiPoint_", "original_string": "private static boolean polylineRelateMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polylineDisjointMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polylineCrossesMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polylineRelateMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn polylineDisjointMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polylineCrossesMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineRelateMultiPoint_", "(", "Polyline", "polyline_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "polylineDisjointMultiPoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polylineContainsMultiPoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polylineTouchesMultiPoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "polylineCrossesMultiPoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L700-L725", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineRelateEnvelope_", "original_string": "private static boolean polylineRelateEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (polylineDisjointEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\tprogress_tracker)) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t} else if (relation == Relation.disjoint) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (relation) {\n\t\tcase Relation.within:\n\t\t\treturn polylineWithinEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polylineEqualsEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polylineOverlapsEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polylineCrossesEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polylineRelateEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (polylineDisjointEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\tprogress_tracker)) {\n\t\t\tif (relation == Relation.disjoint)\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t} else if (relation == Relation.disjoint) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (relation) {\n\t\tcase Relation.within:\n\t\t\treturn polylineWithinEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn polylineContainsEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn polylineEqualsEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn polylineTouchesEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn polylineOverlapsEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn polylineCrossesEnvelope_(polyline_a, envelope_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineRelateEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "polylineDisjointEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "{", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "return", "false", ";", "}", "else", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "{", "return", "false", ";", "}", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "within", ":", "return", "polylineWithinEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "polylineContainsEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "polylineEqualsEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "polylineTouchesEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "overlaps", ":", "return", "polylineOverlapsEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "polylineCrossesEnvelope_", "(", "polyline_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L728-L771", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointRelateMultiPoint_", "original_string": "private static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn multiPointDisjointMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn multiPointContainsMultiPoint_(multipoint_b, multipoint_a,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn multiPointContainsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn multiPointEqualsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn multiPointOverlapsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn multiPointDisjointMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn multiPointContainsMultiPoint_(multipoint_b, multipoint_a,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn multiPointContainsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn multiPointEqualsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.overlaps:\n\t\t\treturn multiPointOverlapsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointRelateMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "multiPointDisjointMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "multiPointContainsMultiPoint_", "(", "multipoint_b", ",", "multipoint_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "multiPointContainsMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "multiPointEqualsMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "overlaps", ":", "return", "multiPointOverlapsMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L774-L803", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointRelatePoint_", "original_string": "private static boolean multiPointRelatePoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn multiPointDisjointPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn multiPointWithinPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn multiPointContainsPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn multiPointEqualsPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean multiPointRelatePoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn multiPointDisjointPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn multiPointWithinPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn multiPointContainsPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn multiPointEqualsPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointRelatePoint_", "(", "MultiPoint", "multipoint_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "multiPointDisjointPoint_", "(", "multipoint_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "multiPointWithinPoint_", "(", "multipoint_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "multiPointContainsPoint_", "(", "multipoint_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "multiPointEqualsPoint_", "(", "multipoint_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L806-L831", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointRelateEnvelope_", "original_string": "private static boolean multiPointRelateEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn multiPointDisjointEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn multiPointWithinEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn multiPointContainsEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn multiPointEqualsEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn multiPointTouchesEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn multiPointCrossesEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean multiPointRelateEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance, int relation,\n\t\t\tProgressTracker progress_tracker) {\n\t\tswitch (relation) {\n\t\tcase Relation.disjoint:\n\t\t\treturn multiPointDisjointEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.within:\n\t\t\treturn multiPointWithinEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.contains:\n\t\t\treturn multiPointContainsEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.equals:\n\t\t\treturn multiPointEqualsEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.touches:\n\t\t\treturn multiPointTouchesEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tcase Relation.crosses:\n\t\t\treturn multiPointCrossesEnvelope_(multipoint_a, envelope_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\n\t\tdefault:\n\t\t\tbreak; // warning fix\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointRelateEnvelope_", "(", "MultiPoint", "multipoint_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "int", "relation", ",", "ProgressTracker", "progress_tracker", ")", "{", "switch", "(", "relation", ")", "{", "case", "Relation", ".", "disjoint", ":", "return", "multiPointDisjointEnvelope_", "(", "multipoint_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "within", ":", "return", "multiPointWithinEnvelope_", "(", "multipoint_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "contains", ":", "return", "multiPointContainsEnvelope_", "(", "multipoint_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "equals", ":", "return", "multiPointEqualsEnvelope_", "(", "multipoint_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "touches", ":", "return", "multiPointTouchesEnvelope_", "(", "multipoint_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "case", "Relation", ".", "crosses", ":", "return", "multiPointCrossesEnvelope_", "(", "multipoint_a", ",", "envelope_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "default", ":", "break", ";", "// warning fix", "}", "return", "false", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L834-L867", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonEqualsPolygon_", "original_string": "private static boolean polygonEqualsPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolygon_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\t// Quick point equality check for true equality. This just checks if all\n\t\t// the points in each ring are the same (within a tolerance) and in the\n\t\t// same order\n\t\tif (multiPathExactlyEqualsMultiPath_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker))\n\t\t\treturn true;\n\n\t\tdouble length_a = polygon_a.calculateLength2D();\n\t\tdouble length_b = polygon_b.calculateLength2D();\n\t\tint max_vertices = Math.max(polygon_a.getPointCount(),\n\t\t\t\tpolygon_b.getPointCount());\n\n\t\tif (Math.abs(length_a - length_b) > max_vertices * 4.0 * tolerance)\n\t\t\treturn false;\n\n\t\treturn linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);\n\t}", "language": "java", "code": "private static boolean polygonEqualsPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolygon_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\t// Quick point equality check for true equality. This just checks if all\n\t\t// the points in each ring are the same (within a tolerance) and in the\n\t\t// same order\n\t\tif (multiPathExactlyEqualsMultiPath_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker))\n\t\t\treturn true;\n\n\t\tdouble length_a = polygon_a.calculateLength2D();\n\t\tdouble length_b = polygon_b.calculateLength2D();\n\t\tint max_vertices = Math.max(polygon_a.getPointCount(),\n\t\t\t\tpolygon_b.getPointCount());\n\n\t\tif (Math.abs(length_a - length_b) > max_vertices * 4.0 * tolerance)\n\t\t\treturn false;\n\n\t\treturn linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonEqualsPolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polygon_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "if", "(", "!", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "// Quick point equality check for true equality. This just checks if all", "// the points in each ring are the same (within a tolerance) and in the", "// same order", "if", "(", "multiPathExactlyEqualsMultiPath_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "true", ";", "double", "length_a", "=", "polygon_a", ".", "calculateLength2D", "(", ")", ";", "double", "length_b", "=", "polygon_b", ".", "calculateLength2D", "(", ")", ";", "int", "max_vertices", "=", "Math", ".", "max", "(", "polygon_a", ".", "getPointCount", "(", ")", ",", "polygon_b", ".", "getPointCount", "(", ")", ")", ";", "if", "(", "Math", ".", "abs", "(", "length_a", "-", "length_b", ")", ">", "max_vertices", "*", "4.0", "*", "tolerance", ")", "return", "false", ";", "return", "linearPathEqualsLinearPath_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "true", ")", ";", "}"], "docstring": "Returns true if polygon_a equals polygon_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "equals", "polygon_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L870-L906", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonDisjointPolygon_", "original_string": "private static boolean polygonDisjointPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, true);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains || relation == Relation.within\n\t\t\t\t|| relation == Relation.intersects)\n\t\t\treturn false;\n\n\t\treturn polygonDisjointMultiPath_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonDisjointPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, true);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains || relation == Relation.within\n\t\t\t\t|| relation == Relation.intersects)\n\t\t\treturn false;\n\n\t\treturn polygonDisjointMultiPath_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonDisjointPolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "true", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "if", "(", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", "||", "relation", "==", "Relation", ".", "intersects", ")", "return", "false", ";", "return", "polygonDisjointMultiPath_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a is disjoint from polygon_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "disjoint", "from", "polygon_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L909-L926", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonTouchesPolygon_", "original_string": "private static boolean polygonTouchesPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\treturn polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance, null);\n\t}", "language": "java", "code": "private static boolean polygonTouchesPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\treturn polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance, null);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonTouchesPolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "return", "polygonTouchesPolygonImpl_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "null", ")", ";", "}"], "docstring": "Returns true if polygon_a touches polygon_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "touches", "polygon_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L929-L942", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonOverlapsPolygon_", "original_string": "private static boolean polygonOverlapsPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\treturn polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonOverlapsPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\treturn polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonOverlapsPolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "return", "polygonOverlapsPolygonImpl_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a overlaps polygon_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "overlaps", "polygon_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L945-L959", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonContainsPolygon_", "original_string": "private static boolean polygonContainsPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolygon_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.within)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n\t\treturn polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonContainsPolygon_(Polygon polygon_a,\n\t\t\tPolygon polygon_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolygon_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.within)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n\t\treturn polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonContainsPolygon_", "(", "Polygon", "polygon_a", ",", "Polygon", "polygon_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polygon_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "if", "(", "relation", "==", "Relation", ".", "contains", ")", "return", "true", ";", "return", "polygonContainsPolygonImpl_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a contains polygon_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "contains", "polygon_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L962-L986", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonDisjointPolyline_", "original_string": "private static boolean polygonDisjointPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, true);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains || relation == Relation.intersects)\n\t\t\treturn false;\n\n\t\treturn polygonDisjointMultiPath_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonDisjointPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, true);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains || relation == Relation.intersects)\n\t\t\treturn false;\n\n\t\treturn polygonDisjointMultiPath_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonDisjointPolyline_", "(", "Polygon", "polygon_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "true", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "if", "(", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "intersects", ")", "return", "false", ";", "return", "polygonDisjointMultiPath_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a is disjoint from polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "disjoint", "from", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L989-L1005", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonTouchesPolyline_", "original_string": "private static boolean polygonTouchesPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains)\n\t\t\treturn false;\n\n\t\treturn polygonTouchesPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonTouchesPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains)\n\t\t\treturn false;\n\n\t\treturn polygonTouchesPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonTouchesPolyline_", "(", "Polygon", "polygon_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", ")", "return", "false", ";", "return", "polygonTouchesPolylineImpl_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a touches polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "touches", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1008-L1021", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonCrossesPolyline_", "original_string": "private static boolean polygonCrossesPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains)\n\t\t\treturn false;\n\n\t\treturn polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tnull);\n\t}", "language": "java", "code": "private static boolean polygonCrossesPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains)\n\t\t\treturn false;\n\n\t\treturn polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tnull);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonCrossesPolyline_", "(", "Polygon", "polygon_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", ")", "return", "false", ";", "return", "polygonCrossesPolylineImpl_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "null", ")", ";", "}"], "docstring": "Returns true if polygon_a crosses polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "crosses", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1024-L1037", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonContainsPolyline_", "original_string": "private static boolean polygonContainsPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n\t\treturn polygonContainsPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonContainsPolyline_(Polygon polygon_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n\t\treturn polygonContainsPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonContainsPolyline_", "(", "Polygon", "polygon_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polyline_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "if", "(", "relation", "==", "Relation", ".", "contains", ")", "return", "true", ";", "return", "polygonContainsPolylineImpl_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a contains polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "contains", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1040-L1064", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonDisjointPoint_", "original_string": "private static boolean polygonDisjointPoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(\n\t\t\t\tpolygon_a, point_b, tolerance);\n\n\t\tif (result == PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polygonDisjointPoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(\n\t\t\t\tpolygon_a, point_b, tolerance);\n\n\t\tif (result == PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonDisjointPoint_", "(", "Polygon", "polygon_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "point_b", ",", "tolerance", ")", ";", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Returns true if polygon_a is disjoint from point_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "disjoint", "from", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1067-L1076", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonTouchesPoint_", "original_string": "private static boolean polygonTouchesPoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn polygonTouchesPointImpl_(polygon_a, pt_b, tolerance, null);\n\t}", "language": "java", "code": "private static boolean polygonTouchesPoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn polygonTouchesPointImpl_(polygon_a, pt_b, tolerance, null);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonTouchesPoint_", "(", "Polygon", "polygon_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "return", "polygonTouchesPointImpl_", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ",", "null", ")", ";", "}"], "docstring": "Returns true of polygon_a touches point_b.", "docstring_tokens": ["Returns", "true", "of", "polygon_a", "touches", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1079-L1083", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonContainsPoint_", "original_string": "private static boolean polygonContainsPoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn polygonContainsPointImpl_(polygon_a, pt_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonContainsPoint_(Polygon polygon_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn polygonContainsPointImpl_(polygon_a, pt_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonContainsPoint_", "(", "Polygon", "polygon_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "return", "polygonContainsPointImpl_", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a contains point_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "contains", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1086-L1091", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonDisjointMultiPoint_", "original_string": "private static boolean polygonDisjointMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tboolean bIncludeBoundaryA, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a,\n\t\t\t\tmultipoint_b, tolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a_inflated = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a_inflated);\n\t\tenv_a_inflated.inflate(tolerance, tolerance);\n\t\tPoint2D ptB = new Point2D();\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (!env_a_inflated.contains(ptB))\n\t\t\t\tcontinue;\n\n\t\t\tPolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(\n\t\t\t\t\tpolygon_a, ptB, tolerance);\n\n\t\t\tif (result == PolygonUtils.PiPResult.PiPInside\n\t\t\t\t\t|| (bIncludeBoundaryA && result == PolygonUtils.PiPResult.PiPBoundary))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean polygonDisjointMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tboolean bIncludeBoundaryA, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a,\n\t\t\t\tmultipoint_b, tolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a_inflated = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a_inflated);\n\t\tenv_a_inflated.inflate(tolerance, tolerance);\n\t\tPoint2D ptB = new Point2D();\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (!env_a_inflated.contains(ptB))\n\t\t\t\tcontinue;\n\n\t\t\tPolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(\n\t\t\t\t\tpolygon_a, ptB, tolerance);\n\n\t\t\tif (result == PolygonUtils.PiPResult.PiPInside\n\t\t\t\t\t|| (bIncludeBoundaryA && result == PolygonUtils.PiPResult.PiPBoundary))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonDisjointMultiPoint_", "(", "Polygon", "polygon_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "boolean", "bIncludeBoundaryA", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "if", "(", "relation", "==", "Relation", ".", "contains", ")", "return", "false", ";", "Envelope2D", "env_a_inflated", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a_inflated", ")", ";", "env_a_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "Point2D", "ptB", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_b", ".", "getXY", "(", "i", ",", "ptB", ")", ";", "if", "(", "!", "env_a_inflated", ".", "contains", "(", "ptB", ")", ")", "continue", ";", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "ptB", ",", "tolerance", ")", ";", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPInside", "||", "(", "bIncludeBoundaryA", "&&", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPBoundary", ")", ")", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Returns true if polygon_a is disjoint from multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "disjoint", "from", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1094-L1128", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonTouchesMultiPoint_", "original_string": "private static boolean polygonTouchesMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a,\n\t\t\t\tmultipoint_b, tolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains)\n\t\t\treturn false;\n\n        Envelope2D env_a_inflated = new Envelope2D();\n        polygon_a.queryEnvelope2D(env_a_inflated);\n        env_a_inflated.inflate(tolerance, tolerance);\n\n        Point2D ptB;\n        boolean b_boundary = false;\n\n        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();\n\n        Polygon pa = null;\n        Polygon p_polygon_a = polygon_a;\n\n        boolean b_checked_polygon_a_quad_tree = false;\n\n        for (int i = 0; i < multipoint_b.getPointCount(); i++)\n        {\n            ptB = multipoint_b.getXY(i);\n\n            if (env_a_inflated.contains(ptB)) {\n\n                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);\n\n                if (result == PolygonUtils.PiPResult.PiPBoundary)\n                    b_boundary = true;\n                else if (result == PolygonUtils.PiPResult.PiPInside)\n                    return false;\n            }\n\n            if (!b_checked_polygon_a_quad_tree) {\n                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) && (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {\n                    pa = new Polygon();\n                    polygon_a.copyTo(pa);\n                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                    p_polygon_a = pa;\n                } else {\n                    p_polygon_a = polygon_a;\n                }\n\n                b_checked_polygon_a_quad_tree = true;\n            }\n        }\n\n        if (b_boundary)\n            return true;\n\n        return false;\n\t}", "language": "java", "code": "private static boolean polygonTouchesMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a,\n\t\t\t\tmultipoint_b, tolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains)\n\t\t\treturn false;\n\n        Envelope2D env_a_inflated = new Envelope2D();\n        polygon_a.queryEnvelope2D(env_a_inflated);\n        env_a_inflated.inflate(tolerance, tolerance);\n\n        Point2D ptB;\n        boolean b_boundary = false;\n\n        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();\n\n        Polygon pa = null;\n        Polygon p_polygon_a = polygon_a;\n\n        boolean b_checked_polygon_a_quad_tree = false;\n\n        for (int i = 0; i < multipoint_b.getPointCount(); i++)\n        {\n            ptB = multipoint_b.getXY(i);\n\n            if (env_a_inflated.contains(ptB)) {\n\n                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);\n\n                if (result == PolygonUtils.PiPResult.PiPBoundary)\n                    b_boundary = true;\n                else if (result == PolygonUtils.PiPResult.PiPInside)\n                    return false;\n            }\n\n            if (!b_checked_polygon_a_quad_tree) {\n                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) && (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {\n                    pa = new Polygon();\n                    polygon_a.copyTo(pa);\n                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                    p_polygon_a = pa;\n                } else {\n                    p_polygon_a = polygon_a;\n                }\n\n                b_checked_polygon_a_quad_tree = true;\n            }\n        }\n\n        if (b_boundary)\n            return true;\n\n        return false;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonTouchesMultiPoint_", "(", "Polygon", "polygon_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", ")", "return", "false", ";", "Envelope2D", "env_a_inflated", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a_inflated", ")", ";", "env_a_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "Point2D", "ptB", ";", "boolean", "b_boundary", "=", "false", ";", "MultiPathImpl", "polygon_a_impl", "=", "(", "MultiPathImpl", ")", "polygon_a", ".", "_getImpl", "(", ")", ";", "Polygon", "pa", "=", "null", ";", "Polygon", "p_polygon_a", "=", "polygon_a", ";", "boolean", "b_checked_polygon_a_quad_tree", "=", "false", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "ptB", "=", "multipoint_b", ".", "getXY", "(", "i", ")", ";", "if", "(", "env_a_inflated", ".", "contains", "(", "ptB", ")", ")", "{", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "p_polygon_a", ",", "ptB", ",", "tolerance", ")", ";", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPBoundary", ")", "b_boundary", "=", "true", ";", "else", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPInside", ")", "return", "false", ";", "}", "if", "(", "!", "b_checked_polygon_a_quad_tree", ")", "{", "if", "(", "PointInPolygonHelper", ".", "quadTreeWillHelp", "(", "polygon_a", ",", "multipoint_b", ".", "getPointCount", "(", ")", "-", "1", ")", "&&", "(", "polygon_a_impl", ".", "_getAccelerators", "(", ")", "==", "null", "||", "polygon_a_impl", ".", "_getAccelerators", "(", ")", ".", "getQuadTree", "(", ")", "==", "null", ")", ")", "{", "pa", "=", "new", "Polygon", "(", ")", ";", "polygon_a", ".", "copyTo", "(", "pa", ")", ";", "(", "(", "MultiPathImpl", ")", "pa", ".", "_getImpl", "(", ")", ")", ".", "_buildQuadTreeAccelerator", "(", "Geometry", ".", "GeometryAccelerationDegree", ".", "enumMedium", ")", ";", "p_polygon_a", "=", "pa", ";", "}", "else", "{", "p_polygon_a", "=", "polygon_a", ";", "}", "b_checked_polygon_a_quad_tree", "=", "true", ";", "}", "}", "if", "(", "b_boundary", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Returns true if polygon_a touches multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "touches", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1131-L1188", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonContainsMultiPoint_", "original_string": "private static boolean polygonContainsMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a,\n\t\t\t\tmultipoint_b, tolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n        boolean b_interior = false;\n        Point2D ptB;\n\n        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();\n\n        Polygon pa = null;\n        Polygon p_polygon_a = polygon_a;\n\n        boolean b_checked_polygon_a_quad_tree = false;\n\n        for (int i = 0; i < multipoint_b.getPointCount(); i++)\n        {\n            ptB = multipoint_b.getXY(i);\n\n            if (!env_a.contains(ptB))\n                return false;\n\n            PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);\n\n            if (result == PolygonUtils.PiPResult.PiPInside)\n                b_interior = true;\n            else if (result == PolygonUtils.PiPResult.PiPOutside)\n                return false;\n\n            if (!b_checked_polygon_a_quad_tree) {\n                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) && (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {\n                    pa = new Polygon();\n                    polygon_a.copyTo(pa);\n                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                    p_polygon_a = pa;\n                } else {\n                    p_polygon_a = polygon_a;\n                }\n\n                b_checked_polygon_a_quad_tree = true;\n            }\n        }\n\n        return b_interior;\n\t}", "language": "java", "code": "private static boolean polygonContainsMultiPoint_(Polygon polygon_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a,\n\t\t\t\tmultipoint_b, tolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n        boolean b_interior = false;\n        Point2D ptB;\n\n        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();\n\n        Polygon pa = null;\n        Polygon p_polygon_a = polygon_a;\n\n        boolean b_checked_polygon_a_quad_tree = false;\n\n        for (int i = 0; i < multipoint_b.getPointCount(); i++)\n        {\n            ptB = multipoint_b.getXY(i);\n\n            if (!env_a.contains(ptB))\n                return false;\n\n            PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);\n\n            if (result == PolygonUtils.PiPResult.PiPInside)\n                b_interior = true;\n            else if (result == PolygonUtils.PiPResult.PiPOutside)\n                return false;\n\n            if (!b_checked_polygon_a_quad_tree) {\n                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) && (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {\n                    pa = new Polygon();\n                    polygon_a.copyTo(pa);\n                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                    p_polygon_a = pa;\n                } else {\n                    p_polygon_a = polygon_a;\n                }\n\n                b_checked_polygon_a_quad_tree = true;\n            }\n        }\n\n        return b_interior;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonContainsMultiPoint_", "(", "Polygon", "polygon_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "if", "(", "relation", "==", "Relation", ".", "contains", ")", "return", "true", ";", "boolean", "b_interior", "=", "false", ";", "Point2D", "ptB", ";", "MultiPathImpl", "polygon_a_impl", "=", "(", "MultiPathImpl", ")", "polygon_a", ".", "_getImpl", "(", ")", ";", "Polygon", "pa", "=", "null", ";", "Polygon", "p_polygon_a", "=", "polygon_a", ";", "boolean", "b_checked_polygon_a_quad_tree", "=", "false", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "ptB", "=", "multipoint_b", ".", "getXY", "(", "i", ")", ";", "if", "(", "!", "env_a", ".", "contains", "(", "ptB", ")", ")", "return", "false", ";", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "p_polygon_a", ",", "ptB", ",", "tolerance", ")", ";", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPInside", ")", "b_interior", "=", "true", ";", "else", "if", "(", "result", "==", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "if", "(", "!", "b_checked_polygon_a_quad_tree", ")", "{", "if", "(", "PointInPolygonHelper", ".", "quadTreeWillHelp", "(", "polygon_a", ",", "multipoint_b", ".", "getPointCount", "(", ")", "-", "1", ")", "&&", "(", "polygon_a_impl", ".", "_getAccelerators", "(", ")", "==", "null", "||", "polygon_a_impl", ".", "_getAccelerators", "(", ")", ".", "getQuadTree", "(", ")", "==", "null", ")", ")", "{", "pa", "=", "new", "Polygon", "(", ")", ";", "polygon_a", ".", "copyTo", "(", "pa", ")", ";", "(", "(", "MultiPathImpl", ")", "pa", ".", "_getImpl", "(", ")", ")", ".", "_buildQuadTreeAccelerator", "(", "Geometry", ".", "GeometryAccelerationDegree", ".", "enumMedium", ")", ";", "p_polygon_a", "=", "pa", ";", "}", "else", "{", "p_polygon_a", "=", "polygon_a", ";", "}", "b_checked_polygon_a_quad_tree", "=", "true", ";", "}", "}", "return", "b_interior", ";", "}"], "docstring": "Returns true if polygon_a contains multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "contains", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1258-L1319", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonEqualsEnvelope_", "original_string": "private static boolean polygonEqualsEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\t// This check will correctly handle degenerate envelope cases (i.e.\n\t\t// degenerate to point or line)\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\n\t\treturn linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);\n\t}", "language": "java", "code": "private static boolean polygonEqualsEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\t// This check will correctly handle degenerate envelope cases (i.e.\n\t\t// degenerate to point or line)\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\n\t\treturn linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonEqualsEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "// This check will correctly handle degenerate envelope cases (i.e.", "// degenerate to point or line)", "if", "(", "!", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "false", ";", "Polygon", "polygon_b", "=", "new", "Polygon", "(", ")", ";", "polygon_b", ".", "addEnvelope", "(", "envelope_b", ",", "false", ")", ";", "return", "linearPathEqualsLinearPath_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "true", ")", ";", "}"], "docstring": "Returns true if polygon_a equals envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "equals", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1322-L1339", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonDisjointEnvelope_", "original_string": "private static boolean polygonDisjointEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains || relation == Relation.within)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tPolygonUtils.PiPResult pipres;\n\t\tPoint2D pt_b = new Point2D();\n\t\tenv_b.queryLowerLeft(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tenv_b.queryLowerRight(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tenv_b.queryUpperRight(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tenv_b.queryUpperLeft(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tMultiPathImpl mimpl_a = (MultiPathImpl) polygon_a._getImpl();\n\t\tAttributeStreamOfDbl pos = (AttributeStreamOfDbl) (mimpl_a\n\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\tfor (int ptIndex = 0, n = mimpl_a.getPointCount(); ptIndex < n; ptIndex++) {\n\t\t\tdouble x = pos.read(2 * ptIndex);\n\t\t\tdouble y = pos.read(2 * ptIndex + 1);\n\t\t\tif (env_b_inflated.contains(x, y))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn !linearPathIntersectsEnvelope_(polygon_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonDisjointEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tif (relation == Relation.contains || relation == Relation.within)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tPolygonUtils.PiPResult pipres;\n\t\tPoint2D pt_b = new Point2D();\n\t\tenv_b.queryLowerLeft(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tenv_b.queryLowerRight(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tenv_b.queryUpperRight(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tenv_b.queryUpperLeft(pt_b);\n\t\tpipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);\n\t\tif (pipres != PolygonUtils.PiPResult.PiPOutside)\n\t\t\treturn false;\n\n\t\tMultiPathImpl mimpl_a = (MultiPathImpl) polygon_a._getImpl();\n\t\tAttributeStreamOfDbl pos = (AttributeStreamOfDbl) (mimpl_a\n\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\tfor (int ptIndex = 0, n = mimpl_a.getPointCount(); ptIndex < n; ptIndex++) {\n\t\t\tdouble x = pos.read(2 * ptIndex);\n\t\t\tdouble y = pos.read(2 * ptIndex + 1);\n\t\t\tif (env_b_inflated.contains(x, y))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn !linearPathIntersectsEnvelope_(polygon_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonDisjointEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "if", "(", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "PolygonUtils", ".", "PiPResult", "pipres", ";", "Point2D", "pt_b", "=", "new", "Point2D", "(", ")", ";", "env_b", ".", "queryLowerLeft", "(", "pt_b", ")", ";", "pipres", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ")", ";", "if", "(", "pipres", "!=", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "env_b", ".", "queryLowerRight", "(", "pt_b", ")", ";", "pipres", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ")", ";", "if", "(", "pipres", "!=", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "env_b", ".", "queryUpperRight", "(", "pt_b", ")", ";", "pipres", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ")", ";", "if", "(", "pipres", "!=", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "env_b", ".", "queryUpperLeft", "(", "pt_b", ")", ";", "pipres", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ")", ";", "if", "(", "pipres", "!=", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "MultiPathImpl", "mimpl_a", "=", "(", "MultiPathImpl", ")", "polygon_a", ".", "_getImpl", "(", ")", ";", "AttributeStreamOfDbl", "pos", "=", "(", "AttributeStreamOfDbl", ")", "(", "mimpl_a", ".", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ")", ";", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "for", "(", "int", "ptIndex", "=", "0", ",", "n", "=", "mimpl_a", ".", "getPointCount", "(", ")", ";", "ptIndex", "<", "n", ";", "ptIndex", "++", ")", "{", "double", "x", "=", "pos", ".", "read", "(", "2", "*", "ptIndex", ")", ";", "double", "y", "=", "pos", ".", "read", "(", "2", "*", "ptIndex", "+", "1", ")", ";", "if", "(", "env_b_inflated", ".", "contains", "(", "x", ",", "y", ")", ")", "return", "false", ";", "}", "return", "!", "linearPathIntersectsEnvelope_", "(", "polygon_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a is disjoint from envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "disjoint", "from", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1342-L1401", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonTouchesEnvelope_", "original_string": "private static boolean polygonTouchesEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getWidth() <= tolerance && env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn polygonTouchesPointImpl_(polygon_a, pt_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getWidth() <= tolerance || env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polygonTouchesPolylineImpl_(polygon_a, polyline_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\t\t}\n\n\t\t// treat as polygon\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\t\treturn polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonTouchesEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getWidth() <= tolerance && env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn polygonTouchesPointImpl_(polygon_a, pt_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getWidth() <= tolerance || env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polygonTouchesPolylineImpl_(polygon_a, polyline_b,\n\t\t\t\t\ttolerance, progress_tracker);\n\t\t}\n\n\t\t// treat as polygon\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\t\treturn polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonTouchesEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// point", "Point2D", "pt_b", "=", "envelope_b", ".", "getCenterXY", "(", ")", ";", "return", "polygonTouchesPointImpl_", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "if", "(", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "polygonTouchesPolylineImpl_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "// treat as polygon", "Polygon", "polygon_b", "=", "new", "Polygon", "(", ")", ";", "polygon_b", ".", "addEnvelope", "(", "envelope_b", ",", "false", ")", ";", "return", "polygonTouchesPolygonImpl_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a touches envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "touches", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1404-L1449", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonOverlapsEnvelope_", "original_string": "private static boolean polygonOverlapsEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getWidth() <= tolerance || env_b.getHeight() <= tolerance)\n\t\t\treturn false; // has no interior\n\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\t\treturn polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonOverlapsEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.contains\n\t\t\t\t|| relation == Relation.within)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getWidth() <= tolerance || env_b.getHeight() <= tolerance)\n\t\t\treturn false; // has no interior\n\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\t\treturn polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonOverlapsEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "contains", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// has no interior", "Polygon", "polygon_b", "=", "new", "Polygon", "(", ")", ";", "polygon_b", ".", "addEnvelope", "(", "envelope_b", ",", "false", ")", ";", "return", "polygonOverlapsPolygonImpl_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a overlaps envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "overlaps", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1452-L1478", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonWithinEnvelope_", "original_string": "private static boolean polygonWithinEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\treturn envelopeInfContainsEnvelope_(env_b, env_a, tolerance);\n\t}", "language": "java", "code": "private static boolean polygonWithinEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\treturn envelopeInfContainsEnvelope_(env_b, env_a, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonWithinEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "return", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polygon_a is within envelope_b", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "within", "envelope_b"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1481-L1488", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonContainsEnvelope_", "original_string": "private static boolean polygonContainsEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick envelope rejection test\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.within)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n\t\tif (env_b.getWidth() <= tolerance && env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn polygonContainsPointImpl_(polygon_a, pt_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getWidth() <= tolerance || env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polygonContainsPolylineImpl_(polygon_a, polyline_b,\n\t\t\t\t\ttolerance, null);\n\t\t}\n\n\t\t// treat as polygon\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\t\treturn polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tnull);\n\t}", "language": "java", "code": "private static boolean polygonContainsEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick envelope rejection test\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint,\n\t\t// or if one is contained in the other.\n\t\tint relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,\n\t\t\t\ttolerance, false);\n\n\t\tif (relation == Relation.disjoint || relation == Relation.within)\n\t\t\treturn false;\n\n\t\tif (relation == Relation.contains)\n\t\t\treturn true;\n\n\t\tif (env_b.getWidth() <= tolerance && env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn polygonContainsPointImpl_(polygon_a, pt_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getWidth() <= tolerance || env_b.getHeight() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polygonContainsPolylineImpl_(polygon_a, polyline_b,\n\t\t\t\t\ttolerance, null);\n\t\t}\n\n\t\t// treat as polygon\n\t\tPolygon polygon_b = new Polygon();\n\t\tpolygon_b.addEnvelope(envelope_b, false);\n\t\treturn polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,\n\t\t\t\tnull);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonContainsEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick envelope rejection test", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint,", "// or if one is contained in the other.", "int", "relation", "=", "tryRasterizedContainsOrDisjoint_", "(", "polygon_a", ",", "envelope_b", ",", "tolerance", ",", "false", ")", ";", "if", "(", "relation", "==", "Relation", ".", "disjoint", "||", "relation", "==", "Relation", ".", "within", ")", "return", "false", ";", "if", "(", "relation", "==", "Relation", ".", "contains", ")", "return", "true", ";", "if", "(", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// point", "Point2D", "pt_b", "=", "envelope_b", ".", "getCenterXY", "(", ")", ";", "return", "polygonContainsPointImpl_", "(", "polygon_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "if", "(", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "polygonContainsPolylineImpl_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "null", ")", ";", "}", "// treat as polygon", "Polygon", "polygon_b", "=", "new", "Polygon", "(", ")", ";", "polygon_b", ".", "addEnvelope", "(", "envelope_b", ",", "false", ")", ";", "return", "polygonContainsPolygonImpl_", "(", "polygon_a", ",", "polygon_b", ",", "tolerance", ",", "null", ")", ";", "}"], "docstring": "Returns true if polygon_a contains envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "contains", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1491-L1540", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonCrossesEnvelope_", "original_string": "private static boolean polygonCrossesEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // when treated as an area, areas cannot cross areas.\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // when treated as a point, areas cannot cross points.\n\n\t\t// Treat as polyline\n\t\tPolyline polyline_b = new Polyline();\n\t\tPoint p = new Point();\n\t\tenvelope_b.queryCornerByVal(0, p);\n\t\tpolyline_b.startPath(p);\n\t\tenvelope_b.queryCornerByVal(2, p);\n\t\tpolyline_b.lineTo(p);\n\t\treturn polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polygonCrossesEnvelope_(Polygon polygon_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolygon_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // when treated as an area, areas cannot cross areas.\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // when treated as a point, areas cannot cross points.\n\n\t\t// Treat as polyline\n\t\tPolyline polyline_b = new Polyline();\n\t\tPoint p = new Point();\n\t\tenvelope_b.queryCornerByVal(0, p);\n\t\tpolyline_b.startPath(p);\n\t\tenvelope_b.queryCornerByVal(2, p);\n\t\tpolyline_b.lineTo(p);\n\t\treturn polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polygonCrossesEnvelope_", "(", "Polygon", "polygon_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polygon_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "// when treated as an area, areas cannot cross areas.", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// when treated as a point, areas cannot cross points.", "// Treat as polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "polygonCrossesPolylineImpl_", "(", "polygon_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polygon_a crosses envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "crosses", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1543-L1568", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineEqualsPolyline_", "original_string": "private static boolean polylineEqualsPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\t// Quick point equality check for true equality. This just checks if all\n\t\t// the points in each ring are the same (within a tolerance) and in the\n\t\t// same order\n\t\tif (multiPathExactlyEqualsMultiPath_(polyline_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker))\n\t\t\treturn true;\n\n\t\treturn linearPathEqualsLinearPath_(polyline_a, polyline_b, tolerance, false);\n\t}", "language": "java", "code": "private static boolean polylineEqualsPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\t// Quick point equality check for true equality. This just checks if all\n\t\t// the points in each ring are the same (within a tolerance) and in the\n\t\t// same order\n\t\tif (multiPathExactlyEqualsMultiPath_(polyline_a, polyline_b, tolerance,\n\t\t\t\tprogress_tracker))\n\t\t\treturn true;\n\n\t\treturn linearPathEqualsLinearPath_(polyline_a, polyline_b, tolerance, false);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineEqualsPolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polyline_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "if", "(", "!", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "// Quick point equality check for true equality. This just checks if all", "// the points in each ring are the same (within a tolerance) and in the", "// same order", "if", "(", "multiPathExactlyEqualsMultiPath_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "true", ";", "return", "linearPathEqualsLinearPath_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", ";", "}"], "docstring": "Returns true if polyline_a equals polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "equals", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1571-L1595", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineDisjointPolyline_", "original_string": "private static boolean polylineDisjointPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn true;\n\n        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polyline_a._getImpl();\n        MultiPathImpl multi_path_impl_b = (MultiPathImpl)polyline_b._getImpl();\n\n        PairwiseIntersectorImpl intersector_paths = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);\n\n        if (!intersector_paths.next())\n            return false;\n\n\t\treturn !linearPathIntersectsLinearPath_(polyline_a, polyline_b,\n\t\t\t\ttolerance);\n\t}", "language": "java", "code": "private static boolean polylineDisjointPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn true;\n\n        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polyline_a._getImpl();\n        MultiPathImpl multi_path_impl_b = (MultiPathImpl)polyline_b._getImpl();\n\n        PairwiseIntersectorImpl intersector_paths = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);\n\n        if (!intersector_paths.next())\n            return false;\n\n\t\treturn !linearPathIntersectsLinearPath_(polyline_a, polyline_b,\n\t\t\t\ttolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineDisjointPolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "MultiPathImpl", "multi_path_impl_a", "=", "(", "MultiPathImpl", ")", "polyline_a", ".", "_getImpl", "(", ")", ";", "MultiPathImpl", "multi_path_impl_b", "=", "(", "MultiPathImpl", ")", "polyline_b", ".", "_getImpl", "(", ")", ";", "PairwiseIntersectorImpl", "intersector_paths", "=", "new", "PairwiseIntersectorImpl", "(", "multi_path_impl_a", ",", "multi_path_impl_b", ",", "tolerance", ",", "true", ")", ";", "if", "(", "!", "intersector_paths", ".", "next", "(", ")", ")", "return", "false", ";", "return", "!", "linearPathIntersectsLinearPath_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a is disjoint from polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "is", "disjoint", "from", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1598-L1616", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineTouchesPolyline_", "original_string": "private static boolean polylineTouchesPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tAttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);\n\n\t\tint dim = linearPathIntersectsLinearPathMaxDim_(polyline_a, polyline_b,\n\t\t\t\ttolerance, intersections);\n\n\t\tif (dim != 0)\n\t\t\treturn false;\n\n\t\tMultiPoint intersection = new MultiPoint();\n\n\t\tfor (int i = 0; i < intersections.size(); i += 2) {\n\t\t\tdouble x = intersections.read(i);\n\t\t\tdouble y = intersections.read(i + 1);\n\t\t\tintersection.add(x, y);\n\t\t}\n\n\t\tMultiPoint boundary_a_b = (MultiPoint) (polyline_a.getBoundary());\n\t\tMultiPoint boundary_b = (MultiPoint) (polyline_b.getBoundary());\n\n\t\tboundary_a_b.add(boundary_b, 0, boundary_b.getPointCount());\n\n\t\treturn multiPointContainsMultiPointBrute_(boundary_a_b, intersection,\n\t\t\t\ttolerance);\n\t}", "language": "java", "code": "private static boolean polylineTouchesPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tAttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);\n\n\t\tint dim = linearPathIntersectsLinearPathMaxDim_(polyline_a, polyline_b,\n\t\t\t\ttolerance, intersections);\n\n\t\tif (dim != 0)\n\t\t\treturn false;\n\n\t\tMultiPoint intersection = new MultiPoint();\n\n\t\tfor (int i = 0; i < intersections.size(); i += 2) {\n\t\t\tdouble x = intersections.read(i);\n\t\t\tdouble y = intersections.read(i + 1);\n\t\t\tintersection.add(x, y);\n\t\t}\n\n\t\tMultiPoint boundary_a_b = (MultiPoint) (polyline_a.getBoundary());\n\t\tMultiPoint boundary_b = (MultiPoint) (polyline_b.getBoundary());\n\n\t\tboundary_a_b.add(boundary_b, 0, boundary_b.getPointCount());\n\n\t\treturn multiPointContainsMultiPointBrute_(boundary_a_b, intersection,\n\t\t\t\ttolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineTouchesPolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "AttributeStreamOfDbl", "intersections", "=", "new", "AttributeStreamOfDbl", "(", "0", ")", ";", "int", "dim", "=", "linearPathIntersectsLinearPathMaxDim_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "intersections", ")", ";", "if", "(", "dim", "!=", "0", ")", "return", "false", ";", "MultiPoint", "intersection", "=", "new", "MultiPoint", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "intersections", ".", "size", "(", ")", ";", "i", "+=", "2", ")", "{", "double", "x", "=", "intersections", ".", "read", "(", "i", ")", ";", "double", "y", "=", "intersections", ".", "read", "(", "i", "+", "1", ")", ";", "intersection", ".", "add", "(", "x", ",", "y", ")", ";", "}", "MultiPoint", "boundary_a_b", "=", "(", "MultiPoint", ")", "(", "polyline_a", ".", "getBoundary", "(", ")", ")", ";", "MultiPoint", "boundary_b", "=", "(", "MultiPoint", ")", "(", "polyline_b", ".", "getBoundary", "(", ")", ")", ";", "boundary_a_b", ".", "add", "(", "boundary_b", ",", "0", ",", "boundary_b", ".", "getPointCount", "(", ")", ")", ";", "return", "multiPointContainsMultiPointBrute_", "(", "boundary_a_b", ",", "intersection", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a touches polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "touches", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1619-L1650", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineOverlapsPolyline_", "original_string": "private static boolean polylineOverlapsPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\treturn linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);\n\t}", "language": "java", "code": "private static boolean polylineOverlapsPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\treturn linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineOverlapsPolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "return", "linearPathOverlapsLinearPath_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a overlaps polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "overlaps", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1687-L1696", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineContainsPolyline_", "original_string": "private static boolean polylineContainsPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\treturn linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);\n\t}", "language": "java", "code": "private static boolean polylineContainsPolyline_(Polyline polyline_a,\n\t\t\tPolyline polyline_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tpolyline_b.queryEnvelope2D(env_b);\n\n\t\t// Quick envelope rejection test for false equality.\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\treturn linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineContainsPolyline_", "(", "Polyline", "polyline_a", ",", "Polyline", "polyline_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "polyline_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "// Quick envelope rejection test for false equality.", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "return", "linearPathWithinLinearPath_", "(", "polyline_b", ",", "polyline_a", ",", "tolerance", ",", "false", ")", ";", "}"], "docstring": "Returns true if polyline_a contains polyline_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "contains", "polyline_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1699-L1716", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineDisjointPoint_", "original_string": "private static boolean polylineDisjointPoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn !linearPathIntersectsPoint_(polyline_a, pt_b, tolerance);\n\t}", "language": "java", "code": "private static boolean polylineDisjointPoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn true;\n\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn !linearPathIntersectsPoint_(polyline_a, pt_b, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineDisjointPoint_", "(", "Polyline", "polyline_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "point_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "return", "!", "linearPathIntersectsPoint_", "(", "polyline_a", ",", "pt_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a is disjoint from point_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "is", "disjoint", "from", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1719-L1728", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineTouchesPoint_", "original_string": "private static boolean polylineTouchesPoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);\n\t}", "language": "java", "code": "private static boolean polylineTouchesPoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineTouchesPoint_", "(", "Polyline", "polyline_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "point_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "return", "linearPathTouchesPointImpl_", "(", "polyline_a", ",", "pt_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a touches point_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "touches", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1731-L1740", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineContainsPoint_", "original_string": "private static boolean polylineContainsPoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn linearPathContainsPoint_(polyline_a, pt_b, tolerance);\n\t}", "language": "java", "code": "private static boolean polylineContainsPoint_(Polyline polyline_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,\n\t\t\t\tfalse) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn linearPathContainsPoint_(polyline_a, pt_b, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineContainsPoint_", "(", "Polyline", "polyline_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "point_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "return", "linearPathContainsPoint_", "(", "polyline_a", ",", "pt_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true of polyline_a contains point_b.", "docstring_tokens": ["Returns", "true", "of", "polyline_a", "contains", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1743-L1752", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineDisjointMultiPoint_", "original_string": "private static boolean polylineDisjointMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false) == Relation.disjoint)\n\t\t\treturn true;\n\n\t\treturn !linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false);\n\t}", "language": "java", "code": "private static boolean polylineDisjointMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false) == Relation.disjoint)\n\t\t\treturn true;\n\n\t\treturn !linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineDisjointMultiPoint_", "(", "Polyline", "polyline_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "true", ";", "return", "!", "linearPathIntersectsMultiPoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", ";", "}"], "docstring": "Returns true if polyline_a is disjoint from multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "is", "disjoint", "from", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1755-L1765", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineTouchesMultiPoint_", "original_string": "private static boolean polylineTouchesMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false) == Relation.disjoint) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) polyline_a._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tQuadTreeImpl qtA = null;\n\t\tQuadTreeImpl quadTreeA = null;\n        QuadTreeImpl quadTreePathsA = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) (polyline_a._getImpl()))\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeA = accel.getQuadTree();\n            quadTreePathsA = accel.getQuadTreeForPaths();\n\t\t\tif (quadTreeA == null) {\n\t\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) polyline_a._getImpl(), envInter);\n\t\t\t\tquadTreeA = qtA;\n\t\t\t}\n\t\t} else {\n\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) polyline_a._getImpl(), envInter);\n\t\t\tquadTreeA = qtA;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;\n        if (quadTreePathsA != null)\n            qtIterPathsA = quadTreePathsA.getIterator();\n\n\t\tPoint2D ptB = new Point2D(), closest = new Point2D();\n\t\tboolean b_intersects = false;\n\t\tdouble toleranceSq = tolerance * tolerance;\n\n\t\tAttributeStreamOfInt8 intersects = new AttributeStreamOfInt8(\n\t\t\t\tmultipoint_b.getPointCount());\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tintersects.write(i, (byte) 0);\n\t\t}\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (!envInter.contains(ptB)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tenv_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);\n\n            if (qtIterPathsA != null) {\n                qtIterPathsA.resetIterator(env_b, tolerance);\n\n                if (qtIterPathsA.next() == -1)\n                    continue;\n            }\n\n\t\t\tqtIterA.resetIterator(env_b, tolerance);\n\n\t\t\tfor (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_a = quadTreeA.getElement(elementHandleA);\n\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\tif (Point2D.sqrDistance(ptB, closest) <= toleranceSq) {\n\t\t\t\t\tintersects.write(i, (byte) 1);\n\t\t\t\t\tb_intersects = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!b_intersects) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());\n\t\tMultiPoint multipoint_b_inter = new MultiPoint();\n\t\tPoint2D pt = new Point2D();\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tif (intersects.read(i) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmultipoint_b.getXY(i, pt);\n\t\t\tmultipoint_b_inter.add(pt.x, pt.y);\n\t\t}\n\n\t\treturn multiPointContainsMultiPointBrute_(boundary_a,\n\t\t\t\tmultipoint_b_inter, tolerance);\n\t}", "language": "java", "code": "private static boolean polylineTouchesMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false) == Relation.disjoint) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) polyline_a._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tQuadTreeImpl qtA = null;\n\t\tQuadTreeImpl quadTreeA = null;\n        QuadTreeImpl quadTreePathsA = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) (polyline_a._getImpl()))\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeA = accel.getQuadTree();\n            quadTreePathsA = accel.getQuadTreeForPaths();\n\t\t\tif (quadTreeA == null) {\n\t\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) polyline_a._getImpl(), envInter);\n\t\t\t\tquadTreeA = qtA;\n\t\t\t}\n\t\t} else {\n\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) polyline_a._getImpl(), envInter);\n\t\t\tquadTreeA = qtA;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;\n        if (quadTreePathsA != null)\n            qtIterPathsA = quadTreePathsA.getIterator();\n\n\t\tPoint2D ptB = new Point2D(), closest = new Point2D();\n\t\tboolean b_intersects = false;\n\t\tdouble toleranceSq = tolerance * tolerance;\n\n\t\tAttributeStreamOfInt8 intersects = new AttributeStreamOfInt8(\n\t\t\t\tmultipoint_b.getPointCount());\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tintersects.write(i, (byte) 0);\n\t\t}\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (!envInter.contains(ptB)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tenv_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);\n\n            if (qtIterPathsA != null) {\n                qtIterPathsA.resetIterator(env_b, tolerance);\n\n                if (qtIterPathsA.next() == -1)\n                    continue;\n            }\n\n\t\t\tqtIterA.resetIterator(env_b, tolerance);\n\n\t\t\tfor (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_a = quadTreeA.getElement(elementHandleA);\n\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\tif (Point2D.sqrDistance(ptB, closest) <= toleranceSq) {\n\t\t\t\t\tintersects.write(i, (byte) 1);\n\t\t\t\t\tb_intersects = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!b_intersects) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());\n\t\tMultiPoint multipoint_b_inter = new MultiPoint();\n\t\tPoint2D pt = new Point2D();\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tif (intersects.read(i) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmultipoint_b.getXY(i, pt);\n\t\t\tmultipoint_b_inter.add(pt.x, pt.y);\n\t\t}\n\n\t\treturn multiPointContainsMultiPointBrute_(boundary_a,\n\t\t\t\tmultipoint_b_inter, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineTouchesMultiPoint_", "(", "Polyline", "polyline_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "{", "return", "false", ";", "}", "SegmentIteratorImpl", "segIterA", "=", "(", "(", "MultiPathImpl", ")", "polyline_a", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "envInter", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "env_b", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "envInter", ".", "setCoords", "(", "env_a", ")", ";", "envInter", ".", "intersect", "(", "env_b", ")", ";", "QuadTreeImpl", "qtA", "=", "null", ";", "QuadTreeImpl", "quadTreeA", "=", "null", ";", "QuadTreeImpl", "quadTreePathsA", "=", "null", ";", "GeometryAccelerators", "accel", "=", "(", "(", "MultiPathImpl", ")", "(", "polyline_a", ".", "_getImpl", "(", ")", ")", ")", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "quadTreeA", "=", "accel", ".", "getQuadTree", "(", ")", ";", "quadTreePathsA", "=", "accel", ".", "getQuadTreeForPaths", "(", ")", ";", "if", "(", "quadTreeA", "==", "null", ")", "{", "qtA", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "polyline_a", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeA", "=", "qtA", ";", "}", "}", "else", "{", "qtA", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "polyline_a", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeA", "=", "qtA", ";", "}", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterA", "=", "quadTreeA", ".", "getIterator", "(", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterPathsA", "=", "null", ";", "if", "(", "quadTreePathsA", "!=", "null", ")", "qtIterPathsA", "=", "quadTreePathsA", ".", "getIterator", "(", ")", ";", "Point2D", "ptB", "=", "new", "Point2D", "(", ")", ",", "closest", "=", "new", "Point2D", "(", ")", ";", "boolean", "b_intersects", "=", "false", ";", "double", "toleranceSq", "=", "tolerance", "*", "tolerance", ";", "AttributeStreamOfInt8", "intersects", "=", "new", "AttributeStreamOfInt8", "(", "multipoint_b", ".", "getPointCount", "(", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "intersects", ".", "write", "(", "i", ",", "(", "byte", ")", "0", ")", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_b", ".", "getXY", "(", "i", ",", "ptB", ")", ";", "if", "(", "!", "envInter", ".", "contains", "(", "ptB", ")", ")", "{", "continue", ";", "}", "env_b", ".", "setCoords", "(", "ptB", ".", "x", ",", "ptB", ".", "y", ",", "ptB", ".", "x", ",", "ptB", ".", "y", ")", ";", "if", "(", "qtIterPathsA", "!=", "null", ")", "{", "qtIterPathsA", ".", "resetIterator", "(", "env_b", ",", "tolerance", ")", ";", "if", "(", "qtIterPathsA", ".", "next", "(", ")", "==", "-", "1", ")", "continue", ";", "}", "qtIterA", ".", "resetIterator", "(", "env_b", ",", "tolerance", ")", ";", "for", "(", "int", "elementHandleA", "=", "qtIterA", ".", "next", "(", ")", ";", "elementHandleA", "!=", "-", "1", ";", "elementHandleA", "=", "qtIterA", ".", "next", "(", ")", ")", "{", "int", "vertex_a", "=", "quadTreeA", ".", "getElement", "(", "elementHandleA", ")", ";", "segIterA", ".", "resetToVertex", "(", "vertex_a", ")", ";", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "double", "t", "=", "segmentA", ".", "getClosestCoordinate", "(", "ptB", ",", "false", ")", ";", "segmentA", ".", "getCoord2D", "(", "t", ",", "closest", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptB", ",", "closest", ")", "<=", "toleranceSq", ")", "{", "intersects", ".", "write", "(", "i", ",", "(", "byte", ")", "1", ")", ";", "b_intersects", "=", "true", ";", "break", ";", "}", "}", "}", "if", "(", "!", "b_intersects", ")", "{", "return", "false", ";", "}", "MultiPoint", "boundary_a", "=", "(", "MultiPoint", ")", "(", "polyline_a", ".", "getBoundary", "(", ")", ")", ";", "MultiPoint", "multipoint_b_inter", "=", "new", "MultiPoint", "(", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "intersects", ".", "read", "(", "i", ")", "==", "0", ")", "{", "continue", ";", "}", "multipoint_b", ".", "getXY", "(", "i", ",", "pt", ")", ";", "multipoint_b_inter", ".", "add", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "}", "return", "multiPointContainsMultiPointBrute_", "(", "boundary_a", ",", "multipoint_b_inter", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a touches multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "touches", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L1768-L1881", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineContainsMultiPoint_", "original_string": "private static boolean polylineContainsMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tif (!linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, true))\n\t\t\treturn false;\n\n\t\tMultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());\n\t\treturn !multiPointIntersectsMultiPoint_(boundary_a, multipoint_b,\n\t\t\t\ttolerance, progress_tracker);\n\t}", "language": "java", "code": "private static boolean polylineContainsMultiPoint_(Polyline polyline_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\t// Quick rasterize test to see whether the the geometries are disjoint.\n\t\tif (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, false) == Relation.disjoint)\n\t\t\treturn false;\n\n\t\tif (!linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,\n\t\t\t\ttolerance, true))\n\t\t\treturn false;\n\n\t\tMultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());\n\t\treturn !multiPointIntersectsMultiPoint_(boundary_a, multipoint_b,\n\t\t\t\ttolerance, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineContainsMultiPoint_", "(", "Polyline", "polyline_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "// Quick rasterize test to see whether the the geometries are disjoint.", "if", "(", "tryRasterizedContainsOrDisjoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ")", "==", "Relation", ".", "disjoint", ")", "return", "false", ";", "if", "(", "!", "linearPathIntersectsMultiPoint_", "(", "polyline_a", ",", "multipoint_b", ",", "tolerance", ",", "true", ")", ")", "return", "false", ";", "MultiPoint", "boundary_a", "=", "(", "MultiPoint", ")", "(", "polyline_a", ".", "getBoundary", "(", ")", ")", ";", "return", "!", "multiPointIntersectsMultiPoint_", "(", "boundary_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polyline_a contains multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "contains", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2011-L2033", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineEqualsEnvelope_", "original_string": "private static boolean polylineEqualsEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // area cannot equal a line\n\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polylineEqualsEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // area cannot equal a line\n\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineEqualsEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "// area cannot equal a line", "return", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polyline_a equals envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "equals", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2036-L2048", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineDisjointEnvelope_", "original_string": "private static boolean polylineDisjointEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\treturn !linearPathIntersectsEnvelope_(polyline_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean polylineDisjointEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\treturn !linearPathIntersectsEnvelope_(polyline_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineDisjointEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "return", "!", "linearPathIntersectsEnvelope_", "(", "polyline_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if polyline_a is disjoint from envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "is", "disjoint", "from", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2051-L2063", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineTouchesEnvelope_", "original_string": "private static boolean polylineTouchesEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);\n\t\t}\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\t// Treat env_b as area\n\n\t\tSegmentIterator seg_iter_a = polyline_a.querySegmentIterator();\n\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tboolean b_boundary = false;\n\t\tEnvelope2D env_segment_a = new Envelope2D();\n\t\tEnvelope2D env_inter = new Envelope2D();\n\n\t\twhile (seg_iter_a.nextPath()) {\n\t\t\twhile (seg_iter_a.hasNextSegment()) {\n\t\t\t\tSegment segment_a = seg_iter_a.nextSegment();\n\t\t\t\tsegment_a.queryEnvelope2D(env_segment_a);\n\n\t\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\t\treturn false; // consider segment within\n\n\t\t\t\tenv_inter.setCoords(env_b_inflated);\n\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\tif (!env_inter.isEmpty())\n\t\t\t\t\tb_boundary = true;\n\t\t\t}\n\t\t}\n\n\t\treturn b_boundary;\n\t}", "language": "java", "code": "private static boolean polylineTouchesEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);\n\t\t}\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\t// Treat env_b as area\n\n\t\tSegmentIterator seg_iter_a = polyline_a.querySegmentIterator();\n\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tboolean b_boundary = false;\n\t\tEnvelope2D env_segment_a = new Envelope2D();\n\t\tEnvelope2D env_inter = new Envelope2D();\n\n\t\twhile (seg_iter_a.nextPath()) {\n\t\t\twhile (seg_iter_a.hasNextSegment()) {\n\t\t\t\tSegment segment_a = seg_iter_a.nextSegment();\n\t\t\t\tsegment_a.queryEnvelope2D(env_segment_a);\n\n\t\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\t\treturn false; // consider segment within\n\n\t\t\t\tenv_inter.setCoords(env_b_inflated);\n\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\tif (!env_inter.isEmpty())\n\t\t\t\t\tb_boundary = true;\n\t\t\t}\n\t\t}\n\n\t\treturn b_boundary;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineTouchesEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// Treat", "// as", "// point", "Point2D", "pt_b", "=", "envelope_b", ".", "getCenterXY", "(", ")", ";", "return", "linearPathTouchesPointImpl_", "(", "polyline_a", ",", "pt_b", ",", "tolerance", ")", ";", "}", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// Treat", "// as", "// polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "polylineTouchesPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "// Treat env_b as area", "SegmentIterator", "seg_iter_a", "=", "polyline_a", ".", "querySegmentIterator", "(", ")", ";", "Envelope2D", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ",", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "boolean", "b_boundary", "=", "false", ";", "Envelope2D", "env_segment_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_inter", "=", "new", "Envelope2D", "(", ")", ";", "while", "(", "seg_iter_a", ".", "nextPath", "(", ")", ")", "{", "while", "(", "seg_iter_a", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segment_a", "=", "seg_iter_a", ".", "nextSegment", "(", ")", ";", "segment_a", ".", "queryEnvelope2D", "(", "env_segment_a", ")", ";", "env_inter", ".", "setCoords", "(", "env_b_deflated", ")", ";", "env_inter", ".", "intersect", "(", "env_segment_a", ")", ";", "if", "(", "!", "env_inter", ".", "isEmpty", "(", ")", "&&", "(", "env_inter", ".", "getHeight", "(", ")", ">", "tolerance", "||", "env_inter", ".", "getWidth", "(", ")", ">", "tolerance", ")", ")", "return", "false", ";", "// consider segment within", "env_inter", ".", "setCoords", "(", "env_b_inflated", ")", ";", "env_inter", ".", "intersect", "(", "env_segment_a", ")", ";", "if", "(", "!", "env_inter", ".", "isEmpty", "(", ")", ")", "b_boundary", "=", "true", ";", "}", "}", "return", "b_boundary", ";", "}"], "docstring": "Returns true if polyline_a touches envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "touches", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2066-L2128", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineOverlapsEnvelope_", "original_string": "private static boolean polylineOverlapsEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)\n\t\t\t\t|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // lines cannot overlap areas\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // lines cannot overlap points\n\n\t\t// Treat as polyline\n\t\tPolyline polyline_b = new Polyline();\n\t\tPoint p = new Point();\n\t\tenvelope_b.queryCornerByVal(0, p);\n\t\tpolyline_b.startPath(p);\n\t\tenvelope_b.queryCornerByVal(2, p);\n\t\tpolyline_b.lineTo(p);\n\t\treturn linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);\n\t}", "language": "java", "code": "private static boolean polylineOverlapsEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)\n\t\t\t\t|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // lines cannot overlap areas\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // lines cannot overlap points\n\n\t\t// Treat as polyline\n\t\tPolyline polyline_b = new Polyline();\n\t\tPoint p = new Point();\n\t\tenvelope_b.queryCornerByVal(0, p);\n\t\tpolyline_b.startPath(p);\n\t\tenvelope_b.queryCornerByVal(2, p);\n\t\tpolyline_b.lineTo(p);\n\t\treturn linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineOverlapsEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", "||", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "// lines cannot overlap areas", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// lines cannot overlap points", "// Treat as polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "linearPathOverlapsLinearPath_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if polyline_a overlaps envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "overlaps", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2131-L2159", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineWithinEnvelope_", "original_string": "private static boolean polylineWithinEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance)\n\t\t\treturn envelopeInfContainsEnvelope_(env_b, env_a, tolerance);\n\n\t\tSegmentIterator seg_iter_a = polyline_a.querySegmentIterator();\n\t\tEnvelope2D env_b_deflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\n\t\tboolean b_interior = false;\n\t\tEnvelope2D env_segment_a = new Envelope2D();\n\t\tEnvelope2D env_inter = new Envelope2D();\n\n\t\twhile (seg_iter_a.nextPath()) {\n\t\t\twhile (seg_iter_a.hasNextSegment()) {\n\t\t\t\tSegment segment_a = seg_iter_a.nextSegment();\n\t\t\t\tsegment_a.queryEnvelope2D(env_segment_a);\n\n\t\t\t\tif (env_b_deflated.containsExclusive(env_segment_a)) {\n\t\t\t\t\tb_interior = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\t\tb_interior = true;\n\t\t\t}\n\t\t}\n\n\t\treturn b_interior;\n\t}", "language": "java", "code": "private static boolean polylineWithinEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance)\n\t\t\treturn envelopeInfContainsEnvelope_(env_b, env_a, tolerance);\n\n\t\tSegmentIterator seg_iter_a = polyline_a.querySegmentIterator();\n\t\tEnvelope2D env_b_deflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\n\t\tboolean b_interior = false;\n\t\tEnvelope2D env_segment_a = new Envelope2D();\n\t\tEnvelope2D env_inter = new Envelope2D();\n\n\t\twhile (seg_iter_a.nextPath()) {\n\t\t\twhile (seg_iter_a.hasNextSegment()) {\n\t\t\t\tSegment segment_a = seg_iter_a.nextSegment();\n\t\t\t\tsegment_a.queryEnvelope2D(env_segment_a);\n\n\t\t\t\tif (env_b_deflated.containsExclusive(env_segment_a)) {\n\t\t\t\t\tb_interior = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\t\tb_interior = true;\n\t\t\t}\n\t\t}\n\n\t\treturn b_interior;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineWithinEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ";", "SegmentIterator", "seg_iter_a", "=", "polyline_a", ".", "querySegmentIterator", "(", ")", ";", "Envelope2D", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "boolean", "b_interior", "=", "false", ";", "Envelope2D", "env_segment_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_inter", "=", "new", "Envelope2D", "(", ")", ";", "while", "(", "seg_iter_a", ".", "nextPath", "(", ")", ")", "{", "while", "(", "seg_iter_a", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segment_a", "=", "seg_iter_a", ".", "nextSegment", "(", ")", ";", "segment_a", ".", "queryEnvelope2D", "(", "env_segment_a", ")", ";", "if", "(", "env_b_deflated", ".", "containsExclusive", "(", "env_segment_a", ")", ")", "{", "b_interior", "=", "true", ";", "continue", ";", "}", "env_inter", ".", "setCoords", "(", "env_b_deflated", ")", ";", "env_inter", ".", "intersect", "(", "env_segment_a", ")", ";", "if", "(", "!", "env_inter", ".", "isEmpty", "(", ")", "&&", "(", "env_inter", ".", "getHeight", "(", ")", ">", "tolerance", "||", "env_inter", ".", "getWidth", "(", ")", ">", "tolerance", ")", ")", "b_interior", "=", "true", ";", "}", "}", "return", "b_interior", ";", "}"], "docstring": "Returns true if polyline_a is within envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "is", "within", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2162-L2208", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineContainsEnvelope_", "original_string": "private static boolean polylineContainsEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // when treated as an area, lines cannot contain\n\t\t\t\t\t\t\t// areas.\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn linearPathContainsPoint_(polyline_a, pt_b, tolerance);\n\t\t}\n\n\t\t// Treat as polyline\n\t\tPolyline polyline_b = new Polyline();\n\t\tPoint p = new Point();\n\t\tenvelope_b.queryCornerByVal(0, p);\n\t\tpolyline_b.startPath(p);\n\t\tenvelope_b.queryCornerByVal(2, p);\n\t\tpolyline_b.lineTo(p);\n\t\treturn linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);\n\t}", "language": "java", "code": "private static boolean polylineContainsEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance)\n\t\t\treturn false; // when treated as an area, lines cannot contain\n\t\t\t\t\t\t\t// areas.\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\t\treturn linearPathContainsPoint_(polyline_a, pt_b, tolerance);\n\t\t}\n\n\t\t// Treat as polyline\n\t\tPolyline polyline_b = new Polyline();\n\t\tPoint p = new Point();\n\t\tenvelope_b.queryCornerByVal(0, p);\n\t\tpolyline_b.startPath(p);\n\t\tenvelope_b.queryCornerByVal(2, p);\n\t\tpolyline_b.lineTo(p);\n\t\treturn linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);\n\t}", "code_tokens": ["private", "static", "boolean", "polylineContainsEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "// when treated as an area, lines cannot contain", "// areas.", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// Treat", "// as", "// point", "Point2D", "pt_b", "=", "envelope_b", ".", "getCenterXY", "(", ")", ";", "return", "linearPathContainsPoint_", "(", "polyline_a", ",", "pt_b", ",", "tolerance", ")", ";", "}", "// Treat as polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "linearPathWithinLinearPath_", "(", "polyline_b", ",", "polyline_a", ",", "tolerance", ",", "false", ")", ";", "}"], "docstring": "Returns true if polyline_a contains envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "contains", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2211-L2240", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polylineCrossesEnvelope_", "original_string": "private static boolean polylineCrossesEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // when treated as a point, lines cannot cross points.\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\t// Treat env_b as area\n\n\t\tSegmentIterator seg_iter_a = polyline_a.querySegmentIterator();\n\t\tEnvelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tboolean b_interior = false, b_exterior = false;\n\t\tEnvelope2D env_segment_a = new Envelope2D();\n\t\tEnvelope2D env_inter = new Envelope2D();\n\n\t\twhile (seg_iter_a.nextPath()) {\n\t\t\twhile (seg_iter_a.hasNextSegment()) {\n\t\t\t\tSegment segment_a = seg_iter_a.nextSegment();\n\t\t\t\tsegment_a.queryEnvelope2D(env_segment_a);\n\n\t\t\t\tif (!b_exterior) {\n\t\t\t\t\tif (!env_b_inflated.contains(env_segment_a))\n\t\t\t\t\t\tb_exterior = true;\n\t\t\t\t}\n\n\t\t\t\tif (!b_interior) {\n\t\t\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\t\t\tb_interior = true;\n\t\t\t\t}\n\n\t\t\t\tif (b_interior && b_exterior)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean polylineCrossesEnvelope_(Polyline polyline_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tpolyline_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // when treated as a point, lines cannot cross points.\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// Treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// polyline\n\t\t\tPolyline polyline_b = new Polyline();\n\t\t\tPoint p = new Point();\n\t\t\tenvelope_b.queryCornerByVal(0, p);\n\t\t\tpolyline_b.startPath(p);\n\t\t\tenvelope_b.queryCornerByVal(2, p);\n\t\t\tpolyline_b.lineTo(p);\n\t\t\treturn polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\t// Treat env_b as area\n\n\t\tSegmentIterator seg_iter_a = polyline_a.querySegmentIterator();\n\t\tEnvelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tboolean b_interior = false, b_exterior = false;\n\t\tEnvelope2D env_segment_a = new Envelope2D();\n\t\tEnvelope2D env_inter = new Envelope2D();\n\n\t\twhile (seg_iter_a.nextPath()) {\n\t\t\twhile (seg_iter_a.hasNextSegment()) {\n\t\t\t\tSegment segment_a = seg_iter_a.nextSegment();\n\t\t\t\tsegment_a.queryEnvelope2D(env_segment_a);\n\n\t\t\t\tif (!b_exterior) {\n\t\t\t\t\tif (!env_b_inflated.contains(env_segment_a))\n\t\t\t\t\t\tb_exterior = true;\n\t\t\t\t}\n\n\t\t\t\tif (!b_interior) {\n\t\t\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\t\t\tenv_inter.intersect(env_segment_a);\n\n\t\t\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\t\t\tb_interior = true;\n\t\t\t\t}\n\n\t\t\t\tif (b_interior && b_exterior)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "polylineCrossesEnvelope_", "(", "Polyline", "polyline_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "polyline_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// when treated as a point, lines cannot cross points.", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// Treat", "// as", "// polyline", "Polyline", "polyline_b", "=", "new", "Polyline", "(", ")", ";", "Point", "p", "=", "new", "Point", "(", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "0", ",", "p", ")", ";", "polyline_b", ".", "startPath", "(", "p", ")", ";", "envelope_b", ".", "queryCornerByVal", "(", "2", ",", "p", ")", ";", "polyline_b", ".", "lineTo", "(", "p", ")", ";", "return", "polylineCrossesPolyline_", "(", "polyline_a", ",", "polyline_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "// Treat env_b as area", "SegmentIterator", "seg_iter_a", "=", "polyline_a", ".", "querySegmentIterator", "(", ")", ";", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ",", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "boolean", "b_interior", "=", "false", ",", "b_exterior", "=", "false", ";", "Envelope2D", "env_segment_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_inter", "=", "new", "Envelope2D", "(", ")", ";", "while", "(", "seg_iter_a", ".", "nextPath", "(", ")", ")", "{", "while", "(", "seg_iter_a", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segment_a", "=", "seg_iter_a", ".", "nextSegment", "(", ")", ";", "segment_a", ".", "queryEnvelope2D", "(", "env_segment_a", ")", ";", "if", "(", "!", "b_exterior", ")", "{", "if", "(", "!", "env_b_inflated", ".", "contains", "(", "env_segment_a", ")", ")", "b_exterior", "=", "true", ";", "}", "if", "(", "!", "b_interior", ")", "{", "env_inter", ".", "setCoords", "(", "env_b_deflated", ")", ";", "env_inter", ".", "intersect", "(", "env_segment_a", ")", ";", "if", "(", "!", "env_inter", ".", "isEmpty", "(", ")", "&&", "(", "env_inter", ".", "getHeight", "(", ")", ">", "tolerance", "||", "env_inter", ".", "getWidth", "(", ")", ">", "tolerance", ")", ")", "b_interior", "=", "true", ";", "}", "if", "(", "b_interior", "&&", "b_exterior", ")", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Returns true if polyline_a crosses envelope_b.", "docstring_tokens": ["Returns", "true", "if", "polyline_a", "crosses", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2243-L2308", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointEqualsMultiPoint_", "original_string": "private static boolean multiPointEqualsMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\tif (multiPointExactlyEqualsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, progress_tracker))\n\t\t\treturn true;\n\n\t\treturn multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, false, true, false, progress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointEqualsMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))\n\t\t\treturn false;\n\n\t\tif (multiPointExactlyEqualsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, progress_tracker))\n\t\t\treturn true;\n\n\t\treturn multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, false, true, false, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointEqualsMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "false", ";", "if", "(", "multiPointExactlyEqualsMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ")", "return", "true", ";", "return", "multiPointCoverageMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ",", "true", ",", "false", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a equals multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "equals", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2311-L2327", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointDisjointMultiPoint_", "original_string": "private static boolean multiPointDisjointMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\treturn !multiPointIntersectsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, progress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointDisjointMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\treturn !multiPointIntersectsMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointDisjointMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "!", "multiPointIntersectsMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a is disjoint from multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "is", "disjoint", "from", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2330-L2335", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointOverlapsMultiPoint_", "original_string": "private static boolean multiPointOverlapsMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\treturn multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, false, false, true, progress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointOverlapsMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\treturn multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,\n\t\t\t\ttolerance, false, false, true, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointOverlapsMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "multiPointCoverageMultiPoint_", "(", "multipoint_a", ",", "multipoint_b", ",", "tolerance", ",", "false", ",", "false", ",", "true", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a overlaps multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "overlaps", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2338-L2343", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointContainsMultiPoint_", "original_string": "private static boolean multiPointContainsMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\treturn multiPointCoverageMultiPoint_(multipoint_b, multipoint_a,\n\t\t\t\ttolerance, true, false, false, progress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointContainsMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\treturn multiPointCoverageMultiPoint_(multipoint_b, multipoint_a,\n\t\t\t\ttolerance, true, false, false, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointContainsMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "return", "multiPointCoverageMultiPoint_", "(", "multipoint_b", ",", "multipoint_a", ",", "tolerance", ",", "true", ",", "false", ",", "false", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a contains multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "contains", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2346-L2358", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointEqualsPoint_", "original_string": "static boolean multiPointEqualsPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tpoint_b.queryEnvelope2D(env_b);\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "static boolean multiPointEqualsPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tpoint_b.queryEnvelope2D(env_b);\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["static", "boolean", "multiPointEqualsPoint_", "(", "MultiPoint", "multipoint_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "point_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "return", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a equals point_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "equals", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2387-L2394", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointDisjointPoint_", "original_string": "private static boolean multiPointDisjointPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointDisjointPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tPoint2D pt_b = point_b.getXY();\n\t\treturn multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointDisjointPoint_", "(", "MultiPoint", "multipoint_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Point2D", "pt_b", "=", "point_b", ".", "getXY", "(", ")", ";", "return", "multiPointDisjointPointImpl_", "(", "multipoint_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a is disjoint from point_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "is", "disjoint", "from", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2397-L2402", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointWithinPoint_", "original_string": "private static boolean multiPointWithinPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn multiPointEqualsPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointWithinPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn multiPointEqualsPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointWithinPoint_", "(", "MultiPoint", "multipoint_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "multiPointEqualsPoint_", "(", "multipoint_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a is within point_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "is", "within", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2405-L2409", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointContainsPoint_", "original_string": "private static boolean multiPointContainsPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn !multiPointDisjointPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointContainsPoint_(MultiPoint multipoint_a,\n\t\t\tPoint point_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn !multiPointDisjointPoint_(multipoint_a, point_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointContainsPoint_", "(", "MultiPoint", "multipoint_a", ",", "Point", "point_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "!", "multiPointDisjointPoint_", "(", "multipoint_a", ",", "point_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a contains point_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "contains", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2412-L2416", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointEqualsEnvelope_", "original_string": "private static boolean multiPointEqualsEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (env_b.getHeight() > tolerance || env_b.getWidth() > tolerance)\n\t\t\treturn false;\n\n\t\t// only true if all the points of the multi_point degenerate to a point\n\t\t// equal to the envelope\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointEqualsEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (env_b.getHeight() > tolerance || env_b.getWidth() > tolerance)\n\t\t\treturn false;\n\n\t\t// only true if all the points of the multi_point degenerate to a point\n\t\t// equal to the envelope\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointEqualsEnvelope_", "(", "MultiPoint", "multipoint_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "// only true if all the points of the multi_point degenerate to a point", "// equal to the envelope", "return", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a equals envelope_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "equals", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2419-L2433", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointDisjointEnvelope_", "original_string": "private static boolean multiPointDisjointEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\tPoint2D pt_a = new Point2D();\n\n\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\tmultipoint_a.getXY(i, pt_a);\n\n\t\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\t\tcontinue;\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean multiPointDisjointEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\tPoint2D pt_a = new Point2D();\n\n\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\tmultipoint_a.getXY(i, pt_a);\n\n\t\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\t\tcontinue;\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointDisjointEnvelope_", "(", "MultiPoint", "multipoint_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "Point2D", "pt_a", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_a", ".", "getXY", "(", "i", ",", "pt_a", ")", ";", "if", "(", "!", "env_b_inflated", ".", "contains", "(", "pt_a", ")", ")", "continue", ";", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Returns true if multipoint_a is disjoint from envelope_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "is", "disjoint", "from", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2436-L2461", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointWithinEnvelope_", "original_string": "private static boolean multiPointWithinEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker); // treat as point\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t\tboolean b_interior = false;\n\n\t\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();\n\t\t\tenv_b_deflated.setCoords(env_b);\n\t\t\tenv_b_inflated.setCoords(env_b);\n\n\t\t\tif (env_b.getHeight() > tolerance)\n\t\t\t\tenv_b_deflated.inflate(0, -tolerance);\n\t\t\telse\n\t\t\t\tenv_b_deflated.inflate(-tolerance, 0);\n\n\t\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\t\tPoint2D pt_a = new Point2D();\n\n\t\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\t\tmultipoint_a.getXY(i, pt_a);\n\n\t\t\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (env_b.getHeight() > tolerance) {\n\t\t\t\t\tif (pt_a.y > env_b_deflated.ymin\n\t\t\t\t\t\t\t&& pt_a.y < env_b_deflated.ymax)\n\t\t\t\t\t\tb_interior = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (pt_a.x > env_b_deflated.xmin\n\t\t\t\t\t\t\t&& pt_a.x < env_b_deflated.xmax)\n\t\t\t\t\t\tb_interior = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn b_interior;\n\t\t}\n\n\t\t// treat as area\n\n\t\tboolean b_interior = false;\n\n\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tPoint2D pt_a = new Point2D();\n\n\t\t// we loop to find a proper interior intersection (i.e. something inside\n\t\t// instead of just on the boundary)\n\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\tmultipoint_a.getXY(i, pt_a);\n\n\t\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\t\treturn false;\n\n\t\t\tif (env_b_deflated.containsExclusive(pt_a))\n\t\t\t\tb_interior = true;\n\t\t}\n\n\t\treturn b_interior;\n\t}", "language": "java", "code": "private static boolean multiPointWithinEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker); // treat as point\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t\tboolean b_interior = false;\n\n\t\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();\n\t\t\tenv_b_deflated.setCoords(env_b);\n\t\t\tenv_b_inflated.setCoords(env_b);\n\n\t\t\tif (env_b.getHeight() > tolerance)\n\t\t\t\tenv_b_deflated.inflate(0, -tolerance);\n\t\t\telse\n\t\t\t\tenv_b_deflated.inflate(-tolerance, 0);\n\n\t\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\t\tPoint2D pt_a = new Point2D();\n\n\t\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\t\tmultipoint_a.getXY(i, pt_a);\n\n\t\t\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (env_b.getHeight() > tolerance) {\n\t\t\t\t\tif (pt_a.y > env_b_deflated.ymin\n\t\t\t\t\t\t\t&& pt_a.y < env_b_deflated.ymax)\n\t\t\t\t\t\tb_interior = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (pt_a.x > env_b_deflated.xmin\n\t\t\t\t\t\t\t&& pt_a.x < env_b_deflated.xmax)\n\t\t\t\t\t\tb_interior = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn b_interior;\n\t\t}\n\n\t\t// treat as area\n\n\t\tboolean b_interior = false;\n\n\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tPoint2D pt_a = new Point2D();\n\n\t\t// we loop to find a proper interior intersection (i.e. something inside\n\t\t// instead of just on the boundary)\n\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\tmultipoint_a.getXY(i, pt_a);\n\n\t\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\t\treturn false;\n\n\t\t\tif (env_b_deflated.containsExclusive(pt_a))\n\t\t\t\tb_interior = true;\n\t\t}\n\n\t\treturn b_interior;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointWithinEnvelope_", "(", "MultiPoint", "multipoint_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "// treat as point", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// as", "// line", "boolean", "b_interior", "=", "false", ";", "Envelope2D", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ",", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", ")", "env_b_deflated", ".", "inflate", "(", "0", ",", "-", "tolerance", ")", ";", "else", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "0", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "Point2D", "pt_a", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_a", ".", "getXY", "(", "i", ",", "pt_a", ")", ";", "if", "(", "!", "env_b_inflated", ".", "contains", "(", "pt_a", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", ")", "{", "if", "(", "pt_a", ".", "y", ">", "env_b_deflated", ".", "ymin", "&&", "pt_a", ".", "y", "<", "env_b_deflated", ".", "ymax", ")", "b_interior", "=", "true", ";", "}", "else", "{", "if", "(", "pt_a", ".", "x", ">", "env_b_deflated", ".", "xmin", "&&", "pt_a", ".", "x", "<", "env_b_deflated", ".", "xmax", ")", "b_interior", "=", "true", ";", "}", "}", "return", "b_interior", ";", "}", "// treat as area", "boolean", "b_interior", "=", "false", ";", "Envelope2D", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ",", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "Point2D", "pt_a", "=", "new", "Point2D", "(", ")", ";", "// we loop to find a proper interior intersection (i.e. something inside", "// instead of just on the boundary)", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_a", ".", "getXY", "(", "i", ",", "pt_a", ")", ";", "if", "(", "!", "env_b_inflated", ".", "contains", "(", "pt_a", ")", ")", "return", "false", ";", "if", "(", "env_b_deflated", ".", "containsExclusive", "(", "pt_a", ")", ")", "b_interior", "=", "true", ";", "}", "return", "b_interior", ";", "}"], "docstring": "Returns true if multipoint_a is within envelope_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "is", "within", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2537-L2615", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointContainsEnvelope_", "original_string": "private static boolean multiPointContainsEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance || env_b.getWidth() > tolerance)\n\t\t\treturn false;\n\n\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\treturn !multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean multiPointContainsEnvelope_(MultiPoint multipoint_a,\n\t\t\tEnvelope envelope_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tenvelope_b.queryEnvelope2D(env_b);\n\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() > tolerance || env_b.getWidth() > tolerance)\n\t\t\treturn false;\n\n\t\tPoint2D pt_b = envelope_b.getCenterXY();\n\t\treturn !multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointContainsEnvelope_", "(", "MultiPoint", "multipoint_a", ",", "Envelope", "envelope_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "envelope_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "Point2D", "pt_b", "=", "envelope_b", ".", "getCenterXY", "(", ")", ";", "return", "!", "multiPointDisjointPointImpl_", "(", "multipoint_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if multipoint_a contains envelope_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "contains", "envelope_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2618-L2634", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.pointEqualsPoint_", "original_string": "private static boolean pointEqualsPoint_(Point2D pt_a, Point2D pt_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tif (Point2D.sqrDistance(pt_a, pt_b) <= tolerance * tolerance)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean pointEqualsPoint_(Point2D pt_a, Point2D pt_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tif (Point2D.sqrDistance(pt_a, pt_b) <= tolerance * tolerance)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "pointEqualsPoint_", "(", "Point2D", "pt_a", ",", "Point2D", "pt_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "Point2D", ".", "sqrDistance", "(", "pt_a", ",", "pt_b", ")", "<=", "tolerance", "*", "tolerance", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Returns true if pt_a equals pt_b.", "docstring_tokens": ["Returns", "true", "if", "pt_a", "equals", "pt_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2721-L2727", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.pointContainsPoint_", "original_string": "private static boolean pointContainsPoint_(Point2D pt_a, Point2D pt_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\treturn pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\t}", "language": "java", "code": "private static boolean pointContainsPoint_(Point2D pt_a, Point2D pt_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\treturn pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "pointContainsPoint_", "(", "Point2D", "pt_a", ",", "Point2D", "pt_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "pointEqualsPoint_", "(", "pt_a", ",", "pt_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if pt_a contains pt_b.", "docstring_tokens": ["Returns", "true", "if", "pt_a", "contains", "pt_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2739-L2742", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.pointEqualsEnvelope_", "original_string": "private static boolean pointEqualsEnvelope_(Point2D pt_a, Envelope2D env_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tenv_a.setCoords(pt_a);\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "language": "java", "code": "private static boolean pointEqualsEnvelope_(Point2D pt_a, Envelope2D env_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tenv_a.setCoords(pt_a);\n\t\treturn envelopeEqualsEnvelope_(env_a, env_b, tolerance,\n\t\t\t\tprogress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "pointEqualsEnvelope_", "(", "Point2D", "pt_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "env_a", ".", "setCoords", "(", "pt_a", ")", ";", "return", "envelopeEqualsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if pt_a equals enve_b.", "docstring_tokens": ["Returns", "true", "if", "pt_a", "equals", "enve_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2745-L2751", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.pointDisjointEnvelope_", "original_string": "static boolean pointDisjointEnvelope_(Point2D pt_a, Envelope2D env_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\treturn !env_b_inflated.contains(pt_a);\n\t}", "language": "java", "code": "static boolean pointDisjointEnvelope_(Point2D pt_a, Envelope2D env_b,\n\t\t\tdouble tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\treturn !env_b_inflated.contains(pt_a);\n\t}", "code_tokens": ["static", "boolean", "pointDisjointEnvelope_", "(", "Point2D", "pt_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "return", "!", "env_b_inflated", ".", "contains", "(", "pt_a", ")", ";", "}"], "docstring": "Returns true if pt_a is disjoint from env_b.", "docstring_tokens": ["Returns", "true", "if", "pt_a", "is", "disjoint", "from", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2754-L2760", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.pointTouchesEnvelope_", "original_string": "private static boolean pointTouchesEnvelope_(Point2D pt_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // when treates as a point, points cannot touch points\n\n\t\tEnvelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();\n\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {\n\t\t\tenv_b_deflated.setCoords(env_b);\n\n\t\t\tif (env_b.getHeight() > tolerance)\n\t\t\t\tenv_b_deflated.inflate(0, -tolerance);\n\t\t\telse\n\t\t\t\tenv_b_deflated.inflate(-tolerance, 0);\n\n\t\t\tif (env_b.getHeight() > tolerance) {\n\t\t\t\tif (pt_a.y > env_b_deflated.ymin\n\t\t\t\t\t\t&& pt_a.y < env_b_deflated.ymax)\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (pt_a.x > env_b_deflated.xmin\n\t\t\t\t\t\t&& pt_a.x < env_b_deflated.xmax)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\n\t\tif (env_b_deflated.containsExclusive(pt_a))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean pointTouchesEnvelope_(Point2D pt_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // when treates as a point, points cannot touch points\n\n\t\tEnvelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();\n\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\n\t\tif (!env_b_inflated.contains(pt_a))\n\t\t\treturn false;\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {\n\t\t\tenv_b_deflated.setCoords(env_b);\n\n\t\t\tif (env_b.getHeight() > tolerance)\n\t\t\t\tenv_b_deflated.inflate(0, -tolerance);\n\t\t\telse\n\t\t\t\tenv_b_deflated.inflate(-tolerance, 0);\n\n\t\t\tif (env_b.getHeight() > tolerance) {\n\t\t\t\tif (pt_a.y > env_b_deflated.ymin\n\t\t\t\t\t\t&& pt_a.y < env_b_deflated.ymax)\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (pt_a.x > env_b_deflated.xmin\n\t\t\t\t\t\t&& pt_a.x < env_b_deflated.xmax)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tenv_b_deflated.setCoords(env_b);\n\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\n\t\tif (env_b_deflated.containsExclusive(pt_a))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "pointTouchesEnvelope_", "(", "Point2D", "pt_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// when treates as a point, points cannot touch points", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ",", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "if", "(", "!", "env_b_inflated", ".", "contains", "(", "pt_a", ")", ")", "return", "false", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", ")", "env_b_deflated", ".", "inflate", "(", "0", ",", "-", "tolerance", ")", ";", "else", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "0", ")", ";", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", ")", "{", "if", "(", "pt_a", ".", "y", ">", "env_b_deflated", ".", "ymin", "&&", "pt_a", ".", "y", "<", "env_b_deflated", ".", "ymax", ")", "return", "false", ";", "}", "else", "{", "if", "(", "pt_a", ".", "x", ">", "env_b_deflated", ".", "xmin", "&&", "pt_a", ".", "x", "<", "env_b_deflated", ".", "xmax", ")", "return", "false", ";", "}", "return", "true", ";", "}", "env_b_deflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "if", "(", "env_b_deflated", ".", "containsExclusive", "(", "pt_a", ")", ")", "return", "false", ";", "return", "true", ";", "}"], "docstring": "Returns true if pt_a touches env_b.", "docstring_tokens": ["Returns", "true", "if", "pt_a", "touches", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2763-L2804", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.pointContainsEnvelope_", "original_string": "private static boolean pointContainsEnvelope_(Point2D pt_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn pointEqualsEnvelope_(pt_a, env_b, tolerance, progress_tracker);\n\t}", "language": "java", "code": "private static boolean pointContainsEnvelope_(Point2D pt_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn pointEqualsEnvelope_(pt_a, env_b, tolerance, progress_tracker);\n\t}", "code_tokens": ["private", "static", "boolean", "pointContainsEnvelope_", "(", "Point2D", "pt_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "pointEqualsEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}"], "docstring": "Returns true if pt_a contains env_b.", "docstring_tokens": ["Returns", "true", "if", "pt_a", "contains", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2850-L2853", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.envelopeEqualsEnvelope_", "original_string": "private static boolean envelopeEqualsEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn envelopeInfContainsEnvelope_(env_a, env_b, tolerance)\n\t\t\t\t&& envelopeInfContainsEnvelope_(env_b, env_a, tolerance);\n\t}", "language": "java", "code": "private static boolean envelopeEqualsEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\treturn envelopeInfContainsEnvelope_(env_a, env_b, tolerance)\n\t\t\t\t&& envelopeInfContainsEnvelope_(env_b, env_a, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "envelopeEqualsEnvelope_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "return", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", "&&", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if env_a equals env_b.", "docstring_tokens": ["Returns", "true", "if", "env_a", "equals", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2856-L2860", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.envelopeDisjointEnvelope_", "original_string": "static boolean envelopeDisjointEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\treturn !env_a.isIntersecting(env_b_inflated);\n\t}", "language": "java", "code": "static boolean envelopeDisjointEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\tenv_b_inflated.setCoords(env_b);\n\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\treturn !env_a.isIntersecting(env_b_inflated);\n\t}", "code_tokens": ["static", "boolean", "envelopeDisjointEnvelope_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "return", "!", "env_a", ".", "isIntersecting", "(", "env_b_inflated", ")", ";", "}"], "docstring": "Returns true if env_a is disjoint from env_b.", "docstring_tokens": ["Returns", "true", "if", "env_a", "is", "disjoint", "from", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2863-L2869", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.envelopeTouchesEnvelope_", "original_string": "private static boolean envelopeTouchesEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (env_a.getHeight() <= tolerance && env_a.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_a = env_a.getCenter();\n\t\t\treturn pointTouchesEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = env_b.getCenter();\n\t\t\treturn pointTouchesEnvelope_(pt_b, env_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tEnvelope2D _env_a;\n\t\tEnvelope2D _env_b;\n\n\t\tif (env_a.getHeight() > tolerance\n\t\t\t\t&& env_a.getWidth() > tolerance\n\t\t\t\t&& (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance)) {\n\t\t\t// swap a and b\n\t\t\t_env_a = env_b;\n\t\t\t_env_b = env_a;\n\t\t} else {\n\t\t\t_env_a = env_a;\n\t\t\t_env_b = env_b;\n\t\t}\n\n\t\tif (_env_a.getHeight() <= tolerance || _env_a.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t\tif (_env_b.getHeight() <= tolerance\n\t\t\t\t\t|| _env_b.getWidth() <= tolerance) {// treat env_b as line\n\n\t\t\t\tLine line_a = new Line(), line_b = new Line();\n\t\t\t\tdouble[] scalars_a = new double[2];\n\t\t\t\tdouble[] scalars_b = new double[2];\n\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t_env_a.queryLowerLeft(pt);\n\t\t\t\tline_a.setStartXY(pt);\n\t\t\t\t_env_a.queryUpperRight(pt);\n\t\t\t\tline_a.setEndXY(pt);\n\t\t\t\t_env_b.queryLowerLeft(pt);\n\t\t\t\tline_b.setStartXY(pt);\n\t\t\t\t_env_b.queryUpperRight(pt);\n\t\t\t\tline_b.setEndXY(pt);\n\n\t\t\t\tline_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);\n\t\t\t\tint count = line_a.intersect(line_b, null, null, null,\n\t\t\t\t\t\ttolerance);\n\n\t\t\t\tif (count != 1)\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn scalars_a[0] == 0.0 || scalars_a[1] == 1.0\n\t\t\t\t\t\t|| scalars_b[0] == 0.0 || scalars_b[1] == 1.0;\n\t\t\t}\n\n\t\t\t// treat env_b as area\n\n\t\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_inter = new Envelope2D();\n\t\t\tenv_b_deflated.setCoords(_env_b);\n\t\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\tenv_inter.intersect(_env_a);\n\n\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\treturn false;\n\n\t\t\tassert (!envelopeDisjointEnvelope_(_env_a, _env_b, tolerance,\n\t\t\t\t\tprogress_tracker));\n\t\t\treturn true; // we already know they intersect within a tolerance\n\t\t}\n\n\t\tEnvelope2D env_inter = new Envelope2D();\n\t\tenv_inter.setCoords(_env_a);\n\t\tenv_inter.intersect(_env_b);\n\n\t\tif (!env_inter.isEmpty() && env_inter.getHeight() > tolerance\n\t\t\t\t&& env_inter.getWidth() > tolerance)\n\t\t\treturn false;\n\n\t\treturn true; // we already know they intersect within a tolerance\n\t}", "language": "java", "code": "private static boolean envelopeTouchesEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (env_a.getHeight() <= tolerance && env_a.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_a = env_a.getCenter();\n\t\t\treturn pointTouchesEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n\t\t\tPoint2D pt_b = env_b.getCenter();\n\t\t\treturn pointTouchesEnvelope_(pt_b, env_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tEnvelope2D _env_a;\n\t\tEnvelope2D _env_b;\n\n\t\tif (env_a.getHeight() > tolerance\n\t\t\t\t&& env_a.getWidth() > tolerance\n\t\t\t\t&& (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance)) {\n\t\t\t// swap a and b\n\t\t\t_env_a = env_b;\n\t\t\t_env_b = env_a;\n\t\t} else {\n\t\t\t_env_a = env_a;\n\t\t\t_env_b = env_b;\n\t\t}\n\n\t\tif (_env_a.getHeight() <= tolerance || _env_a.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t\tif (_env_b.getHeight() <= tolerance\n\t\t\t\t\t|| _env_b.getWidth() <= tolerance) {// treat env_b as line\n\n\t\t\t\tLine line_a = new Line(), line_b = new Line();\n\t\t\t\tdouble[] scalars_a = new double[2];\n\t\t\t\tdouble[] scalars_b = new double[2];\n\t\t\t\tPoint2D pt = new Point2D();\n\t\t\t\t_env_a.queryLowerLeft(pt);\n\t\t\t\tline_a.setStartXY(pt);\n\t\t\t\t_env_a.queryUpperRight(pt);\n\t\t\t\tline_a.setEndXY(pt);\n\t\t\t\t_env_b.queryLowerLeft(pt);\n\t\t\t\tline_b.setStartXY(pt);\n\t\t\t\t_env_b.queryUpperRight(pt);\n\t\t\t\tline_b.setEndXY(pt);\n\n\t\t\t\tline_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);\n\t\t\t\tint count = line_a.intersect(line_b, null, null, null,\n\t\t\t\t\t\ttolerance);\n\n\t\t\t\tif (count != 1)\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn scalars_a[0] == 0.0 || scalars_a[1] == 1.0\n\t\t\t\t\t\t|| scalars_b[0] == 0.0 || scalars_b[1] == 1.0;\n\t\t\t}\n\n\t\t\t// treat env_b as area\n\n\t\t\tEnvelope2D env_b_deflated = new Envelope2D(), env_inter = new Envelope2D();\n\t\t\tenv_b_deflated.setCoords(_env_b);\n\t\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\tenv_inter.intersect(_env_a);\n\n\t\t\tif (!env_inter.isEmpty()\n\t\t\t\t\t&& (env_inter.getHeight() > tolerance || env_inter\n\t\t\t\t\t\t\t.getWidth() > tolerance))\n\t\t\t\treturn false;\n\n\t\t\tassert (!envelopeDisjointEnvelope_(_env_a, _env_b, tolerance,\n\t\t\t\t\tprogress_tracker));\n\t\t\treturn true; // we already know they intersect within a tolerance\n\t\t}\n\n\t\tEnvelope2D env_inter = new Envelope2D();\n\t\tenv_inter.setCoords(_env_a);\n\t\tenv_inter.intersect(_env_b);\n\n\t\tif (!env_inter.isEmpty() && env_inter.getHeight() > tolerance\n\t\t\t\t&& env_inter.getWidth() > tolerance)\n\t\t\treturn false;\n\n\t\treturn true; // we already know they intersect within a tolerance\n\t}", "code_tokens": ["private", "static", "boolean", "envelopeTouchesEnvelope_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "env_a", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_a", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// env_a", "// as", "// point", "Point2D", "pt_a", "=", "env_a", ".", "getCenter", "(", ")", ";", "return", "pointTouchesEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// env_b", "// as", "// point", "Point2D", "pt_b", "=", "env_b", ".", "getCenter", "(", ")", ";", "return", "pointTouchesEnvelope_", "(", "pt_b", ",", "env_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "Envelope2D", "_env_a", ";", "Envelope2D", "_env_b", ";", "if", "(", "env_a", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_a", ".", "getWidth", "(", ")", ">", "tolerance", "&&", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", ")", "{", "// swap a and b", "_env_a", "=", "env_b", ";", "_env_b", "=", "env_a", ";", "}", "else", "{", "_env_a", "=", "env_a", ";", "_env_b", "=", "env_b", ";", "}", "if", "(", "_env_a", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "_env_a", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// env_a", "// as", "// line", "if", "(", "_env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "_env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat env_b as line", "Line", "line_a", "=", "new", "Line", "(", ")", ",", "line_b", "=", "new", "Line", "(", ")", ";", "double", "[", "]", "scalars_a", "=", "new", "double", "[", "2", "]", ";", "double", "[", "]", "scalars_b", "=", "new", "double", "[", "2", "]", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "_env_a", ".", "queryLowerLeft", "(", "pt", ")", ";", "line_a", ".", "setStartXY", "(", "pt", ")", ";", "_env_a", ".", "queryUpperRight", "(", "pt", ")", ";", "line_a", ".", "setEndXY", "(", "pt", ")", ";", "_env_b", ".", "queryLowerLeft", "(", "pt", ")", ";", "line_b", ".", "setStartXY", "(", "pt", ")", ";", "_env_b", ".", "queryUpperRight", "(", "pt", ")", ";", "line_b", ".", "setEndXY", "(", "pt", ")", ";", "line_a", ".", "intersect", "(", "line_b", ",", "null", ",", "scalars_a", ",", "scalars_b", ",", "tolerance", ")", ";", "int", "count", "=", "line_a", ".", "intersect", "(", "line_b", ",", "null", ",", "null", ",", "null", ",", "tolerance", ")", ";", "if", "(", "count", "!=", "1", ")", "return", "false", ";", "return", "scalars_a", "[", "0", "]", "==", "0.0", "||", "scalars_a", "[", "1", "]", "==", "1.0", "||", "scalars_b", "[", "0", "]", "==", "0.0", "||", "scalars_b", "[", "1", "]", "==", "1.0", ";", "}", "// treat env_b as area", "Envelope2D", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ",", "env_inter", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "_env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "env_inter", ".", "setCoords", "(", "env_b_deflated", ")", ";", "env_inter", ".", "intersect", "(", "_env_a", ")", ";", "if", "(", "!", "env_inter", ".", "isEmpty", "(", ")", "&&", "(", "env_inter", ".", "getHeight", "(", ")", ">", "tolerance", "||", "env_inter", ".", "getWidth", "(", ")", ">", "tolerance", ")", ")", "return", "false", ";", "assert", "(", "!", "envelopeDisjointEnvelope_", "(", "_env_a", ",", "_env_b", ",", "tolerance", ",", "progress_tracker", ")", ")", ";", "return", "true", ";", "// we already know they intersect within a tolerance", "}", "Envelope2D", "env_inter", "=", "new", "Envelope2D", "(", ")", ";", "env_inter", ".", "setCoords", "(", "_env_a", ")", ";", "env_inter", ".", "intersect", "(", "_env_b", ")", ";", "if", "(", "!", "env_inter", ".", "isEmpty", "(", ")", "&&", "env_inter", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_inter", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "return", "true", ";", "// we already know they intersect within a tolerance", "}"], "docstring": "Returns true if env_a touches env_b.", "docstring_tokens": ["Returns", "true", "if", "env_a", "touches", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L2872-L2965", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.envelopeContainsEnvelope_", "original_string": "private static boolean envelopeContainsEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_a.getHeight() <= tolerance && env_a.getWidth() <= tolerance) {\n\t\t\tPoint2D pt_a = env_a.getCenter();\n\t\t\treturn pointWithinEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {\n\t\t\tPoint2D pt_b = env_b.getCenter();\n\t\t\treturn pointWithinEnvelope_(pt_b, env_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_a.getHeight() <= tolerance || env_a.getWidth() <= tolerance)\n\t\t\treturn envelopeInfContainsEnvelope_(env_a, env_b, tolerance); // treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t// treat env_a as area\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t\tEnvelope2D env_a_deflated = new Envelope2D();\n\t\t\tenv_a_deflated.setCoords(env_a);\n\t\t\tenv_a_deflated.inflate(-tolerance, -tolerance);\n\n\t\t\tif (env_a_deflated.containsExclusive(env_b))\n\t\t\t\treturn true;\n\n\t\t\tEnvelope2D env_inter = new Envelope2D();\n\t\t\tenv_inter.setCoords(env_a_deflated);\n\t\t\tenv_inter.intersect(env_b);\n\n\t\t\tif (env_inter.isEmpty()\n\t\t\t\t\t|| (env_inter.getHeight() <= tolerance && env_inter\n\t\t\t\t\t\t\t.getWidth() <= tolerance))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn envelopeInfContainsEnvelope_(env_a, env_b, tolerance);\n\t}", "language": "java", "code": "private static boolean envelopeContainsEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_a.getHeight() <= tolerance && env_a.getWidth() <= tolerance) {\n\t\t\tPoint2D pt_a = env_a.getCenter();\n\t\t\treturn pointWithinEnvelope_(pt_a, env_b, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance) {\n\t\t\tPoint2D pt_b = env_b.getCenter();\n\t\t\treturn pointWithinEnvelope_(pt_b, env_a, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t}\n\n\t\tif (env_a.getHeight() <= tolerance || env_a.getWidth() <= tolerance)\n\t\t\treturn envelopeInfContainsEnvelope_(env_a, env_b, tolerance); // treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t// treat env_a as area\n\n\t\tif (env_b.getHeight() <= tolerance || env_b.getWidth() <= tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line\n\n\t\t\tEnvelope2D env_a_deflated = new Envelope2D();\n\t\t\tenv_a_deflated.setCoords(env_a);\n\t\t\tenv_a_deflated.inflate(-tolerance, -tolerance);\n\n\t\t\tif (env_a_deflated.containsExclusive(env_b))\n\t\t\t\treturn true;\n\n\t\t\tEnvelope2D env_inter = new Envelope2D();\n\t\t\tenv_inter.setCoords(env_a_deflated);\n\t\t\tenv_inter.intersect(env_b);\n\n\t\t\tif (env_inter.isEmpty()\n\t\t\t\t\t|| (env_inter.getHeight() <= tolerance && env_inter\n\t\t\t\t\t\t\t.getWidth() <= tolerance))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn envelopeInfContainsEnvelope_(env_a, env_b, tolerance);\n\t}", "code_tokens": ["private", "static", "boolean", "envelopeContainsEnvelope_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_a", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_a", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "Point2D", "pt_a", "=", "env_a", ".", "getCenter", "(", ")", ";", "return", "pointWithinEnvelope_", "(", "pt_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "Point2D", "pt_b", "=", "env_b", ".", "getCenter", "(", ")", ";", "return", "pointWithinEnvelope_", "(", "pt_b", ",", "env_a", ",", "tolerance", ",", "progress_tracker", ")", ";", "}", "if", "(", "env_a", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_a", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ";", "// treat", "// env_b", "// as", "// line", "// treat env_a as area", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "||", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "{", "// treat", "// env_b", "// as", "// line", "Envelope2D", "env_a_deflated", "=", "new", "Envelope2D", "(", ")", ";", "env_a_deflated", ".", "setCoords", "(", "env_a", ")", ";", "env_a_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "if", "(", "env_a_deflated", ".", "containsExclusive", "(", "env_b", ")", ")", "return", "true", ";", "Envelope2D", "env_inter", "=", "new", "Envelope2D", "(", ")", ";", "env_inter", ".", "setCoords", "(", "env_a_deflated", ")", ";", "env_inter", ".", "intersect", "(", "env_b", ")", ";", "if", "(", "env_inter", ".", "isEmpty", "(", ")", "||", "(", "env_inter", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_inter", ".", "getWidth", "(", ")", "<=", "tolerance", ")", ")", "return", "false", ";", "return", "true", ";", "}", "return", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ";", "}"], "docstring": "Returns true if env_a contains env_b.", "docstring_tokens": ["Returns", "true", "if", "env_a", "contains", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3037-L3087", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.envelopeCrossesEnvelope_", "original_string": "private static boolean envelopeCrossesEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)\n\t\t\t\t|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_a.getHeight() <= tolerance && env_a.getWidth() <= tolerance)\n\t\t\treturn false; // points cannot cross\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // points cannot cross\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance) {\n\t\t\tif (env_a.getHeight() > tolerance && env_a.getWidth() > tolerance)\n\t\t\t\treturn false; // areas cannot cross\n\t\t}\n\n\t\tEnvelope2D _env_a;\n\t\tEnvelope2D _env_b;\n\n\t\tif (env_a.getHeight() > tolerance && env_a.getWidth() > tolerance) {\n\t\t\t// swap b and a\n\t\t\t_env_a = env_b;\n\t\t\t_env_b = env_a;\n\t\t} else {\n\t\t\t_env_a = env_a;\n\t\t\t_env_b = env_b;\n\t\t}\n\n\t\tif (_env_b.getHeight() > tolerance && _env_b.getWidth() > tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// area\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (env_a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line);\n\n\t\t\tEnvelope2D env_inter = new Envelope2D(), env_b_deflated = new Envelope2D();\n\t\t\tenv_b_deflated.setCoords(_env_b);\n\t\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\tenv_inter.intersect(_env_a);\n\n\t\t\tif (env_inter.isEmpty())\n\t\t\t\treturn false;\n\n\t\t\tif (env_inter.getHeight() <= tolerance\n\t\t\t\t\t&& env_inter.getWidth() <= tolerance)\n\t\t\t\treturn false; // not a line\n\n\t\t\tassert (!envelopeInfContainsEnvelope_(env_inter, _env_a, tolerance));\n\t\t\treturn true;\n\t\t}\n\n\t\t// treat both as lines\n\n\t\tLine line_a = new Line(), line_b = new Line();\n\t\tdouble[] scalars_a = new double[2];\n\t\tdouble[] scalars_b = new double[2];\n\t\tPoint2D pt = new Point2D();\n\t\t_env_a.queryLowerLeft(pt);\n\t\tline_a.setStartXY(pt);\n\t\t_env_a.queryUpperRight(pt);\n\t\tline_a.setEndXY(pt);\n\t\t_env_b.queryLowerLeft(pt);\n\t\tline_b.setStartXY(pt);\n\t\t_env_b.queryUpperRight(pt);\n\t\tline_b.setEndXY(pt);\n\n\t\tline_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);\n\t\tint count = line_a.intersect(line_b, null, null, null, tolerance);\n\n\t\tif (count != 1)\n\t\t\treturn false;\n\n\t\treturn scalars_a[0] > 0.0 && scalars_a[1] < 1.0 && scalars_b[0] > 0.0\n\t\t\t\t&& scalars_b[1] < 1.0;\n\t}", "language": "java", "code": "private static boolean envelopeCrossesEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)\n\t\t\t\t|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))\n\t\t\treturn false;\n\n\t\tif (env_a.getHeight() <= tolerance && env_a.getWidth() <= tolerance)\n\t\t\treturn false; // points cannot cross\n\n\t\tif (env_b.getHeight() <= tolerance && env_b.getWidth() <= tolerance)\n\t\t\treturn false; // points cannot cross\n\n\t\tif (env_b.getHeight() > tolerance && env_b.getWidth() > tolerance) {\n\t\t\tif (env_a.getHeight() > tolerance && env_a.getWidth() > tolerance)\n\t\t\t\treturn false; // areas cannot cross\n\t\t}\n\n\t\tEnvelope2D _env_a;\n\t\tEnvelope2D _env_b;\n\n\t\tif (env_a.getHeight() > tolerance && env_a.getWidth() > tolerance) {\n\t\t\t// swap b and a\n\t\t\t_env_a = env_b;\n\t\t\t_env_b = env_a;\n\t\t} else {\n\t\t\t_env_a = env_a;\n\t\t\t_env_b = env_b;\n\t\t}\n\n\t\tif (_env_b.getHeight() > tolerance && _env_b.getWidth() > tolerance) {// treat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// env_b\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// area\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (env_a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// line);\n\n\t\t\tEnvelope2D env_inter = new Envelope2D(), env_b_deflated = new Envelope2D();\n\t\t\tenv_b_deflated.setCoords(_env_b);\n\t\t\tenv_b_deflated.inflate(-tolerance, -tolerance);\n\t\t\tenv_inter.setCoords(env_b_deflated);\n\t\t\tenv_inter.intersect(_env_a);\n\n\t\t\tif (env_inter.isEmpty())\n\t\t\t\treturn false;\n\n\t\t\tif (env_inter.getHeight() <= tolerance\n\t\t\t\t\t&& env_inter.getWidth() <= tolerance)\n\t\t\t\treturn false; // not a line\n\n\t\t\tassert (!envelopeInfContainsEnvelope_(env_inter, _env_a, tolerance));\n\t\t\treturn true;\n\t\t}\n\n\t\t// treat both as lines\n\n\t\tLine line_a = new Line(), line_b = new Line();\n\t\tdouble[] scalars_a = new double[2];\n\t\tdouble[] scalars_b = new double[2];\n\t\tPoint2D pt = new Point2D();\n\t\t_env_a.queryLowerLeft(pt);\n\t\tline_a.setStartXY(pt);\n\t\t_env_a.queryUpperRight(pt);\n\t\tline_a.setEndXY(pt);\n\t\t_env_b.queryLowerLeft(pt);\n\t\tline_b.setStartXY(pt);\n\t\t_env_b.queryUpperRight(pt);\n\t\tline_b.setEndXY(pt);\n\n\t\tline_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);\n\t\tint count = line_a.intersect(line_b, null, null, null, tolerance);\n\n\t\tif (count != 1)\n\t\t\treturn false;\n\n\t\treturn scalars_a[0] > 0.0 && scalars_a[1] < 1.0 && scalars_b[0] > 0.0\n\t\t\t\t&& scalars_b[1] < 1.0;\n\t}", "code_tokens": ["private", "static", "boolean", "envelopeCrossesEnvelope_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "envelopeInfContainsEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", "||", "envelopeInfContainsEnvelope_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ")", "return", "false", ";", "if", "(", "env_a", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_a", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// points cannot cross", "if", "(", "env_b", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// points cannot cross", "if", "(", "env_b", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "{", "if", "(", "env_a", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_a", ".", "getWidth", "(", ")", ">", "tolerance", ")", "return", "false", ";", "// areas cannot cross", "}", "Envelope2D", "_env_a", ";", "Envelope2D", "_env_b", ";", "if", "(", "env_a", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "env_a", ".", "getWidth", "(", ")", ">", "tolerance", ")", "{", "// swap b and a", "_env_a", "=", "env_b", ";", "_env_b", "=", "env_a", ";", "}", "else", "{", "_env_a", "=", "env_a", ";", "_env_b", "=", "env_b", ";", "}", "if", "(", "_env_b", ".", "getHeight", "(", ")", ">", "tolerance", "&&", "_env_b", ".", "getWidth", "(", ")", ">", "tolerance", ")", "{", "// treat", "// env_b", "// as", "// an", "// area", "// (env_a", "// as", "// a", "// line);", "Envelope2D", "env_inter", "=", "new", "Envelope2D", "(", ")", ",", "env_b_deflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_deflated", ".", "setCoords", "(", "_env_b", ")", ";", "env_b_deflated", ".", "inflate", "(", "-", "tolerance", ",", "-", "tolerance", ")", ";", "env_inter", ".", "setCoords", "(", "env_b_deflated", ")", ";", "env_inter", ".", "intersect", "(", "_env_a", ")", ";", "if", "(", "env_inter", ".", "isEmpty", "(", ")", ")", "return", "false", ";", "if", "(", "env_inter", ".", "getHeight", "(", ")", "<=", "tolerance", "&&", "env_inter", ".", "getWidth", "(", ")", "<=", "tolerance", ")", "return", "false", ";", "// not a line", "assert", "(", "!", "envelopeInfContainsEnvelope_", "(", "env_inter", ",", "_env_a", ",", "tolerance", ")", ")", ";", "return", "true", ";", "}", "// treat both as lines", "Line", "line_a", "=", "new", "Line", "(", ")", ",", "line_b", "=", "new", "Line", "(", ")", ";", "double", "[", "]", "scalars_a", "=", "new", "double", "[", "2", "]", ";", "double", "[", "]", "scalars_b", "=", "new", "double", "[", "2", "]", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "_env_a", ".", "queryLowerLeft", "(", "pt", ")", ";", "line_a", ".", "setStartXY", "(", "pt", ")", ";", "_env_a", ".", "queryUpperRight", "(", "pt", ")", ";", "line_a", ".", "setEndXY", "(", "pt", ")", ";", "_env_b", ".", "queryLowerLeft", "(", "pt", ")", ";", "line_b", ".", "setStartXY", "(", "pt", ")", ";", "_env_b", ".", "queryUpperRight", "(", "pt", ")", ";", "line_b", ".", "setEndXY", "(", "pt", ")", ";", "line_a", ".", "intersect", "(", "line_b", ",", "null", ",", "scalars_a", ",", "scalars_b", ",", "tolerance", ")", ";", "int", "count", "=", "line_a", ".", "intersect", "(", "line_b", ",", "null", ",", "null", ",", "null", ",", "tolerance", ")", ";", "if", "(", "count", "!=", "1", ")", "return", "false", ";", "return", "scalars_a", "[", "0", "]", ">", "0.0", "&&", "scalars_a", "[", "1", "]", "<", "1.0", "&&", "scalars_b", "[", "0", "]", ">", "0.0", "&&", "scalars_b", "[", "1", "]", "<", "1.0", ";", "}"], "docstring": "Returns true if env_a crosses env_b.", "docstring_tokens": ["Returns", "true", "if", "env_a", "crosses", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3090-L3169", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.polygonDisjointMultiPath_", "original_string": "private static boolean polygonDisjointMultiPath_(Polygon polygon_a,\n\t\t\tMultiPath multipath_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n        Point2D pt_a, pt_b;\n        Envelope2D env_a_inf = new Envelope2D(), env_b_inf = new Envelope2D();\n\n        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polygon_a._getImpl();\n        MultiPathImpl multi_path_impl_b = (MultiPathImpl)multipath_b._getImpl();\n\n        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);\n\n        if (!intersector.next())\n            return true; // no rings intersect\n\n        boolean b_intersects = linearPathIntersectsLinearPath_(polygon_a, multipath_b, tolerance);\n\n        if (b_intersects)\n            return false;\n\n        Polygon pa = null;\n        Polygon p_polygon_a = polygon_a;\n\n        Polygon pb = null;\n        Polygon p_polygon_b = null;\n\n        if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)\n            p_polygon_b = (Polygon)multipath_b;\n\n        boolean b_checked_polygon_a_quad_tree = false;\n        boolean b_checked_polygon_b_quad_tree = false;\n\n        do\n        {\n            int path_a = intersector.getRedElement();\n            int path_b = intersector.getBlueElement();\n\n            pt_b = multipath_b.getXY(multipath_b.getPathStart(path_b));\n            env_a_inf.setCoords(intersector.getRedEnvelope());\n            env_a_inf.inflate(tolerance, tolerance);\n\n            if (env_a_inf.contains(pt_b))\n            {\n                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, pt_b, 0.0);\n\n                if (result != PolygonUtils.PiPResult.PiPOutside)\n                    return false;\n            }\n\n            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)\n            {\n                pt_a = polygon_a.getXY(polygon_a.getPathStart(path_a));\n                env_b_inf.setCoords(intersector.getBlueEnvelope());\n                env_b_inf.inflate(tolerance, tolerance);\n\n                if (env_b_inf.contains(pt_a))\n                {\n                    PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_b, pt_a, 0.0);\n\n                    if (result != PolygonUtils.PiPResult.PiPOutside)\n                        return false;\n                }\n            }\n\n            if (!b_checked_polygon_a_quad_tree) {\n                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipath_b.getPathCount() - 1) && (multi_path_impl_a._getAccelerators() == null || multi_path_impl_a._getAccelerators().getQuadTree() == null)) {\n                    pa = new Polygon();\n                    polygon_a.copyTo(pa);\n                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                    p_polygon_a = pa;\n                } else {\n                    p_polygon_a = polygon_a;\n                }\n\n                b_checked_polygon_a_quad_tree = true;\n            }\n\n            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)\n            {\n                if (!b_checked_polygon_b_quad_tree) {\n                    Polygon polygon_b = (Polygon) multipath_b;\n                    if (PointInPolygonHelper.quadTreeWillHelp(polygon_b, polygon_a.getPathCount() - 1) && (multi_path_impl_b._getAccelerators() == null || multi_path_impl_b._getAccelerators().getQuadTree() == null)) {\n                        pb = new Polygon();\n                        polygon_b.copyTo(pb);\n                        ((MultiPathImpl) pb._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                        p_polygon_b = pb;\n                    } else {\n                        p_polygon_b = (Polygon) multipath_b;\n                    }\n\n                    b_checked_polygon_b_quad_tree = true;\n                }\n            }\n\n        } while (intersector.next());\n\n        return true;\n\t}", "language": "java", "code": "private static boolean polygonDisjointMultiPath_(Polygon polygon_a,\n\t\t\tMultiPath multipath_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n        Point2D pt_a, pt_b;\n        Envelope2D env_a_inf = new Envelope2D(), env_b_inf = new Envelope2D();\n\n        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polygon_a._getImpl();\n        MultiPathImpl multi_path_impl_b = (MultiPathImpl)multipath_b._getImpl();\n\n        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);\n\n        if (!intersector.next())\n            return true; // no rings intersect\n\n        boolean b_intersects = linearPathIntersectsLinearPath_(polygon_a, multipath_b, tolerance);\n\n        if (b_intersects)\n            return false;\n\n        Polygon pa = null;\n        Polygon p_polygon_a = polygon_a;\n\n        Polygon pb = null;\n        Polygon p_polygon_b = null;\n\n        if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)\n            p_polygon_b = (Polygon)multipath_b;\n\n        boolean b_checked_polygon_a_quad_tree = false;\n        boolean b_checked_polygon_b_quad_tree = false;\n\n        do\n        {\n            int path_a = intersector.getRedElement();\n            int path_b = intersector.getBlueElement();\n\n            pt_b = multipath_b.getXY(multipath_b.getPathStart(path_b));\n            env_a_inf.setCoords(intersector.getRedEnvelope());\n            env_a_inf.inflate(tolerance, tolerance);\n\n            if (env_a_inf.contains(pt_b))\n            {\n                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, pt_b, 0.0);\n\n                if (result != PolygonUtils.PiPResult.PiPOutside)\n                    return false;\n            }\n\n            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)\n            {\n                pt_a = polygon_a.getXY(polygon_a.getPathStart(path_a));\n                env_b_inf.setCoords(intersector.getBlueEnvelope());\n                env_b_inf.inflate(tolerance, tolerance);\n\n                if (env_b_inf.contains(pt_a))\n                {\n                    PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_b, pt_a, 0.0);\n\n                    if (result != PolygonUtils.PiPResult.PiPOutside)\n                        return false;\n                }\n            }\n\n            if (!b_checked_polygon_a_quad_tree) {\n                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipath_b.getPathCount() - 1) && (multi_path_impl_a._getAccelerators() == null || multi_path_impl_a._getAccelerators().getQuadTree() == null)) {\n                    pa = new Polygon();\n                    polygon_a.copyTo(pa);\n                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                    p_polygon_a = pa;\n                } else {\n                    p_polygon_a = polygon_a;\n                }\n\n                b_checked_polygon_a_quad_tree = true;\n            }\n\n            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)\n            {\n                if (!b_checked_polygon_b_quad_tree) {\n                    Polygon polygon_b = (Polygon) multipath_b;\n                    if (PointInPolygonHelper.quadTreeWillHelp(polygon_b, polygon_a.getPathCount() - 1) && (multi_path_impl_b._getAccelerators() == null || multi_path_impl_b._getAccelerators().getQuadTree() == null)) {\n                        pb = new Polygon();\n                        polygon_b.copyTo(pb);\n                        ((MultiPathImpl) pb._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);\n                        p_polygon_b = pb;\n                    } else {\n                        p_polygon_b = (Polygon) multipath_b;\n                    }\n\n                    b_checked_polygon_b_quad_tree = true;\n                }\n            }\n\n        } while (intersector.next());\n\n        return true;\n\t}", "code_tokens": ["private", "static", "boolean", "polygonDisjointMultiPath_", "(", "Polygon", "polygon_a", ",", "MultiPath", "multipath_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "Point2D", "pt_a", ",", "pt_b", ";", "Envelope2D", "env_a_inf", "=", "new", "Envelope2D", "(", ")", ",", "env_b_inf", "=", "new", "Envelope2D", "(", ")", ";", "MultiPathImpl", "multi_path_impl_a", "=", "(", "MultiPathImpl", ")", "polygon_a", ".", "_getImpl", "(", ")", ";", "MultiPathImpl", "multi_path_impl_b", "=", "(", "MultiPathImpl", ")", "multipath_b", ".", "_getImpl", "(", ")", ";", "PairwiseIntersectorImpl", "intersector", "=", "new", "PairwiseIntersectorImpl", "(", "multi_path_impl_a", ",", "multi_path_impl_b", ",", "tolerance", ",", "true", ")", ";", "if", "(", "!", "intersector", ".", "next", "(", ")", ")", "return", "true", ";", "// no rings intersect", "boolean", "b_intersects", "=", "linearPathIntersectsLinearPath_", "(", "polygon_a", ",", "multipath_b", ",", "tolerance", ")", ";", "if", "(", "b_intersects", ")", "return", "false", ";", "Polygon", "pa", "=", "null", ";", "Polygon", "p_polygon_a", "=", "polygon_a", ";", "Polygon", "pb", "=", "null", ";", "Polygon", "p_polygon_b", "=", "null", ";", "if", "(", "multipath_b", ".", "getType", "(", ")", ".", "value", "(", ")", "==", "Geometry", ".", "GeometryType", ".", "Polygon", ")", "p_polygon_b", "=", "(", "Polygon", ")", "multipath_b", ";", "boolean", "b_checked_polygon_a_quad_tree", "=", "false", ";", "boolean", "b_checked_polygon_b_quad_tree", "=", "false", ";", "do", "{", "int", "path_a", "=", "intersector", ".", "getRedElement", "(", ")", ";", "int", "path_b", "=", "intersector", ".", "getBlueElement", "(", ")", ";", "pt_b", "=", "multipath_b", ".", "getXY", "(", "multipath_b", ".", "getPathStart", "(", "path_b", ")", ")", ";", "env_a_inf", ".", "setCoords", "(", "intersector", ".", "getRedEnvelope", "(", ")", ")", ";", "env_a_inf", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "if", "(", "env_a_inf", ".", "contains", "(", "pt_b", ")", ")", "{", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "p_polygon_a", ",", "pt_b", ",", "0.0", ")", ";", "if", "(", "result", "!=", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "}", "if", "(", "multipath_b", ".", "getType", "(", ")", ".", "value", "(", ")", "==", "Geometry", ".", "GeometryType", ".", "Polygon", ")", "{", "pt_a", "=", "polygon_a", ".", "getXY", "(", "polygon_a", ".", "getPathStart", "(", "path_a", ")", ")", ";", "env_b_inf", ".", "setCoords", "(", "intersector", ".", "getBlueEnvelope", "(", ")", ")", ";", "env_b_inf", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "if", "(", "env_b_inf", ".", "contains", "(", "pt_a", ")", ")", "{", "PolygonUtils", ".", "PiPResult", "result", "=", "PolygonUtils", ".", "isPointInPolygon2D", "(", "p_polygon_b", ",", "pt_a", ",", "0.0", ")", ";", "if", "(", "result", "!=", "PolygonUtils", ".", "PiPResult", ".", "PiPOutside", ")", "return", "false", ";", "}", "}", "if", "(", "!", "b_checked_polygon_a_quad_tree", ")", "{", "if", "(", "PointInPolygonHelper", ".", "quadTreeWillHelp", "(", "polygon_a", ",", "multipath_b", ".", "getPathCount", "(", ")", "-", "1", ")", "&&", "(", "multi_path_impl_a", ".", "_getAccelerators", "(", ")", "==", "null", "||", "multi_path_impl_a", ".", "_getAccelerators", "(", ")", ".", "getQuadTree", "(", ")", "==", "null", ")", ")", "{", "pa", "=", "new", "Polygon", "(", ")", ";", "polygon_a", ".", "copyTo", "(", "pa", ")", ";", "(", "(", "MultiPathImpl", ")", "pa", ".", "_getImpl", "(", ")", ")", ".", "_buildQuadTreeAccelerator", "(", "Geometry", ".", "GeometryAccelerationDegree", ".", "enumMedium", ")", ";", "p_polygon_a", "=", "pa", ";", "}", "else", "{", "p_polygon_a", "=", "polygon_a", ";", "}", "b_checked_polygon_a_quad_tree", "=", "true", ";", "}", "if", "(", "multipath_b", ".", "getType", "(", ")", ".", "value", "(", ")", "==", "Geometry", ".", "GeometryType", ".", "Polygon", ")", "{", "if", "(", "!", "b_checked_polygon_b_quad_tree", ")", "{", "Polygon", "polygon_b", "=", "(", "Polygon", ")", "multipath_b", ";", "if", "(", "PointInPolygonHelper", ".", "quadTreeWillHelp", "(", "polygon_b", ",", "polygon_a", ".", "getPathCount", "(", ")", "-", "1", ")", "&&", "(", "multi_path_impl_b", ".", "_getAccelerators", "(", ")", "==", "null", "||", "multi_path_impl_b", ".", "_getAccelerators", "(", ")", ".", "getQuadTree", "(", ")", "==", "null", ")", ")", "{", "pb", "=", "new", "Polygon", "(", ")", ";", "polygon_b", ".", "copyTo", "(", "pb", ")", ";", "(", "(", "MultiPathImpl", ")", "pb", ".", "_getImpl", "(", ")", ")", ".", "_buildQuadTreeAccelerator", "(", "Geometry", ".", "GeometryAccelerationDegree", ".", "enumMedium", ")", ";", "p_polygon_b", "=", "pb", ";", "}", "else", "{", "p_polygon_b", "=", "(", "Polygon", ")", "multipath_b", ";", "}", "b_checked_polygon_b_quad_tree", "=", "true", ";", "}", "}", "}", "while", "(", "intersector", ".", "next", "(", ")", ")", ";", "return", "true", ";", "}"], "docstring": "Returns true if polygon_a is disjoint from multipath_b.", "docstring_tokens": ["Returns", "true", "if", "polygon_a", "is", "disjoint", "from", "multipath_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3172-L3268", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.envelopeInfContainsEnvelope_", "original_string": "private static boolean envelopeInfContainsEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance) {\n\t\tEnvelope2D env_a_inflated = new Envelope2D();\n\t\tenv_a_inflated.setCoords(env_a);\n\t\tenv_a_inflated.inflate(tolerance, tolerance);\n\t\treturn env_a_inflated.contains(env_b);\n\t}", "language": "java", "code": "private static boolean envelopeInfContainsEnvelope_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance) {\n\t\tEnvelope2D env_a_inflated = new Envelope2D();\n\t\tenv_a_inflated.setCoords(env_a);\n\t\tenv_a_inflated.inflate(tolerance, tolerance);\n\t\treturn env_a_inflated.contains(env_b);\n\t}", "code_tokens": ["private", "static", "boolean", "envelopeInfContainsEnvelope_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ")", "{", "Envelope2D", "env_a_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_a_inflated", ".", "setCoords", "(", "env_a", ")", ";", "env_a_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "return", "env_a_inflated", ".", "contains", "(", "env_b", ")", ";", "}"], "docstring": "Returns true if env_a inflated contains env_b.", "docstring_tokens": ["Returns", "true", "if", "env_a", "inflated", "contains", "env_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3271-L3277", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.interiorEnvExteriorEnv_", "original_string": "private static boolean interiorEnvExteriorEnv_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance) {\n\t\tEnvelope2D envBInflated = new Envelope2D();\n\t\tenvBInflated.setCoords(env_b);\n\t\tenvBInflated.inflate(tolerance, tolerance);\n\t\tPoint2D pt = new Point2D();\n\n\t\tenv_a.queryLowerLeft(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tenv_a.queryLowerRight(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tenv_a.queryUpperLeft(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tenv_a.queryUpperRight(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tassert (envBInflated.contains(env_a));\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean interiorEnvExteriorEnv_(Envelope2D env_a,\n\t\t\tEnvelope2D env_b, double tolerance) {\n\t\tEnvelope2D envBInflated = new Envelope2D();\n\t\tenvBInflated.setCoords(env_b);\n\t\tenvBInflated.inflate(tolerance, tolerance);\n\t\tPoint2D pt = new Point2D();\n\n\t\tenv_a.queryLowerLeft(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tenv_a.queryLowerRight(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tenv_a.queryUpperLeft(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tenv_a.queryUpperRight(pt);\n\t\tif (!envBInflated.contains(pt))\n\t\t\treturn true;\n\n\t\tassert (envBInflated.contains(env_a));\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "interiorEnvExteriorEnv_", "(", "Envelope2D", "env_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ")", "{", "Envelope2D", "envBInflated", "=", "new", "Envelope2D", "(", ")", ";", "envBInflated", ".", "setCoords", "(", "env_b", ")", ";", "envBInflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "env_a", ".", "queryLowerLeft", "(", "pt", ")", ";", "if", "(", "!", "envBInflated", ".", "contains", "(", "pt", ")", ")", "return", "true", ";", "env_a", ".", "queryLowerRight", "(", "pt", ")", ";", "if", "(", "!", "envBInflated", ".", "contains", "(", "pt", ")", ")", "return", "true", ";", "env_a", ".", "queryUpperLeft", "(", "pt", ")", ";", "if", "(", "!", "envBInflated", ".", "contains", "(", "pt", ")", ")", "return", "true", ";", "env_a", ".", "queryUpperRight", "(", "pt", ")", ";", "if", "(", "!", "envBInflated", ".", "contains", "(", "pt", ")", ")", "return", "true", ";", "assert", "(", "envBInflated", ".", "contains", "(", "env_a", ")", ")", ";", "return", "false", ";", "}"], "docstring": "Returns true if a coordinate of envelope A is outside of envelope B.", "docstring_tokens": ["Returns", "true", "if", "a", "coordinate", "of", "envelope", "A", "is", "outside", "of", "envelope", "B", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3280-L3305", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPathExactlyEqualsMultiPath_", "original_string": "private static boolean multiPathExactlyEqualsMultiPath_(\n\t\t\tMultiPath multipathA, MultiPath multipathB, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (multipathA.getPathCount() != multipathB.getPathCount()\n\t\t\t\t|| multipathA.getPointCount() != multipathB.getPointCount())\n\t\t\treturn false;\n\n\t\tPoint2D ptA = new Point2D(), ptB = new Point2D();\n\t\tboolean bAllPointsEqual = true;\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tfor (int ipath = 0; ipath < multipathA.getPathCount(); ipath++) {\n\t\t\tif (multipathA.getPathEnd(ipath) != multipathB.getPathEnd(ipath)) {\n\t\t\t\tbAllPointsEqual = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = multipathA.getPathStart(ipath); i < multipathB\n\t\t\t\t\t.getPathEnd(ipath); i++) {\n\t\t\t\tmultipathA.getXY(i, ptA);\n\t\t\t\tmultipathB.getXY(i, ptB);\n\n\t\t\t\tif (Point2D.sqrDistance(ptA, ptB) > tolerance_sq) {\n\t\t\t\t\tbAllPointsEqual = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bAllPointsEqual)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bAllPointsEqual)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean multiPathExactlyEqualsMultiPath_(\n\t\t\tMultiPath multipathA, MultiPath multipathB, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (multipathA.getPathCount() != multipathB.getPathCount()\n\t\t\t\t|| multipathA.getPointCount() != multipathB.getPointCount())\n\t\t\treturn false;\n\n\t\tPoint2D ptA = new Point2D(), ptB = new Point2D();\n\t\tboolean bAllPointsEqual = true;\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tfor (int ipath = 0; ipath < multipathA.getPathCount(); ipath++) {\n\t\t\tif (multipathA.getPathEnd(ipath) != multipathB.getPathEnd(ipath)) {\n\t\t\t\tbAllPointsEqual = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = multipathA.getPathStart(ipath); i < multipathB\n\t\t\t\t\t.getPathEnd(ipath); i++) {\n\t\t\t\tmultipathA.getXY(i, ptA);\n\t\t\t\tmultipathB.getXY(i, ptB);\n\n\t\t\t\tif (Point2D.sqrDistance(ptA, ptB) > tolerance_sq) {\n\t\t\t\t\tbAllPointsEqual = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bAllPointsEqual)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bAllPointsEqual)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPathExactlyEqualsMultiPath_", "(", "MultiPath", "multipathA", ",", "MultiPath", "multipathB", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "multipathA", ".", "getPathCount", "(", ")", "!=", "multipathB", ".", "getPathCount", "(", ")", "||", "multipathA", ".", "getPointCount", "(", ")", "!=", "multipathB", ".", "getPointCount", "(", ")", ")", "return", "false", ";", "Point2D", "ptA", "=", "new", "Point2D", "(", ")", ",", "ptB", "=", "new", "Point2D", "(", ")", ";", "boolean", "bAllPointsEqual", "=", "true", ";", "double", "tolerance_sq", "=", "tolerance", "*", "tolerance", ";", "for", "(", "int", "ipath", "=", "0", ";", "ipath", "<", "multipathA", ".", "getPathCount", "(", ")", ";", "ipath", "++", ")", "{", "if", "(", "multipathA", ".", "getPathEnd", "(", "ipath", ")", "!=", "multipathB", ".", "getPathEnd", "(", "ipath", ")", ")", "{", "bAllPointsEqual", "=", "false", ";", "break", ";", "}", "for", "(", "int", "i", "=", "multipathA", ".", "getPathStart", "(", "ipath", ")", ";", "i", "<", "multipathB", ".", "getPathEnd", "(", "ipath", ")", ";", "i", "++", ")", "{", "multipathA", ".", "getXY", "(", "i", ",", "ptA", ")", ";", "multipathB", ".", "getXY", "(", "i", ",", "ptB", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptA", ",", "ptB", ")", ">", "tolerance_sq", ")", "{", "bAllPointsEqual", "=", "false", ";", "break", ";", "}", "}", "if", "(", "!", "bAllPointsEqual", ")", "break", ";", "}", "if", "(", "!", "bAllPointsEqual", ")", "return", "false", ";", "return", "true", ";", "}"], "docstring": "those in multipathB, within a tolerance, and in the same order.", "docstring_tokens": ["those", "in", "multipathB", "within", "a", "tolerance", "and", "in", "the", "same", "order", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3309-L3345", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointExactlyEqualsMultiPoint_", "original_string": "private static boolean multiPointExactlyEqualsMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (multipoint_a.getPointCount() != multipoint_b.getPointCount())\n\t\t\treturn false;\n\n\t\tPoint2D ptA = new Point2D(), ptB = new Point2D();\n\t\tboolean bAllPointsEqual = true;\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\tmultipoint_a.getXY(i, ptA);\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (Point2D.sqrDistance(ptA, ptB) > tolerance_sq) {\n\t\t\t\tbAllPointsEqual = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!bAllPointsEqual)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean multiPointExactlyEqualsMultiPoint_(\n\t\t\tMultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tif (multipoint_a.getPointCount() != multipoint_b.getPointCount())\n\t\t\treturn false;\n\n\t\tPoint2D ptA = new Point2D(), ptB = new Point2D();\n\t\tboolean bAllPointsEqual = true;\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tfor (int i = 0; i < multipoint_a.getPointCount(); i++) {\n\t\t\tmultipoint_a.getXY(i, ptA);\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (Point2D.sqrDistance(ptA, ptB) > tolerance_sq) {\n\t\t\t\tbAllPointsEqual = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!bAllPointsEqual)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointExactlyEqualsMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "multipoint_a", ".", "getPointCount", "(", ")", "!=", "multipoint_b", ".", "getPointCount", "(", ")", ")", "return", "false", ";", "Point2D", "ptA", "=", "new", "Point2D", "(", ")", ",", "ptB", "=", "new", "Point2D", "(", ")", ";", "boolean", "bAllPointsEqual", "=", "true", ";", "double", "tolerance_sq", "=", "tolerance", "*", "tolerance", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_a", ".", "getXY", "(", "i", ",", "ptA", ")", ";", "multipoint_b", ".", "getXY", "(", "i", ",", "ptB", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptA", ",", "ptB", ")", ">", "tolerance_sq", ")", "{", "bAllPointsEqual", "=", "false", ";", "break", ";", "}", "}", "if", "(", "!", "bAllPointsEqual", ")", "return", "false", ";", "return", "true", ";", "}"], "docstring": "multipoint_b, within a tolerance, and in the same order.", "docstring_tokens": ["multipoint_b", "within", "a", "tolerance", "and", "in", "the", "same", "order", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3349-L3373", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointCoverageMultiPoint_", "original_string": "private static boolean multiPointCoverageMultiPoint_(\n\t\t\tMultiPoint _multipointA, MultiPoint _multipointB, double tolerance,\n\t\t\tboolean bPerformWithin, boolean bPerformEquals,\n\t\t\tboolean bPerformOverlaps, ProgressTracker progress_tracker) {\n\t\tboolean bPerformContains = false;\n\t\tMultiPoint multipoint_a;\n\t\tMultiPoint multipoint_b;\n\n\t\tif (_multipointA.getPointCount() > _multipointB.getPointCount()) {\n\t\t\tif (bPerformWithin) {\n\t\t\t\tbPerformWithin = false;\n\t\t\t\tbPerformContains = true;\n\t\t\t}\n\n\t\t\tmultipoint_a = _multipointB;\n\t\t\tmultipoint_b = _multipointA;\n\t\t} else {\n\t\t\tmultipoint_a = _multipointA;\n\t\t\tmultipoint_b = _multipointB;\n\t\t}\n\n\t\tAttributeStreamOfInt8 contained = null;\n\n\t\tif (bPerformEquals || bPerformOverlaps || bPerformContains) {\n\t\t\tcontained = new AttributeStreamOfInt8(multipoint_b.getPointCount());\n\n\t\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++)\n\t\t\t\tcontained.write(i, (byte) 0);\n\t\t}\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tPoint2D ptA = new Point2D();\n\t\tPoint2D ptB = new Point2D();\n\n\t\tboolean bWithin = true; // starts off true by default\n\n\t\tQuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(\n\t\t\t\t(MultiPointImpl) (multipoint_b._getImpl()), envInter);\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tfor (int vertex_a = 0; vertex_a < multipoint_a.getPointCount(); vertex_a++) {\n\t\t\tmultipoint_a.getXY(vertex_a, ptA);\n\n\t\t\tif (!envInter.contains(ptA)) {\n\t\t\t\tif (bPerformEquals || bPerformWithin)\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tbWithin = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean bPtACovered = false;\n\t\t\tenv_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);\n\t\t\tqtIterB.resetIterator(env_a, tolerance);\n\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\tmultipoint_b.getXY(vertex_b, ptB);\n\n\t\t\t\tif (Point2D.sqrDistance(ptA, ptB) <= tolerance_sq) {\n\t\t\t\t\tif (bPerformEquals || bPerformOverlaps || bPerformContains)\n\t\t\t\t\t\tcontained.write(vertex_b, (byte) 1);\n\n\t\t\t\t\tbPtACovered = true;\n\n\t\t\t\t\tif (bPerformWithin)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bPtACovered) {\n\t\t\t\tbWithin = false;\n\n\t\t\t\tif (bPerformEquals || bPerformWithin)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (bPerformOverlaps && bWithin)\n\t\t\treturn false;\n\n\t\tif (bPerformWithin)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tif (contained.read(i) == 1) {\n\t\t\t\tif (bPerformOverlaps)\n\t\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (bPerformEquals || bPerformContains)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (bPerformOverlaps)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "language": "java", "code": "private static boolean multiPointCoverageMultiPoint_(\n\t\t\tMultiPoint _multipointA, MultiPoint _multipointB, double tolerance,\n\t\t\tboolean bPerformWithin, boolean bPerformEquals,\n\t\t\tboolean bPerformOverlaps, ProgressTracker progress_tracker) {\n\t\tboolean bPerformContains = false;\n\t\tMultiPoint multipoint_a;\n\t\tMultiPoint multipoint_b;\n\n\t\tif (_multipointA.getPointCount() > _multipointB.getPointCount()) {\n\t\t\tif (bPerformWithin) {\n\t\t\t\tbPerformWithin = false;\n\t\t\t\tbPerformContains = true;\n\t\t\t}\n\n\t\t\tmultipoint_a = _multipointB;\n\t\t\tmultipoint_b = _multipointA;\n\t\t} else {\n\t\t\tmultipoint_a = _multipointA;\n\t\t\tmultipoint_b = _multipointB;\n\t\t}\n\n\t\tAttributeStreamOfInt8 contained = null;\n\n\t\tif (bPerformEquals || bPerformOverlaps || bPerformContains) {\n\t\t\tcontained = new AttributeStreamOfInt8(multipoint_b.getPointCount());\n\n\t\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++)\n\t\t\t\tcontained.write(i, (byte) 0);\n\t\t}\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tPoint2D ptA = new Point2D();\n\t\tPoint2D ptB = new Point2D();\n\n\t\tboolean bWithin = true; // starts off true by default\n\n\t\tQuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(\n\t\t\t\t(MultiPointImpl) (multipoint_b._getImpl()), envInter);\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tfor (int vertex_a = 0; vertex_a < multipoint_a.getPointCount(); vertex_a++) {\n\t\t\tmultipoint_a.getXY(vertex_a, ptA);\n\n\t\t\tif (!envInter.contains(ptA)) {\n\t\t\t\tif (bPerformEquals || bPerformWithin)\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tbWithin = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean bPtACovered = false;\n\t\t\tenv_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);\n\t\t\tqtIterB.resetIterator(env_a, tolerance);\n\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\tmultipoint_b.getXY(vertex_b, ptB);\n\n\t\t\t\tif (Point2D.sqrDistance(ptA, ptB) <= tolerance_sq) {\n\t\t\t\t\tif (bPerformEquals || bPerformOverlaps || bPerformContains)\n\t\t\t\t\t\tcontained.write(vertex_b, (byte) 1);\n\n\t\t\t\t\tbPtACovered = true;\n\n\t\t\t\t\tif (bPerformWithin)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bPtACovered) {\n\t\t\t\tbWithin = false;\n\n\t\t\t\tif (bPerformEquals || bPerformWithin)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (bPerformOverlaps && bWithin)\n\t\t\treturn false;\n\n\t\tif (bPerformWithin)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tif (contained.read(i) == 1) {\n\t\t\t\tif (bPerformOverlaps)\n\t\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (bPerformEquals || bPerformContains)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (bPerformOverlaps)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointCoverageMultiPoint_", "(", "MultiPoint", "_multipointA", ",", "MultiPoint", "_multipointB", ",", "double", "tolerance", ",", "boolean", "bPerformWithin", ",", "boolean", "bPerformEquals", ",", "boolean", "bPerformOverlaps", ",", "ProgressTracker", "progress_tracker", ")", "{", "boolean", "bPerformContains", "=", "false", ";", "MultiPoint", "multipoint_a", ";", "MultiPoint", "multipoint_b", ";", "if", "(", "_multipointA", ".", "getPointCount", "(", ")", ">", "_multipointB", ".", "getPointCount", "(", ")", ")", "{", "if", "(", "bPerformWithin", ")", "{", "bPerformWithin", "=", "false", ";", "bPerformContains", "=", "true", ";", "}", "multipoint_a", "=", "_multipointB", ";", "multipoint_b", "=", "_multipointA", ";", "}", "else", "{", "multipoint_a", "=", "_multipointA", ";", "multipoint_b", "=", "_multipointB", ";", "}", "AttributeStreamOfInt8", "contained", "=", "null", ";", "if", "(", "bPerformEquals", "||", "bPerformOverlaps", "||", "bPerformContains", ")", "{", "contained", "=", "new", "AttributeStreamOfInt8", "(", "multipoint_b", ".", "getPointCount", "(", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "contained", ".", "write", "(", "i", ",", "(", "byte", ")", "0", ")", ";", "}", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "envInter", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "env_b", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "envInter", ".", "setCoords", "(", "env_a", ")", ";", "envInter", ".", "intersect", "(", "env_b", ")", ";", "Point2D", "ptA", "=", "new", "Point2D", "(", ")", ";", "Point2D", "ptB", "=", "new", "Point2D", "(", ")", ";", "boolean", "bWithin", "=", "true", ";", "// starts off true by default", "QuadTreeImpl", "quadTreeB", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPointImpl", ")", "(", "multipoint_b", ".", "_getImpl", "(", ")", ")", ",", "envInter", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterB", "=", "quadTreeB", ".", "getIterator", "(", ")", ";", "double", "tolerance_sq", "=", "tolerance", "*", "tolerance", ";", "for", "(", "int", "vertex_a", "=", "0", ";", "vertex_a", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "vertex_a", "++", ")", "{", "multipoint_a", ".", "getXY", "(", "vertex_a", ",", "ptA", ")", ";", "if", "(", "!", "envInter", ".", "contains", "(", "ptA", ")", ")", "{", "if", "(", "bPerformEquals", "||", "bPerformWithin", ")", "return", "false", ";", "else", "{", "bWithin", "=", "false", ";", "continue", ";", "}", "}", "boolean", "bPtACovered", "=", "false", ";", "env_a", ".", "setCoords", "(", "ptA", ".", "x", ",", "ptA", ".", "y", ",", "ptA", ".", "x", ",", "ptA", ".", "y", ")", ";", "qtIterB", ".", "resetIterator", "(", "env_a", ",", "tolerance", ")", ";", "for", "(", "int", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ";", "elementHandleB", "!=", "-", "1", ";", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ")", "{", "int", "vertex_b", "=", "quadTreeB", ".", "getElement", "(", "elementHandleB", ")", ";", "multipoint_b", ".", "getXY", "(", "vertex_b", ",", "ptB", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptA", ",", "ptB", ")", "<=", "tolerance_sq", ")", "{", "if", "(", "bPerformEquals", "||", "bPerformOverlaps", "||", "bPerformContains", ")", "contained", ".", "write", "(", "vertex_b", ",", "(", "byte", ")", "1", ")", ";", "bPtACovered", "=", "true", ";", "if", "(", "bPerformWithin", ")", "break", ";", "}", "}", "if", "(", "!", "bPtACovered", ")", "{", "bWithin", "=", "false", ";", "if", "(", "bPerformEquals", "||", "bPerformWithin", ")", "return", "false", ";", "}", "}", "if", "(", "bPerformOverlaps", "&&", "bWithin", ")", "return", "false", ";", "if", "(", "bPerformWithin", ")", "return", "true", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "contained", ".", "read", "(", "i", ")", "==", "1", ")", "{", "if", "(", "bPerformOverlaps", ")", "return", "true", ";", "}", "else", "{", "if", "(", "bPerformEquals", "||", "bPerformContains", ")", "return", "false", ";", "}", "}", "if", "(", "bPerformOverlaps", ")", "return", "false", ";", "return", "true", ";", "}"], "docstring": "Otherwise it will do equals.", "docstring_tokens": ["Otherwise", "it", "will", "do", "equals", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3377-L3486", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.multiPointIntersectsMultiPoint_", "original_string": "private static boolean multiPointIntersectsMultiPoint_(\n\t\t\tMultiPoint _multipointA, MultiPoint _multipointB, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tMultiPoint multipoint_a;\n\t\tMultiPoint multipoint_b;\n\n\t\tif (_multipointA.getPointCount() > _multipointB.getPointCount()) {\n\t\t\tmultipoint_a = _multipointB;\n\t\t\tmultipoint_b = _multipointA;\n\t\t} else {\n\t\t\tmultipoint_a = _multipointA;\n\t\t\tmultipoint_b = _multipointB;\n\t\t}\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tPoint2D ptA = new Point2D();\n\t\tPoint2D ptB = new Point2D();\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tQuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(\n\t\t\t\t(MultiPointImpl) (multipoint_b._getImpl()), envInter);\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\n\t\tfor (int vertex_a = 0; vertex_a < multipoint_a.getPointCount(); vertex_a++) {\n\t\t\tmultipoint_a.getXY(vertex_a, ptA);\n\n\t\t\tif (!envInter.contains(ptA))\n\t\t\t\tcontinue;\n\n\t\t\tenv_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);\n\t\t\tqtIterB.resetIterator(env_a, tolerance);\n\n\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\tmultipoint_b.getXY(vertex_b, ptB);\n\n\t\t\t\tif (Point2D.sqrDistance(ptA, ptB) <= tolerance_sq)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean multiPointIntersectsMultiPoint_(\n\t\t\tMultiPoint _multipointA, MultiPoint _multipointB, double tolerance,\n\t\t\tProgressTracker progress_tracker) {\n\t\tMultiPoint multipoint_a;\n\t\tMultiPoint multipoint_b;\n\n\t\tif (_multipointA.getPointCount() > _multipointB.getPointCount()) {\n\t\t\tmultipoint_a = _multipointB;\n\t\t\tmultipoint_b = _multipointA;\n\t\t} else {\n\t\t\tmultipoint_a = _multipointA;\n\t\t\tmultipoint_b = _multipointB;\n\t\t}\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tPoint2D ptA = new Point2D();\n\t\tPoint2D ptB = new Point2D();\n\t\tdouble tolerance_sq = tolerance * tolerance;\n\n\t\tQuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(\n\t\t\t\t(MultiPointImpl) (multipoint_b._getImpl()), envInter);\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\n\t\tfor (int vertex_a = 0; vertex_a < multipoint_a.getPointCount(); vertex_a++) {\n\t\t\tmultipoint_a.getXY(vertex_a, ptA);\n\n\t\t\tif (!envInter.contains(ptA))\n\t\t\t\tcontinue;\n\n\t\t\tenv_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);\n\t\t\tqtIterB.resetIterator(env_a, tolerance);\n\n\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\tmultipoint_b.getXY(vertex_b, ptB);\n\n\t\t\t\tif (Point2D.sqrDistance(ptA, ptB) <= tolerance_sq)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "multiPointIntersectsMultiPoint_", "(", "MultiPoint", "_multipointA", ",", "MultiPoint", "_multipointB", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "MultiPoint", "multipoint_a", ";", "MultiPoint", "multipoint_b", ";", "if", "(", "_multipointA", ".", "getPointCount", "(", ")", ">", "_multipointB", ".", "getPointCount", "(", ")", ")", "{", "multipoint_a", "=", "_multipointB", ";", "multipoint_b", "=", "_multipointA", ";", "}", "else", "{", "multipoint_a", "=", "_multipointA", ";", "multipoint_b", "=", "_multipointB", ";", "}", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "envInter", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "env_b", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "envInter", ".", "setCoords", "(", "env_a", ")", ";", "envInter", ".", "intersect", "(", "env_b", ")", ";", "Point2D", "ptA", "=", "new", "Point2D", "(", ")", ";", "Point2D", "ptB", "=", "new", "Point2D", "(", ")", ";", "double", "tolerance_sq", "=", "tolerance", "*", "tolerance", ";", "QuadTreeImpl", "quadTreeB", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPointImpl", ")", "(", "multipoint_b", ".", "_getImpl", "(", ")", ")", ",", "envInter", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterB", "=", "quadTreeB", ".", "getIterator", "(", ")", ";", "for", "(", "int", "vertex_a", "=", "0", ";", "vertex_a", "<", "multipoint_a", ".", "getPointCount", "(", ")", ";", "vertex_a", "++", ")", "{", "multipoint_a", ".", "getXY", "(", "vertex_a", ",", "ptA", ")", ";", "if", "(", "!", "envInter", ".", "contains", "(", "ptA", ")", ")", "continue", ";", "env_a", ".", "setCoords", "(", "ptA", ".", "x", ",", "ptA", ".", "y", ",", "ptA", ".", "x", ",", "ptA", ".", "y", ")", ";", "qtIterB", ".", "resetIterator", "(", "env_a", ",", "tolerance", ")", ";", "for", "(", "int", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ";", "elementHandleB", "!=", "-", "1", ";", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ")", "{", "int", "vertex_b", "=", "quadTreeB", ".", "getElement", "(", "elementHandleB", ")", ";", "multipoint_b", ".", "getXY", "(", "vertex_b", ",", "ptB", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptA", ",", "ptB", ")", "<=", "tolerance_sq", ")", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Returns true if multipoint_a intersects multipoint_b.", "docstring_tokens": ["Returns", "true", "if", "multipoint_a", "intersects", "multipoint_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3489-L3541", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathEqualsLinearPath_", "original_string": "private static boolean linearPathEqualsLinearPath_(MultiPath multipathA,\n\t\t\tMultiPath multipathB, double tolerance, boolean bEnforceOrientation) {\n\t\treturn linearPathWithinLinearPath_(multipathA, multipathB, tolerance, bEnforceOrientation)\n\t\t\t\t&& linearPathWithinLinearPath_(multipathB, multipathA,\n\t\t\t\t\t\ttolerance, bEnforceOrientation);\n\t}", "language": "java", "code": "private static boolean linearPathEqualsLinearPath_(MultiPath multipathA,\n\t\t\tMultiPath multipathB, double tolerance, boolean bEnforceOrientation) {\n\t\treturn linearPathWithinLinearPath_(multipathA, multipathB, tolerance, bEnforceOrientation)\n\t\t\t\t&& linearPathWithinLinearPath_(multipathB, multipathA,\n\t\t\t\t\t\ttolerance, bEnforceOrientation);\n\t}", "code_tokens": ["private", "static", "boolean", "linearPathEqualsLinearPath_", "(", "MultiPath", "multipathA", ",", "MultiPath", "multipathB", ",", "double", "tolerance", ",", "boolean", "bEnforceOrientation", ")", "{", "return", "linearPathWithinLinearPath_", "(", "multipathA", ",", "multipathB", ",", "tolerance", ",", "bEnforceOrientation", ")", "&&", "linearPathWithinLinearPath_", "(", "multipathB", ",", "multipathA", ",", "tolerance", ",", "bEnforceOrientation", ")", ";", "}"], "docstring": "Returns true if multipathA equals multipathB.", "docstring_tokens": ["Returns", "true", "if", "multipathA", "equals", "multipathB", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3544-L3549", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathWithinLinearPath_", "original_string": "private static boolean linearPathWithinLinearPath_(MultiPath multipathA,\n\t\t\tMultiPath multipathB, double tolerance, boolean bEnforceOrientation) {\n\t\tboolean bWithin = true;\n\t\tdouble[] scalarsA = new double[2];\n\t\tdouble[] scalarsB = new double[2];\n\n\t\tint ievent = 0;\n\t\tAttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);\n\t\tRelationalOperations relOps = new RelationalOperations();\n\t\tOverlapComparer overlapComparer = new OverlapComparer(relOps);\n\t\tOverlapEvent overlapEvent;\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipathB.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\t\tSegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tQuadTreeImpl qtB = null;\n\t\tQuadTreeImpl quadTreeB = null;\n        QuadTreeImpl quadTreePathsB = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeB = accel.getQuadTree();\n            quadTreePathsB = accel.getQuadTreeForPaths();\n\t\t\tif (quadTreeB == null) {\n\t\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\t\tquadTreeB = qtB;\n\t\t\t}\n\t\t} else {\n\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\tquadTreeB = qtB;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;\n        if (quadTreePathsB != null)\n            qtIterPathsB = quadTreePathsB.getIterator();\n\n\t\twhile (segIterA.nextPath()) {\n\t\t\twhile (segIterA.hasNextSegment()) {\n\t\t\t\tboolean bStringOfSegmentAsCovered = false;\n\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tsegmentA.queryEnvelope2D(env_a);\n\n\t\t\t\tif (!env_a.isIntersecting(envInter)) {\n\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t}\n\n                if (qtIterPathsB != null) {\n                    qtIterPathsB.resetIterator(env_a, tolerance);\n\n                    if (qtIterPathsB.next() == -1) {\n                        bWithin = false;\n                        return false;\n                    }\n                }\n\n\t\t\t\tdouble lengthA = segmentA.calculateLength2D();\n\n\t\t\t\tqtIterB.resetIterator(segmentA, tolerance);\n\n\t\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t\t.next()) {\n\t\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\t\t\tSegment segmentB = segIterB.nextSegment();\n\n\t\t\t\t\tint result = segmentA.intersect(segmentB, null, scalarsA,\n\t\t\t\t\t\t\tscalarsB, tolerance);\n\n\t\t\t\t\tif (result == 2 && (!bEnforceOrientation || scalarsB[0] <= scalarsB[1])) {\n\t\t\t\t\t\tdouble scalar_a_0 = scalarsA[0];\n\t\t\t\t\t\tdouble scalar_a_1 = scalarsA[1];\n\t\t\t\t\t\tdouble scalar_b_0 = scalarsB[0];\n\t\t\t\t\t\tdouble scalar_b_1 = scalarsB[1];\n\n\t\t\t\t\t\t// Performance enhancement for nice cases where\n\t\t\t\t\t\t// localization occurs. Increment segIterA as far as we\n\t\t\t\t\t\t// can while the current segmentA is covered.\n\t\t\t\t\t\tif (scalar_a_0 * lengthA <= tolerance\n\t\t\t\t\t\t\t\t&& (1.0 - scalar_a_1) * lengthA <= tolerance) {\n\t\t\t\t\t\t\tbStringOfSegmentAsCovered = true;\n\n\t\t\t\t\t\t\tievent = 0;\n\t\t\t\t\t\t\teventIndices.resize(0);\n\t\t\t\t\t\t\trelOps.m_overlap_events.clear();\n\n\t\t\t\t\t\t\tint ivertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\tboolean bSegmentACovered = true;\n\n\t\t\t\t\t\t\twhile (bSegmentACovered) {// keep going while the\n\t\t\t\t\t\t\t\t// current segmentA is\n\t\t\t\t\t\t\t\t// covered.\n\t\t\t\t\t\t\t\tif (segIterA.hasNextSegment()) {\n\t\t\t\t\t\t\t\t\tsegmentA = segIterA.nextSegment();\n\t\t\t\t\t\t\t\t\tlengthA = segmentA.calculateLength2D();\n\n\t\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\t\tscalarsA, scalarsB, tolerance);\n\n\t\t\t\t\t\t\t\t\tif (result == 2 && (!bEnforceOrientation || scalarsB[0] <= scalarsB[1])) {\n\t\t\t\t\t\t\t\t\t\tscalar_a_0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\t\tscalar_a_1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\t\tif (scalar_a_0 * lengthA <= tolerance\n\t\t\t\t\t\t\t\t\t\t\t\t&& (1.0 - scalar_a_1) * lengthA <= tolerance) {\n\t\t\t\t\t\t\t\t\t\t\tivertex_a = segIterA\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getStartPointIndex();\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (segIterB.hasNextSegment()) {\n\t\t\t\t\t\t\t\t\t\tsegmentB = segIterB.nextSegment();\n\t\t\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB,\n\t\t\t\t\t\t\t\t\t\t\t\tnull, scalarsA, scalarsB,\n\t\t\t\t\t\t\t\t\t\t\t\ttolerance);\n\n\t\t\t\t\t\t\t\t\t\tif (result == 2 && (!bEnforceOrientation || scalarsB[0] <= scalarsB[1])) {\n\t\t\t\t\t\t\t\t\t\t\tscalar_a_0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\t\t\tscalar_a_1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\t\t\tif (scalar_a_0 * lengthA <= tolerance\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& (1.0 - scalar_a_1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* lengthA <= tolerance) {\n\t\t\t\t\t\t\t\t\t\t\t\tivertex_a = segIterA\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getStartPointIndex();\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbSegmentACovered = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (ivertex_a != segIterA.getStartPointIndex()) {\n\t\t\t\t\t\t\t\tsegIterA.resetToVertex(ivertex_a);\n\t\t\t\t\t\t\t\tsegIterA.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ivertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_a = segIterA.getPathIndex();\n\t\t\t\t\t\t\tint ivertex_b = segIterB.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_b = segIterB.getPathIndex();\n\n\t\t\t\t\t\t\toverlapEvent = OverlapEvent.construct(ivertex_a,\n\t\t\t\t\t\t\t\t\tipath_a, scalar_a_0, scalar_a_1, ivertex_b,\n\t\t\t\t\t\t\t\t\tipath_b, scalar_b_0, scalar_b_1);\n\t\t\t\t\t\t\trelOps.m_overlap_events.add(overlapEvent);\n\t\t\t\t\t\t\teventIndices.add(eventIndices.size());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (bStringOfSegmentAsCovered) {\n\t\t\t\t\tcontinue; // no need to check that segmentA is covered\n\t\t\t\t}\n\t\t\t\tif (ievent == relOps.m_overlap_events.size()) {\n\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t}\n\n\t\t\t\tif (eventIndices.size() - ievent > 1) {\n\t\t\t\t\teventIndices.Sort(ievent, eventIndices.size(),\n\t\t\t\t\t\t\toverlapComparer);\n\t\t\t\t}\n\n\t\t\t\tdouble lastScalar = 0.0;\n\n\t\t\t\tfor (int i = ievent; i < relOps.m_overlap_events.size(); i++) {\n\t\t\t\t\toverlapEvent = relOps.m_overlap_events.get(eventIndices\n\t\t\t\t\t\t\t.get(i));\n\n\t\t\t\t\tif (overlapEvent.m_scalar_a_0 < lastScalar\n\t\t\t\t\t\t\t&& overlapEvent.m_scalar_a_1 < lastScalar) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) > tolerance) {\n\t\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastScalar = overlapEvent.m_scalar_a_1;\n\n\t\t\t\t\t\tif (lengthA * (1.0 - lastScalar) <= tolerance\n\t\t\t\t\t\t\t\t|| lastScalar == 1.0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lengthA * (1.0 - lastScalar) > tolerance) {\n\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t}\n\n\t\t\t\tievent = 0;\n\t\t\t\teventIndices.resize(0);\n\t\t\t\trelOps.m_overlap_events.clear();\n\t\t\t}\n\t\t}\n\n\t\treturn bWithin;\n\t}", "language": "java", "code": "private static boolean linearPathWithinLinearPath_(MultiPath multipathA,\n\t\t\tMultiPath multipathB, double tolerance, boolean bEnforceOrientation) {\n\t\tboolean bWithin = true;\n\t\tdouble[] scalarsA = new double[2];\n\t\tdouble[] scalarsB = new double[2];\n\n\t\tint ievent = 0;\n\t\tAttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);\n\t\tRelationalOperations relOps = new RelationalOperations();\n\t\tOverlapComparer overlapComparer = new OverlapComparer(relOps);\n\t\tOverlapEvent overlapEvent;\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipathB.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\t\tSegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tQuadTreeImpl qtB = null;\n\t\tQuadTreeImpl quadTreeB = null;\n        QuadTreeImpl quadTreePathsB = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeB = accel.getQuadTree();\n            quadTreePathsB = accel.getQuadTreeForPaths();\n\t\t\tif (quadTreeB == null) {\n\t\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\t\tquadTreeB = qtB;\n\t\t\t}\n\t\t} else {\n\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\tquadTreeB = qtB;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;\n        if (quadTreePathsB != null)\n            qtIterPathsB = quadTreePathsB.getIterator();\n\n\t\twhile (segIterA.nextPath()) {\n\t\t\twhile (segIterA.hasNextSegment()) {\n\t\t\t\tboolean bStringOfSegmentAsCovered = false;\n\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tsegmentA.queryEnvelope2D(env_a);\n\n\t\t\t\tif (!env_a.isIntersecting(envInter)) {\n\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t}\n\n                if (qtIterPathsB != null) {\n                    qtIterPathsB.resetIterator(env_a, tolerance);\n\n                    if (qtIterPathsB.next() == -1) {\n                        bWithin = false;\n                        return false;\n                    }\n                }\n\n\t\t\t\tdouble lengthA = segmentA.calculateLength2D();\n\n\t\t\t\tqtIterB.resetIterator(segmentA, tolerance);\n\n\t\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t\t.next()) {\n\t\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\t\t\tSegment segmentB = segIterB.nextSegment();\n\n\t\t\t\t\tint result = segmentA.intersect(segmentB, null, scalarsA,\n\t\t\t\t\t\t\tscalarsB, tolerance);\n\n\t\t\t\t\tif (result == 2 && (!bEnforceOrientation || scalarsB[0] <= scalarsB[1])) {\n\t\t\t\t\t\tdouble scalar_a_0 = scalarsA[0];\n\t\t\t\t\t\tdouble scalar_a_1 = scalarsA[1];\n\t\t\t\t\t\tdouble scalar_b_0 = scalarsB[0];\n\t\t\t\t\t\tdouble scalar_b_1 = scalarsB[1];\n\n\t\t\t\t\t\t// Performance enhancement for nice cases where\n\t\t\t\t\t\t// localization occurs. Increment segIterA as far as we\n\t\t\t\t\t\t// can while the current segmentA is covered.\n\t\t\t\t\t\tif (scalar_a_0 * lengthA <= tolerance\n\t\t\t\t\t\t\t\t&& (1.0 - scalar_a_1) * lengthA <= tolerance) {\n\t\t\t\t\t\t\tbStringOfSegmentAsCovered = true;\n\n\t\t\t\t\t\t\tievent = 0;\n\t\t\t\t\t\t\teventIndices.resize(0);\n\t\t\t\t\t\t\trelOps.m_overlap_events.clear();\n\n\t\t\t\t\t\t\tint ivertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\tboolean bSegmentACovered = true;\n\n\t\t\t\t\t\t\twhile (bSegmentACovered) {// keep going while the\n\t\t\t\t\t\t\t\t// current segmentA is\n\t\t\t\t\t\t\t\t// covered.\n\t\t\t\t\t\t\t\tif (segIterA.hasNextSegment()) {\n\t\t\t\t\t\t\t\t\tsegmentA = segIterA.nextSegment();\n\t\t\t\t\t\t\t\t\tlengthA = segmentA.calculateLength2D();\n\n\t\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\t\tscalarsA, scalarsB, tolerance);\n\n\t\t\t\t\t\t\t\t\tif (result == 2 && (!bEnforceOrientation || scalarsB[0] <= scalarsB[1])) {\n\t\t\t\t\t\t\t\t\t\tscalar_a_0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\t\tscalar_a_1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\t\tif (scalar_a_0 * lengthA <= tolerance\n\t\t\t\t\t\t\t\t\t\t\t\t&& (1.0 - scalar_a_1) * lengthA <= tolerance) {\n\t\t\t\t\t\t\t\t\t\t\tivertex_a = segIterA\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getStartPointIndex();\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (segIterB.hasNextSegment()) {\n\t\t\t\t\t\t\t\t\t\tsegmentB = segIterB.nextSegment();\n\t\t\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB,\n\t\t\t\t\t\t\t\t\t\t\t\tnull, scalarsA, scalarsB,\n\t\t\t\t\t\t\t\t\t\t\t\ttolerance);\n\n\t\t\t\t\t\t\t\t\t\tif (result == 2 && (!bEnforceOrientation || scalarsB[0] <= scalarsB[1])) {\n\t\t\t\t\t\t\t\t\t\t\tscalar_a_0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\t\t\tscalar_a_1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\t\t\tif (scalar_a_0 * lengthA <= tolerance\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& (1.0 - scalar_a_1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* lengthA <= tolerance) {\n\t\t\t\t\t\t\t\t\t\t\t\tivertex_a = segIterA\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getStartPointIndex();\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbSegmentACovered = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (ivertex_a != segIterA.getStartPointIndex()) {\n\t\t\t\t\t\t\t\tsegIterA.resetToVertex(ivertex_a);\n\t\t\t\t\t\t\t\tsegIterA.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ivertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_a = segIterA.getPathIndex();\n\t\t\t\t\t\t\tint ivertex_b = segIterB.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_b = segIterB.getPathIndex();\n\n\t\t\t\t\t\t\toverlapEvent = OverlapEvent.construct(ivertex_a,\n\t\t\t\t\t\t\t\t\tipath_a, scalar_a_0, scalar_a_1, ivertex_b,\n\t\t\t\t\t\t\t\t\tipath_b, scalar_b_0, scalar_b_1);\n\t\t\t\t\t\t\trelOps.m_overlap_events.add(overlapEvent);\n\t\t\t\t\t\t\teventIndices.add(eventIndices.size());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (bStringOfSegmentAsCovered) {\n\t\t\t\t\tcontinue; // no need to check that segmentA is covered\n\t\t\t\t}\n\t\t\t\tif (ievent == relOps.m_overlap_events.size()) {\n\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t}\n\n\t\t\t\tif (eventIndices.size() - ievent > 1) {\n\t\t\t\t\teventIndices.Sort(ievent, eventIndices.size(),\n\t\t\t\t\t\t\toverlapComparer);\n\t\t\t\t}\n\n\t\t\t\tdouble lastScalar = 0.0;\n\n\t\t\t\tfor (int i = ievent; i < relOps.m_overlap_events.size(); i++) {\n\t\t\t\t\toverlapEvent = relOps.m_overlap_events.get(eventIndices\n\t\t\t\t\t\t\t.get(i));\n\n\t\t\t\t\tif (overlapEvent.m_scalar_a_0 < lastScalar\n\t\t\t\t\t\t\t&& overlapEvent.m_scalar_a_1 < lastScalar) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) > tolerance) {\n\t\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastScalar = overlapEvent.m_scalar_a_1;\n\n\t\t\t\t\t\tif (lengthA * (1.0 - lastScalar) <= tolerance\n\t\t\t\t\t\t\t\t|| lastScalar == 1.0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lengthA * (1.0 - lastScalar) > tolerance) {\n\t\t\t\t\treturn false; // bWithin = false\n\t\t\t\t}\n\n\t\t\t\tievent = 0;\n\t\t\t\teventIndices.resize(0);\n\t\t\t\trelOps.m_overlap_events.clear();\n\t\t\t}\n\t\t}\n\n\t\treturn bWithin;\n\t}", "code_tokens": ["private", "static", "boolean", "linearPathWithinLinearPath_", "(", "MultiPath", "multipathA", ",", "MultiPath", "multipathB", ",", "double", "tolerance", ",", "boolean", "bEnforceOrientation", ")", "{", "boolean", "bWithin", "=", "true", ";", "double", "[", "]", "scalarsA", "=", "new", "double", "[", "2", "]", ";", "double", "[", "]", "scalarsB", "=", "new", "double", "[", "2", "]", ";", "int", "ievent", "=", "0", ";", "AttributeStreamOfInt32", "eventIndices", "=", "new", "AttributeStreamOfInt32", "(", "0", ")", ";", "RelationalOperations", "relOps", "=", "new", "RelationalOperations", "(", ")", ";", "OverlapComparer", "overlapComparer", "=", "new", "OverlapComparer", "(", "relOps", ")", ";", "OverlapEvent", "overlapEvent", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "envInter", "=", "new", "Envelope2D", "(", ")", ";", "multipathA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipathB", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "env_b", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "envInter", ".", "setCoords", "(", "env_a", ")", ";", "envInter", ".", "intersect", "(", "env_b", ")", ";", "SegmentIteratorImpl", "segIterA", "=", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "SegmentIteratorImpl", "segIterB", "=", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "QuadTreeImpl", "qtB", "=", "null", ";", "QuadTreeImpl", "quadTreeB", "=", "null", ";", "QuadTreeImpl", "quadTreePathsB", "=", "null", ";", "GeometryAccelerators", "accel", "=", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ")", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "quadTreeB", "=", "accel", ".", "getQuadTree", "(", ")", ";", "quadTreePathsB", "=", "accel", ".", "getQuadTreeForPaths", "(", ")", ";", "if", "(", "quadTreeB", "==", "null", ")", "{", "qtB", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeB", "=", "qtB", ";", "}", "}", "else", "{", "qtB", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeB", "=", "qtB", ";", "}", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterB", "=", "quadTreeB", ".", "getIterator", "(", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterPathsB", "=", "null", ";", "if", "(", "quadTreePathsB", "!=", "null", ")", "qtIterPathsB", "=", "quadTreePathsB", ".", "getIterator", "(", ")", ";", "while", "(", "segIterA", ".", "nextPath", "(", ")", ")", "{", "while", "(", "segIterA", ".", "hasNextSegment", "(", ")", ")", "{", "boolean", "bStringOfSegmentAsCovered", "=", "false", ";", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "segmentA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "if", "(", "!", "env_a", ".", "isIntersecting", "(", "envInter", ")", ")", "{", "return", "false", ";", "// bWithin = false", "}", "if", "(", "qtIterPathsB", "!=", "null", ")", "{", "qtIterPathsB", ".", "resetIterator", "(", "env_a", ",", "tolerance", ")", ";", "if", "(", "qtIterPathsB", ".", "next", "(", ")", "==", "-", "1", ")", "{", "bWithin", "=", "false", ";", "return", "false", ";", "}", "}", "double", "lengthA", "=", "segmentA", ".", "calculateLength2D", "(", ")", ";", "qtIterB", ".", "resetIterator", "(", "segmentA", ",", "tolerance", ")", ";", "for", "(", "int", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ";", "elementHandleB", "!=", "-", "1", ";", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ")", "{", "int", "vertex_b", "=", "quadTreeB", ".", "getElement", "(", "elementHandleB", ")", ";", "segIterB", ".", "resetToVertex", "(", "vertex_b", ")", ";", "Segment", "segmentB", "=", "segIterB", ".", "nextSegment", "(", ")", ";", "int", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "scalarsB", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", "&&", "(", "!", "bEnforceOrientation", "||", "scalarsB", "[", "0", "]", "<=", "scalarsB", "[", "1", "]", ")", ")", "{", "double", "scalar_a_0", "=", "scalarsA", "[", "0", "]", ";", "double", "scalar_a_1", "=", "scalarsA", "[", "1", "]", ";", "double", "scalar_b_0", "=", "scalarsB", "[", "0", "]", ";", "double", "scalar_b_1", "=", "scalarsB", "[", "1", "]", ";", "// Performance enhancement for nice cases where", "// localization occurs. Increment segIterA as far as we", "// can while the current segmentA is covered.", "if", "(", "scalar_a_0", "*", "lengthA", "<=", "tolerance", "&&", "(", "1.0", "-", "scalar_a_1", ")", "*", "lengthA", "<=", "tolerance", ")", "{", "bStringOfSegmentAsCovered", "=", "true", ";", "ievent", "=", "0", ";", "eventIndices", ".", "resize", "(", "0", ")", ";", "relOps", ".", "m_overlap_events", ".", "clear", "(", ")", ";", "int", "ivertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "boolean", "bSegmentACovered", "=", "true", ";", "while", "(", "bSegmentACovered", ")", "{", "// keep going while the", "// current segmentA is", "// covered.", "if", "(", "segIterA", ".", "hasNextSegment", "(", ")", ")", "{", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "lengthA", "=", "segmentA", ".", "calculateLength2D", "(", ")", ";", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "scalarsB", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", "&&", "(", "!", "bEnforceOrientation", "||", "scalarsB", "[", "0", "]", "<=", "scalarsB", "[", "1", "]", ")", ")", "{", "scalar_a_0", "=", "scalarsA", "[", "0", "]", ";", "scalar_a_1", "=", "scalarsA", "[", "1", "]", ";", "if", "(", "scalar_a_0", "*", "lengthA", "<=", "tolerance", "&&", "(", "1.0", "-", "scalar_a_1", ")", "*", "lengthA", "<=", "tolerance", ")", "{", "ivertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "continue", ";", "}", "}", "if", "(", "segIterB", ".", "hasNextSegment", "(", ")", ")", "{", "segmentB", "=", "segIterB", ".", "nextSegment", "(", ")", ";", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "scalarsB", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", "&&", "(", "!", "bEnforceOrientation", "||", "scalarsB", "[", "0", "]", "<=", "scalarsB", "[", "1", "]", ")", ")", "{", "scalar_a_0", "=", "scalarsA", "[", "0", "]", ";", "scalar_a_1", "=", "scalarsA", "[", "1", "]", ";", "if", "(", "scalar_a_0", "*", "lengthA", "<=", "tolerance", "&&", "(", "1.0", "-", "scalar_a_1", ")", "*", "lengthA", "<=", "tolerance", ")", "{", "ivertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "continue", ";", "}", "}", "}", "}", "bSegmentACovered", "=", "false", ";", "}", "if", "(", "ivertex_a", "!=", "segIterA", ".", "getStartPointIndex", "(", ")", ")", "{", "segIterA", ".", "resetToVertex", "(", "ivertex_a", ")", ";", "segIterA", ".", "nextSegment", "(", ")", ";", "}", "break", ";", "}", "else", "{", "int", "ivertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "int", "ipath_a", "=", "segIterA", ".", "getPathIndex", "(", ")", ";", "int", "ivertex_b", "=", "segIterB", ".", "getStartPointIndex", "(", ")", ";", "int", "ipath_b", "=", "segIterB", ".", "getPathIndex", "(", ")", ";", "overlapEvent", "=", "OverlapEvent", ".", "construct", "(", "ivertex_a", ",", "ipath_a", ",", "scalar_a_0", ",", "scalar_a_1", ",", "ivertex_b", ",", "ipath_b", ",", "scalar_b_0", ",", "scalar_b_1", ")", ";", "relOps", ".", "m_overlap_events", ".", "add", "(", "overlapEvent", ")", ";", "eventIndices", ".", "add", "(", "eventIndices", ".", "size", "(", ")", ")", ";", "}", "}", "}", "if", "(", "bStringOfSegmentAsCovered", ")", "{", "continue", ";", "// no need to check that segmentA is covered", "}", "if", "(", "ievent", "==", "relOps", ".", "m_overlap_events", ".", "size", "(", ")", ")", "{", "return", "false", ";", "// bWithin = false", "}", "if", "(", "eventIndices", ".", "size", "(", ")", "-", "ievent", ">", "1", ")", "{", "eventIndices", ".", "Sort", "(", "ievent", ",", "eventIndices", ".", "size", "(", ")", ",", "overlapComparer", ")", ";", "}", "double", "lastScalar", "=", "0.0", ";", "for", "(", "int", "i", "=", "ievent", ";", "i", "<", "relOps", ".", "m_overlap_events", ".", "size", "(", ")", ";", "i", "++", ")", "{", "overlapEvent", "=", "relOps", ".", "m_overlap_events", ".", "get", "(", "eventIndices", ".", "get", "(", "i", ")", ")", ";", "if", "(", "overlapEvent", ".", "m_scalar_a_0", "<", "lastScalar", "&&", "overlapEvent", ".", "m_scalar_a_1", "<", "lastScalar", ")", "{", "continue", ";", "}", "if", "(", "lengthA", "*", "(", "overlapEvent", ".", "m_scalar_a_0", "-", "lastScalar", ")", ">", "tolerance", ")", "{", "return", "false", ";", "// bWithin = false", "}", "else", "{", "lastScalar", "=", "overlapEvent", ".", "m_scalar_a_1", ";", "if", "(", "lengthA", "*", "(", "1.0", "-", "lastScalar", ")", "<=", "tolerance", "||", "lastScalar", "==", "1.0", ")", "{", "break", ";", "}", "}", "}", "if", "(", "lengthA", "*", "(", "1.0", "-", "lastScalar", ")", ">", "tolerance", ")", "{", "return", "false", ";", "// bWithin = false", "}", "ievent", "=", "0", ";", "eventIndices", ".", "resize", "(", "0", ")", ";", "relOps", ".", "m_overlap_events", ".", "clear", "(", ")", ";", "}", "}", "return", "bWithin", ";", "}"], "docstring": "multipathB.", "docstring_tokens": ["multipathB", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3553-L3773", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathOverlapsLinearPath_", "original_string": "private static boolean linearPathOverlapsLinearPath_(MultiPath multipathA,\n\t\t\tMultiPath multipathB, double tolerance) {\n\t\tint dim = linearPathIntersectsLinearPathMaxDim_(multipathA, multipathB,\n\t\t\t\ttolerance, null);\n\n\t\tif (dim < 1)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipathB.queryEnvelope2D(env_b);\n\n\t\tboolean bIntAExtB = interiorEnvExteriorEnv_(env_a, env_b, tolerance);\n\t\tboolean bIntBExtA = interiorEnvExteriorEnv_(env_b, env_a, tolerance);\n\n\t\tif (bIntAExtB && bIntBExtA)\n\t\t\treturn true;\n\n\t\tif (bIntAExtB && !bIntBExtA)\n\t\t\treturn !linearPathWithinLinearPath_(multipathB, multipathA,\n\t\t\t\t\ttolerance, false);\n\n\t\tif (bIntBExtA && !bIntAExtB)\n\t\t\treturn !linearPathWithinLinearPath_(multipathA, multipathB,\n\t\t\t\t\ttolerance, false);\n\n\t\treturn !linearPathWithinLinearPath_(multipathA, multipathB, tolerance, false)\n\t\t\t\t&& !linearPathWithinLinearPath_(multipathB, multipathA,\n\t\t\t\t\t\ttolerance, false);\n\t}", "language": "java", "code": "private static boolean linearPathOverlapsLinearPath_(MultiPath multipathA,\n\t\t\tMultiPath multipathB, double tolerance) {\n\t\tint dim = linearPathIntersectsLinearPathMaxDim_(multipathA, multipathB,\n\t\t\t\ttolerance, null);\n\n\t\tif (dim < 1)\n\t\t\treturn false;\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipathB.queryEnvelope2D(env_b);\n\n\t\tboolean bIntAExtB = interiorEnvExteriorEnv_(env_a, env_b, tolerance);\n\t\tboolean bIntBExtA = interiorEnvExteriorEnv_(env_b, env_a, tolerance);\n\n\t\tif (bIntAExtB && bIntBExtA)\n\t\t\treturn true;\n\n\t\tif (bIntAExtB && !bIntBExtA)\n\t\t\treturn !linearPathWithinLinearPath_(multipathB, multipathA,\n\t\t\t\t\ttolerance, false);\n\n\t\tif (bIntBExtA && !bIntAExtB)\n\t\t\treturn !linearPathWithinLinearPath_(multipathA, multipathB,\n\t\t\t\t\ttolerance, false);\n\n\t\treturn !linearPathWithinLinearPath_(multipathA, multipathB, tolerance, false)\n\t\t\t\t&& !linearPathWithinLinearPath_(multipathB, multipathA,\n\t\t\t\t\t\ttolerance, false);\n\t}", "code_tokens": ["private", "static", "boolean", "linearPathOverlapsLinearPath_", "(", "MultiPath", "multipathA", ",", "MultiPath", "multipathB", ",", "double", "tolerance", ")", "{", "int", "dim", "=", "linearPathIntersectsLinearPathMaxDim_", "(", "multipathA", ",", "multipathB", ",", "tolerance", ",", "null", ")", ";", "if", "(", "dim", "<", "1", ")", "return", "false", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipathA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipathB", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bIntAExtB", "=", "interiorEnvExteriorEnv_", "(", "env_a", ",", "env_b", ",", "tolerance", ")", ";", "boolean", "bIntBExtA", "=", "interiorEnvExteriorEnv_", "(", "env_b", ",", "env_a", ",", "tolerance", ")", ";", "if", "(", "bIntAExtB", "&&", "bIntBExtA", ")", "return", "true", ";", "if", "(", "bIntAExtB", "&&", "!", "bIntBExtA", ")", "return", "!", "linearPathWithinLinearPath_", "(", "multipathB", ",", "multipathA", ",", "tolerance", ",", "false", ")", ";", "if", "(", "bIntBExtA", "&&", "!", "bIntAExtB", ")", "return", "!", "linearPathWithinLinearPath_", "(", "multipathA", ",", "multipathB", ",", "tolerance", ",", "false", ")", ";", "return", "!", "linearPathWithinLinearPath_", "(", "multipathA", ",", "multipathB", ",", "tolerance", ",", "false", ")", "&&", "!", "linearPathWithinLinearPath_", "(", "multipathB", ",", "multipathA", ",", "tolerance", ",", "false", ")", ";", "}"], "docstring": "multipathB.", "docstring_tokens": ["multipathB", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3777-L3806", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathIntersectsLinearPathMaxDim_", "original_string": "static int linearPathIntersectsLinearPathMaxDim_(MultiPath _multipathA,\n\t\t\tMultiPath _multipathB, double tolerance,\n\t\t\tAttributeStreamOfDbl intersections) {\n\t\tMultiPath multipathA;\n\t\tMultiPath multipathB;\n\n\t\tif (_multipathA.getSegmentCount() > _multipathB.getSegmentCount()) {\n\t\t\tmultipathA = _multipathB;\n\t\t\tmultipathB = _multipathA;\n\t\t} else {\n\t\t\tmultipathA = _multipathA;\n\t\t\tmultipathB = _multipathB;\n\t\t}\n\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\t\tSegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t.querySegmentIterator();\n\t\tdouble[] scalarsA = new double[2];\n\t\tdouble[] scalarsB = new double[2];\n\n\t\tint dim = -1;\n\n\t\tint ievent = 0;\n\t\tdouble overlapLength;\n\t\tAttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);\n\t\tRelationalOperations relOps = new RelationalOperations();\n\t\tOverlapComparer overlapComparer = new OverlapComparer(relOps);\n\t\tOverlapEvent overlapEvent;\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipathB.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tPoint2D int_point = null;\n\n\t\tif (intersections != null) {\n\t\t\tint_point = new Point2D();\n\t\t}\n\n\t\tQuadTreeImpl qtB = null;\n\t\tQuadTreeImpl quadTreeB = null;\n        QuadTreeImpl quadTreePathsB = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeB = accel.getQuadTree();\n            quadTreePathsB = accel.getQuadTreeForPaths();\n\t\t\tif (quadTreeB == null) {\n\t\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\t\tquadTreeB = qtB;\n\t\t\t}\n\t\t} else {\n\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\tquadTreeB = qtB;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;\n        if (quadTreePathsB != null)\n            qtIterPathsB = quadTreePathsB.getIterator();\n\n\t\twhile (segIterA.nextPath()) {\n\t\t\toverlapLength = 0.0;\n\n\t\t\twhile (segIterA.hasNextSegment()) {\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tsegmentA.queryEnvelope2D(env_a);\n\n\t\t\t\tif (!env_a.isIntersecting(envInter)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n                if (qtIterPathsB != null) {\n                    qtIterPathsB.resetIterator(env_a, tolerance);\n\n                    if (qtIterPathsB.next() == -1)\n                        continue;\n                }\n\n\t\t\t\tdouble lengthA = segmentA.calculateLength2D();\n\n\t\t\t\tqtIterB.resetIterator(segmentA, tolerance);\n\n\t\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t\t.next()) {\n\t\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\n\t\t\t\t\tSegment segmentB = segIterB.nextSegment();\n\t\t\t\t\tdouble lengthB = segmentB.calculateLength2D();\n\n\t\t\t\t\tint result = segmentA.intersect(segmentB, null, scalarsA,\n\t\t\t\t\t\t\tscalarsB, tolerance);\n\n\t\t\t\t\tif (result > 0) {\n\t\t\t\t\t\tdouble scalar_a_0 = scalarsA[0];\n\t\t\t\t\t\tdouble scalar_b_0 = scalarsB[0];\n\t\t\t\t\t\tdouble scalar_a_1 = (result == 2 ? scalarsA[1]\n\t\t\t\t\t\t\t\t: NumberUtils.TheNaN);\n\t\t\t\t\t\tdouble scalar_b_1 = (result == 2 ? scalarsB[1]\n\t\t\t\t\t\t\t\t: NumberUtils.TheNaN);\n\n\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\tif (lengthA * (scalar_a_1 - scalar_a_0) > tolerance) {\n\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Quick neighbor check\n\t\t\t\t\t\t\tdouble length = lengthA * (scalar_a_1 - scalar_a_0);\n\n\t\t\t\t\t\t\tif (segIterB.hasNextSegment()) {\n\t\t\t\t\t\t\t\tsegmentB = segIterB.nextSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthNext = lengthA\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthNext > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\t\t\t\t\t\tsegIterB.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!segIterB.isFirstSegmentInPath()) {\n\t\t\t\t\t\t\t\tsegIterB.previousSegment();\n\t\t\t\t\t\t\t\tsegmentB = segIterB.previousSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthPrevious = lengthA\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthPrevious > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\t\t\t\t\t\tsegIterB.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (segIterA.hasNextSegment()) {\n\t\t\t\t\t\t\t\tint vertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\t\tsegmentA = segIterA.nextSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthNext = lengthA\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthNext > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\t\t\t\t\t\tsegIterA.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!segIterA.isFirstSegmentInPath()) {\n\t\t\t\t\t\t\t\tint vertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\t\tsegIterA.previousSegment();\n\t\t\t\t\t\t\t\tsegmentA = segIterA.previousSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthPrevious = lengthB\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthPrevious > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\t\t\t\t\t\tsegIterA.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint ivertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_a = segIterA.getPathIndex();\n\t\t\t\t\t\t\tint ivertex_b = segIterB.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_b = segIterB.getPathIndex();\n\n\t\t\t\t\t\t\toverlapEvent = OverlapEvent.construct(ivertex_a,\n\t\t\t\t\t\t\t\t\tipath_a, scalar_a_0, scalar_a_1, ivertex_b,\n\t\t\t\t\t\t\t\t\tipath_b, scalar_b_0, scalar_b_1);\n\t\t\t\t\t\t\trelOps.m_overlap_events.add(overlapEvent);\n\t\t\t\t\t\t\teventIndices.add(eventIndices.size());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdim = 0;\n\n\t\t\t\t\t\tif (intersections != null) {\n\t\t\t\t\t\t\tsegmentA.getCoord2D(scalar_a_0, int_point);\n\t\t\t\t\t\t\tintersections.add(int_point.x);\n\t\t\t\t\t\t\tintersections.add(int_point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ievent < relOps.m_overlap_events.size()) {\n\t\t\t\t\teventIndices.Sort(ievent, eventIndices.size(),\n\t\t\t\t\t\t\toverlapComparer);\n\n\t\t\t\t\tdouble lastScalar = 0.0;\n\t\t\t\t\tint lastPath = relOps.m_overlap_events.get(eventIndices\n\t\t\t\t\t\t\t.get(ievent)).m_ipath_a;\n\n\t\t\t\t\tfor (int i = ievent; i < relOps.m_overlap_events.size(); i++) {\n\t\t\t\t\t\toverlapEvent = relOps.m_overlap_events.get(eventIndices\n\t\t\t\t\t\t\t\t.get(i));\n\n\t\t\t\t\t\tif (overlapEvent.m_scalar_a_0 < lastScalar\n\t\t\t\t\t\t\t\t&& overlapEvent.m_scalar_a_1 < lastScalar) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) > tolerance) {\n\t\t\t\t\t\t\toverlapLength = lengthA\n\t\t\t\t\t\t\t\t\t* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset\n\t\t\t\t\t\t\tlastScalar = overlapEvent.m_scalar_a_1;\n\t\t\t\t\t\t\tlastPath = overlapEvent.m_ipath_a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (overlapEvent.m_ipath_a != lastPath) {\n\t\t\t\t\t\t\t\toverlapLength = lengthA\n\t\t\t\t\t\t\t\t\t\t* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset\n\t\t\t\t\t\t\t\tlastPath = overlapEvent.m_ipath_a;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toverlapLength += lengthA\n\t\t\t\t\t\t\t\t\t\t* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // accumulate\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (overlapLength > tolerance) {\n\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlastScalar = overlapEvent.m_scalar_a_1;\n\n\t\t\t\t\t\t\tif (lastScalar == 1.0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lengthA * (1.0 - lastScalar) > tolerance) {\n\t\t\t\t\t\toverlapLength = 0.0; // reset\n\t\t\t\t\t}\n\t\t\t\t\tievent = 0;\n\t\t\t\t\teventIndices.resize(0);\n\t\t\t\t\trelOps.m_overlap_events.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dim;\n\t}", "language": "java", "code": "static int linearPathIntersectsLinearPathMaxDim_(MultiPath _multipathA,\n\t\t\tMultiPath _multipathB, double tolerance,\n\t\t\tAttributeStreamOfDbl intersections) {\n\t\tMultiPath multipathA;\n\t\tMultiPath multipathB;\n\n\t\tif (_multipathA.getSegmentCount() > _multipathB.getSegmentCount()) {\n\t\t\tmultipathA = _multipathB;\n\t\t\tmultipathB = _multipathA;\n\t\t} else {\n\t\t\tmultipathA = _multipathA;\n\t\t\tmultipathB = _multipathB;\n\t\t}\n\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\t\tSegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t.querySegmentIterator();\n\t\tdouble[] scalarsA = new double[2];\n\t\tdouble[] scalarsB = new double[2];\n\n\t\tint dim = -1;\n\n\t\tint ievent = 0;\n\t\tdouble overlapLength;\n\t\tAttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);\n\t\tRelationalOperations relOps = new RelationalOperations();\n\t\tOverlapComparer overlapComparer = new OverlapComparer(relOps);\n\t\tOverlapEvent overlapEvent;\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipathB.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tPoint2D int_point = null;\n\n\t\tif (intersections != null) {\n\t\t\tint_point = new Point2D();\n\t\t}\n\n\t\tQuadTreeImpl qtB = null;\n\t\tQuadTreeImpl quadTreeB = null;\n        QuadTreeImpl quadTreePathsB = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeB = accel.getQuadTree();\n            quadTreePathsB = accel.getQuadTreeForPaths();\n\t\t\tif (quadTreeB == null) {\n\t\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\t\tquadTreeB = qtB;\n\t\t\t}\n\t\t} else {\n\t\t\tqtB = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) multipathB._getImpl(), envInter);\n\t\t\tquadTreeB = qtB;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;\n        if (quadTreePathsB != null)\n            qtIterPathsB = quadTreePathsB.getIterator();\n\n\t\twhile (segIterA.nextPath()) {\n\t\t\toverlapLength = 0.0;\n\n\t\t\twhile (segIterA.hasNextSegment()) {\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tsegmentA.queryEnvelope2D(env_a);\n\n\t\t\t\tif (!env_a.isIntersecting(envInter)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n                if (qtIterPathsB != null) {\n                    qtIterPathsB.resetIterator(env_a, tolerance);\n\n                    if (qtIterPathsB.next() == -1)\n                        continue;\n                }\n\n\t\t\t\tdouble lengthA = segmentA.calculateLength2D();\n\n\t\t\t\tqtIterB.resetIterator(segmentA, tolerance);\n\n\t\t\t\tfor (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB\n\t\t\t\t\t\t.next()) {\n\t\t\t\t\tint vertex_b = quadTreeB.getElement(elementHandleB);\n\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\n\t\t\t\t\tSegment segmentB = segIterB.nextSegment();\n\t\t\t\t\tdouble lengthB = segmentB.calculateLength2D();\n\n\t\t\t\t\tint result = segmentA.intersect(segmentB, null, scalarsA,\n\t\t\t\t\t\t\tscalarsB, tolerance);\n\n\t\t\t\t\tif (result > 0) {\n\t\t\t\t\t\tdouble scalar_a_0 = scalarsA[0];\n\t\t\t\t\t\tdouble scalar_b_0 = scalarsB[0];\n\t\t\t\t\t\tdouble scalar_a_1 = (result == 2 ? scalarsA[1]\n\t\t\t\t\t\t\t\t: NumberUtils.TheNaN);\n\t\t\t\t\t\tdouble scalar_b_1 = (result == 2 ? scalarsB[1]\n\t\t\t\t\t\t\t\t: NumberUtils.TheNaN);\n\n\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\tif (lengthA * (scalar_a_1 - scalar_a_0) > tolerance) {\n\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Quick neighbor check\n\t\t\t\t\t\t\tdouble length = lengthA * (scalar_a_1 - scalar_a_0);\n\n\t\t\t\t\t\t\tif (segIterB.hasNextSegment()) {\n\t\t\t\t\t\t\t\tsegmentB = segIterB.nextSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthNext = lengthA\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthNext > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\t\t\t\t\t\tsegIterB.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!segIterB.isFirstSegmentInPath()) {\n\t\t\t\t\t\t\t\tsegIterB.previousSegment();\n\t\t\t\t\t\t\t\tsegmentB = segIterB.previousSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthPrevious = lengthA\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthPrevious > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\t\t\t\t\t\tsegIterB.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (segIterA.hasNextSegment()) {\n\t\t\t\t\t\t\t\tint vertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\t\tsegmentA = segIterA.nextSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthNext = lengthA\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthNext > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\t\t\t\t\t\tsegIterA.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!segIterA.isFirstSegmentInPath()) {\n\t\t\t\t\t\t\t\tint vertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\t\tsegIterA.previousSegment();\n\t\t\t\t\t\t\t\tsegmentA = segIterA.previousSegment();\n\t\t\t\t\t\t\t\tresult = segmentA.intersect(segmentB, null,\n\t\t\t\t\t\t\t\t\t\tscalarsA, null, tolerance);\n\n\t\t\t\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\t\t\t\tdouble nextScalarA0 = scalarsA[0];\n\t\t\t\t\t\t\t\t\tdouble nextScalarA1 = scalarsA[1];\n\n\t\t\t\t\t\t\t\t\tdouble lengthPrevious = lengthB\n\t\t\t\t\t\t\t\t\t\t\t* (nextScalarA1 - nextScalarA0);\n\n\t\t\t\t\t\t\t\t\tif (length + lengthPrevious > tolerance) {\n\t\t\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\t\t\t\t\t\tsegIterA.nextSegment();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint ivertex_a = segIterA.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_a = segIterA.getPathIndex();\n\t\t\t\t\t\t\tint ivertex_b = segIterB.getStartPointIndex();\n\t\t\t\t\t\t\tint ipath_b = segIterB.getPathIndex();\n\n\t\t\t\t\t\t\toverlapEvent = OverlapEvent.construct(ivertex_a,\n\t\t\t\t\t\t\t\t\tipath_a, scalar_a_0, scalar_a_1, ivertex_b,\n\t\t\t\t\t\t\t\t\tipath_b, scalar_b_0, scalar_b_1);\n\t\t\t\t\t\t\trelOps.m_overlap_events.add(overlapEvent);\n\t\t\t\t\t\t\teventIndices.add(eventIndices.size());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdim = 0;\n\n\t\t\t\t\t\tif (intersections != null) {\n\t\t\t\t\t\t\tsegmentA.getCoord2D(scalar_a_0, int_point);\n\t\t\t\t\t\t\tintersections.add(int_point.x);\n\t\t\t\t\t\t\tintersections.add(int_point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ievent < relOps.m_overlap_events.size()) {\n\t\t\t\t\teventIndices.Sort(ievent, eventIndices.size(),\n\t\t\t\t\t\t\toverlapComparer);\n\n\t\t\t\t\tdouble lastScalar = 0.0;\n\t\t\t\t\tint lastPath = relOps.m_overlap_events.get(eventIndices\n\t\t\t\t\t\t\t.get(ievent)).m_ipath_a;\n\n\t\t\t\t\tfor (int i = ievent; i < relOps.m_overlap_events.size(); i++) {\n\t\t\t\t\t\toverlapEvent = relOps.m_overlap_events.get(eventIndices\n\t\t\t\t\t\t\t\t.get(i));\n\n\t\t\t\t\t\tif (overlapEvent.m_scalar_a_0 < lastScalar\n\t\t\t\t\t\t\t\t&& overlapEvent.m_scalar_a_1 < lastScalar) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) > tolerance) {\n\t\t\t\t\t\t\toverlapLength = lengthA\n\t\t\t\t\t\t\t\t\t* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset\n\t\t\t\t\t\t\tlastScalar = overlapEvent.m_scalar_a_1;\n\t\t\t\t\t\t\tlastPath = overlapEvent.m_ipath_a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (overlapEvent.m_ipath_a != lastPath) {\n\t\t\t\t\t\t\t\toverlapLength = lengthA\n\t\t\t\t\t\t\t\t\t\t* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset\n\t\t\t\t\t\t\t\tlastPath = overlapEvent.m_ipath_a;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toverlapLength += lengthA\n\t\t\t\t\t\t\t\t\t\t* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // accumulate\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (overlapLength > tolerance) {\n\t\t\t\t\t\t\t\tdim = 1;\n\t\t\t\t\t\t\t\treturn dim;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlastScalar = overlapEvent.m_scalar_a_1;\n\n\t\t\t\t\t\t\tif (lastScalar == 1.0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lengthA * (1.0 - lastScalar) > tolerance) {\n\t\t\t\t\t\toverlapLength = 0.0; // reset\n\t\t\t\t\t}\n\t\t\t\t\tievent = 0;\n\t\t\t\t\teventIndices.resize(0);\n\t\t\t\t\trelOps.m_overlap_events.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dim;\n\t}", "code_tokens": ["static", "int", "linearPathIntersectsLinearPathMaxDim_", "(", "MultiPath", "_multipathA", ",", "MultiPath", "_multipathB", ",", "double", "tolerance", ",", "AttributeStreamOfDbl", "intersections", ")", "{", "MultiPath", "multipathA", ";", "MultiPath", "multipathB", ";", "if", "(", "_multipathA", ".", "getSegmentCount", "(", ")", ">", "_multipathB", ".", "getSegmentCount", "(", ")", ")", "{", "multipathA", "=", "_multipathB", ";", "multipathB", "=", "_multipathA", ";", "}", "else", "{", "multipathA", "=", "_multipathA", ";", "multipathB", "=", "_multipathB", ";", "}", "SegmentIteratorImpl", "segIterA", "=", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "SegmentIteratorImpl", "segIterB", "=", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "double", "[", "]", "scalarsA", "=", "new", "double", "[", "2", "]", ";", "double", "[", "]", "scalarsB", "=", "new", "double", "[", "2", "]", ";", "int", "dim", "=", "-", "1", ";", "int", "ievent", "=", "0", ";", "double", "overlapLength", ";", "AttributeStreamOfInt32", "eventIndices", "=", "new", "AttributeStreamOfInt32", "(", "0", ")", ";", "RelationalOperations", "relOps", "=", "new", "RelationalOperations", "(", ")", ";", "OverlapComparer", "overlapComparer", "=", "new", "OverlapComparer", "(", "relOps", ")", ";", "OverlapEvent", "overlapEvent", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "envInter", "=", "new", "Envelope2D", "(", ")", ";", "multipathA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipathB", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "env_b", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "envInter", ".", "setCoords", "(", "env_a", ")", ";", "envInter", ".", "intersect", "(", "env_b", ")", ";", "Point2D", "int_point", "=", "null", ";", "if", "(", "intersections", "!=", "null", ")", "{", "int_point", "=", "new", "Point2D", "(", ")", ";", "}", "QuadTreeImpl", "qtB", "=", "null", ";", "QuadTreeImpl", "quadTreeB", "=", "null", ";", "QuadTreeImpl", "quadTreePathsB", "=", "null", ";", "GeometryAccelerators", "accel", "=", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ")", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "quadTreeB", "=", "accel", ".", "getQuadTree", "(", ")", ";", "quadTreePathsB", "=", "accel", ".", "getQuadTreeForPaths", "(", ")", ";", "if", "(", "quadTreeB", "==", "null", ")", "{", "qtB", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeB", "=", "qtB", ";", "}", "}", "else", "{", "qtB", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeB", "=", "qtB", ";", "}", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterB", "=", "quadTreeB", ".", "getIterator", "(", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterPathsB", "=", "null", ";", "if", "(", "quadTreePathsB", "!=", "null", ")", "qtIterPathsB", "=", "quadTreePathsB", ".", "getIterator", "(", ")", ";", "while", "(", "segIterA", ".", "nextPath", "(", ")", ")", "{", "overlapLength", "=", "0.0", ";", "while", "(", "segIterA", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "segmentA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "if", "(", "!", "env_a", ".", "isIntersecting", "(", "envInter", ")", ")", "{", "continue", ";", "}", "if", "(", "qtIterPathsB", "!=", "null", ")", "{", "qtIterPathsB", ".", "resetIterator", "(", "env_a", ",", "tolerance", ")", ";", "if", "(", "qtIterPathsB", ".", "next", "(", ")", "==", "-", "1", ")", "continue", ";", "}", "double", "lengthA", "=", "segmentA", ".", "calculateLength2D", "(", ")", ";", "qtIterB", ".", "resetIterator", "(", "segmentA", ",", "tolerance", ")", ";", "for", "(", "int", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ";", "elementHandleB", "!=", "-", "1", ";", "elementHandleB", "=", "qtIterB", ".", "next", "(", ")", ")", "{", "int", "vertex_b", "=", "quadTreeB", ".", "getElement", "(", "elementHandleB", ")", ";", "segIterB", ".", "resetToVertex", "(", "vertex_b", ")", ";", "Segment", "segmentB", "=", "segIterB", ".", "nextSegment", "(", ")", ";", "double", "lengthB", "=", "segmentB", ".", "calculateLength2D", "(", ")", ";", "int", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "scalarsB", ",", "tolerance", ")", ";", "if", "(", "result", ">", "0", ")", "{", "double", "scalar_a_0", "=", "scalarsA", "[", "0", "]", ";", "double", "scalar_b_0", "=", "scalarsB", "[", "0", "]", ";", "double", "scalar_a_1", "=", "(", "result", "==", "2", "?", "scalarsA", "[", "1", "]", ":", "NumberUtils", ".", "TheNaN", ")", ";", "double", "scalar_b_1", "=", "(", "result", "==", "2", "?", "scalarsB", "[", "1", "]", ":", "NumberUtils", ".", "TheNaN", ")", ";", "if", "(", "result", "==", "2", ")", "{", "if", "(", "lengthA", "*", "(", "scalar_a_1", "-", "scalar_a_0", ")", ">", "tolerance", ")", "{", "dim", "=", "1", ";", "return", "dim", ";", "}", "// Quick neighbor check", "double", "length", "=", "lengthA", "*", "(", "scalar_a_1", "-", "scalar_a_0", ")", ";", "if", "(", "segIterB", ".", "hasNextSegment", "(", ")", ")", "{", "segmentB", "=", "segIterB", ".", "nextSegment", "(", ")", ";", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "null", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", ")", "{", "double", "nextScalarA0", "=", "scalarsA", "[", "0", "]", ";", "double", "nextScalarA1", "=", "scalarsA", "[", "1", "]", ";", "double", "lengthNext", "=", "lengthA", "*", "(", "nextScalarA1", "-", "nextScalarA0", ")", ";", "if", "(", "length", "+", "lengthNext", ">", "tolerance", ")", "{", "dim", "=", "1", ";", "return", "dim", ";", "}", "}", "segIterB", ".", "resetToVertex", "(", "vertex_b", ")", ";", "segIterB", ".", "nextSegment", "(", ")", ";", "}", "if", "(", "!", "segIterB", ".", "isFirstSegmentInPath", "(", ")", ")", "{", "segIterB", ".", "previousSegment", "(", ")", ";", "segmentB", "=", "segIterB", ".", "previousSegment", "(", ")", ";", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "null", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", ")", "{", "double", "nextScalarA0", "=", "scalarsA", "[", "0", "]", ";", "double", "nextScalarA1", "=", "scalarsA", "[", "1", "]", ";", "double", "lengthPrevious", "=", "lengthA", "*", "(", "nextScalarA1", "-", "nextScalarA0", ")", ";", "if", "(", "length", "+", "lengthPrevious", ">", "tolerance", ")", "{", "dim", "=", "1", ";", "return", "dim", ";", "}", "}", "segIterB", ".", "resetToVertex", "(", "vertex_b", ")", ";", "segIterB", ".", "nextSegment", "(", ")", ";", "}", "if", "(", "segIterA", ".", "hasNextSegment", "(", ")", ")", "{", "int", "vertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "null", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", ")", "{", "double", "nextScalarA0", "=", "scalarsA", "[", "0", "]", ";", "double", "nextScalarA1", "=", "scalarsA", "[", "1", "]", ";", "double", "lengthNext", "=", "lengthA", "*", "(", "nextScalarA1", "-", "nextScalarA0", ")", ";", "if", "(", "length", "+", "lengthNext", ">", "tolerance", ")", "{", "dim", "=", "1", ";", "return", "dim", ";", "}", "}", "segIterA", ".", "resetToVertex", "(", "vertex_a", ")", ";", "segIterA", ".", "nextSegment", "(", ")", ";", "}", "if", "(", "!", "segIterA", ".", "isFirstSegmentInPath", "(", ")", ")", "{", "int", "vertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "segIterA", ".", "previousSegment", "(", ")", ";", "segmentA", "=", "segIterA", ".", "previousSegment", "(", ")", ";", "result", "=", "segmentA", ".", "intersect", "(", "segmentB", ",", "null", ",", "scalarsA", ",", "null", ",", "tolerance", ")", ";", "if", "(", "result", "==", "2", ")", "{", "double", "nextScalarA0", "=", "scalarsA", "[", "0", "]", ";", "double", "nextScalarA1", "=", "scalarsA", "[", "1", "]", ";", "double", "lengthPrevious", "=", "lengthB", "*", "(", "nextScalarA1", "-", "nextScalarA0", ")", ";", "if", "(", "length", "+", "lengthPrevious", ">", "tolerance", ")", "{", "dim", "=", "1", ";", "return", "dim", ";", "}", "}", "segIterA", ".", "resetToVertex", "(", "vertex_a", ")", ";", "segIterA", ".", "nextSegment", "(", ")", ";", "}", "int", "ivertex_a", "=", "segIterA", ".", "getStartPointIndex", "(", ")", ";", "int", "ipath_a", "=", "segIterA", ".", "getPathIndex", "(", ")", ";", "int", "ivertex_b", "=", "segIterB", ".", "getStartPointIndex", "(", ")", ";", "int", "ipath_b", "=", "segIterB", ".", "getPathIndex", "(", ")", ";", "overlapEvent", "=", "OverlapEvent", ".", "construct", "(", "ivertex_a", ",", "ipath_a", ",", "scalar_a_0", ",", "scalar_a_1", ",", "ivertex_b", ",", "ipath_b", ",", "scalar_b_0", ",", "scalar_b_1", ")", ";", "relOps", ".", "m_overlap_events", ".", "add", "(", "overlapEvent", ")", ";", "eventIndices", ".", "add", "(", "eventIndices", ".", "size", "(", ")", ")", ";", "}", "dim", "=", "0", ";", "if", "(", "intersections", "!=", "null", ")", "{", "segmentA", ".", "getCoord2D", "(", "scalar_a_0", ",", "int_point", ")", ";", "intersections", ".", "add", "(", "int_point", ".", "x", ")", ";", "intersections", ".", "add", "(", "int_point", ".", "y", ")", ";", "}", "}", "}", "if", "(", "ievent", "<", "relOps", ".", "m_overlap_events", ".", "size", "(", ")", ")", "{", "eventIndices", ".", "Sort", "(", "ievent", ",", "eventIndices", ".", "size", "(", ")", ",", "overlapComparer", ")", ";", "double", "lastScalar", "=", "0.0", ";", "int", "lastPath", "=", "relOps", ".", "m_overlap_events", ".", "get", "(", "eventIndices", ".", "get", "(", "ievent", ")", ")", ".", "m_ipath_a", ";", "for", "(", "int", "i", "=", "ievent", ";", "i", "<", "relOps", ".", "m_overlap_events", ".", "size", "(", ")", ";", "i", "++", ")", "{", "overlapEvent", "=", "relOps", ".", "m_overlap_events", ".", "get", "(", "eventIndices", ".", "get", "(", "i", ")", ")", ";", "if", "(", "overlapEvent", ".", "m_scalar_a_0", "<", "lastScalar", "&&", "overlapEvent", ".", "m_scalar_a_1", "<", "lastScalar", ")", "{", "continue", ";", "}", "if", "(", "lengthA", "*", "(", "overlapEvent", ".", "m_scalar_a_0", "-", "lastScalar", ")", ">", "tolerance", ")", "{", "overlapLength", "=", "lengthA", "*", "(", "overlapEvent", ".", "m_scalar_a_1", "-", "overlapEvent", ".", "m_scalar_a_0", ")", ";", "// reset", "lastScalar", "=", "overlapEvent", ".", "m_scalar_a_1", ";", "lastPath", "=", "overlapEvent", ".", "m_ipath_a", ";", "}", "else", "{", "if", "(", "overlapEvent", ".", "m_ipath_a", "!=", "lastPath", ")", "{", "overlapLength", "=", "lengthA", "*", "(", "overlapEvent", ".", "m_scalar_a_1", "-", "overlapEvent", ".", "m_scalar_a_0", ")", ";", "// reset", "lastPath", "=", "overlapEvent", ".", "m_ipath_a", ";", "}", "else", "{", "overlapLength", "+=", "lengthA", "*", "(", "overlapEvent", ".", "m_scalar_a_1", "-", "overlapEvent", ".", "m_scalar_a_0", ")", ";", "// accumulate", "}", "if", "(", "overlapLength", ">", "tolerance", ")", "{", "dim", "=", "1", ";", "return", "dim", ";", "}", "lastScalar", "=", "overlapEvent", ".", "m_scalar_a_1", ";", "if", "(", "lastScalar", "==", "1.0", ")", "{", "break", ";", "}", "}", "}", "if", "(", "lengthA", "*", "(", "1.0", "-", "lastScalar", ")", ">", "tolerance", ")", "{", "overlapLength", "=", "0.0", ";", "// reset", "}", "ievent", "=", "0", ";", "eventIndices", ".", "resize", "(", "0", ")", ";", "relOps", ".", "m_overlap_events", ".", "clear", "(", ")", ";", "}", "}", "}", "return", "dim", ";", "}"], "docstring": "_multipathB.", "docstring_tokens": ["_multipathB", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L3810-L4102", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathIntersectsLinearPath_", "original_string": "private static boolean linearPathIntersectsLinearPath_(\n\t\t\tMultiPath multipathA, MultiPath multipathB, double tolerance) {\n\t\tMultiPathImpl multi_path_impl_a = (MultiPathImpl) multipathA._getImpl();\n\t\tMultiPathImpl multi_path_impl_b = (MultiPathImpl) multipathB._getImpl();\n\n\t\tSegmentIteratorImpl segIterA = multi_path_impl_a.querySegmentIterator();\n\t\tSegmentIteratorImpl segIterB = multi_path_impl_b.querySegmentIterator();\n\n        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, false);\n\n\t\twhile (intersector.next()) {\n\t\t\tint vertex_a = intersector.getRedElement();\n\t\t\tint vertex_b = intersector.getBlueElement();\n\n\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\tSegment segmentB = segIterB.nextSegment();\n\n\t\t\tint result = segmentB.intersect(segmentA, null, null, null,\n\t\t\t\t\ttolerance);\n\n\t\t\tif (result > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean linearPathIntersectsLinearPath_(\n\t\t\tMultiPath multipathA, MultiPath multipathB, double tolerance) {\n\t\tMultiPathImpl multi_path_impl_a = (MultiPathImpl) multipathA._getImpl();\n\t\tMultiPathImpl multi_path_impl_b = (MultiPathImpl) multipathB._getImpl();\n\n\t\tSegmentIteratorImpl segIterA = multi_path_impl_a.querySegmentIterator();\n\t\tSegmentIteratorImpl segIterB = multi_path_impl_b.querySegmentIterator();\n\n        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, false);\n\n\t\twhile (intersector.next()) {\n\t\t\tint vertex_a = intersector.getRedElement();\n\t\t\tint vertex_b = intersector.getBlueElement();\n\n\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\tsegIterB.resetToVertex(vertex_b);\n\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\tSegment segmentB = segIterB.nextSegment();\n\n\t\t\tint result = segmentB.intersect(segmentA, null, null, null,\n\t\t\t\t\ttolerance);\n\n\t\t\tif (result > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "linearPathIntersectsLinearPath_", "(", "MultiPath", "multipathA", ",", "MultiPath", "multipathB", ",", "double", "tolerance", ")", "{", "MultiPathImpl", "multi_path_impl_a", "=", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ";", "MultiPathImpl", "multi_path_impl_b", "=", "(", "MultiPathImpl", ")", "multipathB", ".", "_getImpl", "(", ")", ";", "SegmentIteratorImpl", "segIterA", "=", "multi_path_impl_a", ".", "querySegmentIterator", "(", ")", ";", "SegmentIteratorImpl", "segIterB", "=", "multi_path_impl_b", ".", "querySegmentIterator", "(", ")", ";", "PairwiseIntersectorImpl", "intersector", "=", "new", "PairwiseIntersectorImpl", "(", "multi_path_impl_a", ",", "multi_path_impl_b", ",", "tolerance", ",", "false", ")", ";", "while", "(", "intersector", ".", "next", "(", ")", ")", "{", "int", "vertex_a", "=", "intersector", ".", "getRedElement", "(", ")", ";", "int", "vertex_b", "=", "intersector", ".", "getBlueElement", "(", ")", ";", "segIterA", ".", "resetToVertex", "(", "vertex_a", ")", ";", "segIterB", ".", "resetToVertex", "(", "vertex_b", ")", ";", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "Segment", "segmentB", "=", "segIterB", ".", "nextSegment", "(", ")", ";", "int", "result", "=", "segmentB", ".", "intersect", "(", "segmentA", ",", "null", ",", "null", ",", "null", ",", "tolerance", ")", ";", "if", "(", "result", ">", "0", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "segments of _multipathB.", "docstring_tokens": ["segments", "of", "_multipathB", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L4106-L4134", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathIntersectsMultiPoint_", "original_string": "private static boolean linearPathIntersectsMultiPoint_(\n\t\t\tMultiPath multipathA, MultiPoint multipoint_b, double tolerance,\n\t\t\tboolean b_intersects_all) {\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tboolean bContained = true;\n\t\tboolean bInteriorHitFound = false;\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\n\t\tif (!env_a.contains(env_b)) {\n\t\t\tbContained = false;\n\t\t}\n\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tQuadTreeImpl qtA = null;\n\t\tQuadTreeImpl quadTreeA = null;\n        QuadTreeImpl quadTreePathsA = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeA = accel.getQuadTree();\n\t\t\tif (quadTreeA == null) {\n\t\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) multipathA._getImpl(), envInter);\n\t\t\t\tquadTreeA = qtA;\n\t\t\t}\n\t\t} else {\n\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) multipathA._getImpl(), envInter);\n\t\t\tquadTreeA = qtA;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;\n        if (quadTreePathsA != null)\n            qtIterPathsA = quadTreePathsA.getIterator();\n\n\t\tPoint2D ptB = new Point2D(), closest = new Point2D();\n\t\tboolean b_intersects = false;\n\t\tdouble toleranceSq = tolerance * tolerance;\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (!envInter.contains(ptB)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tenv_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);\n\n            if (qtIterPathsA != null) {\n                qtIterPathsA.resetIterator(env_b, tolerance);\n\n                if (qtIterPathsA.next() == -1)\n                    continue;\n            }\n\n\t\t\tqtIterA.resetIterator(env_b, tolerance);\n\n\t\t\tboolean b_covered = false;\n\n\t\t\tfor (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_a = quadTreeA.getElement(elementHandleA);\n\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\n\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\tif (Point2D.sqrDistance(closest, ptB) <= toleranceSq) {\n\t\t\t\t\tb_covered = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b_intersects_all) {\n\t\t\t\tif (!b_covered) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (b_covered) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (b_intersects_all) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean linearPathIntersectsMultiPoint_(\n\t\t\tMultiPath multipathA, MultiPoint multipoint_b, double tolerance,\n\t\t\tboolean b_intersects_all) {\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tboolean bContained = true;\n\t\tboolean bInteriorHitFound = false;\n\n\t\tEnvelope2D env_a = new Envelope2D();\n\t\tEnvelope2D env_b = new Envelope2D();\n\t\tEnvelope2D envInter = new Envelope2D();\n\t\tmultipathA.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\t\tenv_a.inflate(tolerance, tolerance);\n\n\t\tif (!env_a.contains(env_b)) {\n\t\t\tbContained = false;\n\t\t}\n\n\t\tenv_b.inflate(tolerance, tolerance);\n\t\tenvInter.setCoords(env_a);\n\t\tenvInter.intersect(env_b);\n\n\t\tQuadTreeImpl qtA = null;\n\t\tQuadTreeImpl quadTreeA = null;\n        QuadTreeImpl quadTreePathsA = null;\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tquadTreeA = accel.getQuadTree();\n\t\t\tif (quadTreeA == null) {\n\t\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t\t(MultiPathImpl) multipathA._getImpl(), envInter);\n\t\t\t\tquadTreeA = qtA;\n\t\t\t}\n\t\t} else {\n\t\t\tqtA = InternalUtils.buildQuadTree(\n\t\t\t\t\t(MultiPathImpl) multipathA._getImpl(), envInter);\n\t\t\tquadTreeA = qtA;\n\t\t}\n\n\t\tQuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();\n\n        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;\n        if (quadTreePathsA != null)\n            qtIterPathsA = quadTreePathsA.getIterator();\n\n\t\tPoint2D ptB = new Point2D(), closest = new Point2D();\n\t\tboolean b_intersects = false;\n\t\tdouble toleranceSq = tolerance * tolerance;\n\n\t\tfor (int i = 0; i < multipoint_b.getPointCount(); i++) {\n\t\t\tmultipoint_b.getXY(i, ptB);\n\n\t\t\tif (!envInter.contains(ptB)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tenv_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);\n\n            if (qtIterPathsA != null) {\n                qtIterPathsA.resetIterator(env_b, tolerance);\n\n                if (qtIterPathsA.next() == -1)\n                    continue;\n            }\n\n\t\t\tqtIterA.resetIterator(env_b, tolerance);\n\n\t\t\tboolean b_covered = false;\n\n\t\t\tfor (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA\n\t\t\t\t\t.next()) {\n\t\t\t\tint vertex_a = quadTreeA.getElement(elementHandleA);\n\t\t\t\tsegIterA.resetToVertex(vertex_a);\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\n\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\tif (Point2D.sqrDistance(closest, ptB) <= toleranceSq) {\n\t\t\t\t\tb_covered = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b_intersects_all) {\n\t\t\t\tif (!b_covered) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (b_covered) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (b_intersects_all) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "linearPathIntersectsMultiPoint_", "(", "MultiPath", "multipathA", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "boolean", "b_intersects_all", ")", "{", "SegmentIteratorImpl", "segIterA", "=", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "boolean", "bContained", "=", "true", ";", "boolean", "bInteriorHitFound", "=", "false", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "Envelope2D", "envInter", "=", "new", "Envelope2D", "(", ")", ";", "multipathA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "if", "(", "!", "env_a", ".", "contains", "(", "env_b", ")", ")", "{", "bContained", "=", "false", ";", "}", "env_b", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "envInter", ".", "setCoords", "(", "env_a", ")", ";", "envInter", ".", "intersect", "(", "env_b", ")", ";", "QuadTreeImpl", "qtA", "=", "null", ";", "QuadTreeImpl", "quadTreeA", "=", "null", ";", "QuadTreeImpl", "quadTreePathsA", "=", "null", ";", "GeometryAccelerators", "accel", "=", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ")", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "quadTreeA", "=", "accel", ".", "getQuadTree", "(", ")", ";", "if", "(", "quadTreeA", "==", "null", ")", "{", "qtA", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeA", "=", "qtA", ";", "}", "}", "else", "{", "qtA", "=", "InternalUtils", ".", "buildQuadTree", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ",", "envInter", ")", ";", "quadTreeA", "=", "qtA", ";", "}", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterA", "=", "quadTreeA", ".", "getIterator", "(", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qtIterPathsA", "=", "null", ";", "if", "(", "quadTreePathsA", "!=", "null", ")", "qtIterPathsA", "=", "quadTreePathsA", ".", "getIterator", "(", ")", ";", "Point2D", "ptB", "=", "new", "Point2D", "(", ")", ",", "closest", "=", "new", "Point2D", "(", ")", ";", "boolean", "b_intersects", "=", "false", ";", "double", "toleranceSq", "=", "tolerance", "*", "tolerance", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "multipoint_b", ".", "getPointCount", "(", ")", ";", "i", "++", ")", "{", "multipoint_b", ".", "getXY", "(", "i", ",", "ptB", ")", ";", "if", "(", "!", "envInter", ".", "contains", "(", "ptB", ")", ")", "{", "continue", ";", "}", "env_b", ".", "setCoords", "(", "ptB", ".", "x", ",", "ptB", ".", "y", ",", "ptB", ".", "x", ",", "ptB", ".", "y", ")", ";", "if", "(", "qtIterPathsA", "!=", "null", ")", "{", "qtIterPathsA", ".", "resetIterator", "(", "env_b", ",", "tolerance", ")", ";", "if", "(", "qtIterPathsA", ".", "next", "(", ")", "==", "-", "1", ")", "continue", ";", "}", "qtIterA", ".", "resetIterator", "(", "env_b", ",", "tolerance", ")", ";", "boolean", "b_covered", "=", "false", ";", "for", "(", "int", "elementHandleA", "=", "qtIterA", ".", "next", "(", ")", ";", "elementHandleA", "!=", "-", "1", ";", "elementHandleA", "=", "qtIterA", ".", "next", "(", ")", ")", "{", "int", "vertex_a", "=", "quadTreeA", ".", "getElement", "(", "elementHandleA", ")", ";", "segIterA", ".", "resetToVertex", "(", "vertex_a", ")", ";", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "double", "t", "=", "segmentA", ".", "getClosestCoordinate", "(", "ptB", ",", "false", ")", ";", "segmentA", ".", "getCoord2D", "(", "t", ",", "closest", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "closest", ",", "ptB", ")", "<=", "toleranceSq", ")", "{", "b_covered", "=", "true", ";", "break", ";", "}", "}", "if", "(", "b_intersects_all", ")", "{", "if", "(", "!", "b_covered", ")", "{", "return", "false", ";", "}", "}", "else", "{", "if", "(", "b_covered", ")", "{", "return", "true", ";", "}", "}", "}", "if", "(", "b_intersects_all", ")", "{", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Quad_tree_impl.", "docstring_tokens": ["Quad_tree_impl", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L4139-L4244", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathIntersectsPoint_", "original_string": "static boolean linearPathIntersectsPoint_(MultiPath multipathA,\n\t\t\tPoint2D ptB, double tolerance) {\n\t\tPoint2D closest = new Point2D();\n\t\tdouble toleranceSq = tolerance * tolerance;\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tQuadTreeImpl quadTreeA = accel.getQuadTree();\n\t\t\tif (quadTreeA != null) {\n\t\t\t\tEnvelope2D env_b = new Envelope2D();\n\t\t\t\tenv_b.setCoords(ptB);\n\n\t\t\t\tQuadTreeImpl.QuadTreeIteratorImpl qt_iter = quadTreeA\n\t\t\t\t\t\t.getIterator(env_b, tolerance);\n\n\t\t\t\tfor (int e = qt_iter.next(); e != -1; e = qt_iter.next()) {\n\t\t\t\t\tsegIterA.resetToVertex(quadTreeA.getElement(e));\n\n\t\t\t\t\tif (segIterA.hasNextSegment()) {\n\t\t\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\n\t\t\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\t\t\tif (Point2D.sqrDistance(ptB, closest) <= toleranceSq) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tEnvelope2D env_a = new Envelope2D();\n\n\t\twhile (segIterA.nextPath()) {\n\t\t\twhile (segIterA.hasNextSegment()) {\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tsegmentA.queryEnvelope2D(env_a);\n\t\t\t\tenv_a.inflate(tolerance, tolerance);\n\n\t\t\t\tif (!env_a.contains(ptB)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\tif (Point2D.sqrDistance(ptB, closest) <= toleranceSq) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "static boolean linearPathIntersectsPoint_(MultiPath multipathA,\n\t\t\tPoint2D ptB, double tolerance) {\n\t\tPoint2D closest = new Point2D();\n\t\tdouble toleranceSq = tolerance * tolerance;\n\t\tSegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t.querySegmentIterator();\n\n\t\tGeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())\n\t\t\t\t._getAccelerators();\n\n\t\tif (accel != null) {\n\t\t\tQuadTreeImpl quadTreeA = accel.getQuadTree();\n\t\t\tif (quadTreeA != null) {\n\t\t\t\tEnvelope2D env_b = new Envelope2D();\n\t\t\t\tenv_b.setCoords(ptB);\n\n\t\t\t\tQuadTreeImpl.QuadTreeIteratorImpl qt_iter = quadTreeA\n\t\t\t\t\t\t.getIterator(env_b, tolerance);\n\n\t\t\t\tfor (int e = qt_iter.next(); e != -1; e = qt_iter.next()) {\n\t\t\t\t\tsegIterA.resetToVertex(quadTreeA.getElement(e));\n\n\t\t\t\t\tif (segIterA.hasNextSegment()) {\n\t\t\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\n\t\t\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\t\t\tif (Point2D.sqrDistance(ptB, closest) <= toleranceSq) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tEnvelope2D env_a = new Envelope2D();\n\n\t\twhile (segIterA.nextPath()) {\n\t\t\twhile (segIterA.hasNextSegment()) {\n\t\t\t\tSegment segmentA = segIterA.nextSegment();\n\t\t\t\tsegmentA.queryEnvelope2D(env_a);\n\t\t\t\tenv_a.inflate(tolerance, tolerance);\n\n\t\t\t\tif (!env_a.contains(ptB)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble t = segmentA.getClosestCoordinate(ptB, false);\n\t\t\t\tsegmentA.getCoord2D(t, closest);\n\n\t\t\t\tif (Point2D.sqrDistance(ptB, closest) <= toleranceSq) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["static", "boolean", "linearPathIntersectsPoint_", "(", "MultiPath", "multipathA", ",", "Point2D", "ptB", ",", "double", "tolerance", ")", "{", "Point2D", "closest", "=", "new", "Point2D", "(", ")", ";", "double", "toleranceSq", "=", "tolerance", "*", "tolerance", ";", "SegmentIteratorImpl", "segIterA", "=", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ")", ".", "querySegmentIterator", "(", ")", ";", "GeometryAccelerators", "accel", "=", "(", "(", "MultiPathImpl", ")", "multipathA", ".", "_getImpl", "(", ")", ")", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "QuadTreeImpl", "quadTreeA", "=", "accel", ".", "getQuadTree", "(", ")", ";", "if", "(", "quadTreeA", "!=", "null", ")", "{", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "env_b", ".", "setCoords", "(", "ptB", ")", ";", "QuadTreeImpl", ".", "QuadTreeIteratorImpl", "qt_iter", "=", "quadTreeA", ".", "getIterator", "(", "env_b", ",", "tolerance", ")", ";", "for", "(", "int", "e", "=", "qt_iter", ".", "next", "(", ")", ";", "e", "!=", "-", "1", ";", "e", "=", "qt_iter", ".", "next", "(", ")", ")", "{", "segIterA", ".", "resetToVertex", "(", "quadTreeA", ".", "getElement", "(", "e", ")", ")", ";", "if", "(", "segIterA", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "double", "t", "=", "segmentA", ".", "getClosestCoordinate", "(", "ptB", ",", "false", ")", ";", "segmentA", ".", "getCoord2D", "(", "t", ",", "closest", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptB", ",", "closest", ")", "<=", "toleranceSq", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}", "}", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "while", "(", "segIterA", ".", "nextPath", "(", ")", ")", "{", "while", "(", "segIterA", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segmentA", "=", "segIterA", ".", "nextSegment", "(", ")", ";", "segmentA", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "env_a", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "if", "(", "!", "env_a", ".", "contains", "(", "ptB", ")", ")", "{", "continue", ";", "}", "double", "t", "=", "segmentA", ".", "getClosestCoordinate", "(", "ptB", ",", "false", ")", ";", "segmentA", ".", "getCoord2D", "(", "t", ",", "closest", ")", ";", "if", "(", "Point2D", ".", "sqrDistance", "(", "ptB", ",", "closest", ")", "<=", "toleranceSq", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "docstring": "Returns true if a segment of multipathA intersects point_b.", "docstring_tokens": ["Returns", "true", "if", "a", "segment", "of", "multipathA", "intersects", "point_b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L4247-L4306", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.linearPathIntersectsEnvelope_", "original_string": "private static boolean linearPathIntersectsEnvelope_(MultiPath multipath_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (!multipath_a.hasNonLinearSegments()) {\n\t\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\t\tenv_b_inflated.setCoords(env_b);\n\t\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\t\tMultiPathImpl mimpl_a = (MultiPathImpl) multipath_a._getImpl();\n\t\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) (mimpl_a\n\t\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tPoint2D pt_prev = new Point2D();\n\t\t\tPoint2D pt_1 = new Point2D();\n\t\t\tPoint2D pt_2 = new Point2D();\n\t\t\tfor (int ipath = 0, npath = mimpl_a.getPathCount(); ipath < npath; ipath++) {\n\t\t\t\tboolean b_first = true;\n\t\t\t\tfor (int i = mimpl_a.getPathStart(ipath), n = mimpl_a\n\t\t\t\t\t\t.getPathEnd(ipath); i < n; i++) {\n\t\t\t\t\tif (b_first) {\n\t\t\t\t\t\txy.read(2 * i, pt_prev);\n\t\t\t\t\t\tb_first = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\txy.read(2 * i, pt);\n\t\t\t\t\tpt_1.setCoords(pt_prev);\n\t\t\t\t\tpt_2.setCoords(pt);\n\t\t\t\t\tif (env_b_inflated.clipLine(pt_1, pt_2) != 0)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tpt_prev.setCoords(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tLine line_1 = new Line(env_b.xmin, env_b.ymin, env_b.xmin,\n\t\t\t\t\tenv_b.ymax);\n\t\t\tLine line_2 = new Line(env_b.xmin, env_b.ymax, env_b.xmax,\n\t\t\t\t\tenv_b.ymax);\n\t\t\tLine line3 = new Line(env_b.xmax, env_b.ymax, env_b.xmax,\n\t\t\t\t\tenv_b.ymin);\n\t\t\tLine line4 = new Line(env_b.xmax, env_b.ymin, env_b.xmin,\n\t\t\t\t\tenv_b.ymin);\n\t\t\tSegmentIterator iter = multipath_a.querySegmentIterator();\n\t\t\twhile (iter.nextPath()) {\n\t\t\t\twhile (iter.hasNextSegment()) {\n\t\t\t\t\tSegment polySeg = iter.nextSegment();\n\t\t\t\t\tif (polySeg.isIntersecting(line_1, tolerance))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tif (polySeg.isIntersecting(line_2, tolerance))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tif (polySeg.isIntersecting(line3, tolerance))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tif (polySeg.isIntersecting(line4, tolerance))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean linearPathIntersectsEnvelope_(MultiPath multipath_a,\n\t\t\tEnvelope2D env_b, double tolerance, ProgressTracker progress_tracker) {\n\t\tif (!multipath_a.hasNonLinearSegments()) {\n\t\t\tEnvelope2D env_b_inflated = new Envelope2D();\n\t\t\tenv_b_inflated.setCoords(env_b);\n\t\t\tenv_b_inflated.inflate(tolerance, tolerance);\n\t\t\tMultiPathImpl mimpl_a = (MultiPathImpl) multipath_a._getImpl();\n\t\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) (mimpl_a\n\t\t\t\t\t.getAttributeStreamRef(VertexDescription.Semantics.POSITION));\n\t\t\tPoint2D pt = new Point2D();\n\t\t\tPoint2D pt_prev = new Point2D();\n\t\t\tPoint2D pt_1 = new Point2D();\n\t\t\tPoint2D pt_2 = new Point2D();\n\t\t\tfor (int ipath = 0, npath = mimpl_a.getPathCount(); ipath < npath; ipath++) {\n\t\t\t\tboolean b_first = true;\n\t\t\t\tfor (int i = mimpl_a.getPathStart(ipath), n = mimpl_a\n\t\t\t\t\t\t.getPathEnd(ipath); i < n; i++) {\n\t\t\t\t\tif (b_first) {\n\t\t\t\t\t\txy.read(2 * i, pt_prev);\n\t\t\t\t\t\tb_first = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\txy.read(2 * i, pt);\n\t\t\t\t\tpt_1.setCoords(pt_prev);\n\t\t\t\t\tpt_2.setCoords(pt);\n\t\t\t\t\tif (env_b_inflated.clipLine(pt_1, pt_2) != 0)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tpt_prev.setCoords(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tLine line_1 = new Line(env_b.xmin, env_b.ymin, env_b.xmin,\n\t\t\t\t\tenv_b.ymax);\n\t\t\tLine line_2 = new Line(env_b.xmin, env_b.ymax, env_b.xmax,\n\t\t\t\t\tenv_b.ymax);\n\t\t\tLine line3 = new Line(env_b.xmax, env_b.ymax, env_b.xmax,\n\t\t\t\t\tenv_b.ymin);\n\t\t\tLine line4 = new Line(env_b.xmax, env_b.ymin, env_b.xmin,\n\t\t\t\t\tenv_b.ymin);\n\t\t\tSegmentIterator iter = multipath_a.querySegmentIterator();\n\t\t\twhile (iter.nextPath()) {\n\t\t\t\twhile (iter.hasNextSegment()) {\n\t\t\t\t\tSegment polySeg = iter.nextSegment();\n\t\t\t\t\tif (polySeg.isIntersecting(line_1, tolerance))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tif (polySeg.isIntersecting(line_2, tolerance))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tif (polySeg.isIntersecting(line3, tolerance))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tif (polySeg.isIntersecting(line4, tolerance))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "linearPathIntersectsEnvelope_", "(", "MultiPath", "multipath_a", ",", "Envelope2D", "env_b", ",", "double", "tolerance", ",", "ProgressTracker", "progress_tracker", ")", "{", "if", "(", "!", "multipath_a", ".", "hasNonLinearSegments", "(", ")", ")", "{", "Envelope2D", "env_b_inflated", "=", "new", "Envelope2D", "(", ")", ";", "env_b_inflated", ".", "setCoords", "(", "env_b", ")", ";", "env_b_inflated", ".", "inflate", "(", "tolerance", ",", "tolerance", ")", ";", "MultiPathImpl", "mimpl_a", "=", "(", "MultiPathImpl", ")", "multipath_a", ".", "_getImpl", "(", ")", ";", "AttributeStreamOfDbl", "xy", "=", "(", "AttributeStreamOfDbl", ")", "(", "mimpl_a", ".", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt_prev", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt_1", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt_2", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "ipath", "=", "0", ",", "npath", "=", "mimpl_a", ".", "getPathCount", "(", ")", ";", "ipath", "<", "npath", ";", "ipath", "++", ")", "{", "boolean", "b_first", "=", "true", ";", "for", "(", "int", "i", "=", "mimpl_a", ".", "getPathStart", "(", "ipath", ")", ",", "n", "=", "mimpl_a", ".", "getPathEnd", "(", "ipath", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "b_first", ")", "{", "xy", ".", "read", "(", "2", "*", "i", ",", "pt_prev", ")", ";", "b_first", "=", "false", ";", "continue", ";", "}", "xy", ".", "read", "(", "2", "*", "i", ",", "pt", ")", ";", "pt_1", ".", "setCoords", "(", "pt_prev", ")", ";", "pt_2", ".", "setCoords", "(", "pt", ")", ";", "if", "(", "env_b_inflated", ".", "clipLine", "(", "pt_1", ",", "pt_2", ")", "!=", "0", ")", "return", "true", ";", "pt_prev", ".", "setCoords", "(", "pt", ")", ";", "}", "}", "}", "else", "{", "Line", "line_1", "=", "new", "Line", "(", "env_b", ".", "xmin", ",", "env_b", ".", "ymin", ",", "env_b", ".", "xmin", ",", "env_b", ".", "ymax", ")", ";", "Line", "line_2", "=", "new", "Line", "(", "env_b", ".", "xmin", ",", "env_b", ".", "ymax", ",", "env_b", ".", "xmax", ",", "env_b", ".", "ymax", ")", ";", "Line", "line3", "=", "new", "Line", "(", "env_b", ".", "xmax", ",", "env_b", ".", "ymax", ",", "env_b", ".", "xmax", ",", "env_b", ".", "ymin", ")", ";", "Line", "line4", "=", "new", "Line", "(", "env_b", ".", "xmax", ",", "env_b", ".", "ymin", ",", "env_b", ".", "xmin", ",", "env_b", ".", "ymin", ")", ";", "SegmentIterator", "iter", "=", "multipath_a", ".", "querySegmentIterator", "(", ")", ";", "while", "(", "iter", ".", "nextPath", "(", ")", ")", "{", "while", "(", "iter", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "polySeg", "=", "iter", ".", "nextSegment", "(", ")", ";", "if", "(", "polySeg", ".", "isIntersecting", "(", "line_1", ",", "tolerance", ")", ")", "return", "true", ";", "if", "(", "polySeg", ".", "isIntersecting", "(", "line_2", ",", "tolerance", ")", ")", "return", "true", ";", "if", "(", "polySeg", ".", "isIntersecting", "(", "line3", ",", "tolerance", ")", ")", "return", "true", ";", "if", "(", "polySeg", ".", "isIntersecting", "(", "line4", ",", "tolerance", ")", ")", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "docstring": "Returns true if the segments of multipathA intersects env_b", "docstring_tokens": ["Returns", "true", "if", "the", "segments", "of", "multipathA", "intersects", "env_b"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L4321-L4382", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.tryRasterizedContainsOrDisjoint_", "original_string": "static int tryRasterizedContainsOrDisjoint_(Geometry geom_a,\n\t\t\tGeometry geom_b, double tolerance, boolean bExtraTestForIntersects) {\n\t\tint gtA = geom_a.getType().value();\n\t\tint gtB = geom_b.getType().value();\n\t\tdo {\n\t\t\tif (Geometry.isMultiVertex(gtA)) {\n\t\t\t\tMultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_a\n\t\t\t\t\t\t._getImpl();\n\t\t\t\tGeometryAccelerators accel = impl._getAccelerators();\n\t\t\t\tif (accel != null) {\n\t\t\t\t\tRasterizedGeometry2D rgeom = accel.getRasterizedGeometry();\n\t\t\t\t\tif (rgeom != null) {\n\t\t\t\t\t\tif (gtB == Geometry.GeometryType.Point) {\n\t\t\t\t\t\t\tPoint2D ptB = ((Point) geom_b).getXY();\n\t\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t\t.queryPointInGeometry(ptB.x, ptB.y);\n\t\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\t\treturn Relation.contains;\n\t\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEnvelope2D env_b = new Envelope2D();\n\t\t\t\t\t\tgeom_b.queryEnvelope2D(env_b);\n\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t.queryEnvelopeInGeometry(env_b);\n\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\treturn Relation.contains;\n\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t} else if (bExtraTestForIntersects\n\t\t\t\t\t\t\t\t&& Geometry.isMultiVertex(gtB)) {\n\t\t\t\t\t\t\tif (checkVerticesForIntersection_(\n\t\t\t\t\t\t\t\t\t(MultiVertexGeometryImpl) geom_b._getImpl(),\n\t\t\t\t\t\t\t\t\trgeom)) {\n\t\t\t\t\t\t\t\treturn Relation.intersects;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (false);\n\n\t\tdo {\n\t\t\tif (Geometry.isMultiVertex(gtB)) {\n\t\t\t\tMultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_b\n\t\t\t\t\t\t._getImpl();\n\t\t\t\tGeometryAccelerators accel = impl._getAccelerators();\n\t\t\t\tif (accel != null) {\n\t\t\t\t\tRasterizedGeometry2D rgeom = accel.getRasterizedGeometry();\n\t\t\t\t\tif (rgeom != null) {\n\t\t\t\t\t\tif (gtA == Geometry.GeometryType.Point) {\n\t\t\t\t\t\t\tPoint2D ptA = ((Point) geom_a).getXY();\n\t\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t\t.queryPointInGeometry(ptA.x, ptA.y);\n\t\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\t\treturn Relation.within;\n\t\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tEnvelope2D env_a = new Envelope2D();\n\t\t\t\t\t\tgeom_a.queryEnvelope2D(env_a);\n\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t.queryEnvelopeInGeometry(env_a);\n\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\treturn Relation.within;\n\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t} else if (bExtraTestForIntersects\n\t\t\t\t\t\t\t\t&& Geometry.isMultiVertex(gtA)) {\n\t\t\t\t\t\t\tif (checkVerticesForIntersection_(\n\t\t\t\t\t\t\t\t\t(MultiVertexGeometryImpl) geom_a._getImpl(),\n\t\t\t\t\t\t\t\t\trgeom)) {\n\t\t\t\t\t\t\t\treturn Relation.intersects;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (false);\n\n\t\treturn Relation.unknown;\n\t}", "language": "java", "code": "static int tryRasterizedContainsOrDisjoint_(Geometry geom_a,\n\t\t\tGeometry geom_b, double tolerance, boolean bExtraTestForIntersects) {\n\t\tint gtA = geom_a.getType().value();\n\t\tint gtB = geom_b.getType().value();\n\t\tdo {\n\t\t\tif (Geometry.isMultiVertex(gtA)) {\n\t\t\t\tMultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_a\n\t\t\t\t\t\t._getImpl();\n\t\t\t\tGeometryAccelerators accel = impl._getAccelerators();\n\t\t\t\tif (accel != null) {\n\t\t\t\t\tRasterizedGeometry2D rgeom = accel.getRasterizedGeometry();\n\t\t\t\t\tif (rgeom != null) {\n\t\t\t\t\t\tif (gtB == Geometry.GeometryType.Point) {\n\t\t\t\t\t\t\tPoint2D ptB = ((Point) geom_b).getXY();\n\t\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t\t.queryPointInGeometry(ptB.x, ptB.y);\n\t\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\t\treturn Relation.contains;\n\t\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEnvelope2D env_b = new Envelope2D();\n\t\t\t\t\t\tgeom_b.queryEnvelope2D(env_b);\n\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t.queryEnvelopeInGeometry(env_b);\n\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\treturn Relation.contains;\n\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t} else if (bExtraTestForIntersects\n\t\t\t\t\t\t\t\t&& Geometry.isMultiVertex(gtB)) {\n\t\t\t\t\t\t\tif (checkVerticesForIntersection_(\n\t\t\t\t\t\t\t\t\t(MultiVertexGeometryImpl) geom_b._getImpl(),\n\t\t\t\t\t\t\t\t\trgeom)) {\n\t\t\t\t\t\t\t\treturn Relation.intersects;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (false);\n\n\t\tdo {\n\t\t\tif (Geometry.isMultiVertex(gtB)) {\n\t\t\t\tMultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_b\n\t\t\t\t\t\t._getImpl();\n\t\t\t\tGeometryAccelerators accel = impl._getAccelerators();\n\t\t\t\tif (accel != null) {\n\t\t\t\t\tRasterizedGeometry2D rgeom = accel.getRasterizedGeometry();\n\t\t\t\t\tif (rgeom != null) {\n\t\t\t\t\t\tif (gtA == Geometry.GeometryType.Point) {\n\t\t\t\t\t\t\tPoint2D ptA = ((Point) geom_a).getXY();\n\t\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t\t.queryPointInGeometry(ptA.x, ptA.y);\n\t\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\t\treturn Relation.within;\n\t\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tEnvelope2D env_a = new Envelope2D();\n\t\t\t\t\t\tgeom_a.queryEnvelope2D(env_a);\n\t\t\t\t\t\tRasterizedGeometry2D.HitType hit = rgeom\n\t\t\t\t\t\t\t\t.queryEnvelopeInGeometry(env_a);\n\t\t\t\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\t\t\t\treturn Relation.within;\n\t\t\t\t\t\t} else if (hit == RasterizedGeometry2D.HitType.Outside) {\n\t\t\t\t\t\t\treturn Relation.disjoint;\n\t\t\t\t\t\t} else if (bExtraTestForIntersects\n\t\t\t\t\t\t\t\t&& Geometry.isMultiVertex(gtA)) {\n\t\t\t\t\t\t\tif (checkVerticesForIntersection_(\n\t\t\t\t\t\t\t\t\t(MultiVertexGeometryImpl) geom_a._getImpl(),\n\t\t\t\t\t\t\t\t\trgeom)) {\n\t\t\t\t\t\t\t\treturn Relation.intersects;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (false);\n\n\t\treturn Relation.unknown;\n\t}", "code_tokens": ["static", "int", "tryRasterizedContainsOrDisjoint_", "(", "Geometry", "geom_a", ",", "Geometry", "geom_b", ",", "double", "tolerance", ",", "boolean", "bExtraTestForIntersects", ")", "{", "int", "gtA", "=", "geom_a", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "int", "gtB", "=", "geom_b", ".", "getType", "(", ")", ".", "value", "(", ")", ";", "do", "{", "if", "(", "Geometry", ".", "isMultiVertex", "(", "gtA", ")", ")", "{", "MultiVertexGeometryImpl", "impl", "=", "(", "MultiVertexGeometryImpl", ")", "geom_a", ".", "_getImpl", "(", ")", ";", "GeometryAccelerators", "accel", "=", "impl", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "RasterizedGeometry2D", "rgeom", "=", "accel", ".", "getRasterizedGeometry", "(", ")", ";", "if", "(", "rgeom", "!=", "null", ")", "{", "if", "(", "gtB", "==", "Geometry", ".", "GeometryType", ".", "Point", ")", "{", "Point2D", "ptB", "=", "(", "(", "Point", ")", "geom_b", ")", ".", "getXY", "(", ")", ";", "RasterizedGeometry2D", ".", "HitType", "hit", "=", "rgeom", ".", "queryPointInGeometry", "(", "ptB", ".", "x", ",", "ptB", ".", "y", ")", ";", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Inside", ")", "{", "return", "Relation", ".", "contains", ";", "}", "else", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Outside", ")", "{", "return", "Relation", ".", "disjoint", ";", "}", "break", ";", "}", "Envelope2D", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "geom_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "RasterizedGeometry2D", ".", "HitType", "hit", "=", "rgeom", ".", "queryEnvelopeInGeometry", "(", "env_b", ")", ";", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Inside", ")", "{", "return", "Relation", ".", "contains", ";", "}", "else", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Outside", ")", "{", "return", "Relation", ".", "disjoint", ";", "}", "else", "if", "(", "bExtraTestForIntersects", "&&", "Geometry", ".", "isMultiVertex", "(", "gtB", ")", ")", "{", "if", "(", "checkVerticesForIntersection_", "(", "(", "MultiVertexGeometryImpl", ")", "geom_b", ".", "_getImpl", "(", ")", ",", "rgeom", ")", ")", "{", "return", "Relation", ".", "intersects", ";", "}", "}", "break", ";", "}", "}", "}", "}", "while", "(", "false", ")", ";", "do", "{", "if", "(", "Geometry", ".", "isMultiVertex", "(", "gtB", ")", ")", "{", "MultiVertexGeometryImpl", "impl", "=", "(", "MultiVertexGeometryImpl", ")", "geom_b", ".", "_getImpl", "(", ")", ";", "GeometryAccelerators", "accel", "=", "impl", ".", "_getAccelerators", "(", ")", ";", "if", "(", "accel", "!=", "null", ")", "{", "RasterizedGeometry2D", "rgeom", "=", "accel", ".", "getRasterizedGeometry", "(", ")", ";", "if", "(", "rgeom", "!=", "null", ")", "{", "if", "(", "gtA", "==", "Geometry", ".", "GeometryType", ".", "Point", ")", "{", "Point2D", "ptA", "=", "(", "(", "Point", ")", "geom_a", ")", ".", "getXY", "(", ")", ";", "RasterizedGeometry2D", ".", "HitType", "hit", "=", "rgeom", ".", "queryPointInGeometry", "(", "ptA", ".", "x", ",", "ptA", ".", "y", ")", ";", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Inside", ")", "{", "return", "Relation", ".", "within", ";", "}", "else", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Outside", ")", "{", "return", "Relation", ".", "disjoint", ";", "}", "break", ";", "}", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ";", "geom_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "RasterizedGeometry2D", ".", "HitType", "hit", "=", "rgeom", ".", "queryEnvelopeInGeometry", "(", "env_a", ")", ";", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Inside", ")", "{", "return", "Relation", ".", "within", ";", "}", "else", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Outside", ")", "{", "return", "Relation", ".", "disjoint", ";", "}", "else", "if", "(", "bExtraTestForIntersects", "&&", "Geometry", ".", "isMultiVertex", "(", "gtA", ")", ")", "{", "if", "(", "checkVerticesForIntersection_", "(", "(", "MultiVertexGeometryImpl", ")", "geom_a", ".", "_getImpl", "(", ")", ",", "rgeom", ")", ")", "{", "return", "Relation", ".", "intersects", ";", "}", "}", "break", ";", "}", "}", "}", "}", "while", "(", "false", ")", ";", "return", "Relation", ".", "unknown", ";", "}"], "docstring": "\"intersects\".", "docstring_tokens": ["intersects", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L4388-L4478", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperations.java", "func_name": "RelationalOperations.checkVerticesForIntersection_", "original_string": "private static boolean checkVerticesForIntersection_(\n\t\t\tMultiVertexGeometryImpl geom, RasterizedGeometry2D rgeom) {\n\t\t// Do a quick raster test for each point. If any point is inside, then\n\t\t// there is an intersection.\n\t\tint pointCount = geom.getPointCount();\n\t\tPoint2D pt = new Point2D();\n\t\tfor (int ipoint = 0; ipoint < pointCount; ipoint++) {\n\t\t\tgeom.getXY(ipoint, pt);\n\t\t\tRasterizedGeometry2D.HitType hit = rgeom.queryPointInGeometry(pt.x,\n\t\t\t\t\tpt.y);\n\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean checkVerticesForIntersection_(\n\t\t\tMultiVertexGeometryImpl geom, RasterizedGeometry2D rgeom) {\n\t\t// Do a quick raster test for each point. If any point is inside, then\n\t\t// there is an intersection.\n\t\tint pointCount = geom.getPointCount();\n\t\tPoint2D pt = new Point2D();\n\t\tfor (int ipoint = 0; ipoint < pointCount; ipoint++) {\n\t\t\tgeom.getXY(ipoint, pt);\n\t\t\tRasterizedGeometry2D.HitType hit = rgeom.queryPointInGeometry(pt.x,\n\t\t\t\t\tpt.y);\n\t\t\tif (hit == RasterizedGeometry2D.HitType.Inside) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "checkVerticesForIntersection_", "(", "MultiVertexGeometryImpl", "geom", ",", "RasterizedGeometry2D", "rgeom", ")", "{", "// Do a quick raster test for each point. If any point is inside, then", "// there is an intersection.", "int", "pointCount", "=", "geom", ".", "getPointCount", "(", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "ipoint", "=", "0", ";", "ipoint", "<", "pointCount", ";", "ipoint", "++", ")", "{", "geom", ".", "getXY", "(", "ipoint", ",", "pt", ")", ";", "RasterizedGeometry2D", ".", "HitType", "hit", "=", "rgeom", ".", "queryPointInGeometry", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "if", "(", "hit", "==", "RasterizedGeometry2D", ".", "HitType", ".", "Inside", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Returns true if intersects and false if nothing can be determined.", "docstring_tokens": ["Returns", "true", "if", "intersects", "and", "false", "if", "nothing", "can", "be", "determined", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperations.java#L4481-L4497", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/InternalUtils.java", "func_name": "InternalUtils.addPointsToArray", "original_string": "static int addPointsToArray(Point2D p0In, Point2D p1In,\n\t\t\tPoint2D[] pointsArray, int idx, Envelope2D fullRange2D,\n\t\t\tboolean clockwise, double densifyDist)// PointerOfArrayOf(Point2D)\n\t\t\t\t\t\t\t\t\t\t\t\t\t// pointsArray, int idx,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Envelope2D fullRange2D,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// boolean clockwise, double\n\t\t\t\t\t\t\t\t\t\t\t\t\t// densifyDist)\n\t{\n\t\tPoint2D p0 = new Point2D();\n\t\tp0.setCoords(p0In);\n\t\tPoint2D p1 = new Point2D();\n\t\tp1.setCoords(p1In);\n\t\tfullRange2D._snapToBoundary(p0);\n\t\tfullRange2D._snapToBoundary(p1);\n\t\t// //_ASSERT((p0.x == fullRange2D.xmin || p0.x == fullRange2D.xmax) &&\n\t\t// (p1.x == fullRange2D.xmin || p1.x == fullRange2D.xmax));\n\t\tdouble boundDist0 = fullRange2D._boundaryDistance(p0);\n\t\tdouble boundDist1 = fullRange2D._boundaryDistance(p1);\n\t\tif (boundDist1 == 0.0)\n\t\t\tboundDist1 = fullRange2D.getLength();\n\n\t\tif ((p0.x == p1.x || p0.y == p1.y\n\t\t\t\t&& (p0.y == fullRange2D.ymin || p0.y == fullRange2D.ymax))\n\t\t\t\t&& (boundDist1 > boundDist0) == clockwise) {\n\t\t\tPoint2D delta = new Point2D();\n\t\t\tdelta.setCoords(p1.x - p0.x, p1.y - p0.y);\n\t\t\tif (densifyDist != 0)// if (densifyDist)\n\t\t\t{\n\t\t\t\tlong cPoints = (long) (delta._norm(0) / densifyDist);\n\t\t\t\tif (cPoints > 0) // if (cPoints)\n\t\t\t\t{\n\t\t\t\t\tdelta.scale(1.0 / (cPoints + 1));\n\t\t\t\t\tfor (long i = 0; i < cPoints; i++) {\n\t\t\t\t\t\tp0.add(delta);\n\t\t\t\t\t\tpointsArray[idx++].setCoords(p0.x, p0.y);// ARRAYELEMENT(pointsArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// idx++).setCoords(p0.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// p0.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint side0 = fullRange2D._envelopeSide(p0);\n\t\t\tint side1 = fullRange2D._envelopeSide(p1);\n\t\t\t// create up to four corner points; the order depends on boolean\n\t\t\t// clockwise\n\t\t\tPoint2D corner;\n\t\t\tint deltaSide = clockwise ? 1 : 3; // 3 is equivalent to -1\n\t\t\tdo {\n\t\t\t\tside0 = (side0 + deltaSide) & 3;\n\t\t\t\tcorner = fullRange2D.queryCorner(side0);\n\t\t\t\tif (densifyDist != 0)// if (densifyDist)\n\t\t\t\t{\n\t\t\t\t\tidx = addPointsToArray(p0, corner, pointsArray, idx,\n\t\t\t\t\t\t\tfullRange2D, clockwise, densifyDist);\n\t\t\t\t}\n\t\t\t\tpointsArray[idx++].setCoords(corner.x, corner.y);// ARRAYELEMENT(pointsArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// idx++).setCoords(corner.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// corner.y);\n\t\t\t\tp0 = corner;\n\t\t\t} while ((side0 & 3) != side1);\n\n\t\t\tif (densifyDist != 0)// if (densifyDist)\n\t\t\t\tidx = addPointsToArray(p0, p1, pointsArray, idx, fullRange2D,\n\t\t\t\t\t\tclockwise, densifyDist);\n\t\t}\n\n\t\treturn idx;\n\t}", "language": "java", "code": "static int addPointsToArray(Point2D p0In, Point2D p1In,\n\t\t\tPoint2D[] pointsArray, int idx, Envelope2D fullRange2D,\n\t\t\tboolean clockwise, double densifyDist)// PointerOfArrayOf(Point2D)\n\t\t\t\t\t\t\t\t\t\t\t\t\t// pointsArray, int idx,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Envelope2D fullRange2D,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// boolean clockwise, double\n\t\t\t\t\t\t\t\t\t\t\t\t\t// densifyDist)\n\t{\n\t\tPoint2D p0 = new Point2D();\n\t\tp0.setCoords(p0In);\n\t\tPoint2D p1 = new Point2D();\n\t\tp1.setCoords(p1In);\n\t\tfullRange2D._snapToBoundary(p0);\n\t\tfullRange2D._snapToBoundary(p1);\n\t\t// //_ASSERT((p0.x == fullRange2D.xmin || p0.x == fullRange2D.xmax) &&\n\t\t// (p1.x == fullRange2D.xmin || p1.x == fullRange2D.xmax));\n\t\tdouble boundDist0 = fullRange2D._boundaryDistance(p0);\n\t\tdouble boundDist1 = fullRange2D._boundaryDistance(p1);\n\t\tif (boundDist1 == 0.0)\n\t\t\tboundDist1 = fullRange2D.getLength();\n\n\t\tif ((p0.x == p1.x || p0.y == p1.y\n\t\t\t\t&& (p0.y == fullRange2D.ymin || p0.y == fullRange2D.ymax))\n\t\t\t\t&& (boundDist1 > boundDist0) == clockwise) {\n\t\t\tPoint2D delta = new Point2D();\n\t\t\tdelta.setCoords(p1.x - p0.x, p1.y - p0.y);\n\t\t\tif (densifyDist != 0)// if (densifyDist)\n\t\t\t{\n\t\t\t\tlong cPoints = (long) (delta._norm(0) / densifyDist);\n\t\t\t\tif (cPoints > 0) // if (cPoints)\n\t\t\t\t{\n\t\t\t\t\tdelta.scale(1.0 / (cPoints + 1));\n\t\t\t\t\tfor (long i = 0; i < cPoints; i++) {\n\t\t\t\t\t\tp0.add(delta);\n\t\t\t\t\t\tpointsArray[idx++].setCoords(p0.x, p0.y);// ARRAYELEMENT(pointsArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// idx++).setCoords(p0.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// p0.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint side0 = fullRange2D._envelopeSide(p0);\n\t\t\tint side1 = fullRange2D._envelopeSide(p1);\n\t\t\t// create up to four corner points; the order depends on boolean\n\t\t\t// clockwise\n\t\t\tPoint2D corner;\n\t\t\tint deltaSide = clockwise ? 1 : 3; // 3 is equivalent to -1\n\t\t\tdo {\n\t\t\t\tside0 = (side0 + deltaSide) & 3;\n\t\t\t\tcorner = fullRange2D.queryCorner(side0);\n\t\t\t\tif (densifyDist != 0)// if (densifyDist)\n\t\t\t\t{\n\t\t\t\t\tidx = addPointsToArray(p0, corner, pointsArray, idx,\n\t\t\t\t\t\t\tfullRange2D, clockwise, densifyDist);\n\t\t\t\t}\n\t\t\t\tpointsArray[idx++].setCoords(corner.x, corner.y);// ARRAYELEMENT(pointsArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// idx++).setCoords(corner.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// corner.y);\n\t\t\t\tp0 = corner;\n\t\t\t} while ((side0 & 3) != side1);\n\n\t\t\tif (densifyDist != 0)// if (densifyDist)\n\t\t\t\tidx = addPointsToArray(p0, p1, pointsArray, idx, fullRange2D,\n\t\t\t\t\t\tclockwise, densifyDist);\n\t\t}\n\n\t\treturn idx;\n\t}", "code_tokens": ["static", "int", "addPointsToArray", "(", "Point2D", "p0In", ",", "Point2D", "p1In", ",", "Point2D", "[", "]", "pointsArray", ",", "int", "idx", ",", "Envelope2D", "fullRange2D", ",", "boolean", "clockwise", ",", "double", "densifyDist", ")", "// PointerOfArrayOf(Point2D)", "// pointsArray, int idx,", "// Envelope2D fullRange2D,", "// boolean clockwise, double", "// densifyDist)", "{", "Point2D", "p0", "=", "new", "Point2D", "(", ")", ";", "p0", ".", "setCoords", "(", "p0In", ")", ";", "Point2D", "p1", "=", "new", "Point2D", "(", ")", ";", "p1", ".", "setCoords", "(", "p1In", ")", ";", "fullRange2D", ".", "_snapToBoundary", "(", "p0", ")", ";", "fullRange2D", ".", "_snapToBoundary", "(", "p1", ")", ";", "// //_ASSERT((p0.x == fullRange2D.xmin || p0.x == fullRange2D.xmax) &&", "// (p1.x == fullRange2D.xmin || p1.x == fullRange2D.xmax));", "double", "boundDist0", "=", "fullRange2D", ".", "_boundaryDistance", "(", "p0", ")", ";", "double", "boundDist1", "=", "fullRange2D", ".", "_boundaryDistance", "(", "p1", ")", ";", "if", "(", "boundDist1", "==", "0.0", ")", "boundDist1", "=", "fullRange2D", ".", "getLength", "(", ")", ";", "if", "(", "(", "p0", ".", "x", "==", "p1", ".", "x", "||", "p0", ".", "y", "==", "p1", ".", "y", "&&", "(", "p0", ".", "y", "==", "fullRange2D", ".", "ymin", "||", "p0", ".", "y", "==", "fullRange2D", ".", "ymax", ")", ")", "&&", "(", "boundDist1", ">", "boundDist0", ")", "==", "clockwise", ")", "{", "Point2D", "delta", "=", "new", "Point2D", "(", ")", ";", "delta", ".", "setCoords", "(", "p1", ".", "x", "-", "p0", ".", "x", ",", "p1", ".", "y", "-", "p0", ".", "y", ")", ";", "if", "(", "densifyDist", "!=", "0", ")", "// if (densifyDist)", "{", "long", "cPoints", "=", "(", "long", ")", "(", "delta", ".", "_norm", "(", "0", ")", "/", "densifyDist", ")", ";", "if", "(", "cPoints", ">", "0", ")", "// if (cPoints)", "{", "delta", ".", "scale", "(", "1.0", "/", "(", "cPoints", "+", "1", ")", ")", ";", "for", "(", "long", "i", "=", "0", ";", "i", "<", "cPoints", ";", "i", "++", ")", "{", "p0", ".", "add", "(", "delta", ")", ";", "pointsArray", "[", "idx", "++", "]", ".", "setCoords", "(", "p0", ".", "x", ",", "p0", ".", "y", ")", ";", "// ARRAYELEMENT(pointsArray,", "// idx++).setCoords(p0.x,", "// p0.y);", "}", "}", "}", "}", "else", "{", "int", "side0", "=", "fullRange2D", ".", "_envelopeSide", "(", "p0", ")", ";", "int", "side1", "=", "fullRange2D", ".", "_envelopeSide", "(", "p1", ")", ";", "// create up to four corner points; the order depends on boolean", "// clockwise", "Point2D", "corner", ";", "int", "deltaSide", "=", "clockwise", "?", "1", ":", "3", ";", "// 3 is equivalent to -1", "do", "{", "side0", "=", "(", "side0", "+", "deltaSide", ")", "&", "3", ";", "corner", "=", "fullRange2D", ".", "queryCorner", "(", "side0", ")", ";", "if", "(", "densifyDist", "!=", "0", ")", "// if (densifyDist)", "{", "idx", "=", "addPointsToArray", "(", "p0", ",", "corner", ",", "pointsArray", ",", "idx", ",", "fullRange2D", ",", "clockwise", ",", "densifyDist", ")", ";", "}", "pointsArray", "[", "idx", "++", "]", ".", "setCoords", "(", "corner", ".", "x", ",", "corner", ".", "y", ")", ";", "// ARRAYELEMENT(pointsArray,", "// idx++).setCoords(corner.x,", "// corner.y);", "p0", "=", "corner", ";", "}", "while", "(", "(", "side0", "&", "3", ")", "!=", "side1", ")", ";", "if", "(", "densifyDist", "!=", "0", ")", "// if (densifyDist)", "idx", "=", "addPointsToArray", "(", "p0", ",", "p1", ",", "pointsArray", ",", "idx", ",", "fullRange2D", ",", "clockwise", ",", "densifyDist", ")", ";", "}", "return", "idx", ";", "}"], "docstring": "corners)", "docstring_tokens": ["corners", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/InternalUtils.java#L34-L101", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/BucketSort.java", "func_name": "BucketSort.sort", "original_string": "public void sort(AttributeStreamOfInt32 indices, int begin, int end,\n\t\t\tClassicSort sorter) {\n\t\tif (end - begin < 32) {\n\t\t\tsorter.userSort(begin, end, indices);\n\t\t\treturn;\n\t\t}\n\t\tboolean b_fallback = true;\n\t\ttry {\n\t\t\tdouble miny = NumberUtils.positiveInf();\n\t\t\tdouble maxy = NumberUtils.negativeInf();\n\t\t\tfor (int i = begin; i < end; i++) {\n\t\t\t\tdouble y = sorter.getValue(indices.get(i));\n\t\t\t\tif (y < miny)\n\t\t\t\t\tminy = y;\n\t\t\t\tif (y > maxy)\n\t\t\t\t\tmaxy = y;\n\t\t\t}\n\n\t\t\tif (reset(end - begin, miny, maxy, end - begin)) {\n\t\t\t\tfor (int i = begin; i < end; i++) {\n\t\t\t\t\tint vertex = indices.get(i);\n\t\t\t\t\tdouble y = sorter.getValue(vertex);\n\t\t\t\t\tint bucket = getBucket(y);\n\t\t\t\t\tm_buckets.set(bucket, m_buckets.get(bucket) + 1);// counting\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// values\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// in a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bucket.\n\t\t\t\t\tm_bucketed_indices.write(i - begin, vertex);\n\t\t\t\t}\n\n\t\t\t\t// Recalculate buckets to contain start positions of buckets.\n\t\t\t\tint c = m_buckets.get(0);\n\t\t\t\tm_buckets.set(0, 0);\n\t\t\t\tfor (int i = 1, n = m_buckets.size(); i < n; i++) {\n\t\t\t\t\tint b = m_buckets.get(i);\n\t\t\t\t\tm_buckets.set(i, c);\n\t\t\t\t\tc += b;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = begin; i < end; i++) {\n\t\t\t\t\tint vertex = m_bucketed_indices.read(i - begin);\n\t\t\t\t\tdouble y = sorter.getValue(vertex);\n\t\t\t\t\tint bucket = getBucket(y);\n\t\t\t\t\tint bucket_index = m_buckets.get(bucket);\n\t\t\t\t\tindices.set(bucket_index + begin, vertex);\n\t\t\t\t\tm_buckets.set(bucket, bucket_index + 1);\n\t\t\t\t}\n\n\t\t\t\tb_fallback = false;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tm_buckets.resize(0);\n\t\t\tm_bucketed_indices.resize(0);\n\t\t}\n\n\t\tif (b_fallback) {\n\t\t\tsorter.userSort(begin, end, indices);\n\t\t\treturn;\n\t\t}\n\n\t\tint j = 0;\n\t\tfor (int i = 0, n = m_buckets.size(); i < n; i++) {\n\t\t\tint j0 = j;\n\t\t\tj = m_buckets.get(i);\n\t\t\tif (j > j0)\n\t\t\t\tsorter.userSort(begin + j0, begin + j, indices);\n\t\t}\n\t\tassert (j == end);\n\n\t\tif (getBucketCount() > 100) // some heuristics to preserve memory\n\t\t{\n\t\t\tm_buckets.resize(0);\n\t\t\tm_bucketed_indices.resize(0);\n\t\t}\n\t}", "language": "java", "code": "public void sort(AttributeStreamOfInt32 indices, int begin, int end,\n\t\t\tClassicSort sorter) {\n\t\tif (end - begin < 32) {\n\t\t\tsorter.userSort(begin, end, indices);\n\t\t\treturn;\n\t\t}\n\t\tboolean b_fallback = true;\n\t\ttry {\n\t\t\tdouble miny = NumberUtils.positiveInf();\n\t\t\tdouble maxy = NumberUtils.negativeInf();\n\t\t\tfor (int i = begin; i < end; i++) {\n\t\t\t\tdouble y = sorter.getValue(indices.get(i));\n\t\t\t\tif (y < miny)\n\t\t\t\t\tminy = y;\n\t\t\t\tif (y > maxy)\n\t\t\t\t\tmaxy = y;\n\t\t\t}\n\n\t\t\tif (reset(end - begin, miny, maxy, end - begin)) {\n\t\t\t\tfor (int i = begin; i < end; i++) {\n\t\t\t\t\tint vertex = indices.get(i);\n\t\t\t\t\tdouble y = sorter.getValue(vertex);\n\t\t\t\t\tint bucket = getBucket(y);\n\t\t\t\t\tm_buckets.set(bucket, m_buckets.get(bucket) + 1);// counting\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// values\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// in a\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bucket.\n\t\t\t\t\tm_bucketed_indices.write(i - begin, vertex);\n\t\t\t\t}\n\n\t\t\t\t// Recalculate buckets to contain start positions of buckets.\n\t\t\t\tint c = m_buckets.get(0);\n\t\t\t\tm_buckets.set(0, 0);\n\t\t\t\tfor (int i = 1, n = m_buckets.size(); i < n; i++) {\n\t\t\t\t\tint b = m_buckets.get(i);\n\t\t\t\t\tm_buckets.set(i, c);\n\t\t\t\t\tc += b;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = begin; i < end; i++) {\n\t\t\t\t\tint vertex = m_bucketed_indices.read(i - begin);\n\t\t\t\t\tdouble y = sorter.getValue(vertex);\n\t\t\t\t\tint bucket = getBucket(y);\n\t\t\t\t\tint bucket_index = m_buckets.get(bucket);\n\t\t\t\t\tindices.set(bucket_index + begin, vertex);\n\t\t\t\t\tm_buckets.set(bucket, bucket_index + 1);\n\t\t\t\t}\n\n\t\t\t\tb_fallback = false;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tm_buckets.resize(0);\n\t\t\tm_bucketed_indices.resize(0);\n\t\t}\n\n\t\tif (b_fallback) {\n\t\t\tsorter.userSort(begin, end, indices);\n\t\t\treturn;\n\t\t}\n\n\t\tint j = 0;\n\t\tfor (int i = 0, n = m_buckets.size(); i < n; i++) {\n\t\t\tint j0 = j;\n\t\t\tj = m_buckets.get(i);\n\t\t\tif (j > j0)\n\t\t\t\tsorter.userSort(begin + j0, begin + j, indices);\n\t\t}\n\t\tassert (j == end);\n\n\t\tif (getBucketCount() > 100) // some heuristics to preserve memory\n\t\t{\n\t\t\tm_buckets.resize(0);\n\t\t\tm_bucketed_indices.resize(0);\n\t\t}\n\t}", "code_tokens": ["public", "void", "sort", "(", "AttributeStreamOfInt32", "indices", ",", "int", "begin", ",", "int", "end", ",", "ClassicSort", "sorter", ")", "{", "if", "(", "end", "-", "begin", "<", "32", ")", "{", "sorter", ".", "userSort", "(", "begin", ",", "end", ",", "indices", ")", ";", "return", ";", "}", "boolean", "b_fallback", "=", "true", ";", "try", "{", "double", "miny", "=", "NumberUtils", ".", "positiveInf", "(", ")", ";", "double", "maxy", "=", "NumberUtils", ".", "negativeInf", "(", ")", ";", "for", "(", "int", "i", "=", "begin", ";", "i", "<", "end", ";", "i", "++", ")", "{", "double", "y", "=", "sorter", ".", "getValue", "(", "indices", ".", "get", "(", "i", ")", ")", ";", "if", "(", "y", "<", "miny", ")", "miny", "=", "y", ";", "if", "(", "y", ">", "maxy", ")", "maxy", "=", "y", ";", "}", "if", "(", "reset", "(", "end", "-", "begin", ",", "miny", ",", "maxy", ",", "end", "-", "begin", ")", ")", "{", "for", "(", "int", "i", "=", "begin", ";", "i", "<", "end", ";", "i", "++", ")", "{", "int", "vertex", "=", "indices", ".", "get", "(", "i", ")", ";", "double", "y", "=", "sorter", ".", "getValue", "(", "vertex", ")", ";", "int", "bucket", "=", "getBucket", "(", "y", ")", ";", "m_buckets", ".", "set", "(", "bucket", ",", "m_buckets", ".", "get", "(", "bucket", ")", "+", "1", ")", ";", "// counting", "// values", "// in a", "// bucket.", "m_bucketed_indices", ".", "write", "(", "i", "-", "begin", ",", "vertex", ")", ";", "}", "// Recalculate buckets to contain start positions of buckets.", "int", "c", "=", "m_buckets", ".", "get", "(", "0", ")", ";", "m_buckets", ".", "set", "(", "0", ",", "0", ")", ";", "for", "(", "int", "i", "=", "1", ",", "n", "=", "m_buckets", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "b", "=", "m_buckets", ".", "get", "(", "i", ")", ";", "m_buckets", ".", "set", "(", "i", ",", "c", ")", ";", "c", "+=", "b", ";", "}", "for", "(", "int", "i", "=", "begin", ";", "i", "<", "end", ";", "i", "++", ")", "{", "int", "vertex", "=", "m_bucketed_indices", ".", "read", "(", "i", "-", "begin", ")", ";", "double", "y", "=", "sorter", ".", "getValue", "(", "vertex", ")", ";", "int", "bucket", "=", "getBucket", "(", "y", ")", ";", "int", "bucket_index", "=", "m_buckets", ".", "get", "(", "bucket", ")", ";", "indices", ".", "set", "(", "bucket_index", "+", "begin", ",", "vertex", ")", ";", "m_buckets", ".", "set", "(", "bucket", ",", "bucket_index", "+", "1", ")", ";", "}", "b_fallback", "=", "false", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "m_buckets", ".", "resize", "(", "0", ")", ";", "m_bucketed_indices", ".", "resize", "(", "0", ")", ";", "}", "if", "(", "b_fallback", ")", "{", "sorter", ".", "userSort", "(", "begin", ",", "end", ",", "indices", ")", ";", "return", ";", "}", "int", "j", "=", "0", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_buckets", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "int", "j0", "=", "j", ";", "j", "=", "m_buckets", ".", "get", "(", "i", ")", ";", "if", "(", "j", ">", "j0", ")", "sorter", ".", "userSort", "(", "begin", "+", "j0", ",", "begin", "+", "j", ",", "indices", ")", ";", "}", "assert", "(", "j", "==", "end", ")", ";", "if", "(", "getBucketCount", "(", ")", ">", "100", ")", "// some heuristics to preserve memory", "{", "m_buckets", ".", "resize", "(", "0", ")", ";", "m_bucketed_indices", ".", "resize", "(", "0", ")", ";", "}", "}"], "docstring": "Executes sort on the Bucket_sort. The result is fed into the indices\narray in the range between begin (inclusive) and end (exclusive). Uses\nuser supplied sorter to execute sort on each bucket. Users either supply\nthe sorter and use this method of Bucket_sort class, or use other methods\nto form the buckets and take care of bucket sorting themselves.", "docstring_tokens": ["Executes", "sort", "on", "the", "Bucket_sort", ".", "The", "result", "is", "fed", "into", "the", "indices", "array", "in", "the", "range", "between", "begin", "(", "inclusive", ")", "and", "end", "(", "exclusive", ")", ".", "Uses", "user", "supplied", "sorter", "to", "execute", "sort", "on", "each", "bucket", ".", "Users", "either", "supply", "the", "sorter", "and", "use", "this", "method", "of", "Bucket_sort", "class", "or", "use", "other", "methods", "to", "form", "the", "buckets", "and", "take", "care", "of", "bucket", "sorting", "themselves", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/BucketSort.java#L50-L124", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/BucketSort.java", "func_name": "BucketSort.reset", "original_string": "private boolean reset(int bucket_count, double min_value, double max_value,\n\t\t\tint capacity) {\n\t\tif (bucket_count < 2 || max_value == min_value)\n\t\t\treturn false;\n\n\t\tint bc = Math.min(MAXBUCKETS, bucket_count);\n\t\tm_buckets.reserve(bc);\n\t\tm_buckets.resize(bc);\n\t\tm_buckets.setRange(0, 0, m_buckets.size());\n\t\tm_min_value = min_value;\n\t\tm_max_value = max_value;\n\t\tm_bucketed_indices.resize(capacity);\n\n\t\tm_dy = (max_value - min_value) / (bc - 1);\n\t\treturn true;\n\t}", "language": "java", "code": "private boolean reset(int bucket_count, double min_value, double max_value,\n\t\t\tint capacity) {\n\t\tif (bucket_count < 2 || max_value == min_value)\n\t\t\treturn false;\n\n\t\tint bc = Math.min(MAXBUCKETS, bucket_count);\n\t\tm_buckets.reserve(bc);\n\t\tm_buckets.resize(bc);\n\t\tm_buckets.setRange(0, 0, m_buckets.size());\n\t\tm_min_value = min_value;\n\t\tm_max_value = max_value;\n\t\tm_bucketed_indices.resize(capacity);\n\n\t\tm_dy = (max_value - min_value) / (bc - 1);\n\t\treturn true;\n\t}", "code_tokens": ["private", "boolean", "reset", "(", "int", "bucket_count", ",", "double", "min_value", ",", "double", "max_value", ",", "int", "capacity", ")", "{", "if", "(", "bucket_count", "<", "2", "||", "max_value", "==", "min_value", ")", "return", "false", ";", "int", "bc", "=", "Math", ".", "min", "(", "MAXBUCKETS", ",", "bucket_count", ")", ";", "m_buckets", ".", "reserve", "(", "bc", ")", ";", "m_buckets", ".", "resize", "(", "bc", ")", ";", "m_buckets", ".", "setRange", "(", "0", ",", "0", ",", "m_buckets", ".", "size", "(", ")", ")", ";", "m_min_value", "=", "min_value", ";", "m_max_value", "=", "max_value", ";", "m_bucketed_indices", ".", "resize", "(", "capacity", ")", ";", "m_dy", "=", "(", "max_value", "-", "min_value", ")", "/", "(", "bc", "-", "1", ")", ";", "return", "true", ";", "}"], "docstring": "Clears and resets Bucket_sort to the new state, preparing for the\naccumulation of new data.\n\n@param bucket_count\n- the number of buckets. Usually equal to the number of\nelements to sort.\n@param min_value\n- the minimum value of elements to sort.\n@param max_value\n- the maximum value of elements to sort.\n@param capacity\n- the number of elements to sort (-1 if not known). The\nbucket_count are usually equal.\n@return Returns False, if the bucket sort cannot be used with the given\nparameters. The method also can throw out of memory exception. In\nthe later case, one should fall back to the regular sort.", "docstring_tokens": ["Clears", "and", "resets", "Bucket_sort", "to", "the", "new", "state", "preparing", "for", "the", "accumulation", "of", "new", "data", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/BucketSort.java#L144-L159", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/BucketSort.java", "func_name": "BucketSort.getBucket", "original_string": "private int getBucket(double value) {\n\t\tassert (value >= m_min_value && value <= m_max_value);\n\t\tint bucket = (int) ((value - m_min_value) / m_dy);\n\t\treturn bucket;\n\t}", "language": "java", "code": "private int getBucket(double value) {\n\t\tassert (value >= m_min_value && value <= m_max_value);\n\t\tint bucket = (int) ((value - m_min_value) / m_dy);\n\t\treturn bucket;\n\t}", "code_tokens": ["private", "int", "getBucket", "(", "double", "value", ")", "{", "assert", "(", "value", ">=", "m_min_value", "&&", "value", "<=", "m_max_value", ")", ";", "int", "bucket", "=", "(", "int", ")", "(", "(", "value", "-", "m_min_value", ")", "/", "m_dy", ")", ";", "return", "bucket", ";", "}"], "docstring": "Adds new element to the bucket builder. The value must be between\nmin_value and max_value.\n\n@param The\nvalue used for bucketing.\n@param The\nindex of the element to store in the buffer. Usually it is an\nindex into some array, where the real elements are stored.", "docstring_tokens": ["Adds", "new", "element", "to", "the", "bucket", "builder", ".", "The", "value", "must", "be", "between", "min_value", "and", "max_value", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/BucketSort.java#L171-L175", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorSimplify.java", "func_name": "OperatorSimplify.isSimpleAsFeature", "original_string": "public boolean isSimpleAsFeature(Geometry geom,\n\t\t\tSpatialReference spatialRef, ProgressTracker progressTracker) {\n\t\treturn isSimpleAsFeature(geom, spatialRef, false, null, progressTracker);\n\t}", "language": "java", "code": "public boolean isSimpleAsFeature(Geometry geom,\n\t\t\tSpatialReference spatialRef, ProgressTracker progressTracker) {\n\t\treturn isSimpleAsFeature(geom, spatialRef, false, null, progressTracker);\n\t}", "code_tokens": ["public", "boolean", "isSimpleAsFeature", "(", "Geometry", "geom", ",", "SpatialReference", "spatialRef", ",", "ProgressTracker", "progressTracker", ")", "{", "return", "isSimpleAsFeature", "(", "geom", ",", "spatialRef", ",", "false", ",", "null", ",", "progressTracker", ")", ";", "}"], "docstring": "Tests if the Geometry is simple (second call will use a cached IsKnownSimple flag and immediately return).\n@param geom The Geometry to be tested.\n@param spatialRef Spatial reference from which the tolerance is obtained. Can be null, then a\nvery small tolerance value is derived from the geometry bounds.\n@param progressTracker Allows cancellation of a long operation. Can be null.", "docstring_tokens": ["Tests", "if", "the", "Geometry", "is", "simple", "(", "second", "call", "will", "use", "a", "cached", "IsKnownSimple", "flag", "and", "immediately", "return", ")", ".", "@param", "geom", "The", "Geometry", "to", "be", "tested", ".", "@param", "spatialRef", "Spatial", "reference", "from", "which", "the", "tolerance", "is", "obtained", ".", "Can", "be", "null", "then", "a", "very", "small", "tolerance", "value", "is", "derived", "from", "the", "geometry", "bounds", ".", "@param", "progressTracker", "Allows", "cancellation", "of", "a", "long", "operation", ".", "Can", "be", "null", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorSimplify.java#L69-L72", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java", "func_name": "StridedIndexTypeCollection.getField", "original_string": "int getField(int element, int field) {\n\t\tassert(m_buffer[element >> m_blockPower][(element & m_blockMask) + 1] != -0x7eadbeed);\n\t\treturn m_buffer[element >> m_blockPower][(element & m_blockMask)\n\t\t\t\t+ field];\n\t}", "language": "java", "code": "int getField(int element, int field) {\n\t\tassert(m_buffer[element >> m_blockPower][(element & m_blockMask) + 1] != -0x7eadbeed);\n\t\treturn m_buffer[element >> m_blockPower][(element & m_blockMask)\n\t\t\t\t+ field];\n\t}", "code_tokens": ["int", "getField", "(", "int", "element", ",", "int", "field", ")", "{", "assert", "(", "m_buffer", "[", "element", ">>", "m_blockPower", "]", "[", "(", "element", "&", "m_blockMask", ")", "+", "1", "]", "!=", "-", "0x7eadbeed", ")", ";", "return", "m_buffer", "[", "element", ">>", "m_blockPower", "]", "[", "(", "element", "&", "m_blockMask", ")", "+", "field", "]", ";", "}"], "docstring": "Returns the given field of the element.", "docstring_tokens": ["Returns", "the", "given", "field", "of", "the", "element", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java#L94-L98", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java", "func_name": "StridedIndexTypeCollection.setField", "original_string": "void setField(int element, int field, int value) {\n\t\tassert(m_buffer[element >> m_blockPower][(element & m_blockMask) + 1] != -0x7eadbeed);\n\t\tm_buffer[element >> m_blockPower][(element & m_blockMask) + field] = value;\n\t}", "language": "java", "code": "void setField(int element, int field, int value) {\n\t\tassert(m_buffer[element >> m_blockPower][(element & m_blockMask) + 1] != -0x7eadbeed);\n\t\tm_buffer[element >> m_blockPower][(element & m_blockMask) + field] = value;\n\t}", "code_tokens": ["void", "setField", "(", "int", "element", ",", "int", "field", ",", "int", "value", ")", "{", "assert", "(", "m_buffer", "[", "element", ">>", "m_blockPower", "]", "[", "(", "element", "&", "m_blockMask", ")", "+", "1", "]", "!=", "-", "0x7eadbeed", ")", ";", "m_buffer", "[", "element", ">>", "m_blockPower", "]", "[", "(", "element", "&", "m_blockMask", ")", "+", "field", "]", "=", "value", ";", "}"], "docstring": "Sets the given field of the element.", "docstring_tokens": ["Sets", "the", "given", "field", "of", "the", "element", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java#L101-L104", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java", "func_name": "StridedIndexTypeCollection.newElement", "original_string": "int newElement() {\n\t\tint element = m_firstFree;\n\t\tif (element == -1) {\n\t\t\tif (m_last == m_capacity) {\n\t\t\t\tlong newcap = m_capacity != 0 ? (((long) m_capacity + 1) * 3 / 2)\n\t\t\t\t\t\t: (long) 1;\n\t\t\t\tif (newcap > Integer.MAX_VALUE)\n\t\t\t\t\tnewcap = Integer.MAX_VALUE;// cannot grow past 2gb elements\n\t\t\t\t\t\t\t\t\t\t\t\t// presently\n\n\t\t\t\tif (newcap == m_capacity)\n\t\t\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t\t\tgrow_(newcap);\n\t\t\t}\n\n\t\t\telement = ((m_last / m_blockSize) << m_blockPower)\n\t\t\t\t\t+ (m_last % m_blockSize) * m_realStride;\n\t\t\tm_last++;\n\t\t} else {\n\t\t\tm_firstFree = m_buffer[element >> m_blockPower][element\n\t\t\t\t\t& m_blockMask];\n\t\t}\n\n\t\tm_size++;\n\t\tint ar[] = m_buffer[element >> m_blockPower];\n\t\tint ind = element & m_blockMask;\n\t\tfor (int i = 0; i < m_stride; i++) {\n\t\t\tar[ind + i] = -1;\n\t\t}\n\t\treturn element;\n\t}", "language": "java", "code": "int newElement() {\n\t\tint element = m_firstFree;\n\t\tif (element == -1) {\n\t\t\tif (m_last == m_capacity) {\n\t\t\t\tlong newcap = m_capacity != 0 ? (((long) m_capacity + 1) * 3 / 2)\n\t\t\t\t\t\t: (long) 1;\n\t\t\t\tif (newcap > Integer.MAX_VALUE)\n\t\t\t\t\tnewcap = Integer.MAX_VALUE;// cannot grow past 2gb elements\n\t\t\t\t\t\t\t\t\t\t\t\t// presently\n\n\t\t\t\tif (newcap == m_capacity)\n\t\t\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t\t\tgrow_(newcap);\n\t\t\t}\n\n\t\t\telement = ((m_last / m_blockSize) << m_blockPower)\n\t\t\t\t\t+ (m_last % m_blockSize) * m_realStride;\n\t\t\tm_last++;\n\t\t} else {\n\t\t\tm_firstFree = m_buffer[element >> m_blockPower][element\n\t\t\t\t\t& m_blockMask];\n\t\t}\n\n\t\tm_size++;\n\t\tint ar[] = m_buffer[element >> m_blockPower];\n\t\tint ind = element & m_blockMask;\n\t\tfor (int i = 0; i < m_stride; i++) {\n\t\t\tar[ind + i] = -1;\n\t\t}\n\t\treturn element;\n\t}", "code_tokens": ["int", "newElement", "(", ")", "{", "int", "element", "=", "m_firstFree", ";", "if", "(", "element", "==", "-", "1", ")", "{", "if", "(", "m_last", "==", "m_capacity", ")", "{", "long", "newcap", "=", "m_capacity", "!=", "0", "?", "(", "(", "(", "long", ")", "m_capacity", "+", "1", ")", "*", "3", "/", "2", ")", ":", "(", "long", ")", "1", ";", "if", "(", "newcap", ">", "Integer", ".", "MAX_VALUE", ")", "newcap", "=", "Integer", ".", "MAX_VALUE", ";", "// cannot grow past 2gb elements", "// presently", "if", "(", "newcap", "==", "m_capacity", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "grow_", "(", "newcap", ")", ";", "}", "element", "=", "(", "(", "m_last", "/", "m_blockSize", ")", "<<", "m_blockPower", ")", "+", "(", "m_last", "%", "m_blockSize", ")", "*", "m_realStride", ";", "m_last", "++", ";", "}", "else", "{", "m_firstFree", "=", "m_buffer", "[", "element", ">>", "m_blockPower", "]", "[", "element", "&", "m_blockMask", "]", ";", "}", "m_size", "++", ";", "int", "ar", "[", "]", "=", "m_buffer", "[", "element", ">>", "m_blockPower", "]", ";", "int", "ind", "=", "element", "&", "m_blockMask", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_stride", ";", "i", "++", ")", "{", "ar", "[", "ind", "+", "i", "]", "=", "-", "1", ";", "}", "return", "element", ";", "}"], "docstring": "All fields are initialized to -1.", "docstring_tokens": ["All", "fields", "are", "initialized", "to", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java#L113-L144", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java", "func_name": "StridedIndexTypeCollection.swap", "original_string": "void swap(int element1, int element2) {\n\t\tint ar1[] = m_buffer[element1 >> m_blockPower];\n\t\tint ar2[] = m_buffer[element2 >> m_blockPower];\n\t\tint ind1 = element1 & m_blockMask;\n\t\tint ind2 = element2 & m_blockMask;\n\t\tfor (int i = 0; i < m_stride; i++) {\n\t\t\tint tmp = ar1[ind1 + i];\n\t\t\tar1[ind1 + i] = ar2[ind2 + i];\n\t\t\tar2[ind2 + i] = tmp;\n\t\t}\n\t}", "language": "java", "code": "void swap(int element1, int element2) {\n\t\tint ar1[] = m_buffer[element1 >> m_blockPower];\n\t\tint ar2[] = m_buffer[element2 >> m_blockPower];\n\t\tint ind1 = element1 & m_blockMask;\n\t\tint ind2 = element2 & m_blockMask;\n\t\tfor (int i = 0; i < m_stride; i++) {\n\t\t\tint tmp = ar1[ind1 + i];\n\t\t\tar1[ind1 + i] = ar2[ind2 + i];\n\t\t\tar2[ind2 + i] = tmp;\n\t\t}\n\t}", "code_tokens": ["void", "swap", "(", "int", "element1", ",", "int", "element2", ")", "{", "int", "ar1", "[", "]", "=", "m_buffer", "[", "element1", ">>", "m_blockPower", "]", ";", "int", "ar2", "[", "]", "=", "m_buffer", "[", "element2", ">>", "m_blockPower", "]", ";", "int", "ind1", "=", "element1", "&", "m_blockMask", ";", "int", "ind2", "=", "element2", "&", "m_blockMask", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_stride", ";", "i", "++", ")", "{", "int", "tmp", "=", "ar1", "[", "ind1", "+", "i", "]", ";", "ar1", "[", "ind1", "+", "i", "]", "=", "ar2", "[", "ind2", "+", "i", "]", ";", "ar2", "[", "ind2", "+", "i", "]", "=", "tmp", ";", "}", "}"], "docstring": "Swaps content of two elements (each field of the stride)", "docstring_tokens": ["Swaps", "content", "of", "two", "elements", "(", "each", "field", "of", "the", "stride", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java#L180-L190", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java", "func_name": "StridedIndexTypeCollection.swapField", "original_string": "void swapField(int element1, int element2, int field) {\n\t\tint ar1[] = m_buffer[element1 >> m_blockPower];\n\t\tint ar2[] = m_buffer[element2 >> m_blockPower];\n\t\tint ind1 = (element1 & m_blockMask) + field;\n\t\tint ind2 = (element2 & m_blockMask) + field;\n\t\tint tmp = ar1[ind1];\n\t\tar1[ind1] = ar2[ind2];\n\t\tar2[ind2] = tmp;\n\t}", "language": "java", "code": "void swapField(int element1, int element2, int field) {\n\t\tint ar1[] = m_buffer[element1 >> m_blockPower];\n\t\tint ar2[] = m_buffer[element2 >> m_blockPower];\n\t\tint ind1 = (element1 & m_blockMask) + field;\n\t\tint ind2 = (element2 & m_blockMask) + field;\n\t\tint tmp = ar1[ind1];\n\t\tar1[ind1] = ar2[ind2];\n\t\tar2[ind2] = tmp;\n\t}", "code_tokens": ["void", "swapField", "(", "int", "element1", ",", "int", "element2", ",", "int", "field", ")", "{", "int", "ar1", "[", "]", "=", "m_buffer", "[", "element1", ">>", "m_blockPower", "]", ";", "int", "ar2", "[", "]", "=", "m_buffer", "[", "element2", ">>", "m_blockPower", "]", ";", "int", "ind1", "=", "(", "element1", "&", "m_blockMask", ")", "+", "field", ";", "int", "ind2", "=", "(", "element2", "&", "m_blockMask", ")", "+", "field", ";", "int", "tmp", "=", "ar1", "[", "ind1", "]", ";", "ar1", "[", "ind1", "]", "=", "ar2", "[", "ind2", "]", ";", "ar2", "[", "ind2", "]", "=", "tmp", ";", "}"], "docstring": "Swaps content of two fields", "docstring_tokens": ["Swaps", "content", "of", "two", "fields"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/StridedIndexTypeCollection.java#L193-L201", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPoint.java", "func_name": "MultiPoint.add", "original_string": "public void add(MultiVertexGeometry src, int srcFrom, int srcTo) {\n\t\tm_impl.add((MultiVertexGeometryImpl) src._getImpl(), srcFrom, srcTo);\n\t}", "language": "java", "code": "public void add(MultiVertexGeometry src, int srcFrom, int srcTo) {\n\t\tm_impl.add((MultiVertexGeometryImpl) src._getImpl(), srcFrom, srcTo);\n\t}", "code_tokens": ["public", "void", "add", "(", "MultiVertexGeometry", "src", ",", "int", "srcFrom", ",", "int", "srcTo", ")", "{", "m_impl", ".", "add", "(", "(", "MultiVertexGeometryImpl", ")", "src", ".", "_getImpl", "(", ")", ",", "srcFrom", ",", "srcTo", ")", ";", "}"], "docstring": "Appends points from another multipoint at the end of this multipoint.\n\n@param src\nThe mulitpoint to append to this multipoint.\n@param srcFrom\nThe start index in the source multipoint from which to start\nappending points.\n@param srcTo\nThe end index in the source multipoint right after the last\npoint to be appended. Use -1 to indicate the rest of the\nsource multipoint.", "docstring_tokens": ["Appends", "points", "from", "another", "multipoint", "at", "the", "end", "of", "this", "multipoint", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPoint.java#L163-L165", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.transform", "original_string": "public void transform(Point[] pointsIn, int count, Point[] pointsOut) {\n\t\tPoint2D res = new Point2D();\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tPoint2D p = pointsIn[i].getXY();\n\t\t\tres.x = xx * p.x + xy * p.y + xd;\n\t\t\tres.y = yx * p.x + yy * p.y + yd;\n\t\t\tpointsOut[i] = new Point(res.x, res.y);\n\t\t}\n\t}", "language": "java", "code": "public void transform(Point[] pointsIn, int count, Point[] pointsOut) {\n\t\tPoint2D res = new Point2D();\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tPoint2D p = pointsIn[i].getXY();\n\t\t\tres.x = xx * p.x + xy * p.y + xd;\n\t\t\tres.y = yx * p.x + yy * p.y + yd;\n\t\t\tpointsOut[i] = new Point(res.x, res.y);\n\t\t}\n\t}", "code_tokens": ["public", "void", "transform", "(", "Point", "[", "]", "pointsIn", ",", "int", "count", ",", "Point", "[", "]", "pointsOut", ")", "{", "Point2D", "res", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "Point2D", "p", "=", "pointsIn", "[", "i", "]", ".", "getXY", "(", ")", ";", "res", ".", "x", "=", "xx", "*", "p", ".", "x", "+", "xy", "*", "p", ".", "y", "+", "xd", ";", "res", ".", "y", "=", "yx", "*", "p", ".", "x", "+", "yy", "*", "p", ".", "y", "+", "yd", ";", "pointsOut", "[", "i", "]", "=", "new", "Point", "(", "res", ".", "x", ",", "res", ".", "y", ")", ";", "}", "}"], "docstring": "Transforms an array of points.\n\n@param pointsIn\nThe points to be transformed.\n@param count\nThe number of points to transform.\n@param pointsOut\nThe transformed points are returned using this array. It\nshould have the same or greater size as the input array.", "docstring_tokens": ["Transforms", "an", "array", "of", "points", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L165-L173", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.transform", "original_string": "public void transform(double[] pointsXYInterleaved, int start, int count) {\n\t\tint n = Math.min(pointsXYInterleaved.length, (start + count) * 2) / 2;\n\t\tfor (int i = count; i < n; i++) {\n\t\t\tdouble px = pointsXYInterleaved[2 * i];\n\t\t\tdouble py = pointsXYInterleaved[2 * i + 1];\n\t\t\tpointsXYInterleaved[2 * i] = xx * px + xy * py + xd;\n\t\t\tpointsXYInterleaved[2 * i + 1] = yx * px + yy * py + yd;\n\t\t}\n\t}", "language": "java", "code": "public void transform(double[] pointsXYInterleaved, int start, int count) {\n\t\tint n = Math.min(pointsXYInterleaved.length, (start + count) * 2) / 2;\n\t\tfor (int i = count; i < n; i++) {\n\t\t\tdouble px = pointsXYInterleaved[2 * i];\n\t\t\tdouble py = pointsXYInterleaved[2 * i + 1];\n\t\t\tpointsXYInterleaved[2 * i] = xx * px + xy * py + xd;\n\t\t\tpointsXYInterleaved[2 * i + 1] = yx * px + yy * py + yd;\n\t\t}\n\t}", "code_tokens": ["public", "void", "transform", "(", "double", "[", "]", "pointsXYInterleaved", ",", "int", "start", ",", "int", "count", ")", "{", "int", "n", "=", "Math", ".", "min", "(", "pointsXYInterleaved", ".", "length", ",", "(", "start", "+", "count", ")", "*", "2", ")", "/", "2", ";", "for", "(", "int", "i", "=", "count", ";", "i", "<", "n", ";", "i", "++", ")", "{", "double", "px", "=", "pointsXYInterleaved", "[", "2", "*", "i", "]", ";", "double", "py", "=", "pointsXYInterleaved", "[", "2", "*", "i", "+", "1", "]", ";", "pointsXYInterleaved", "[", "2", "*", "i", "]", "=", "xx", "*", "px", "+", "xy", "*", "py", "+", "xd", ";", "pointsXYInterleaved", "[", "2", "*", "i", "+", "1", "]", "=", "yx", "*", "px", "+", "yy", "*", "py", "+", "yd", ";", "}", "}"], "docstring": "Transforms an array of points stored in an array of doubles as\ninterleaved XY coordinates.\n\n@param pointsXYInterleaved\nThe array of points with interleaved X, Y values to be\ntransformed.\n@param start\nThe start point index to transform from (the actual element\nindex is 2 * start).\n@param count\nThe number of points to transform (the actual element count is\n2 * count).", "docstring_tokens": ["Transforms", "an", "array", "of", "points", "stored", "in", "an", "array", "of", "doubles", "as", "interleaved", "XY", "coordinates", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L189-L197", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.multiply", "original_string": "public static void multiply(Transformation2D a, Transformation2D b,\n\t\t\tTransformation2D result) {\n\t\tdouble xx, xy, xd, yx, yy, yd;\n\n\t\txx = a.xx * b.xx + a.yx * b.xy;\n\t\txy = a.xy * b.xx + a.yy * b.xy;\n\t\txd = a.xd * b.xx + a.yd * b.xy + b.xd;\n\t\tyx = a.xx * b.yx + a.yx * b.yy;\n\t\tyy = a.xy * b.yx + a.yy * b.yy;\n\t\tyd = a.xd * b.yx + a.yd * b.yy + b.yd;\n\n\t\tresult.xx = xx;\n\t\tresult.xy = xy;\n\t\tresult.xd = xd;\n\t\tresult.yx = yx;\n\t\tresult.yy = yy;\n\t\tresult.yd = yd;\n\t}", "language": "java", "code": "public static void multiply(Transformation2D a, Transformation2D b,\n\t\t\tTransformation2D result) {\n\t\tdouble xx, xy, xd, yx, yy, yd;\n\n\t\txx = a.xx * b.xx + a.yx * b.xy;\n\t\txy = a.xy * b.xx + a.yy * b.xy;\n\t\txd = a.xd * b.xx + a.yd * b.xy + b.xd;\n\t\tyx = a.xx * b.yx + a.yx * b.yy;\n\t\tyy = a.xy * b.yx + a.yy * b.yy;\n\t\tyd = a.xd * b.yx + a.yd * b.yy + b.yd;\n\n\t\tresult.xx = xx;\n\t\tresult.xy = xy;\n\t\tresult.xd = xd;\n\t\tresult.yx = yx;\n\t\tresult.yy = yy;\n\t\tresult.yd = yd;\n\t}", "code_tokens": ["public", "static", "void", "multiply", "(", "Transformation2D", "a", ",", "Transformation2D", "b", ",", "Transformation2D", "result", ")", "{", "double", "xx", ",", "xy", ",", "xd", ",", "yx", ",", "yy", ",", "yd", ";", "xx", "=", "a", ".", "xx", "*", "b", ".", "xx", "+", "a", ".", "yx", "*", "b", ".", "xy", ";", "xy", "=", "a", ".", "xy", "*", "b", ".", "xx", "+", "a", ".", "yy", "*", "b", ".", "xy", ";", "xd", "=", "a", ".", "xd", "*", "b", ".", "xx", "+", "a", ".", "yd", "*", "b", ".", "xy", "+", "b", ".", "xd", ";", "yx", "=", "a", ".", "xx", "*", "b", ".", "yx", "+", "a", ".", "yx", "*", "b", ".", "yy", ";", "yy", "=", "a", ".", "xy", "*", "b", ".", "yx", "+", "a", ".", "yy", "*", "b", ".", "yy", ";", "yd", "=", "a", ".", "xd", "*", "b", ".", "yx", "+", "a", ".", "yd", "*", "b", ".", "yy", "+", "b", ".", "yd", ";", "result", ".", "xx", "=", "xx", ";", "result", ".", "xy", "=", "xy", ";", "result", ".", "xd", "=", "xd", ";", "result", ".", "yx", "=", "yx", ";", "result", ".", "yy", "=", "yy", ";", "result", ".", "yd", "=", "yd", ";", "}"], "docstring": "Performs multiplication of matrices a and b and places the result into\nthis matrix. The a, b, and result could point to same objects. <br>\nEquivalent to result = a * b.\n\n@param a\nThe 2D transformation to be multiplied.\n@param b\nThe 2D transformation to be multiplied.\n@param result\nThe 2D transformation created by multiplication of matrices.", "docstring_tokens": ["Performs", "multiplication", "of", "matrices", "a", "and", "b", "and", "places", "the", "result", "into", "this", "matrix", ".", "The", "a", "b", "and", "result", "could", "point", "to", "same", "objects", ".", "<br", ">", "Equivalent", "to", "result", "=", "a", "*", "b", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L235-L252", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.copy", "original_string": "public Transformation2D copy() {\n\t\tTransformation2D result = new Transformation2D();\n\t\tresult.xx = xx;\n\t\tresult.xy = xy;\n\t\tresult.xd = xd;\n\t\tresult.yx = yx;\n\t\tresult.yy = yy;\n\t\tresult.yd = yd;\n\t\treturn result;\n\t}", "language": "java", "code": "public Transformation2D copy() {\n\t\tTransformation2D result = new Transformation2D();\n\t\tresult.xx = xx;\n\t\tresult.xy = xy;\n\t\tresult.xd = xd;\n\t\tresult.yx = yx;\n\t\tresult.yy = yy;\n\t\tresult.yd = yd;\n\t\treturn result;\n\t}", "code_tokens": ["public", "Transformation2D", "copy", "(", ")", "{", "Transformation2D", "result", "=", "new", "Transformation2D", "(", ")", ";", "result", ".", "xx", "=", "xx", ";", "result", ".", "xy", "=", "xy", ";", "result", ".", "xd", "=", "xd", ";", "result", ".", "yx", "=", "yx", ";", "result", ".", "yy", "=", "yy", ";", "result", ".", "yd", "=", "yd", ";", "return", "result", ";", "}"], "docstring": "Returns a copy of the Transformation2D object.\n\n@return A copy of this object.", "docstring_tokens": ["Returns", "a", "copy", "of", "the", "Transformation2D", "object", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L259-L268", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.getCoefficients", "original_string": "public void getCoefficients(double[] coefs) {\n\t\tif (coefs.length < 6)\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"Buffer is too small. coefs needs 6 members\");\n\n\t\tcoefs[0] = xx;\n\t\tcoefs[1] = xy;\n\t\tcoefs[2] = xd;\n\t\tcoefs[3] = yx;\n\t\tcoefs[4] = yy;\n\t\tcoefs[5] = yd;\n\t}", "language": "java", "code": "public void getCoefficients(double[] coefs) {\n\t\tif (coefs.length < 6)\n\t\t\tthrow new GeometryException(\n\t\t\t\t\t\"Buffer is too small. coefs needs 6 members\");\n\n\t\tcoefs[0] = xx;\n\t\tcoefs[1] = xy;\n\t\tcoefs[2] = xd;\n\t\tcoefs[3] = yx;\n\t\tcoefs[4] = yy;\n\t\tcoefs[5] = yd;\n\t}", "code_tokens": ["public", "void", "getCoefficients", "(", "double", "[", "]", "coefs", ")", "{", "if", "(", "coefs", ".", "length", "<", "6", ")", "throw", "new", "GeometryException", "(", "\"Buffer is too small. coefs needs 6 members\"", ")", ";", "coefs", "[", "0", "]", "=", "xx", ";", "coefs", "[", "1", "]", "=", "xy", ";", "coefs", "[", "2", "]", "=", "xd", ";", "coefs", "[", "3", "]", "=", "yx", ";", "coefs", "[", "4", "]", "=", "yy", ";", "coefs", "[", "5", "]", "=", "yd", ";", "}"], "docstring": "Writes the matrix coefficients in the order XX, XY, XD, YX, YY, YD into\nthe given array.\n\n@param coefs\nThe array into which the coefficients are returned. Should be\nof size 6 elements.", "docstring_tokens": ["Writes", "the", "matrix", "coefficients", "in", "the", "order", "XX", "XY", "XD", "YX", "YY", "YD", "into", "the", "given", "array", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L278-L289", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.transform", "original_string": "void transform(Envelope2D env) {\n\n\t\tif (env.isEmpty())\n\t\t\treturn;\n\n\t\tPoint2D[] buf = new Point2D[4];\n\t\tenv.queryCorners(buf);\n\t\ttransform(buf, buf);\n\t\tenv.setFromPoints(buf, 4);\n\t}", "language": "java", "code": "void transform(Envelope2D env) {\n\n\t\tif (env.isEmpty())\n\t\t\treturn;\n\n\t\tPoint2D[] buf = new Point2D[4];\n\t\tenv.queryCorners(buf);\n\t\ttransform(buf, buf);\n\t\tenv.setFromPoints(buf, 4);\n\t}", "code_tokens": ["void", "transform", "(", "Envelope2D", "env", ")", "{", "if", "(", "env", ".", "isEmpty", "(", ")", ")", "return", ";", "Point2D", "[", "]", "buf", "=", "new", "Point2D", "[", "4", "]", ";", "env", ".", "queryCorners", "(", "buf", ")", ";", "transform", "(", "buf", ",", "buf", ")", ";", "env", ".", "setFromPoints", "(", "buf", ",", "4", ")", ";", "}"], "docstring": "Transforms envelope\n\n@param env\nThe envelope that is to be transformed", "docstring_tokens": ["Transforms", "envelope"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L297-L306", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.initializeFromRect", "original_string": "void initializeFromRect(Envelope2D src, Envelope2D dest) {\n\t\tif (src.isEmpty() || dest.isEmpty() || 0 == src.getWidth()\n\t\t\t\t|| 0 == src.getHeight())\n\t\t\tsetZero();\n\t\telse {\n\t\t\txy = yx = 0;\n\t\t\txx = dest.getWidth() / src.getWidth();\n\t\t\tyy = dest.getHeight() / src.getHeight();\n\t\t\txd = dest.xmin - src.xmin * xx;\n\t\t\tyd = dest.ymin - src.ymin * yy;\n\t\t}\n\t}", "language": "java", "code": "void initializeFromRect(Envelope2D src, Envelope2D dest) {\n\t\tif (src.isEmpty() || dest.isEmpty() || 0 == src.getWidth()\n\t\t\t\t|| 0 == src.getHeight())\n\t\t\tsetZero();\n\t\telse {\n\t\t\txy = yx = 0;\n\t\t\txx = dest.getWidth() / src.getWidth();\n\t\t\tyy = dest.getHeight() / src.getHeight();\n\t\t\txd = dest.xmin - src.xmin * xx;\n\t\t\tyd = dest.ymin - src.ymin * yy;\n\t\t}\n\t}", "code_tokens": ["void", "initializeFromRect", "(", "Envelope2D", "src", ",", "Envelope2D", "dest", ")", "{", "if", "(", "src", ".", "isEmpty", "(", ")", "||", "dest", ".", "isEmpty", "(", ")", "||", "0", "==", "src", ".", "getWidth", "(", ")", "||", "0", "==", "src", ".", "getHeight", "(", ")", ")", "setZero", "(", ")", ";", "else", "{", "xy", "=", "yx", "=", "0", ";", "xx", "=", "dest", ".", "getWidth", "(", ")", "/", "src", ".", "getWidth", "(", ")", ";", "yy", "=", "dest", ".", "getHeight", "(", ")", "/", "src", ".", "getHeight", "(", ")", ";", "xd", "=", "dest", ".", "xmin", "-", "src", ".", "xmin", "*", "xx", ";", "yd", "=", "dest", ".", "ymin", "-", "src", ".", "ymin", "*", "yy", ";", "}", "}"], "docstring": "Initialize transformation from two rectangles.", "docstring_tokens": ["Initialize", "transformation", "from", "two", "rectangles", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L321-L332", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.initializeFromRectIsotropic", "original_string": "void initializeFromRectIsotropic(Envelope2D src, Envelope2D dest) {\n\n\t\tif (src.isEmpty() || dest.isEmpty() || 0 == src.getWidth()\n\t\t\t\t|| 0 == src.getHeight())\n\t\t\tsetZero();\n\t\telse {\n\t\t\tyx = 0;\n\t\t\txy = 0;\n\t\t\txx = dest.getWidth() / src.getWidth();\n\t\t\tyy = dest.getHeight() / src.getHeight();\n\t\t\tif (xx > yy)\n\t\t\t\txx = yy;\n\t\t\telse\n\t\t\t\tyy = xx;\n\n\t\t\tPoint2D destCenter = dest.getCenter();\n\t\t\tPoint2D srcCenter = src.getCenter();\n\t\t\txd = destCenter.x - srcCenter.x * xx;\n\t\t\tyd = destCenter.y - srcCenter.y * yy;\n\t\t}\n\t}", "language": "java", "code": "void initializeFromRectIsotropic(Envelope2D src, Envelope2D dest) {\n\n\t\tif (src.isEmpty() || dest.isEmpty() || 0 == src.getWidth()\n\t\t\t\t|| 0 == src.getHeight())\n\t\t\tsetZero();\n\t\telse {\n\t\t\tyx = 0;\n\t\t\txy = 0;\n\t\t\txx = dest.getWidth() / src.getWidth();\n\t\t\tyy = dest.getHeight() / src.getHeight();\n\t\t\tif (xx > yy)\n\t\t\t\txx = yy;\n\t\t\telse\n\t\t\t\tyy = xx;\n\n\t\t\tPoint2D destCenter = dest.getCenter();\n\t\t\tPoint2D srcCenter = src.getCenter();\n\t\t\txd = destCenter.x - srcCenter.x * xx;\n\t\t\tyd = destCenter.y - srcCenter.y * yy;\n\t\t}\n\t}", "code_tokens": ["void", "initializeFromRectIsotropic", "(", "Envelope2D", "src", ",", "Envelope2D", "dest", ")", "{", "if", "(", "src", ".", "isEmpty", "(", ")", "||", "dest", ".", "isEmpty", "(", ")", "||", "0", "==", "src", ".", "getWidth", "(", ")", "||", "0", "==", "src", ".", "getHeight", "(", ")", ")", "setZero", "(", ")", ";", "else", "{", "yx", "=", "0", ";", "xy", "=", "0", ";", "xx", "=", "dest", ".", "getWidth", "(", ")", "/", "src", ".", "getWidth", "(", ")", ";", "yy", "=", "dest", ".", "getHeight", "(", ")", "/", "src", ".", "getHeight", "(", ")", ";", "if", "(", "xx", ">", "yy", ")", "xx", "=", "yy", ";", "else", "yy", "=", "xx", ";", "Point2D", "destCenter", "=", "dest", ".", "getCenter", "(", ")", ";", "Point2D", "srcCenter", "=", "src", ".", "getCenter", "(", ")", ";", "xd", "=", "destCenter", ".", "x", "-", "srcCenter", ".", "x", "*", "xx", ";", "yd", "=", "destCenter", ".", "y", "-", "srcCenter", ".", "y", "*", "yy", ";", "}", "}"], "docstring": "Initializes an orhtonormal transformation from the Src and Dest\nrectangles.\n\nThe result transformation proportionally fits the Src into the Dest. The\ncenter of the Src will be in the center of the Dest.", "docstring_tokens": ["Initializes", "an", "orhtonormal", "transformation", "from", "the", "Src", "and", "Dest", "rectangles", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L341-L361", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.transformSize", "original_string": "Point2D transformSize(Point2D SizeSrc) {\n\t\tPoint2D pt = new Point2D();\n\t\tpt.x = Math.sqrt(xx * xx + yx * yx) * SizeSrc.x;\n\t\tpt.y = Math.sqrt(xy * xy + yy * yy) * SizeSrc.y;\n\t\treturn pt;\n\t}", "language": "java", "code": "Point2D transformSize(Point2D SizeSrc) {\n\t\tPoint2D pt = new Point2D();\n\t\tpt.x = Math.sqrt(xx * xx + yx * yx) * SizeSrc.x;\n\t\tpt.y = Math.sqrt(xy * xy + yy * yy) * SizeSrc.y;\n\t\treturn pt;\n\t}", "code_tokens": ["Point2D", "transformSize", "(", "Point2D", "SizeSrc", ")", "{", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "pt", ".", "x", "=", "Math", ".", "sqrt", "(", "xx", "*", "xx", "+", "yx", "*", "yx", ")", "*", "SizeSrc", ".", "x", ";", "pt", ".", "y", "=", "Math", ".", "sqrt", "(", "xy", "*", "xy", "+", "yy", "*", "yy", ")", "*", "SizeSrc", ".", "y", ";", "return", "pt", ";", "}"], "docstring": "Transforms size.\n\nCreates an AABB with width of SizeSrc.x and height of SizeSrc.y.\nTransforms that AABB and gets a quadrangle in new coordinate system. The\nresult x contains the length of the quadrangle edge, which were parallel\nto X in the original system, and y contains the length of the edge, that\nwere parallel to the Y axis in the original system.", "docstring_tokens": ["Transforms", "size", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L381-L386", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.transform", "original_string": "public double transform(double tolerance) {\n\t\t// the function should be implemented as follows: find encompassing\n\t\t// circle for the transformed circle of radius = Tolerance.\n\n\t\t// this is approximation.\n\t\tPoint2D pt1 = new Point2D();\n\t\tPoint2D pt2 = new Point2D();\n\t\t/*\n\t\t * pt[0].Set(0, 0); pt[1].Set(1, 0); pt[2].Set(0, 1); Transform(pt);\n\t\t * pt[1] -= pt[0]; pt[2] -= pt[0];\n\t\t */\n\n\t\tpt1.setCoords(xx, yx);\n\t\tpt2.setCoords(xy, yy);\n\t\tpt1.sub(pt1);\n\t\tdouble d1 = pt1.sqrLength() * 0.5;\n\t\tpt1.setCoords(xx, yx);\n\t\tpt2.setCoords(xy, yy);\n\t\tpt1.add(pt2);\n\t\tdouble d2 = pt1.sqrLength() * 0.5;\n\t\treturn tolerance * ((d1 > d2) ? Math.sqrt(d1) : Math.sqrt(d2));\n\t}", "language": "java", "code": "public double transform(double tolerance) {\n\t\t// the function should be implemented as follows: find encompassing\n\t\t// circle for the transformed circle of radius = Tolerance.\n\n\t\t// this is approximation.\n\t\tPoint2D pt1 = new Point2D();\n\t\tPoint2D pt2 = new Point2D();\n\t\t/*\n\t\t * pt[0].Set(0, 0); pt[1].Set(1, 0); pt[2].Set(0, 1); Transform(pt);\n\t\t * pt[1] -= pt[0]; pt[2] -= pt[0];\n\t\t */\n\n\t\tpt1.setCoords(xx, yx);\n\t\tpt2.setCoords(xy, yy);\n\t\tpt1.sub(pt1);\n\t\tdouble d1 = pt1.sqrLength() * 0.5;\n\t\tpt1.setCoords(xx, yx);\n\t\tpt2.setCoords(xy, yy);\n\t\tpt1.add(pt2);\n\t\tdouble d2 = pt1.sqrLength() * 0.5;\n\t\treturn tolerance * ((d1 > d2) ? Math.sqrt(d1) : Math.sqrt(d2));\n\t}", "code_tokens": ["public", "double", "transform", "(", "double", "tolerance", ")", "{", "// the function should be implemented as follows: find encompassing", "// circle for the transformed circle of radius = Tolerance.", "// this is approximation.", "Point2D", "pt1", "=", "new", "Point2D", "(", ")", ";", "Point2D", "pt2", "=", "new", "Point2D", "(", ")", ";", "/*\n\t\t * pt[0].Set(0, 0); pt[1].Set(1, 0); pt[2].Set(0, 1); Transform(pt);\n\t\t * pt[1] -= pt[0]; pt[2] -= pt[0];\n\t\t */", "pt1", ".", "setCoords", "(", "xx", ",", "yx", ")", ";", "pt2", ".", "setCoords", "(", "xy", ",", "yy", ")", ";", "pt1", ".", "sub", "(", "pt1", ")", ";", "double", "d1", "=", "pt1", ".", "sqrLength", "(", ")", "*", "0.5", ";", "pt1", ".", "setCoords", "(", "xx", ",", "yx", ")", ";", "pt2", ".", "setCoords", "(", "xy", ",", "yy", ")", ";", "pt1", ".", "add", "(", "pt2", ")", ";", "double", "d2", "=", "pt1", ".", "sqrLength", "(", ")", "*", "0.5", ";", "return", "tolerance", "*", "(", "(", "d1", ">", "d2", ")", "?", "Math", ".", "sqrt", "(", "d1", ")", ":", "Math", ".", "sqrt", "(", "d2", ")", ")", ";", "}"], "docstring": "Transforms a tolerance value.\n\n@param tolerance\nThe tolerance value.", "docstring_tokens": ["Transforms", "a", "tolerance", "value", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L394-L415", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.transformWithoutShift", "original_string": "void transformWithoutShift(Point2D[] pointsIn, int from, int count,\n\t\t\tPoint2D[] pointsOut) {\n\t\tfor (int i = from, n = from + count; i < n; i++) {\n\t\t\tPoint2D p = pointsIn[i];\n\t\t\tdouble new_x = xx * p.x + xy * p.y;\n\t\t\tdouble new_y = yx * p.x + yy * p.y;\n\t\t\tpointsOut[i].setCoords(new_x, new_y);\n\t\t}\n\t}", "language": "java", "code": "void transformWithoutShift(Point2D[] pointsIn, int from, int count,\n\t\t\tPoint2D[] pointsOut) {\n\t\tfor (int i = from, n = from + count; i < n; i++) {\n\t\t\tPoint2D p = pointsIn[i];\n\t\t\tdouble new_x = xx * p.x + xy * p.y;\n\t\t\tdouble new_y = yx * p.x + yy * p.y;\n\t\t\tpointsOut[i].setCoords(new_x, new_y);\n\t\t}\n\t}", "code_tokens": ["void", "transformWithoutShift", "(", "Point2D", "[", "]", "pointsIn", ",", "int", "from", ",", "int", "count", ",", "Point2D", "[", "]", "pointsOut", ")", "{", "for", "(", "int", "i", "=", "from", ",", "n", "=", "from", "+", "count", ";", "i", "<", "n", ";", "i", "++", ")", "{", "Point2D", "p", "=", "pointsIn", "[", "i", "]", ";", "double", "new_x", "=", "xx", "*", "p", ".", "x", "+", "xy", "*", "p", ".", "y", ";", "double", "new_y", "=", "yx", "*", "p", ".", "x", "+", "yy", "*", "p", ".", "y", ";", "pointsOut", "[", "i", "]", ".", "setCoords", "(", "new_x", ",", "new_y", ")", ";", "}", "}"], "docstring": "be zeroed.", "docstring_tokens": ["be", "zeroed", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L419-L427", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.isIdentity", "original_string": "public boolean isIdentity(double tol) {\n\t\tPoint2D pt = Point2D.construct(0., 1.);\n\t\ttransform(pt, pt);\n\t\tpt.sub(Point2D.construct(0., 1.));\n\t\tif (pt.sqrLength() > tol * tol)\n\t\t\treturn false;\n\n\t\tpt.setCoords(0, 0);\n\t\ttransform(pt, pt);\n\t\tif (pt.sqrLength() > tol * tol)\n\t\t\treturn false;\n\n\t\tpt.setCoords(1.0, 0.0);\n\t\ttransform(pt, pt);\n\t\tpt.sub(Point2D.construct(1.0, 0.0));\n\t\treturn pt.sqrLength() <= tol * tol;\n\t}", "language": "java", "code": "public boolean isIdentity(double tol) {\n\t\tPoint2D pt = Point2D.construct(0., 1.);\n\t\ttransform(pt, pt);\n\t\tpt.sub(Point2D.construct(0., 1.));\n\t\tif (pt.sqrLength() > tol * tol)\n\t\t\treturn false;\n\n\t\tpt.setCoords(0, 0);\n\t\ttransform(pt, pt);\n\t\tif (pt.sqrLength() > tol * tol)\n\t\t\treturn false;\n\n\t\tpt.setCoords(1.0, 0.0);\n\t\ttransform(pt, pt);\n\t\tpt.sub(Point2D.construct(1.0, 0.0));\n\t\treturn pt.sqrLength() <= tol * tol;\n\t}", "code_tokens": ["public", "boolean", "isIdentity", "(", "double", "tol", ")", "{", "Point2D", "pt", "=", "Point2D", ".", "construct", "(", "0.", ",", "1.", ")", ";", "transform", "(", "pt", ",", "pt", ")", ";", "pt", ".", "sub", "(", "Point2D", ".", "construct", "(", "0.", ",", "1.", ")", ")", ";", "if", "(", "pt", ".", "sqrLength", "(", ")", ">", "tol", "*", "tol", ")", "return", "false", ";", "pt", ".", "setCoords", "(", "0", ",", "0", ")", ";", "transform", "(", "pt", ",", "pt", ")", ";", "if", "(", "pt", ".", "sqrLength", "(", ")", ">", "tol", "*", "tol", ")", "return", "false", ";", "pt", ".", "setCoords", "(", "1.0", ",", "0.0", ")", ";", "transform", "(", "pt", ",", "pt", ")", ";", "pt", ".", "sub", "(", "Point2D", ".", "construct", "(", "1.0", ",", "0.0", ")", ")", ";", "return", "pt", ".", "sqrLength", "(", ")", "<=", "tol", "*", "tol", ";", "}"], "docstring": "Returns TRUE if this matrix is an identity matrix within the given\ntolerance.\n\n@param tol\nThe tolerance value.", "docstring_tokens": ["Returns", "TRUE", "if", "this", "matrix", "is", "an", "identity", "matrix", "within", "the", "given", "tolerance", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L462-L478", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.isUniform", "original_string": "public boolean isUniform(double eps) {\n\t\tdouble v1 = xx * xx + yx * yx;\n\t\tdouble v2 = xy * xy + yy * yy;\n\t\tdouble e = (v1 + v2) * eps;\n\t\treturn Math.abs(v1 - v2) <= e && Math.abs(xx * xy + yx * yy) <= e;\n\t}", "language": "java", "code": "public boolean isUniform(double eps) {\n\t\tdouble v1 = xx * xx + yx * yx;\n\t\tdouble v2 = xy * xy + yy * yy;\n\t\tdouble e = (v1 + v2) * eps;\n\t\treturn Math.abs(v1 - v2) <= e && Math.abs(xx * xy + yx * yy) <= e;\n\t}", "code_tokens": ["public", "boolean", "isUniform", "(", "double", "eps", ")", "{", "double", "v1", "=", "xx", "*", "xx", "+", "yx", "*", "yx", ";", "double", "v2", "=", "xy", "*", "xy", "+", "yy", "*", "yy", ";", "double", "e", "=", "(", "v1", "+", "v2", ")", "*", "eps", ";", "return", "Math", ".", "abs", "(", "v1", "-", "v2", ")", "<=", "e", "&&", "Math", ".", "abs", "(", "xx", "*", "xy", "+", "yx", "*", "yy", ")", "<=", "e", ";", "}"], "docstring": "Returns TRUE if this transformation is a uniform transformation.\n\nThe uniform transformation is a transformation, which transforms a square\nto a square.", "docstring_tokens": ["Returns", "TRUE", "if", "this", "transformation", "is", "a", "uniform", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L494-L499", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.isShift", "original_string": "public boolean isShift(double tol) {\n\t\tPoint2D pt = transformWithoutShift(Point2D.construct(0.0, 1.0));\n\t\tpt.y -= 1.0;\n\t\tif (pt.sqrLength() > tol * tol)\n\t\t\treturn false;\n\n\t\tpt = transformWithoutShift(Point2D.construct(1.0, 0.0));\n\t\tpt.x -= 1.0;\n\t\treturn pt.sqrLength() <= tol * tol;\n\t}", "language": "java", "code": "public boolean isShift(double tol) {\n\t\tPoint2D pt = transformWithoutShift(Point2D.construct(0.0, 1.0));\n\t\tpt.y -= 1.0;\n\t\tif (pt.sqrLength() > tol * tol)\n\t\t\treturn false;\n\n\t\tpt = transformWithoutShift(Point2D.construct(1.0, 0.0));\n\t\tpt.x -= 1.0;\n\t\treturn pt.sqrLength() <= tol * tol;\n\t}", "code_tokens": ["public", "boolean", "isShift", "(", "double", "tol", ")", "{", "Point2D", "pt", "=", "transformWithoutShift", "(", "Point2D", ".", "construct", "(", "0.0", ",", "1.0", ")", ")", ";", "pt", ".", "y", "-=", "1.0", ";", "if", "(", "pt", ".", "sqrLength", "(", ")", ">", "tol", "*", "tol", ")", "return", "false", ";", "pt", "=", "transformWithoutShift", "(", "Point2D", ".", "construct", "(", "1.0", ",", "0.0", ")", ")", ";", "pt", ".", "x", "-=", "1.0", ";", "return", "pt", ".", "sqrLength", "(", ")", "<=", "tol", "*", "tol", ";", "}"], "docstring": "Returns TRUE if this transformation is a shift transformation within the\ngiven tolerance.\n\n@param tol\nThe tolerance value.", "docstring_tokens": ["Returns", "TRUE", "if", "this", "transformation", "is", "a", "shift", "transformation", "within", "the", "given", "tolerance", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L516-L525", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.isOrthonormal", "original_string": "public boolean isOrthonormal(double tol) {\n\t\tTransformation2D r = new Transformation2D();\n\t\tr.xx = xx * xx + xy * xy;\n\t\tr.xy = xx * yx + xy * yy;\n\t\tr.yx = yx * xx + yy * xy;\n\t\tr.yy = yx * yx + yy * yy;\n\t\tr.xd = 0;\n\t\tr.yd = 0;\n\n\t\treturn r.isIdentity(tol);\n\t}", "language": "java", "code": "public boolean isOrthonormal(double tol) {\n\t\tTransformation2D r = new Transformation2D();\n\t\tr.xx = xx * xx + xy * xy;\n\t\tr.xy = xx * yx + xy * yy;\n\t\tr.yx = yx * xx + yy * xy;\n\t\tr.yy = yx * yx + yy * yy;\n\t\tr.xd = 0;\n\t\tr.yd = 0;\n\n\t\treturn r.isIdentity(tol);\n\t}", "code_tokens": ["public", "boolean", "isOrthonormal", "(", "double", "tol", ")", "{", "Transformation2D", "r", "=", "new", "Transformation2D", "(", ")", ";", "r", ".", "xx", "=", "xx", "*", "xx", "+", "xy", "*", "xy", ";", "r", ".", "xy", "=", "xx", "*", "yx", "+", "xy", "*", "yy", ";", "r", ".", "yx", "=", "yx", "*", "xx", "+", "yy", "*", "xy", ";", "r", ".", "yy", "=", "yx", "*", "yx", "+", "yy", "*", "yy", ";", "r", ".", "xd", "=", "0", ";", "r", ".", "yd", "=", "0", ";", "return", "r", ".", "isIdentity", "(", "tol", ")", ";", "}"], "docstring": "Returns TRUE if this is an orthonormal transformation with the given\ntolerance. The orthonormal: Rotation or rotoinversion and shift\n(preserves lengths of vectors and angles between vectors).\n\n@param tol\nThe tolerance value.", "docstring_tokens": ["Returns", "TRUE", "if", "this", "is", "an", "orthonormal", "transformation", "with", "the", "given", "tolerance", ".", "The", "orthonormal", ":", "Rotation", "or", "rotoinversion", "and", "shift", "(", "preserves", "lengths", "of", "vectors", "and", "angles", "between", "vectors", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L535-L545", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.isDegenerate", "original_string": "public boolean isDegenerate(double tol) {\n\t\treturn Math.abs(xx * yy - yx * xy) <= 2 * tol\n\t\t\t\t* (Math.abs(xx * yy) + Math.abs(yx * xy));\n\t}", "language": "java", "code": "public boolean isDegenerate(double tol) {\n\t\treturn Math.abs(xx * yy - yx * xy) <= 2 * tol\n\t\t\t\t* (Math.abs(xx * yy) + Math.abs(yx * xy));\n\t}", "code_tokens": ["public", "boolean", "isDegenerate", "(", "double", "tol", ")", "{", "return", "Math", ".", "abs", "(", "xx", "*", "yy", "-", "yx", "*", "xy", ")", "<=", "2", "*", "tol", "*", "(", "Math", ".", "abs", "(", "xx", "*", "yy", ")", "+", "Math", ".", "abs", "(", "yx", "*", "xy", ")", ")", ";", "}"], "docstring": "Returns TRUE if this matrix is degenerated (does not have an inverse)\nwithin the given tolerance.\n\n@param tol\nThe tolerance value.", "docstring_tokens": ["Returns", "TRUE", "if", "this", "matrix", "is", "degenerated", "(", "does", "not", "have", "an", "inverse", ")", "within", "the", "given", "tolerance", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L554-L557", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.isScaleAndShift", "original_string": "public boolean isScaleAndShift(double tol) {\n\t\treturn xy * xy + yx * yx < (xx * xx + yy * yy) * tol;\n\t}", "language": "java", "code": "public boolean isScaleAndShift(double tol) {\n\t\treturn xy * xy + yx * yx < (xx * xx + yy * yy) * tol;\n\t}", "code_tokens": ["public", "boolean", "isScaleAndShift", "(", "double", "tol", ")", "{", "return", "xy", "*", "xy", "+", "yx", "*", "yx", "<", "(", "xx", "*", "xx", "+", "yy", "*", "yy", ")", "*", "tol", ";", "}"], "docstring": "Returns TRUE, if this transformation does not have rotation and shear\nwithin the given tolerance.\n\n@param tol\nThe tolerance value.", "docstring_tokens": ["Returns", "TRUE", "if", "this", "transformation", "does", "not", "have", "rotation", "and", "shear", "within", "the", "given", "tolerance", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L566-L568", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setShift", "original_string": "public void setShift(double x, double y) {\n\t\txx = 1;\n\t\txy = 0;\n\t\txd = x;\n\t\tyx = 0;\n\t\tyy = 1;\n\t\tyd = y;\n\t}", "language": "java", "code": "public void setShift(double x, double y) {\n\t\txx = 1;\n\t\txy = 0;\n\t\txd = x;\n\t\tyx = 0;\n\t\tyy = 1;\n\t\tyd = y;\n\t}", "code_tokens": ["public", "void", "setShift", "(", "double", "x", ",", "double", "y", ")", "{", "xx", "=", "1", ";", "xy", "=", "0", ";", "xd", "=", "x", ";", "yx", "=", "0", ";", "yy", "=", "1", ";", "yd", "=", "y", ";", "}"], "docstring": "Set this transformation to be a shift.\n\n@param x\nThe X coordinate to shift to.\n@param y\nThe Y coordinate to shift to.", "docstring_tokens": ["Set", "this", "transformation", "to", "be", "a", "shift", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L578-L585", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setFlipX", "original_string": "public void setFlipX(double x0, double x1) {\n\t\txx = -1;\n\t\txy = 0;\n\t\txd = x0 + x1;\n\t\tyx = 0;\n\t\tyy = 1;\n\t\tyd = 0;\n\t}", "language": "java", "code": "public void setFlipX(double x0, double x1) {\n\t\txx = -1;\n\t\txy = 0;\n\t\txd = x0 + x1;\n\t\tyx = 0;\n\t\tyy = 1;\n\t\tyd = 0;\n\t}", "code_tokens": ["public", "void", "setFlipX", "(", "double", "x0", ",", "double", "x1", ")", "{", "xx", "=", "-", "1", ";", "xy", "=", "0", ";", "xd", "=", "x0", "+", "x1", ";", "yx", "=", "0", ";", "yy", "=", "1", ";", "yd", "=", "0", ";", "}"], "docstring": "Sets the transformation to be a flip around the X axis. Flips the X\ncoordinates so that the x0 becomes x1 and vice verse.\n\n@param x0\nThe X coordinate to flip.\n@param x1\nThe X coordinate to flip to.", "docstring_tokens": ["Sets", "the", "transformation", "to", "be", "a", "flip", "around", "the", "X", "axis", ".", "Flips", "the", "X", "coordinates", "so", "that", "the", "x0", "becomes", "x1", "and", "vice", "verse", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L623-L630", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setFlipY", "original_string": "public void setFlipY(double y0, double y1) {\n\t\txx = 1;\n\t\txy = 0;\n\t\txd = 0;\n\t\tyx = 0;\n\t\tyy = -1;\n\t\tyd = y0 + y1;\n\t}", "language": "java", "code": "public void setFlipY(double y0, double y1) {\n\t\txx = 1;\n\t\txy = 0;\n\t\txd = 0;\n\t\tyx = 0;\n\t\tyy = -1;\n\t\tyd = y0 + y1;\n\t}", "code_tokens": ["public", "void", "setFlipY", "(", "double", "y0", ",", "double", "y1", ")", "{", "xx", "=", "1", ";", "xy", "=", "0", ";", "xd", "=", "0", ";", "yx", "=", "0", ";", "yy", "=", "-", "1", ";", "yd", "=", "y0", "+", "y1", ";", "}"], "docstring": "Sets the transformation to be a flip around the Y axis. Flips the Y\ncoordinates so that the y0 becomes y1 and vice verse.\n\n@param y0\nThe Y coordinate to flip.\n@param y1\nThe Y coordinate to flip to.", "docstring_tokens": ["Sets", "the", "transformation", "to", "be", "a", "flip", "around", "the", "Y", "axis", ".", "Flips", "the", "Y", "coordinates", "so", "that", "the", "y0", "becomes", "y1", "and", "vice", "verse", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L641-L648", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setShear", "original_string": "public void setShear(double proportionX, double proportionY) {\n\t\txx = 1;\n\t\txy = proportionX;\n\t\txd = 0;\n\t\tyx = proportionY;\n\t\tyy = 1;\n\t\tyd = 0;\n\t}", "language": "java", "code": "public void setShear(double proportionX, double proportionY) {\n\t\txx = 1;\n\t\txy = proportionX;\n\t\txd = 0;\n\t\tyx = proportionY;\n\t\tyy = 1;\n\t\tyd = 0;\n\t}", "code_tokens": ["public", "void", "setShear", "(", "double", "proportionX", ",", "double", "proportionY", ")", "{", "xx", "=", "1", ";", "xy", "=", "proportionX", ";", "xd", "=", "0", ";", "yx", "=", "proportionY", ";", "yy", "=", "1", ";", "yd", "=", "0", ";", "}"], "docstring": "Set transformation to a shear.\n\n@param proportionX\nThe proportion of shearing in x direction.\n@param proportionY\nThe proportion of shearing in y direction.", "docstring_tokens": ["Set", "transformation", "to", "a", "shear", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L658-L665", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setRotate", "original_string": "void setRotate(double angle_in_Radians, Point2D rotationCenter) {\n\t\tsetRotate(Math.cos(angle_in_Radians), Math.sin(angle_in_Radians),\n\t\t\t\trotationCenter);\n\t}", "language": "java", "code": "void setRotate(double angle_in_Radians, Point2D rotationCenter) {\n\t\tsetRotate(Math.cos(angle_in_Radians), Math.sin(angle_in_Radians),\n\t\t\t\trotationCenter);\n\t}", "code_tokens": ["void", "setRotate", "(", "double", "angle_in_Radians", ",", "Point2D", "rotationCenter", ")", "{", "setRotate", "(", "Math", ".", "cos", "(", "angle_in_Radians", ")", ",", "Math", ".", "sin", "(", "angle_in_Radians", ")", ",", "rotationCenter", ")", ";", "}"], "docstring": "Sets this transformation to be a rotation around point rotationCenter.\n\nWhen the axis Y is directed up and X is directed to the right, the\npositive angle corresponds to the anti-clockwise rotation. When the axis\nY is directed down and X is directed to the right, the positive angle\ncorresponds to the clockwise rotation.\n\n@param angle_in_Radians\nThe rotation angle in radian.\n@param rotationCenter\nThe center point of the rotation.", "docstring_tokens": ["Sets", "this", "transformation", "to", "be", "a", "rotation", "around", "point", "rotationCenter", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L709-L712", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setRotate", "original_string": "public void setRotate(double cosA, double sinA) {\n\t\txx = cosA;\n\t\txy = -sinA;\n\t\txd = 0;\n\t\tyx = sinA;\n\t\tyy = cosA;\n\t\tyd = 0;\n\t}", "language": "java", "code": "public void setRotate(double cosA, double sinA) {\n\t\txx = cosA;\n\t\txy = -sinA;\n\t\txd = 0;\n\t\tyx = sinA;\n\t\tyy = cosA;\n\t\tyd = 0;\n\t}", "code_tokens": ["public", "void", "setRotate", "(", "double", "cosA", ",", "double", "sinA", ")", "{", "xx", "=", "cosA", ";", "xy", "=", "-", "sinA", ";", "xd", "=", "0", ";", "yx", "=", "sinA", ";", "yy", "=", "cosA", ";", "yd", "=", "0", ";", "}"], "docstring": "Sets rotation for this transformation.\n\nWhen the axis Y is directed up and X is directed to the right, the\npositive angle corresponds to the anti-clockwise rotation. When the axis\nY is directed down and X is directed to the right, the positive angle\ncorresponds to the clockwise rotation.\n\n@param cosA\nThe rotation angle.\n@param sinA\nThe rotation angle.", "docstring_tokens": ["Sets", "rotation", "for", "this", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L728-L735", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.setRotate", "original_string": "void setRotate(double cosA, double sinA, Point2D rotationCenter) {\n\t\tsetShift(-rotationCenter.x, -rotationCenter.y);\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(cosA, sinA);\n\t\tmultiply(temp);\n\t\tshift(rotationCenter.x, rotationCenter.y);\n\t}", "language": "java", "code": "void setRotate(double cosA, double sinA, Point2D rotationCenter) {\n\t\tsetShift(-rotationCenter.x, -rotationCenter.y);\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(cosA, sinA);\n\t\tmultiply(temp);\n\t\tshift(rotationCenter.x, rotationCenter.y);\n\t}", "code_tokens": ["void", "setRotate", "(", "double", "cosA", ",", "double", "sinA", ",", "Point2D", "rotationCenter", ")", "{", "setShift", "(", "-", "rotationCenter", ".", "x", ",", "-", "rotationCenter", ".", "y", ")", ";", "Transformation2D", "temp", "=", "new", "Transformation2D", "(", ")", ";", "temp", ".", "setRotate", "(", "cosA", ",", "sinA", ")", ";", "multiply", "(", "temp", ")", ";", "shift", "(", "rotationCenter", ".", "x", ",", "rotationCenter", ".", "y", ")", ";", "}"], "docstring": "Sets this transformation to be a rotation around point rotationCenter.\n\nWhen the axis Y is directed up and X is directed to the right, the\npositive angle corresponds to the anti-clockwise rotation. When the axis\nY is directed down and X is directed to the right, the positive angle\ncorresponds to the clockwise rotation.\n\n@param cosA\nThe cos of the rotation angle.\n@param sinA\nThe sin of the rotation angle.\n@param rotationCenter\nThe center point of the rotation.", "docstring_tokens": ["Sets", "this", "transformation", "to", "be", "a", "rotation", "around", "point", "rotationCenter", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L752-L758", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.scale", "original_string": "public void scale(double x, double y) {\n\t\txx *= x;\n\t\txy *= x;\n\t\txd *= x;\n\t\tyx *= y;\n\t\tyy *= y;\n\t\tyd *= y;\n\t}", "language": "java", "code": "public void scale(double x, double y) {\n\t\txx *= x;\n\t\txy *= x;\n\t\txd *= x;\n\t\tyx *= y;\n\t\tyy *= y;\n\t\tyd *= y;\n\t}", "code_tokens": ["public", "void", "scale", "(", "double", "x", ",", "double", "y", ")", "{", "xx", "*=", "x", ";", "xy", "*=", "x", ";", "xd", "*=", "x", ";", "yx", "*=", "y", ";", "yy", "*=", "y", ";", "yd", "*=", "y", ";", "}"], "docstring": "Scales the transformation.\n\n@param x\nThe scale factor in X direction.\n@param y\nThe scale factor in Y direction.", "docstring_tokens": ["Scales", "the", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L781-L788", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.flipX", "original_string": "public void flipX(double x0, double x1) {\n\t\txx = -xx;\n\t\txy = -xy;\n\t\txd = x0 + x1 - xd;\n\t}", "language": "java", "code": "public void flipX(double x0, double x1) {\n\t\txx = -xx;\n\t\txy = -xy;\n\t\txd = x0 + x1 - xd;\n\t}", "code_tokens": ["public", "void", "flipX", "(", "double", "x0", ",", "double", "x1", ")", "{", "xx", "=", "-", "xx", ";", "xy", "=", "-", "xy", ";", "xd", "=", "x0", "+", "x1", "-", "xd", ";", "}"], "docstring": "Flips the transformation around the X axis.\n\n@param x0\nThe X coordinate to flip.\n@param x1\nThe X coordinate to flip to.", "docstring_tokens": ["Flips", "the", "transformation", "around", "the", "X", "axis", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L798-L802", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.flipY", "original_string": "public void flipY(double y0, double y1) {\n\t\tyx = -yx;\n\t\tyy = -yy;\n\t\tyd = y0 + y1 - yd;\n\t}", "language": "java", "code": "public void flipY(double y0, double y1) {\n\t\tyx = -yx;\n\t\tyy = -yy;\n\t\tyd = y0 + y1 - yd;\n\t}", "code_tokens": ["public", "void", "flipY", "(", "double", "y0", ",", "double", "y1", ")", "{", "yx", "=", "-", "yx", ";", "yy", "=", "-", "yy", ";", "yd", "=", "y0", "+", "y1", "-", "yd", ";", "}"], "docstring": "Flips the transformation around the Y axis.\n\n@param y0\nThe Y coordinate to flip.\n@param y1\nThe Y coordinate to flip to.", "docstring_tokens": ["Flips", "the", "transformation", "around", "the", "Y", "axis", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L812-L816", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.shear", "original_string": "public void shear(double proportionX, double proportionY) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setShear(proportionX, proportionY);\n\t\tmultiply(temp);\n\t}", "language": "java", "code": "public void shear(double proportionX, double proportionY) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setShear(proportionX, proportionY);\n\t\tmultiply(temp);\n\t}", "code_tokens": ["public", "void", "shear", "(", "double", "proportionX", ",", "double", "proportionY", ")", "{", "Transformation2D", "temp", "=", "new", "Transformation2D", "(", ")", ";", "temp", ".", "setShear", "(", "proportionX", ",", "proportionY", ")", ";", "multiply", "(", "temp", ")", ";", "}"], "docstring": "Shears the transformation.\n\n@param proportionX\nThe proportion of shearing in x direction.\n@param proportionY\nThe proportion of shearing in y direction.", "docstring_tokens": ["Shears", "the", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L826-L830", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.rotate", "original_string": "public void rotate(double angle_in_Radians) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(angle_in_Radians);\n\t\tmultiply(temp);\n\t}", "language": "java", "code": "public void rotate(double angle_in_Radians) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(angle_in_Radians);\n\t\tmultiply(temp);\n\t}", "code_tokens": ["public", "void", "rotate", "(", "double", "angle_in_Radians", ")", "{", "Transformation2D", "temp", "=", "new", "Transformation2D", "(", ")", ";", "temp", ".", "setRotate", "(", "angle_in_Radians", ")", ";", "multiply", "(", "temp", ")", ";", "}"], "docstring": "Rotates the transformation.\n\n@param angle_in_Radians\nThe rotation angle in radian.", "docstring_tokens": ["Rotates", "the", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L838-L842", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.rotate", "original_string": "public void rotate(double cos, double sin) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(cos, sin);\n\t\tmultiply(temp);\n\t}", "language": "java", "code": "public void rotate(double cos, double sin) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(cos, sin);\n\t\tmultiply(temp);\n\t}", "code_tokens": ["public", "void", "rotate", "(", "double", "cos", ",", "double", "sin", ")", "{", "Transformation2D", "temp", "=", "new", "Transformation2D", "(", ")", ";", "temp", ".", "setRotate", "(", "cos", ",", "sin", ")", ";", "multiply", "(", "temp", ")", ";", "}"], "docstring": "Rotates the transformation.\n\n@param cos\nThe cos angle of the rotation.\n@param sin\nThe sin angle of the rotation.", "docstring_tokens": ["Rotates", "the", "transformation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L852-L856", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.rotate", "original_string": "public void rotate(double cos, double sin, Point2D rotationCenter) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(cos, sin, rotationCenter);\n\t\tmultiply(temp);\n\t}", "language": "java", "code": "public void rotate(double cos, double sin, Point2D rotationCenter) {\n\t\tTransformation2D temp = new Transformation2D();\n\t\ttemp.setRotate(cos, sin, rotationCenter);\n\t\tmultiply(temp);\n\t}", "code_tokens": ["public", "void", "rotate", "(", "double", "cos", ",", "double", "sin", ",", "Point2D", "rotationCenter", ")", "{", "Transformation2D", "temp", "=", "new", "Transformation2D", "(", ")", ";", "temp", ".", "setRotate", "(", "cos", ",", "sin", ",", "rotationCenter", ")", ";", "multiply", "(", "temp", ")", ";", "}"], "docstring": "Rotates the transformation aroung a center point.\n\n@param cos\nThe cos angle of the rotation.\n@param sin\nsin angle of the rotation.\n@param rotationCenter\nThe center point of the rotation.", "docstring_tokens": ["Rotates", "the", "transformation", "aroung", "a", "center", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L868-L872", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.inverse", "original_string": "public void inverse(Transformation2D inverse) {\n\t\tdouble det = xx * yy - xy * yx;\n\n\t\tif (det == 0) {\n\t\t\tinverse.setZero();\n\t\t\treturn;\n\t\t}\n\n\t\tdet = 1 / det;\n\n\t\tinverse.xd = (xy * yd - xd * yy) * det;\n\t\tinverse.yd = (xd * yx - xx * yd) * det;\n\t\tinverse.xx = yy * det;\n\t\tinverse.xy = -xy * det;\n\t\tinverse.yx = -yx * det;\n\t\tinverse.yy = xx * det;\n\t}", "language": "java", "code": "public void inverse(Transformation2D inverse) {\n\t\tdouble det = xx * yy - xy * yx;\n\n\t\tif (det == 0) {\n\t\t\tinverse.setZero();\n\t\t\treturn;\n\t\t}\n\n\t\tdet = 1 / det;\n\n\t\tinverse.xd = (xy * yd - xd * yy) * det;\n\t\tinverse.yd = (xd * yx - xx * yd) * det;\n\t\tinverse.xx = yy * det;\n\t\tinverse.xy = -xy * det;\n\t\tinverse.yx = -yx * det;\n\t\tinverse.yy = xx * det;\n\t}", "code_tokens": ["public", "void", "inverse", "(", "Transformation2D", "inverse", ")", "{", "double", "det", "=", "xx", "*", "yy", "-", "xy", "*", "yx", ";", "if", "(", "det", "==", "0", ")", "{", "inverse", ".", "setZero", "(", ")", ";", "return", ";", "}", "det", "=", "1", "/", "det", ";", "inverse", ".", "xd", "=", "(", "xy", "*", "yd", "-", "xd", "*", "yy", ")", "*", "det", ";", "inverse", ".", "yd", "=", "(", "xd", "*", "yx", "-", "xx", "*", "yd", ")", "*", "det", ";", "inverse", ".", "xx", "=", "yy", "*", "det", ";", "inverse", ".", "xy", "=", "-", "xy", "*", "det", ";", "inverse", ".", "yx", "=", "-", "yx", "*", "det", ";", "inverse", ".", "yy", "=", "xx", "*", "det", ";", "}"], "docstring": "Produces inverse matrix for this matrix and puts result into the inverse\nparameter.\n\n@param inverse\nThe result inverse matrix.", "docstring_tokens": ["Produces", "inverse", "matrix", "for", "this", "matrix", "and", "puts", "result", "into", "the", "inverse", "parameter", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L881-L897", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Transformation2D.java", "func_name": "Transformation2D.extractScaleTransform", "original_string": "public void extractScaleTransform(Transformation2D scale,\n\t\t\tTransformation2D rotateNshearNshift) {\n\n\t\tscale.setScale(Math.sqrt(xx * xx + xy * xy),\n\t\t\t\tMath.sqrt(yx * yx + yy * yy));\n\t\trotateNshearNshift.setScale(1.0 / scale.xx, 1.0 / scale.yy);\n\t\trotateNshearNshift.multiply(this);\n\t}", "language": "java", "code": "public void extractScaleTransform(Transformation2D scale,\n\t\t\tTransformation2D rotateNshearNshift) {\n\n\t\tscale.setScale(Math.sqrt(xx * xx + xy * xy),\n\t\t\t\tMath.sqrt(yx * yx + yy * yy));\n\t\trotateNshearNshift.setScale(1.0 / scale.xx, 1.0 / scale.yy);\n\t\trotateNshearNshift.multiply(this);\n\t}", "code_tokens": ["public", "void", "extractScaleTransform", "(", "Transformation2D", "scale", ",", "Transformation2D", "rotateNshearNshift", ")", "{", "scale", ".", "setScale", "(", "Math", ".", "sqrt", "(", "xx", "*", "xx", "+", "xy", "*", "xy", ")", ",", "Math", ".", "sqrt", "(", "yx", "*", "yx", "+", "yy", "*", "yy", ")", ")", ";", "rotateNshearNshift", ".", "setScale", "(", "1.0", "/", "scale", ".", "xx", ",", "1.0", "/", "scale", ".", "yy", ")", ";", "rotateNshearNshift", ".", "multiply", "(", "this", ")", ";", "}"], "docstring": "Extracts scaling part of the transformation. this == scale *\nrotateNshearNshift.\n\n@param scale\nThe destination matrix where the scale part is copied.\n@param rotateNshearNshift\nThe destination matrix where the part excluding rotation is\ncopied.", "docstring_tokens": ["Extracts", "scaling", "part", "of", "the", "transformation", ".", "this", "==", "scale", "*", "rotateNshearNshift", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Transformation2D.java#L917-L924", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MathUtils.java", "func_name": "MathUtils.copySign", "original_string": "static double copySign(double x, double y) {\n\t\treturn y >= 0.0 ? Math.abs(x) : -Math.abs(x);\n\t}", "language": "java", "code": "static double copySign(double x, double y) {\n\t\treturn y >= 0.0 ? Math.abs(x) : -Math.abs(x);\n\t}", "code_tokens": ["static", "double", "copySign", "(", "double", "x", ",", "double", "y", ")", "{", "return", "y", ">=", "0.0", "?", "Math", ".", "abs", "(", "x", ")", ":", "-", "Math", ".", "abs", "(", "x", ")", ";", "}"], "docstring": "Returns one value with the sign of another (like copysign).", "docstring_tokens": ["Returns", "one", "value", "with", "the", "sign", "of", "another", "(", "like", "copysign", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MathUtils.java#L127-L129", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MathUtils.java", "func_name": "MathUtils.lerp", "original_string": "static double lerp(double start_, double end_, double t) {\n\t\t// When end == start, we want result to be equal to start, for all t\n\t\t// values. At the same time, when end != start, we want the result to be\n\t\t// equal to start for t==0 and end for t == 1.0\n\t\t// The regular formula end_ * t + (1.0 - t) * start_, when end_ ==\n\t\t// start_, and t at 1/3, produces value different from start\n\t\tdouble v;\n\t\tif (t <= 0.5)\n\t\t\tv = start_ + (end_ - start_) * t;\n\t\telse\n\t\t\tv = end_ - (end_ - start_) * (1.0 - t);\n\n\t\tassert (t < 0 || t > 1.0 || (v >= start_ && v <= end_) || (v <= start_ && v >= end_) || NumberUtils.isNaN(start_) || NumberUtils.isNaN(end_));\n\t\treturn v;\n\t}", "language": "java", "code": "static double lerp(double start_, double end_, double t) {\n\t\t// When end == start, we want result to be equal to start, for all t\n\t\t// values. At the same time, when end != start, we want the result to be\n\t\t// equal to start for t==0 and end for t == 1.0\n\t\t// The regular formula end_ * t + (1.0 - t) * start_, when end_ ==\n\t\t// start_, and t at 1/3, produces value different from start\n\t\tdouble v;\n\t\tif (t <= 0.5)\n\t\t\tv = start_ + (end_ - start_) * t;\n\t\telse\n\t\t\tv = end_ - (end_ - start_) * (1.0 - t);\n\n\t\tassert (t < 0 || t > 1.0 || (v >= start_ && v <= end_) || (v <= start_ && v >= end_) || NumberUtils.isNaN(start_) || NumberUtils.isNaN(end_));\n\t\treturn v;\n\t}", "code_tokens": ["static", "double", "lerp", "(", "double", "start_", ",", "double", "end_", ",", "double", "t", ")", "{", "// When end == start, we want result to be equal to start, for all t", "// values. At the same time, when end != start, we want the result to be", "// equal to start for t==0 and end for t == 1.0", "// The regular formula end_ * t + (1.0 - t) * start_, when end_ ==", "// start_, and t at 1/3, produces value different from start", "double", "v", ";", "if", "(", "t", "<=", "0.5", ")", "v", "=", "start_", "+", "(", "end_", "-", "start_", ")", "*", "t", ";", "else", "v", "=", "end_", "-", "(", "end_", "-", "start_", ")", "*", "(", "1.0", "-", "t", ")", ";", "assert", "(", "t", "<", "0", "||", "t", ">", "1.0", "||", "(", "v", ">=", "start_", "&&", "v", "<=", "end_", ")", "||", "(", "v", "<=", "start_", "&&", "v", ">=", "end_", ")", "||", "NumberUtils", ".", "isNaN", "(", "start_", ")", "||", "NumberUtils", ".", "isNaN", "(", "end_", ")", ")", ";", "return", "v", ";", "}"], "docstring": "Computes interpolation between two values, using the interpolation factor t.\nThe interpolation formula is (end - start) * t + start.\nHowever, the computation ensures that t = 0 produces exactly start, and t = 1, produces exactly end.\nIt also guarantees that for 0 <= t <= 1, the interpolated value v is between start and end.", "docstring_tokens": ["Computes", "interpolation", "between", "two", "values", "using", "the", "interpolation", "factor", "t", ".", "The", "interpolation", "formula", "is", "(", "end", "-", "start", ")", "*", "t", "+", "start", ".", "However", "the", "computation", "ensures", "that", "t", "=", "0", "produces", "exactly", "start", "and", "t", "=", "1", "produces", "exactly", "end", ".", "It", "also", "guarantees", "that", "for", "0", "<", "=", "t", "<", "=", "1", "the", "interpolated", "value", "v", "is", "between", "start", "and", "end", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MathUtils.java#L174-L188", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MathUtils.java", "func_name": "MathUtils.lerp", "original_string": "static void lerp(Point2D start_, Point2D end_, double t, Point2D result) {\n\t\tassert(start_ != result);\n\t\t// When end == start, we want result to be equal to start, for all t\n\t\t// values. At the same time, when end != start, we want the result to be\n\t\t// equal to start for t==0 and end for t == 1.0\n\t\t// The regular formula end_ * t + (1.0 - t) * start_, when end_ ==\n\t\t// start_, and t at 1/3, produces value different from start\n\t\tdouble rx, ry;\n\t\tif (t <= 0.5) {\n\t\t\trx = start_.x + (end_.x - start_.x) * t;\n\t\t\try = start_.y + (end_.y - start_.y) * t;\n\t\t}\n\t\telse {\n\t\t\trx = end_.x - (end_.x - start_.x) * (1.0 - t);\n\t\t\try = end_.y - (end_.y - start_.y) * (1.0 - t);\n\t\t}\n\n\t\tassert (t < 0 || t > 1.0 || (rx >= start_.x && rx <= end_.x) || (rx <= start_.x && rx >= end_.x));\n\t\tassert (t < 0 || t > 1.0 || (ry >= start_.y && ry <= end_.y) || (ry <= start_.y && ry >= end_.y));\n\t\tresult.x = rx;\n\t\tresult.y = ry;\n\t}", "language": "java", "code": "static void lerp(Point2D start_, Point2D end_, double t, Point2D result) {\n\t\tassert(start_ != result);\n\t\t// When end == start, we want result to be equal to start, for all t\n\t\t// values. At the same time, when end != start, we want the result to be\n\t\t// equal to start for t==0 and end for t == 1.0\n\t\t// The regular formula end_ * t + (1.0 - t) * start_, when end_ ==\n\t\t// start_, and t at 1/3, produces value different from start\n\t\tdouble rx, ry;\n\t\tif (t <= 0.5) {\n\t\t\trx = start_.x + (end_.x - start_.x) * t;\n\t\t\try = start_.y + (end_.y - start_.y) * t;\n\t\t}\n\t\telse {\n\t\t\trx = end_.x - (end_.x - start_.x) * (1.0 - t);\n\t\t\try = end_.y - (end_.y - start_.y) * (1.0 - t);\n\t\t}\n\n\t\tassert (t < 0 || t > 1.0 || (rx >= start_.x && rx <= end_.x) || (rx <= start_.x && rx >= end_.x));\n\t\tassert (t < 0 || t > 1.0 || (ry >= start_.y && ry <= end_.y) || (ry <= start_.y && ry >= end_.y));\n\t\tresult.x = rx;\n\t\tresult.y = ry;\n\t}", "code_tokens": ["static", "void", "lerp", "(", "Point2D", "start_", ",", "Point2D", "end_", ",", "double", "t", ",", "Point2D", "result", ")", "{", "assert", "(", "start_", "!=", "result", ")", ";", "// When end == start, we want result to be equal to start, for all t", "// values. At the same time, when end != start, we want the result to be", "// equal to start for t==0 and end for t == 1.0", "// The regular formula end_ * t + (1.0 - t) * start_, when end_ ==", "// start_, and t at 1/3, produces value different from start", "double", "rx", ",", "ry", ";", "if", "(", "t", "<=", "0.5", ")", "{", "rx", "=", "start_", ".", "x", "+", "(", "end_", ".", "x", "-", "start_", ".", "x", ")", "*", "t", ";", "ry", "=", "start_", ".", "y", "+", "(", "end_", ".", "y", "-", "start_", ".", "y", ")", "*", "t", ";", "}", "else", "{", "rx", "=", "end_", ".", "x", "-", "(", "end_", ".", "x", "-", "start_", ".", "x", ")", "*", "(", "1.0", "-", "t", ")", ";", "ry", "=", "end_", ".", "y", "-", "(", "end_", ".", "y", "-", "start_", ".", "y", ")", "*", "(", "1.0", "-", "t", ")", ";", "}", "assert", "(", "t", "<", "0", "||", "t", ">", "1.0", "||", "(", "rx", ">=", "start_", ".", "x", "&&", "rx", "<=", "end_", ".", "x", ")", "||", "(", "rx", "<=", "start_", ".", "x", "&&", "rx", ">=", "end_", ".", "x", ")", ")", ";", "assert", "(", "t", "<", "0", "||", "t", ">", "1.0", "||", "(", "ry", ">=", "start_", ".", "y", "&&", "ry", "<=", "end_", ".", "y", ")", "||", "(", "ry", "<=", "start_", ".", "y", "&&", "ry", ">=", "end_", ".", "y", ")", ")", ";", "result", ".", "x", "=", "rx", ";", "result", ".", "y", "=", "ry", ";", "}"], "docstring": "Computes interpolation between two values, using the interpolation factor t.\nThe interpolation formula is (end - start) * t + start.\nHowever, the computation ensures that t = 0 produces exactly start, and t = 1, produces exactly end.\nIt also guarantees that for 0 <= t <= 1, the interpolated value v is between start and end.", "docstring_tokens": ["Computes", "interpolation", "between", "two", "values", "using", "the", "interpolation", "factor", "t", ".", "The", "interpolation", "formula", "is", "(", "end", "-", "start", ")", "*", "t", "+", "start", ".", "However", "the", "computation", "ensures", "that", "t", "=", "0", "produces", "exactly", "start", "and", "t", "=", "1", "produces", "exactly", "end", ".", "It", "also", "guarantees", "that", "for", "0", "<", "=", "t", "<", "=", "1", "the", "interpolated", "value", "v", "is", "between", "start", "and", "end", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MathUtils.java#L196-L217", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PointInPolygonHelper.java", "func_name": "PointInPolygonHelper._isRingInRing2D", "original_string": "static boolean _isRingInRing2D(MultiPath polygon, int iRing1, int iRing2,\n\t\t\tdouble tolerance, QuadTree quadTree) {\n\t\tMultiPathImpl polygonImpl = (MultiPathImpl) polygon._getImpl();\n\t\tSegmentIteratorImpl segIter = polygonImpl.querySegmentIterator();\n\t\tsegIter.resetToPath(iRing1);\n\t\tif (!segIter.nextPath() || !segIter.hasNextSegment())\n\t\t\tthrow new GeometryException(\"corrupted geometry\");\n\n\t\tint res = 2;\n\n\t\twhile (res == 2 && segIter.hasNextSegment()) {\n\t\t\tSegment segment = segIter.nextSegment();\n\t\t\tPoint2D point = segment.getCoord2D(0.5);\n\t\t\tres = PointInPolygonHelper.isPointInRing(polygonImpl, iRing2,\n\t\t\t\t\tpoint, tolerance, quadTree);\n\t\t}\n\n\t\tif (res == 2)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\tif (res == 1)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "static boolean _isRingInRing2D(MultiPath polygon, int iRing1, int iRing2,\n\t\t\tdouble tolerance, QuadTree quadTree) {\n\t\tMultiPathImpl polygonImpl = (MultiPathImpl) polygon._getImpl();\n\t\tSegmentIteratorImpl segIter = polygonImpl.querySegmentIterator();\n\t\tsegIter.resetToPath(iRing1);\n\t\tif (!segIter.nextPath() || !segIter.hasNextSegment())\n\t\t\tthrow new GeometryException(\"corrupted geometry\");\n\n\t\tint res = 2;\n\n\t\twhile (res == 2 && segIter.hasNextSegment()) {\n\t\t\tSegment segment = segIter.nextSegment();\n\t\t\tPoint2D point = segment.getCoord2D(0.5);\n\t\t\tres = PointInPolygonHelper.isPointInRing(polygonImpl, iRing2,\n\t\t\t\t\tpoint, tolerance, quadTree);\n\t\t}\n\n\t\tif (res == 2)\n\t\t\tthrow GeometryException.GeometryInternalError();\n\t\tif (res == 1)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["static", "boolean", "_isRingInRing2D", "(", "MultiPath", "polygon", ",", "int", "iRing1", ",", "int", "iRing2", ",", "double", "tolerance", ",", "QuadTree", "quadTree", ")", "{", "MultiPathImpl", "polygonImpl", "=", "(", "MultiPathImpl", ")", "polygon", ".", "_getImpl", "(", ")", ";", "SegmentIteratorImpl", "segIter", "=", "polygonImpl", ".", "querySegmentIterator", "(", ")", ";", "segIter", ".", "resetToPath", "(", "iRing1", ")", ";", "if", "(", "!", "segIter", ".", "nextPath", "(", ")", "||", "!", "segIter", ".", "hasNextSegment", "(", ")", ")", "throw", "new", "GeometryException", "(", "\"corrupted geometry\"", ")", ";", "int", "res", "=", "2", ";", "while", "(", "res", "==", "2", "&&", "segIter", ".", "hasNextSegment", "(", ")", ")", "{", "Segment", "segment", "=", "segIter", ".", "nextSegment", "(", ")", ";", "Point2D", "point", "=", "segment", ".", "getCoord2D", "(", "0.5", ")", ";", "res", "=", "PointInPolygonHelper", ".", "isPointInRing", "(", "polygonImpl", ",", "iRing2", ",", "point", ",", "tolerance", ",", "quadTree", ")", ";", "}", "if", "(", "res", "==", "2", ")", "throw", "GeometryException", ".", "GeometryInternalError", "(", ")", ";", "if", "(", "res", "==", "1", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "we assume that all of Ring1 is inside Ring2.", "docstring_tokens": ["we", "assume", "that", "all", "of", "Ring1", "is", "inside", "Ring2", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PointInPolygonHelper.java#L394-L417", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.add", "original_string": "public void add(MultiPath src, boolean bReversePaths) {\n\t\tm_impl.add((MultiPathImpl) src._getImpl(), bReversePaths);\n\t}", "language": "java", "code": "public void add(MultiPath src, boolean bReversePaths) {\n\t\tm_impl.add((MultiPathImpl) src._getImpl(), bReversePaths);\n\t}", "code_tokens": ["public", "void", "add", "(", "MultiPath", "src", ",", "boolean", "bReversePaths", ")", "{", "m_impl", ".", "add", "(", "(", "MultiPathImpl", ")", "src", ".", "_getImpl", "(", ")", ",", "bReversePaths", ")", ";", "}"], "docstring": "Appends all paths from another multipath.\n\n@param src\nThe multipath to append to this multipath.\n@param bReversePaths\nTRUE if the multipath is added should be added with its paths\nreversed.", "docstring_tokens": ["Appends", "all", "paths", "from", "another", "multipath", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L248-L250", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.addPath", "original_string": "public void addPath(MultiPath src, int srcPathIndex, boolean bForward) {\n\t\tm_impl.addPath((MultiPathImpl) src._getImpl(), srcPathIndex, bForward);\n\t}", "language": "java", "code": "public void addPath(MultiPath src, int srcPathIndex, boolean bForward) {\n\t\tm_impl.addPath((MultiPathImpl) src._getImpl(), srcPathIndex, bForward);\n\t}", "code_tokens": ["public", "void", "addPath", "(", "MultiPath", "src", ",", "int", "srcPathIndex", ",", "boolean", "bForward", ")", "{", "m_impl", ".", "addPath", "(", "(", "MultiPathImpl", ")", "src", ".", "_getImpl", "(", ")", ",", "srcPathIndex", ",", "bForward", ")", ";", "}"], "docstring": "Copies a path from another multipath.\n\n@param src\nThe multipath to copy from.\n@param srcPathIndex\nThe index of the path in the the source MultiPath.\n@param bForward\nWhen FALSE, the points are inserted in reverse order.", "docstring_tokens": ["Copies", "a", "path", "from", "another", "multipath", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L262-L264", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.addPath", "original_string": "void addPath(Point2D[] points, int count, boolean bForward) {\n\t\tm_impl.addPath(points, count, bForward);\n\t}", "language": "java", "code": "void addPath(Point2D[] points, int count, boolean bForward) {\n\t\tm_impl.addPath(points, count, bForward);\n\t}", "code_tokens": ["void", "addPath", "(", "Point2D", "[", "]", "points", ",", "int", "count", ",", "boolean", "bForward", ")", "{", "m_impl", ".", "addPath", "(", "points", ",", "count", ",", "bForward", ")", ";", "}"], "docstring": "Adds a new path to this multipath.\n\n@param points\nThe array of points to add to this multipath.\n@param count\nThe number of points added to the mulitpath.\n@param bForward\nWhen FALSE, the points are inserted in reverse order.", "docstring_tokens": ["Adds", "a", "new", "path", "to", "this", "multipath", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L276-L278", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.addSegmentsFromPath", "original_string": "public void addSegmentsFromPath(MultiPath src, int srcPathIndex,\n\t\t\tint srcSegmentFrom, int srcSegmentCount, boolean bStartNewPath) {\n\t\tm_impl.addSegmentsFromPath((MultiPathImpl) src._getImpl(),\n\t\t\t\tsrcPathIndex, srcSegmentFrom, srcSegmentCount, bStartNewPath);\n\t}", "language": "java", "code": "public void addSegmentsFromPath(MultiPath src, int srcPathIndex,\n\t\t\tint srcSegmentFrom, int srcSegmentCount, boolean bStartNewPath) {\n\t\tm_impl.addSegmentsFromPath((MultiPathImpl) src._getImpl(),\n\t\t\t\tsrcPathIndex, srcSegmentFrom, srcSegmentCount, bStartNewPath);\n\t}", "code_tokens": ["public", "void", "addSegmentsFromPath", "(", "MultiPath", "src", ",", "int", "srcPathIndex", ",", "int", "srcSegmentFrom", ",", "int", "srcSegmentCount", ",", "boolean", "bStartNewPath", ")", "{", "m_impl", ".", "addSegmentsFromPath", "(", "(", "MultiPathImpl", ")", "src", ".", "_getImpl", "(", ")", ",", "srcPathIndex", ",", "srcSegmentFrom", ",", "srcSegmentCount", ",", "bStartNewPath", ")", ";", "}"], "docstring": "Adds segments from a source multipath to this MultiPath.\n\n@param src\nThe source MultiPath to add segments from.\n@param srcPathIndex\nThe index of the path in the the source MultiPath.\n@param srcSegmentFrom\nThe index of first segment in the path to start adding from.\nThe value has to be between 0 and\nsrc.getSegmentCount(srcPathIndex) - 1.\n@param srcSegmentCount\nThe number of segments to add. If 0, the function does\nnothing.\n@param bStartNewPath\nWhen true, a new path is added and segments are added to it.\nOtherwise the segments are added to the last path of this\nMultiPath.\n\nIf bStartNewPath false, the first point of the first source\nsegment is not added. This is done to ensure proper connection\nto existing segments. When the source path is closed, and the\nclosing segment is among those to be added, it is added also\nas a closing segment, not as a real segment. Use add_segment\ninstead if you do not like that behavior.\n\nThis MultiPath obtains all missing attributes from the src\nMultiPath.", "docstring_tokens": ["Adds", "segments", "from", "a", "source", "multipath", "to", "this", "MultiPath", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L309-L313", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.insertPath", "original_string": "public void insertPath(int pathIndex, MultiPath src, int srcPathIndex,\n\t\t\tboolean bForward) {\n\t\tm_impl.insertPath(pathIndex, (MultiPathImpl) src._getImpl(),\n\t\t\t\tsrcPathIndex, bForward);\n\t}", "language": "java", "code": "public void insertPath(int pathIndex, MultiPath src, int srcPathIndex,\n\t\t\tboolean bForward) {\n\t\tm_impl.insertPath(pathIndex, (MultiPathImpl) src._getImpl(),\n\t\t\t\tsrcPathIndex, bForward);\n\t}", "code_tokens": ["public", "void", "insertPath", "(", "int", "pathIndex", ",", "MultiPath", "src", ",", "int", "srcPathIndex", ",", "boolean", "bForward", ")", "{", "m_impl", ".", "insertPath", "(", "pathIndex", ",", "(", "MultiPathImpl", ")", "src", ".", "_getImpl", "(", ")", ",", "srcPathIndex", ",", "bForward", ")", ";", "}"], "docstring": "Inserts a path from another multipath.\n\n@param pathIndex\nThe start index of the multipath to insert.\n@param src\nThe multipath to insert into this multipath. Can be the same\nas the multipath being modified.\n@param srcPathIndex\nThe start index to insert the path into the multipath.\n@param bForward\nWhen FALSE, the points are inserted in reverse order.", "docstring_tokens": ["Inserts", "a", "path", "from", "another", "multipath", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L367-L371", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.insertPath", "original_string": "void insertPath(int pathIndex, Point2D[] points, int pointsOffset,\n\t\t\tint count, boolean bForward) {\n\t\tm_impl.insertPath(pathIndex, points, pointsOffset, count, bForward);\n\t}", "language": "java", "code": "void insertPath(int pathIndex, Point2D[] points, int pointsOffset,\n\t\t\tint count, boolean bForward) {\n\t\tm_impl.insertPath(pathIndex, points, pointsOffset, count, bForward);\n\t}", "code_tokens": ["void", "insertPath", "(", "int", "pathIndex", ",", "Point2D", "[", "]", "points", ",", "int", "pointsOffset", ",", "int", "count", ",", "boolean", "bForward", ")", "{", "m_impl", ".", "insertPath", "(", "pathIndex", ",", "points", ",", "pointsOffset", ",", "count", ",", "bForward", ")", ";", "}"], "docstring": "Inserts a path from an array of 2D Points.\n\n@param pathIndex\nThe path index of the multipath to place the new path.\n@param points\nThe array of points defining the new path.\n@param pointsOffset\nThe offset into the array to start reading.\n@param count\nThe number of points to insert into the new path.\n@param bForward\nWhen FALSE, the points are inserted in reverse order.", "docstring_tokens": ["Inserts", "a", "path", "from", "an", "array", "of", "2D", "Points", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L387-L390", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.insertPoints", "original_string": "public void insertPoints(int pathIndex, int beforePointIndex,\n\t\t\tMultiPath src, int srcPathIndex, int srcPointIndexFrom,\n\t\t\tint srcPointCount, boolean bForward) {\n\t\tm_impl.insertPoints(pathIndex, beforePointIndex,\n\t\t\t\t(MultiPathImpl) src._getImpl(), srcPathIndex,\n\t\t\t\tsrcPointIndexFrom, srcPointCount, bForward);\n\t}", "language": "java", "code": "public void insertPoints(int pathIndex, int beforePointIndex,\n\t\t\tMultiPath src, int srcPathIndex, int srcPointIndexFrom,\n\t\t\tint srcPointCount, boolean bForward) {\n\t\tm_impl.insertPoints(pathIndex, beforePointIndex,\n\t\t\t\t(MultiPathImpl) src._getImpl(), srcPathIndex,\n\t\t\t\tsrcPointIndexFrom, srcPointCount, bForward);\n\t}", "code_tokens": ["public", "void", "insertPoints", "(", "int", "pathIndex", ",", "int", "beforePointIndex", ",", "MultiPath", "src", ",", "int", "srcPathIndex", ",", "int", "srcPointIndexFrom", ",", "int", "srcPointCount", ",", "boolean", "bForward", ")", "{", "m_impl", ".", "insertPoints", "(", "pathIndex", ",", "beforePointIndex", ",", "(", "MultiPathImpl", ")", "src", ".", "_getImpl", "(", ")", ",", "srcPathIndex", ",", "srcPointIndexFrom", ",", "srcPointCount", ",", "bForward", ")", ";", "}"], "docstring": "Inserts vertices from the given multipath into this multipath. All added\nvertices are connected by linear segments with each other and with the\nexisting vertices.\n\n@param pathIndex\nThe path index in this multipath to insert points to. Must\ncorrespond to an existing path.\n@param beforePointIndex\nThe point index before all other vertices to insert in the\ngiven path of this multipath. This value must be between 0 and\nGetPathSize(pathIndex), or -1 to insert points at the end of\nthe given path.\n@param src\nThe source multipath.\n@param srcPathIndex\nThe source path index to copy points from.\n@param srcPointIndexFrom\nThe start point in the source path to start copying from.\n@param srcPointCount\nThe count of points to add.\n@param bForward\nWhen FALSE, the points are inserted in reverse order.", "docstring_tokens": ["Inserts", "vertices", "from", "the", "given", "multipath", "into", "this", "multipath", ".", "All", "added", "vertices", "are", "connected", "by", "linear", "segments", "with", "each", "other", "and", "with", "the", "existing", "vertices", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L416-L422", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.insertPoints", "original_string": "void insertPoints(int pathIndex, int beforePointIndex, Point2D[] src,\n\t\t\tint srcPointIndexFrom, int srcPointCount, boolean bForward) {\n\t\tm_impl.insertPoints(pathIndex, beforePointIndex, src,\n\t\t\t\tsrcPointIndexFrom, srcPointCount, bForward);\n\t}", "language": "java", "code": "void insertPoints(int pathIndex, int beforePointIndex, Point2D[] src,\n\t\t\tint srcPointIndexFrom, int srcPointCount, boolean bForward) {\n\t\tm_impl.insertPoints(pathIndex, beforePointIndex, src,\n\t\t\t\tsrcPointIndexFrom, srcPointCount, bForward);\n\t}", "code_tokens": ["void", "insertPoints", "(", "int", "pathIndex", ",", "int", "beforePointIndex", ",", "Point2D", "[", "]", "src", ",", "int", "srcPointIndexFrom", ",", "int", "srcPointCount", ",", "boolean", "bForward", ")", "{", "m_impl", ".", "insertPoints", "(", "pathIndex", ",", "beforePointIndex", ",", "src", ",", "srcPointIndexFrom", ",", "srcPointCount", ",", "bForward", ")", ";", "}"], "docstring": "Inserts a part of a path from the given array.\n\n@param pathIndex\nThe path index in this class to insert points to. Must\ncorrespond to an existing path.\n@param beforePointIndex\nThe point index in the given path of this MultiPath before\nwhich the vertices need to be inserted. This value must be\nbetween 0 and GetPathSize(pathIndex), or -1 to insert points\nat the end of the given path.\n@param src\nThe source array\n@param srcPointIndexFrom\nThe start point in the source array to start copying from.\n@param srcPointCount\nThe count of points to add.\n@param bForward\nWhen FALSE, the points are inserted in reverse order.", "docstring_tokens": ["Inserts", "a", "part", "of", "a", "path", "from", "the", "given", "array", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L444-L448", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.insertPoint", "original_string": "void insertPoint(int pathIndex, int beforePointIndex, Point2D pt) {\n\t\tm_impl.insertPoint(pathIndex, beforePointIndex, pt);\n\t}", "language": "java", "code": "void insertPoint(int pathIndex, int beforePointIndex, Point2D pt) {\n\t\tm_impl.insertPoint(pathIndex, beforePointIndex, pt);\n\t}", "code_tokens": ["void", "insertPoint", "(", "int", "pathIndex", ",", "int", "beforePointIndex", ",", "Point2D", "pt", ")", "{", "m_impl", ".", "insertPoint", "(", "pathIndex", ",", "beforePointIndex", ",", "pt", ")", ";", "}"], "docstring": "Inserts a point.\n\n@param pathIndex\nThe path index in this class to insert the point to. Must\ncorrespond to an existing path.\n@param beforePointIndex\nThe point index in the given path of this multipath. This\nvalue must be between 0 and GetPathSize(pathIndex), or -1 to\ninsert the point at the end of the given path.\n@param pt\nThe point to be inserted.", "docstring_tokens": ["Inserts", "a", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L463-L465", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.insertPoint", "original_string": "public void insertPoint(int pathIndex, int beforePointIndex, Point pt) {\n\t\tm_impl.insertPoint(pathIndex, beforePointIndex, pt);\n\t}", "language": "java", "code": "public void insertPoint(int pathIndex, int beforePointIndex, Point pt) {\n\t\tm_impl.insertPoint(pathIndex, beforePointIndex, pt);\n\t}", "code_tokens": ["public", "void", "insertPoint", "(", "int", "pathIndex", ",", "int", "beforePointIndex", ",", "Point", "pt", ")", "{", "m_impl", ".", "insertPoint", "(", "pathIndex", ",", "beforePointIndex", ",", "pt", ")", ";", "}"], "docstring": "Inserts a point.\n\n@param pathIndex\nThe path index in this class to insert the point to. Must\ncorrespond to an existing path.\n@param beforePointIndex\nThe point index in the given path of this multipath. This\nvalue must be between 0 and GetPathSize(pathIndex), or -1 to\ninsert the point at the end of the given path.\n@param pt\nThe point to be inserted.", "docstring_tokens": ["Inserts", "a", "point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L480-L482", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiPath.java", "func_name": "MultiPath.bezierTo", "original_string": "void bezierTo(Point2D controlPoint1, Point2D controlPoint2, Point2D endPoint) {\n\t\tm_impl.bezierTo(controlPoint1, controlPoint2, endPoint);\n\t}", "language": "java", "code": "void bezierTo(Point2D controlPoint1, Point2D controlPoint2, Point2D endPoint) {\n\t\tm_impl.bezierTo(controlPoint1, controlPoint2, endPoint);\n\t}", "code_tokens": ["void", "bezierTo", "(", "Point2D", "controlPoint1", ",", "Point2D", "controlPoint2", ",", "Point2D", "endPoint", ")", "{", "m_impl", ".", "bezierTo", "(", "controlPoint1", ",", "controlPoint2", ",", "endPoint", ")", ";", "}"], "docstring": "Adds a Cubic Bezier Segment to the current Path. The Bezier Segment\nconnects the current last Point and the given endPoint.", "docstring_tokens": ["Adds", "a", "Cubic", "Bezier", "Segment", "to", "the", "current", "Path", ".", "The", "Bezier", "Segment", "connects", "the", "current", "last", "Point", "and", "the", "given", "endPoint", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiPath.java#L615-L617", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/VertexDescription.java", "func_name": "VertexDescription.isDefaultValue", "original_string": "public static boolean isDefaultValue(int semantics, double v) {\n\t\treturn NumberUtils.doubleToInt64Bits(_defaultValues[semantics]) == NumberUtils\n\t\t\t\t.doubleToInt64Bits(v);\n\t}", "language": "java", "code": "public static boolean isDefaultValue(int semantics, double v) {\n\t\treturn NumberUtils.doubleToInt64Bits(_defaultValues[semantics]) == NumberUtils\n\t\t\t\t.doubleToInt64Bits(v);\n\t}", "code_tokens": ["public", "static", "boolean", "isDefaultValue", "(", "int", "semantics", ",", "double", "v", ")", "{", "return", "NumberUtils", ".", "doubleToInt64Bits", "(", "_defaultValues", "[", "semantics", "]", ")", "==", "NumberUtils", ".", "doubleToInt64Bits", "(", "v", ")", ";", "}"], "docstring": "Checks if the given value is the default one. The simple equality test\nwith GetDefaultValue does not work due to the use of NaNs as default\nvalue for some parameters.", "docstring_tokens": ["Checks", "if", "the", "given", "value", "is", "the", "default", "one", ".", "The", "simple", "equality", "test", "with", "GetDefaultValue", "does", "not", "work", "due", "to", "the", "use", "of", "NaNs", "as", "default", "value", "for", "some", "parameters", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/VertexDescription.java#L257-L260", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.createTreap", "original_string": "public int createTreap(int treap_data) {\n\t\tint treap = m_treapData.newElement();\n\t\tsetSize_(0, treap);\n\t\tsetTreapData_(treap_data, treap);\n\t\treturn treap;\n\t}", "language": "java", "code": "public int createTreap(int treap_data) {\n\t\tint treap = m_treapData.newElement();\n\t\tsetSize_(0, treap);\n\t\tsetTreapData_(treap_data, treap);\n\t\treturn treap;\n\t}", "code_tokens": ["public", "int", "createTreap", "(", "int", "treap_data", ")", "{", "int", "treap", "=", "m_treapData", ".", "newElement", "(", ")", ";", "setSize_", "(", "0", ",", "treap", ")", ";", "setTreapData_", "(", "treap_data", ",", "treap", ")", ";", "return", "treap", ";", "}"], "docstring": "Create a new treap and returns the treap handle.", "docstring_tokens": ["Create", "a", "new", "treap", "and", "returns", "the", "treap", "handle", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L115-L120", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.addElement", "original_string": "public int addElement(int element, int treap) {\n\t\tint treap_;\n\t\tif (treap == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t} else {\n\t\t\ttreap_ = treap;\n\t\t}\n\n\t\treturn addElement_(element, 0, treap_);\n\t}", "language": "java", "code": "public int addElement(int element, int treap) {\n\t\tint treap_;\n\t\tif (treap == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t} else {\n\t\t\ttreap_ = treap;\n\t\t}\n\n\t\treturn addElement_(element, 0, treap_);\n\t}", "code_tokens": ["public", "int", "addElement", "(", "int", "element", ",", "int", "treap", ")", "{", "int", "treap_", ";", "if", "(", "treap", "==", "-", "1", ")", "{", "if", "(", "m_defaultTreap", "==", "nullNode", "(", ")", ")", "m_defaultTreap", "=", "createTreap", "(", "-", "1", ")", ";", "treap_", "=", "m_defaultTreap", ";", "}", "else", "{", "treap_", "=", "treap", ";", "}", "return", "addElement_", "(", "element", ",", "0", ",", "treap_", ")", ";", "}"], "docstring": "Adds new element to the treap. Allows duplicates to be added.", "docstring_tokens": ["Adds", "new", "element", "to", "the", "treap", ".", "Allows", "duplicates", "to", "be", "added", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L128-L139", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.addUniqueElement", "original_string": "public int addUniqueElement(int element, int treap) {\n\t\tint treap_;\n\t\tif (treap == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t} else {\n\t\t\ttreap_ = treap;\n\t\t}\n\n\t\treturn addElement_(element, 1, treap_);\n\t}", "language": "java", "code": "public int addUniqueElement(int element, int treap) {\n\t\tint treap_;\n\t\tif (treap == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t} else {\n\t\t\ttreap_ = treap;\n\t\t}\n\n\t\treturn addElement_(element, 1, treap_);\n\t}", "code_tokens": ["public", "int", "addUniqueElement", "(", "int", "element", ",", "int", "treap", ")", "{", "int", "treap_", ";", "if", "(", "treap", "==", "-", "1", ")", "{", "if", "(", "m_defaultTreap", "==", "nullNode", "(", ")", ")", "m_defaultTreap", "=", "createTreap", "(", "-", "1", ")", ";", "treap_", "=", "m_defaultTreap", ";", "}", "else", "{", "treap_", "=", "treap", ";", "}", "return", "addElement_", "(", "element", ",", "1", ",", "treap_", ")", ";", "}"], "docstring": "the already existing element equal to element.", "docstring_tokens": ["the", "already", "existing", "element", "equal", "to", "element", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L144-L155", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.addBiggestElement", "original_string": "public int addBiggestElement(int element, int treap) {\n\t\tint treap_;\n\t\tif (treap == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t} else {\n\t\t\ttreap_ = treap;\n\t\t}\n\n\t\tif (getRoot_(treap_) == nullNode()) {\n\t\t\tint newNode = newNode_(element);\n\t\t\tsetRoot_(newNode, treap_);\n\t\t\taddToList_(-1, newNode, treap_);\n\t\t\treturn newNode;\n\t\t}\n\n\t\tint cur = getLast_(treap_);\n\t\tint newNode = newNode_(element);\n\t\tsetRight_(cur, newNode);\n\t\tsetParent_(newNode, cur);\n\t\tassert (m_b_balancing);// don't use this method for unbalanced tree, or\n\t\t\t\t\t\t\t\t// the performance will be bad.\n\t\tbubbleUp_(newNode);\n\t\tif (getParent(newNode) == nullNode())\n\t\t\tsetRoot_(newNode, treap_);\n\n\t\taddToList_(-1, newNode, treap_);\n\t\treturn newNode;\n\t}", "language": "java", "code": "public int addBiggestElement(int element, int treap) {\n\t\tint treap_;\n\t\tif (treap == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t} else {\n\t\t\ttreap_ = treap;\n\t\t}\n\n\t\tif (getRoot_(treap_) == nullNode()) {\n\t\t\tint newNode = newNode_(element);\n\t\t\tsetRoot_(newNode, treap_);\n\t\t\taddToList_(-1, newNode, treap_);\n\t\t\treturn newNode;\n\t\t}\n\n\t\tint cur = getLast_(treap_);\n\t\tint newNode = newNode_(element);\n\t\tsetRight_(cur, newNode);\n\t\tsetParent_(newNode, cur);\n\t\tassert (m_b_balancing);// don't use this method for unbalanced tree, or\n\t\t\t\t\t\t\t\t// the performance will be bad.\n\t\tbubbleUp_(newNode);\n\t\tif (getParent(newNode) == nullNode())\n\t\t\tsetRoot_(newNode, treap_);\n\n\t\taddToList_(-1, newNode, treap_);\n\t\treturn newNode;\n\t}", "code_tokens": ["public", "int", "addBiggestElement", "(", "int", "element", ",", "int", "treap", ")", "{", "int", "treap_", ";", "if", "(", "treap", "==", "-", "1", ")", "{", "if", "(", "m_defaultTreap", "==", "nullNode", "(", ")", ")", "m_defaultTreap", "=", "createTreap", "(", "-", "1", ")", ";", "treap_", "=", "m_defaultTreap", ";", "}", "else", "{", "treap_", "=", "treap", ";", "}", "if", "(", "getRoot_", "(", "treap_", ")", "==", "nullNode", "(", ")", ")", "{", "int", "newNode", "=", "newNode_", "(", "element", ")", ";", "setRoot_", "(", "newNode", ",", "treap_", ")", ";", "addToList_", "(", "-", "1", ",", "newNode", ",", "treap_", ")", ";", "return", "newNode", ";", "}", "int", "cur", "=", "getLast_", "(", "treap_", ")", ";", "int", "newNode", "=", "newNode_", "(", "element", ")", ";", "setRight_", "(", "cur", ",", "newNode", ")", ";", "setParent_", "(", "newNode", ",", "cur", ")", ";", "assert", "(", "m_b_balancing", ")", ";", "// don't use this method for unbalanced tree, or", "// the performance will be bad.", "bubbleUp_", "(", "newNode", ")", ";", "if", "(", "getParent", "(", "newNode", ")", "==", "nullNode", "(", ")", ")", "setRoot_", "(", "newNode", ",", "treap_", ")", ";", "addToList_", "(", "-", "1", ",", "newNode", ",", "treap_", ")", ";", "return", "newNode", ";", "}"], "docstring": "performance (it does not call the treap comparator).", "docstring_tokens": ["performance", "(", "it", "does", "not", "call", "the", "treap", "comparator", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L161-L190", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.addElementAtPosition", "original_string": "public int addElementAtPosition(int prevNode, int nextNode, int element,\n\t\t\tboolean bUnique, boolean bCallCompare, int treap) {\n\t\tint treap_ = treap;\n\t\tif (treap_ == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t}\n\n\t\t// dbg_check_(m_root);\n\t\tif (getRoot_(treap_) == nullNode()) {\n\t\t\tassert (nextNode == nullNode() && prevNode == nullNode());\n\t\t\tint root = newNode_(element);\n\t\t\tsetRoot_(root, treap_);\n\t\t\taddToList_(-1, root, treap_);\n\t\t\treturn root;\n\t\t}\n\n\t\tint cmpNext;\n\t\tint cmpPrev;\n\t\tif (bCallCompare) {\n\t\t\tcmpNext = nextNode != nullNode() ? m_comparator.compare(this,\n\t\t\t\t\telement, nextNode) : -1;\n\t\t\tassert (cmpNext <= 0);\n\t\t\tcmpPrev = prevNode != nullNode() ? m_comparator.compare(this,\n\t\t\t\t\telement, prevNode) : 1;\n\t\t\t// cmpPrev can be negative in plane sweep when intersection is\n\t\t\t// detected.\n\t\t} else {\n\t\t\tcmpNext = -1;\n\t\t\tcmpPrev = 1;\n\t\t}\n\n\t\tif (bUnique && (cmpNext == 0 || cmpPrev == 0)) {\n\t\t\tm_comparator.onAddUniqueElementFailedImpl_(element);\n\t\t\tint cur = cmpNext == 0 ? nextNode : prevNode;\n\t\t\tsetDuplicateElement_(cur, treap_);\n\t\t\treturn -1;// return negative value.\n\t\t}\n\n\t\tint cur;\n\t\tint cmp;\n\t\tboolean bNext;\n\t\tif (nextNode != nullNode() && prevNode != nullNode()) {\n\t\t\t// randomize the the cost to insert a node.\n\t\t\tbNext = m_random > NumberUtils.nextRand(m_random) >> 1;\n\t\t} else\n\t\t\tbNext = nextNode != nullNode();\n\n\t\tif (bNext) {\n\t\t\tcmp = cmpNext;\n\t\t\tcur = nextNode;\n\t\t} else {\n\t\t\tcmp = cmpPrev;\n\t\t\tcur = prevNode;\n\t\t}\n\n\t\tint newNode = -1;\n\t\tint before = -1;\n\t\tboolean b_first = true;\n\t\tfor (;;) {\n\t\t\tif (cmp < 0) {\n\t\t\t\tint left = getLeft(cur);\n\t\t\t\tif (left != nullNode())\n\t\t\t\t\tcur = left;\n\t\t\t\telse {\n\t\t\t\t\tbefore = cur;\n\t\t\t\t\tnewNode = newNode_(element);\n\t\t\t\t\tsetLeft_(cur, newNode);\n\t\t\t\t\tsetParent_(newNode, cur);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint right = getRight(cur);\n\t\t\t\tif (right != nullNode())\n\t\t\t\t\tcur = right;\n\t\t\t\telse {\n\t\t\t\t\tbefore = getNext(cur);\n\t\t\t\t\tnewNode = newNode_(element);\n\t\t\t\t\tsetRight_(cur, newNode);\n\t\t\t\t\tsetParent_(newNode, cur);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b_first) {\n\t\t\t\tcmp *= -1;\n\t\t\t\tb_first = false;\n\t\t\t}\n\t\t}\n\n\t\tbubbleUp_(newNode);\n\t\tif (getParent(newNode) == nullNode())\n\t\t\tsetRoot_(newNode, treap_);\n\n\t\taddToList_(before, newNode, treap_);\n\t\t// dbg_check_(m_root);\n\t\treturn newNode;\n\t}", "language": "java", "code": "public int addElementAtPosition(int prevNode, int nextNode, int element,\n\t\t\tboolean bUnique, boolean bCallCompare, int treap) {\n\t\tint treap_ = treap;\n\t\tif (treap_ == -1) {\n\t\t\tif (m_defaultTreap == nullNode())\n\t\t\t\tm_defaultTreap = createTreap(-1);\n\t\t\ttreap_ = m_defaultTreap;\n\t\t}\n\n\t\t// dbg_check_(m_root);\n\t\tif (getRoot_(treap_) == nullNode()) {\n\t\t\tassert (nextNode == nullNode() && prevNode == nullNode());\n\t\t\tint root = newNode_(element);\n\t\t\tsetRoot_(root, treap_);\n\t\t\taddToList_(-1, root, treap_);\n\t\t\treturn root;\n\t\t}\n\n\t\tint cmpNext;\n\t\tint cmpPrev;\n\t\tif (bCallCompare) {\n\t\t\tcmpNext = nextNode != nullNode() ? m_comparator.compare(this,\n\t\t\t\t\telement, nextNode) : -1;\n\t\t\tassert (cmpNext <= 0);\n\t\t\tcmpPrev = prevNode != nullNode() ? m_comparator.compare(this,\n\t\t\t\t\telement, prevNode) : 1;\n\t\t\t// cmpPrev can be negative in plane sweep when intersection is\n\t\t\t// detected.\n\t\t} else {\n\t\t\tcmpNext = -1;\n\t\t\tcmpPrev = 1;\n\t\t}\n\n\t\tif (bUnique && (cmpNext == 0 || cmpPrev == 0)) {\n\t\t\tm_comparator.onAddUniqueElementFailedImpl_(element);\n\t\t\tint cur = cmpNext == 0 ? nextNode : prevNode;\n\t\t\tsetDuplicateElement_(cur, treap_);\n\t\t\treturn -1;// return negative value.\n\t\t}\n\n\t\tint cur;\n\t\tint cmp;\n\t\tboolean bNext;\n\t\tif (nextNode != nullNode() && prevNode != nullNode()) {\n\t\t\t// randomize the the cost to insert a node.\n\t\t\tbNext = m_random > NumberUtils.nextRand(m_random) >> 1;\n\t\t} else\n\t\t\tbNext = nextNode != nullNode();\n\n\t\tif (bNext) {\n\t\t\tcmp = cmpNext;\n\t\t\tcur = nextNode;\n\t\t} else {\n\t\t\tcmp = cmpPrev;\n\t\t\tcur = prevNode;\n\t\t}\n\n\t\tint newNode = -1;\n\t\tint before = -1;\n\t\tboolean b_first = true;\n\t\tfor (;;) {\n\t\t\tif (cmp < 0) {\n\t\t\t\tint left = getLeft(cur);\n\t\t\t\tif (left != nullNode())\n\t\t\t\t\tcur = left;\n\t\t\t\telse {\n\t\t\t\t\tbefore = cur;\n\t\t\t\t\tnewNode = newNode_(element);\n\t\t\t\t\tsetLeft_(cur, newNode);\n\t\t\t\t\tsetParent_(newNode, cur);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint right = getRight(cur);\n\t\t\t\tif (right != nullNode())\n\t\t\t\t\tcur = right;\n\t\t\t\telse {\n\t\t\t\t\tbefore = getNext(cur);\n\t\t\t\t\tnewNode = newNode_(element);\n\t\t\t\t\tsetRight_(cur, newNode);\n\t\t\t\t\tsetParent_(newNode, cur);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b_first) {\n\t\t\t\tcmp *= -1;\n\t\t\t\tb_first = false;\n\t\t\t}\n\t\t}\n\n\t\tbubbleUp_(newNode);\n\t\tif (getParent(newNode) == nullNode())\n\t\t\tsetRoot_(newNode, treap_);\n\n\t\taddToList_(before, newNode, treap_);\n\t\t// dbg_check_(m_root);\n\t\treturn newNode;\n\t}", "code_tokens": ["public", "int", "addElementAtPosition", "(", "int", "prevNode", ",", "int", "nextNode", ",", "int", "element", ",", "boolean", "bUnique", ",", "boolean", "bCallCompare", ",", "int", "treap", ")", "{", "int", "treap_", "=", "treap", ";", "if", "(", "treap_", "==", "-", "1", ")", "{", "if", "(", "m_defaultTreap", "==", "nullNode", "(", ")", ")", "m_defaultTreap", "=", "createTreap", "(", "-", "1", ")", ";", "treap_", "=", "m_defaultTreap", ";", "}", "// dbg_check_(m_root);", "if", "(", "getRoot_", "(", "treap_", ")", "==", "nullNode", "(", ")", ")", "{", "assert", "(", "nextNode", "==", "nullNode", "(", ")", "&&", "prevNode", "==", "nullNode", "(", ")", ")", ";", "int", "root", "=", "newNode_", "(", "element", ")", ";", "setRoot_", "(", "root", ",", "treap_", ")", ";", "addToList_", "(", "-", "1", ",", "root", ",", "treap_", ")", ";", "return", "root", ";", "}", "int", "cmpNext", ";", "int", "cmpPrev", ";", "if", "(", "bCallCompare", ")", "{", "cmpNext", "=", "nextNode", "!=", "nullNode", "(", ")", "?", "m_comparator", ".", "compare", "(", "this", ",", "element", ",", "nextNode", ")", ":", "-", "1", ";", "assert", "(", "cmpNext", "<=", "0", ")", ";", "cmpPrev", "=", "prevNode", "!=", "nullNode", "(", ")", "?", "m_comparator", ".", "compare", "(", "this", ",", "element", ",", "prevNode", ")", ":", "1", ";", "// cmpPrev can be negative in plane sweep when intersection is", "// detected.", "}", "else", "{", "cmpNext", "=", "-", "1", ";", "cmpPrev", "=", "1", ";", "}", "if", "(", "bUnique", "&&", "(", "cmpNext", "==", "0", "||", "cmpPrev", "==", "0", ")", ")", "{", "m_comparator", ".", "onAddUniqueElementFailedImpl_", "(", "element", ")", ";", "int", "cur", "=", "cmpNext", "==", "0", "?", "nextNode", ":", "prevNode", ";", "setDuplicateElement_", "(", "cur", ",", "treap_", ")", ";", "return", "-", "1", ";", "// return negative value.", "}", "int", "cur", ";", "int", "cmp", ";", "boolean", "bNext", ";", "if", "(", "nextNode", "!=", "nullNode", "(", ")", "&&", "prevNode", "!=", "nullNode", "(", ")", ")", "{", "// randomize the the cost to insert a node.", "bNext", "=", "m_random", ">", "NumberUtils", ".", "nextRand", "(", "m_random", ")", ">>", "1", ";", "}", "else", "bNext", "=", "nextNode", "!=", "nullNode", "(", ")", ";", "if", "(", "bNext", ")", "{", "cmp", "=", "cmpNext", ";", "cur", "=", "nextNode", ";", "}", "else", "{", "cmp", "=", "cmpPrev", ";", "cur", "=", "prevNode", ";", "}", "int", "newNode", "=", "-", "1", ";", "int", "before", "=", "-", "1", ";", "boolean", "b_first", "=", "true", ";", "for", "(", ";", ";", ")", "{", "if", "(", "cmp", "<", "0", ")", "{", "int", "left", "=", "getLeft", "(", "cur", ")", ";", "if", "(", "left", "!=", "nullNode", "(", ")", ")", "cur", "=", "left", ";", "else", "{", "before", "=", "cur", ";", "newNode", "=", "newNode_", "(", "element", ")", ";", "setLeft_", "(", "cur", ",", "newNode", ")", ";", "setParent_", "(", "newNode", ",", "cur", ")", ";", "break", ";", "}", "}", "else", "{", "int", "right", "=", "getRight", "(", "cur", ")", ";", "if", "(", "right", "!=", "nullNode", "(", ")", ")", "cur", "=", "right", ";", "else", "{", "before", "=", "getNext", "(", "cur", ")", ";", "newNode", "=", "newNode_", "(", "element", ")", ";", "setRight_", "(", "cur", ",", "newNode", ")", ";", "setParent_", "(", "newNode", ",", "cur", ")", ";", "break", ";", "}", "}", "if", "(", "b_first", ")", "{", "cmp", "*=", "-", "1", ";", "b_first", "=", "false", ";", "}", "}", "bubbleUp_", "(", "newNode", ")", ";", "if", "(", "getParent", "(", "newNode", ")", "==", "nullNode", "(", ")", ")", "setRoot_", "(", "newNode", ",", "treap_", ")", ";", "addToList_", "(", "before", ",", "newNode", ",", "treap_", ")", ";", "// dbg_check_(m_root);", "return", "newNode", ";", "}"], "docstring": "get_duplicate_element reutrns the node of the already existing element.", "docstring_tokens": ["get_duplicate_element", "reutrns", "the", "node", "of", "the", "already", "existing", "element", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L200-L298", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.deleteNode", "original_string": "public void deleteNode(int treap_node_index, int treap) {\n\t\ttouch_();\n\t\t// assert(isValidNode(treap_node_index));\n\t\tif (m_comparator != null)\n\t\t\tm_comparator.onDeleteImpl_(this, treap_node_index);\n\n\t\tint treap_;\n\t\tif (treap == -1)\n\t\t\ttreap_ = m_defaultTreap;\n\t\telse\n\t\t\ttreap_ = treap;\n\n\t\tif (!m_b_balancing) {\n\t\t\tunbalancedDelete_(treap_node_index, treap_);\n\t\t} else\n\t\t\tdeleteNode_(treap_node_index, treap_);\n\t}", "language": "java", "code": "public void deleteNode(int treap_node_index, int treap) {\n\t\ttouch_();\n\t\t// assert(isValidNode(treap_node_index));\n\t\tif (m_comparator != null)\n\t\t\tm_comparator.onDeleteImpl_(this, treap_node_index);\n\n\t\tint treap_;\n\t\tif (treap == -1)\n\t\t\ttreap_ = m_defaultTreap;\n\t\telse\n\t\t\ttreap_ = treap;\n\n\t\tif (!m_b_balancing) {\n\t\t\tunbalancedDelete_(treap_node_index, treap_);\n\t\t} else\n\t\t\tdeleteNode_(treap_node_index, treap_);\n\t}", "code_tokens": ["public", "void", "deleteNode", "(", "int", "treap_node_index", ",", "int", "treap", ")", "{", "touch_", "(", ")", ";", "// assert(isValidNode(treap_node_index));", "if", "(", "m_comparator", "!=", "null", ")", "m_comparator", ".", "onDeleteImpl_", "(", "this", ",", "treap_node_index", ")", ";", "int", "treap_", ";", "if", "(", "treap", "==", "-", "1", ")", "treap_", "=", "m_defaultTreap", ";", "else", "treap_", "=", "treap", ";", "if", "(", "!", "m_b_balancing", ")", "{", "unbalancedDelete_", "(", "treap_node_index", ",", "treap_", ")", ";", "}", "else", "deleteNode_", "(", "treap_node_index", ",", "treap_", ")", ";", "}"], "docstring": "Removes a node from the treap. Throws if doesn't exist.", "docstring_tokens": ["Removes", "a", "node", "from", "the", "treap", ".", "Throws", "if", "doesn", "t", "exist", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L309-L325", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.search", "original_string": "public int search(int data, int treap) {\n\t\tint cur = getRoot(treap);\n\t\twhile (cur != nullNode()) {\n\t\t\tint res = m_comparator.compare(this, data, cur);\n\t\t\tif (res == 0)\n\t\t\t\treturn cur;\n\t\t\telse if (res < 0)\n\t\t\t\tcur = getLeft(cur);\n\t\t\telse\n\t\t\t\tcur = getRight(cur);\n\t\t}\n\n\t\tm_comparator.onEndSearchImpl_(data);\n\t\treturn nullNode();\n\t}", "language": "java", "code": "public int search(int data, int treap) {\n\t\tint cur = getRoot(treap);\n\t\twhile (cur != nullNode()) {\n\t\t\tint res = m_comparator.compare(this, data, cur);\n\t\t\tif (res == 0)\n\t\t\t\treturn cur;\n\t\t\telse if (res < 0)\n\t\t\t\tcur = getLeft(cur);\n\t\t\telse\n\t\t\t\tcur = getRight(cur);\n\t\t}\n\n\t\tm_comparator.onEndSearchImpl_(data);\n\t\treturn nullNode();\n\t}", "code_tokens": ["public", "int", "search", "(", "int", "data", ",", "int", "treap", ")", "{", "int", "cur", "=", "getRoot", "(", "treap", ")", ";", "while", "(", "cur", "!=", "nullNode", "(", ")", ")", "{", "int", "res", "=", "m_comparator", ".", "compare", "(", "this", ",", "data", ",", "cur", ")", ";", "if", "(", "res", "==", "0", ")", "return", "cur", ";", "else", "if", "(", "res", "<", "0", ")", "cur", "=", "getLeft", "(", "cur", ")", ";", "else", "cur", "=", "getRight", "(", "cur", ")", ";", "}", "m_comparator", ".", "onEndSearchImpl_", "(", "data", ")", ";", "return", "nullNode", "(", ")", ";", "}"], "docstring": "Finds an element in the treap and returns its node or -1.", "docstring_tokens": ["Finds", "an", "element", "in", "the", "treap", "and", "returns", "its", "node", "or", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L328-L342", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.searchLowerBound", "original_string": "public int searchLowerBound(MonikerComparator moniker, int treap) {\n\t\tint cur = getRoot(treap);\n\t\tint bound = -1;\n\t\twhile (cur != nullNode()) {\n\t\t\tint res = moniker.compare(this, cur);\n\t\t\tif (res == 0)\n\t\t\t\treturn cur;\n\t\t\telse if (res < 0)\n\t\t\t\tcur = getLeft(cur);\n\t\t\telse {\n\t\t\t\tbound = cur;\n\t\t\t\tcur = getRight(cur);\n\t\t\t}\n\t\t}\n\n\t\treturn bound;\n\t}", "language": "java", "code": "public int searchLowerBound(MonikerComparator moniker, int treap) {\n\t\tint cur = getRoot(treap);\n\t\tint bound = -1;\n\t\twhile (cur != nullNode()) {\n\t\t\tint res = moniker.compare(this, cur);\n\t\t\tif (res == 0)\n\t\t\t\treturn cur;\n\t\t\telse if (res < 0)\n\t\t\t\tcur = getLeft(cur);\n\t\t\telse {\n\t\t\t\tbound = cur;\n\t\t\t\tcur = getRight(cur);\n\t\t\t}\n\t\t}\n\n\t\treturn bound;\n\t}", "code_tokens": ["public", "int", "searchLowerBound", "(", "MonikerComparator", "moniker", ",", "int", "treap", ")", "{", "int", "cur", "=", "getRoot", "(", "treap", ")", ";", "int", "bound", "=", "-", "1", ";", "while", "(", "cur", "!=", "nullNode", "(", ")", ")", "{", "int", "res", "=", "moniker", ".", "compare", "(", "this", ",", "cur", ")", ";", "if", "(", "res", "==", "0", ")", "return", "cur", ";", "else", "if", "(", "res", "<", "0", ")", "cur", "=", "getLeft", "(", "cur", ")", ";", "else", "{", "bound", "=", "cur", ";", "cur", "=", "getRight", "(", "cur", ")", ";", "}", "}", "return", "bound", ";", "}"], "docstring": "Returns closest smaller (Comparator::compare returns -1) or any equal.", "docstring_tokens": ["Returns", "closest", "smaller", "(", "Comparator", "::", "compare", "returns", "-", "1", ")", "or", "any", "equal", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L346-L362", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Treap.java", "func_name": "Treap.setElement", "original_string": "public void setElement(int treap_node_index, int newElement) {\n\t\tif (m_comparator != null)\n\t\t\tm_comparator.onSetImpl_(this, treap_node_index);\n\t\tsetElement_(treap_node_index, newElement);\n\t}", "language": "java", "code": "public void setElement(int treap_node_index, int newElement) {\n\t\tif (m_comparator != null)\n\t\t\tm_comparator.onSetImpl_(this, treap_node_index);\n\t\tsetElement_(treap_node_index, newElement);\n\t}", "code_tokens": ["public", "void", "setElement", "(", "int", "treap_node_index", ",", "int", "newElement", ")", "{", "if", "(", "m_comparator", "!=", "null", ")", "m_comparator", ".", "onSetImpl_", "(", "this", ",", "treap_node_index", ")", ";", "setElement_", "(", "treap_node_index", ",", "newElement", ")", ";", "}"], "docstring": "element will change the sorted order.", "docstring_tokens": ["element", "will", "change", "the", "sorted", "order", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Treap.java#L447-L451", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java", "func_name": "OperatorCentroid2DLocal.computePointsCentroid", "original_string": "private static Point2D computePointsCentroid(MultiPoint multiPoint)\n    {\n        double xSum = 0;\n        double ySum = 0;\n        int pointCount = multiPoint.getPointCount();\n        Point2D point2D = new Point2D();\n        for (int i = 0; i < pointCount; i++) {\n            multiPoint.getXY(i, point2D);\n            xSum += point2D.x;\n            ySum += point2D.y;\n        }\n        return new Point2D(xSum / pointCount, ySum / pointCount);\n    }", "language": "java", "code": "private static Point2D computePointsCentroid(MultiPoint multiPoint)\n    {\n        double xSum = 0;\n        double ySum = 0;\n        int pointCount = multiPoint.getPointCount();\n        Point2D point2D = new Point2D();\n        for (int i = 0; i < pointCount; i++) {\n            multiPoint.getXY(i, point2D);\n            xSum += point2D.x;\n            ySum += point2D.y;\n        }\n        return new Point2D(xSum / pointCount, ySum / pointCount);\n    }", "code_tokens": ["private", "static", "Point2D", "computePointsCentroid", "(", "MultiPoint", "multiPoint", ")", "{", "double", "xSum", "=", "0", ";", "double", "ySum", "=", "0", ";", "int", "pointCount", "=", "multiPoint", ".", "getPointCount", "(", ")", ";", "Point2D", "point2D", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pointCount", ";", "i", "++", ")", "{", "multiPoint", ".", "getXY", "(", "i", ",", "point2D", ")", ";", "xSum", "+=", "point2D", ".", "x", ";", "ySum", "+=", "point2D", ".", "y", ";", "}", "return", "new", "Point2D", "(", "xSum", "/", "pointCount", ",", "ySum", "/", "pointCount", ")", ";", "}"], "docstring": "Points centroid is arithmetic mean of the input points", "docstring_tokens": ["Points", "centroid", "is", "arithmetic", "mean", "of", "the", "input", "points"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java#L62-L74", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java", "func_name": "OperatorCentroid2DLocal.computePolylineCentroid", "original_string": "private static Point2D computePolylineCentroid(Polyline polyline)\n    {\n        double xSum = 0;\n        double ySum = 0;\n        double weightSum = 0;\n\n        Point2D startPoint = new Point2D();\n        Point2D endPoint = new Point2D();\n        for (int i = 0; i < polyline.getPathCount(); i++) {\n            polyline.getXY(polyline.getPathStart(i), startPoint);\n            polyline.getXY(polyline.getPathEnd(i) - 1, endPoint);\n            double dx = endPoint.x - startPoint.x;\n            double dy = endPoint.y - startPoint.y;\n            double length = sqrt(dx * dx + dy * dy);\n            weightSum += length;\n            xSum += (startPoint.x + endPoint.x) * length / 2;\n            ySum += (startPoint.y + endPoint.y) * length / 2;\n        }\n        return new Point2D(xSum / weightSum, ySum / weightSum);\n    }", "language": "java", "code": "private static Point2D computePolylineCentroid(Polyline polyline)\n    {\n        double xSum = 0;\n        double ySum = 0;\n        double weightSum = 0;\n\n        Point2D startPoint = new Point2D();\n        Point2D endPoint = new Point2D();\n        for (int i = 0; i < polyline.getPathCount(); i++) {\n            polyline.getXY(polyline.getPathStart(i), startPoint);\n            polyline.getXY(polyline.getPathEnd(i) - 1, endPoint);\n            double dx = endPoint.x - startPoint.x;\n            double dy = endPoint.y - startPoint.y;\n            double length = sqrt(dx * dx + dy * dy);\n            weightSum += length;\n            xSum += (startPoint.x + endPoint.x) * length / 2;\n            ySum += (startPoint.y + endPoint.y) * length / 2;\n        }\n        return new Point2D(xSum / weightSum, ySum / weightSum);\n    }", "code_tokens": ["private", "static", "Point2D", "computePolylineCentroid", "(", "Polyline", "polyline", ")", "{", "double", "xSum", "=", "0", ";", "double", "ySum", "=", "0", ";", "double", "weightSum", "=", "0", ";", "Point2D", "startPoint", "=", "new", "Point2D", "(", ")", ";", "Point2D", "endPoint", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "polyline", ".", "getPathCount", "(", ")", ";", "i", "++", ")", "{", "polyline", ".", "getXY", "(", "polyline", ".", "getPathStart", "(", "i", ")", ",", "startPoint", ")", ";", "polyline", ".", "getXY", "(", "polyline", ".", "getPathEnd", "(", "i", ")", "-", "1", ",", "endPoint", ")", ";", "double", "dx", "=", "endPoint", ".", "x", "-", "startPoint", ".", "x", ";", "double", "dy", "=", "endPoint", ".", "y", "-", "startPoint", ".", "y", ";", "double", "length", "=", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", ";", "weightSum", "+=", "length", ";", "xSum", "+=", "(", "startPoint", ".", "x", "+", "endPoint", ".", "x", ")", "*", "length", "/", "2", ";", "ySum", "+=", "(", "startPoint", ".", "y", "+", "endPoint", ".", "y", ")", "*", "length", "/", "2", ";", "}", "return", "new", "Point2D", "(", "xSum", "/", "weightSum", ",", "ySum", "/", "weightSum", ")", ";", "}"], "docstring": "Lines centroid is weighted mean of each line segment, weight in terms of line length", "docstring_tokens": ["Lines", "centroid", "is", "weighted", "mean", "of", "each", "line", "segment", "weight", "in", "terms", "of", "line", "length"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java#L77-L96", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java", "func_name": "OperatorCentroid2DLocal.computePolygonCentroid", "original_string": "private static Point2D computePolygonCentroid(Polygon polygon)\n    {\n        int pathCount = polygon.getPathCount();\n\n        if (pathCount == 1) {\n            return getPolygonSansHolesCentroid(polygon);\n        }\n\n        double xSum = 0;\n        double ySum = 0;\n        double areaSum = 0;\n\n        for (int i = 0; i < pathCount; i++) {\n            int startIndex = polygon.getPathStart(i);\n            int endIndex = polygon.getPathEnd(i);\n\n            Polygon sansHoles = getSubPolygon(polygon, startIndex, endIndex);\n\n            Point2D centroid = getPolygonSansHolesCentroid(sansHoles);\n            double area = sansHoles.calculateArea2D();\n\n            xSum += centroid.x * area;\n            ySum += centroid.y * area;\n            areaSum += area;\n        }\n\n        return new Point2D(xSum / areaSum, ySum / areaSum);\n    }", "language": "java", "code": "private static Point2D computePolygonCentroid(Polygon polygon)\n    {\n        int pathCount = polygon.getPathCount();\n\n        if (pathCount == 1) {\n            return getPolygonSansHolesCentroid(polygon);\n        }\n\n        double xSum = 0;\n        double ySum = 0;\n        double areaSum = 0;\n\n        for (int i = 0; i < pathCount; i++) {\n            int startIndex = polygon.getPathStart(i);\n            int endIndex = polygon.getPathEnd(i);\n\n            Polygon sansHoles = getSubPolygon(polygon, startIndex, endIndex);\n\n            Point2D centroid = getPolygonSansHolesCentroid(sansHoles);\n            double area = sansHoles.calculateArea2D();\n\n            xSum += centroid.x * area;\n            ySum += centroid.y * area;\n            areaSum += area;\n        }\n\n        return new Point2D(xSum / areaSum, ySum / areaSum);\n    }", "code_tokens": ["private", "static", "Point2D", "computePolygonCentroid", "(", "Polygon", "polygon", ")", "{", "int", "pathCount", "=", "polygon", ".", "getPathCount", "(", ")", ";", "if", "(", "pathCount", "==", "1", ")", "{", "return", "getPolygonSansHolesCentroid", "(", "polygon", ")", ";", "}", "double", "xSum", "=", "0", ";", "double", "ySum", "=", "0", ";", "double", "areaSum", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pathCount", ";", "i", "++", ")", "{", "int", "startIndex", "=", "polygon", ".", "getPathStart", "(", "i", ")", ";", "int", "endIndex", "=", "polygon", ".", "getPathEnd", "(", "i", ")", ";", "Polygon", "sansHoles", "=", "getSubPolygon", "(", "polygon", ",", "startIndex", ",", "endIndex", ")", ";", "Point2D", "centroid", "=", "getPolygonSansHolesCentroid", "(", "sansHoles", ")", ";", "double", "area", "=", "sansHoles", ".", "calculateArea2D", "(", ")", ";", "xSum", "+=", "centroid", ".", "x", "*", "area", ";", "ySum", "+=", "centroid", ".", "y", "*", "area", ";", "areaSum", "+=", "area", ";", "}", "return", "new", "Point2D", "(", "xSum", "/", "areaSum", ",", "ySum", "/", "areaSum", ")", ";", "}"], "docstring": "Polygon centroid: area weighted average of centroids in case of holes", "docstring_tokens": ["Polygon", "centroid", ":", "area", "weighted", "average", "of", "centroids", "in", "case", "of", "holes"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java#L99-L126", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java", "func_name": "OperatorCentroid2DLocal.getPolygonSansHolesCentroid", "original_string": "private static Point2D getPolygonSansHolesCentroid(Polygon polygon)\n    {\n        int pointCount = polygon.getPointCount();\n        double xSum = 0;\n        double ySum = 0;\n        double signedArea = 0;\n\n        Point2D current = new Point2D();\n        Point2D next = new Point2D();\n        for (int i = 0; i < pointCount; i++) {\n            polygon.getXY(i, current);\n            polygon.getXY((i + 1) % pointCount, next);\n            double ladder = current.x * next.y - next.x * current.y;\n            xSum += (current.x + next.x) * ladder;\n            ySum += (current.y + next.y) * ladder;\n            signedArea += ladder / 2;\n        }\n        return new Point2D(xSum / (signedArea * 6), ySum / (signedArea * 6));\n    }", "language": "java", "code": "private static Point2D getPolygonSansHolesCentroid(Polygon polygon)\n    {\n        int pointCount = polygon.getPointCount();\n        double xSum = 0;\n        double ySum = 0;\n        double signedArea = 0;\n\n        Point2D current = new Point2D();\n        Point2D next = new Point2D();\n        for (int i = 0; i < pointCount; i++) {\n            polygon.getXY(i, current);\n            polygon.getXY((i + 1) % pointCount, next);\n            double ladder = current.x * next.y - next.x * current.y;\n            xSum += (current.x + next.x) * ladder;\n            ySum += (current.y + next.y) * ladder;\n            signedArea += ladder / 2;\n        }\n        return new Point2D(xSum / (signedArea * 6), ySum / (signedArea * 6));\n    }", "code_tokens": ["private", "static", "Point2D", "getPolygonSansHolesCentroid", "(", "Polygon", "polygon", ")", "{", "int", "pointCount", "=", "polygon", ".", "getPointCount", "(", ")", ";", "double", "xSum", "=", "0", ";", "double", "ySum", "=", "0", ";", "double", "signedArea", "=", "0", ";", "Point2D", "current", "=", "new", "Point2D", "(", ")", ";", "Point2D", "next", "=", "new", "Point2D", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pointCount", ";", "i", "++", ")", "{", "polygon", ".", "getXY", "(", "i", ",", "current", ")", ";", "polygon", ".", "getXY", "(", "(", "i", "+", "1", ")", "%", "pointCount", ",", "next", ")", ";", "double", "ladder", "=", "current", ".", "x", "*", "next", ".", "y", "-", "next", ".", "x", "*", "current", ".", "y", ";", "xSum", "+=", "(", "current", ".", "x", "+", "next", ".", "x", ")", "*", "ladder", ";", "ySum", "+=", "(", "current", ".", "y", "+", "next", ".", "y", ")", "*", "ladder", ";", "signedArea", "+=", "ladder", "/", "2", ";", "}", "return", "new", "Point2D", "(", "xSum", "/", "(", "signedArea", "*", "6", ")", ",", "ySum", "/", "(", "signedArea", "*", "6", ")", ")", ";", "}"], "docstring": "c[y] = (Sigma(y[i] + y[i + 1]) * (x[i] * y[i + 1] - x[i + 1] * y[i]), for i = 0 to N - 1) / (6 * signedArea)", "docstring_tokens": ["c", "[", "y", "]", "=", "(", "Sigma", "(", "y", "[", "i", "]", "+", "y", "[", "i", "+", "1", "]", ")", "*", "(", "x", "[", "i", "]", "*", "y", "[", "i", "+", "1", "]", "-", "x", "[", "i", "+", "1", "]", "*", "y", "[", "i", "]", ")", "for", "i", "=", "0", "to", "N", "-", "1", ")", "/", "(", "6", "*", "signedArea", ")"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/OperatorCentroid2DLocal.java#L145-L163", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/SpatialReferenceImpl.java", "func_name": "SpatialReferenceImpl.getOldID", "original_string": "@Override\n\tint getOldID() {\n\t\tint ID_ = getID();\n\n\t\tif (m_userOldestWkid != -1)\n\t\t\treturn m_userOldestWkid;\n\n\t\tm_userOldestWkid = Wkid.wkid_to_old(ID_);\n\n\t\tif (m_userOldestWkid != -1)\n\t\t\treturn m_userOldestWkid;\n\n\t\treturn ID_;\n\t}", "language": "java", "code": "@Override\n\tint getOldID() {\n\t\tint ID_ = getID();\n\n\t\tif (m_userOldestWkid != -1)\n\t\t\treturn m_userOldestWkid;\n\n\t\tm_userOldestWkid = Wkid.wkid_to_old(ID_);\n\n\t\tif (m_userOldestWkid != -1)\n\t\t\treturn m_userOldestWkid;\n\n\t\treturn ID_;\n\t}", "code_tokens": ["@", "Override", "int", "getOldID", "(", ")", "{", "int", "ID_", "=", "getID", "(", ")", ";", "if", "(", "m_userOldestWkid", "!=", "-", "1", ")", "return", "m_userOldestWkid", ";", "m_userOldestWkid", "=", "Wkid", ".", "wkid_to_old", "(", "ID_", ")", ";", "if", "(", "m_userOldestWkid", "!=", "-", "1", ")", "return", "m_userOldestWkid", ";", "return", "ID_", ";", "}"], "docstring": "Returns the oldest value of the well known ID for the horizontal\ncoordinate system of the spatial reference. This ID is used for JSON\nserialization. Not public.", "docstring_tokens": ["Returns", "the", "oldest", "value", "of", "the", "well", "known", "ID", "for", "the", "horizontal", "coordinate", "system", "of", "the", "spatial", "reference", ".", "This", "ID", "is", "used", "for", "JSON", "serialization", ".", "Not", "public", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/SpatialReferenceImpl.java#L137-L150", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Geometry.java", "func_name": "Geometry.mergeVertexDescription", "original_string": "public void mergeVertexDescription(VertexDescription src) {\n\t\t_touch();\n\t\tif (src == m_description)\n\t\t\treturn;\n\n\t\t// check if we need to do anything (if the src has same attributes)\n\t\tVertexDescription newdescription = VertexDescriptionDesignerImpl.getMergedVertexDescription(m_description, src);\n\t\tif (newdescription == m_description)\n\t\t\treturn;\n\t\t\n\t\t_assignVertexDescriptionImpl(newdescription);\n\t}", "language": "java", "code": "public void mergeVertexDescription(VertexDescription src) {\n\t\t_touch();\n\t\tif (src == m_description)\n\t\t\treturn;\n\n\t\t// check if we need to do anything (if the src has same attributes)\n\t\tVertexDescription newdescription = VertexDescriptionDesignerImpl.getMergedVertexDescription(m_description, src);\n\t\tif (newdescription == m_description)\n\t\t\treturn;\n\t\t\n\t\t_assignVertexDescriptionImpl(newdescription);\n\t}", "code_tokens": ["public", "void", "mergeVertexDescription", "(", "VertexDescription", "src", ")", "{", "_touch", "(", ")", ";", "if", "(", "src", "==", "m_description", ")", "return", ";", "// check if we need to do anything (if the src has same attributes)", "VertexDescription", "newdescription", "=", "VertexDescriptionDesignerImpl", ".", "getMergedVertexDescription", "(", "m_description", ",", "src", ")", ";", "if", "(", "newdescription", "==", "m_description", ")", "return", ";", "_assignVertexDescriptionImpl", "(", "newdescription", ")", ";", "}"], "docstring": "Merges the new VertexDescription by adding missing attributes from the\nsrc. The Geometry will have a union of the current and the src\ndescriptions.\n@param src VertexDescription to merge.", "docstring_tokens": ["Merges", "the", "new", "VertexDescription", "by", "adding", "missing", "attributes", "from", "the", "src", ".", "The", "Geometry", "will", "have", "a", "union", "of", "the", "current", "and", "the", "src", "descriptions", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Geometry.java#L198-L209", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Geometry.java", "func_name": "Geometry.addAttribute", "original_string": "public void addAttribute(int semantics) {\n\t\t_touch();\n\t\tif (m_description.hasAttribute(semantics))\n\t\t\treturn;\n\t\t\n\t\tVertexDescription newvd = VertexDescriptionDesignerImpl.getMergedVertexDescription(m_description, semantics);\n\t\t_assignVertexDescriptionImpl(newvd);\n\t}", "language": "java", "code": "public void addAttribute(int semantics) {\n\t\t_touch();\n\t\tif (m_description.hasAttribute(semantics))\n\t\t\treturn;\n\t\t\n\t\tVertexDescription newvd = VertexDescriptionDesignerImpl.getMergedVertexDescription(m_description, semantics);\n\t\t_assignVertexDescriptionImpl(newvd);\n\t}", "code_tokens": ["public", "void", "addAttribute", "(", "int", "semantics", ")", "{", "_touch", "(", ")", ";", "if", "(", "m_description", ".", "hasAttribute", "(", "semantics", ")", ")", "return", ";", "VertexDescription", "newvd", "=", "VertexDescriptionDesignerImpl", ".", "getMergedVertexDescription", "(", "m_description", ",", "semantics", ")", ";", "_assignVertexDescriptionImpl", "(", "newvd", ")", ";", "}"], "docstring": "Adds a new attribute to the Geometry.\n\n@param semantics The VertexDescription.Semantics to add.", "docstring_tokens": ["Adds", "a", "new", "attribute", "to", "the", "Geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Geometry.java#L225-L232", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Geometry.java", "func_name": "Geometry.dropAttribute", "original_string": "public void dropAttribute(int semantics) {\n\t\t_touch();\n\t\tif (!m_description.hasAttribute(semantics))\n\t\t\treturn;\n\n\t\tVertexDescription newvd = VertexDescriptionDesignerImpl.removeSemanticsFromVertexDescription(m_description, semantics);\n\t\t_assignVertexDescriptionImpl(newvd);\n\t}", "language": "java", "code": "public void dropAttribute(int semantics) {\n\t\t_touch();\n\t\tif (!m_description.hasAttribute(semantics))\n\t\t\treturn;\n\n\t\tVertexDescription newvd = VertexDescriptionDesignerImpl.removeSemanticsFromVertexDescription(m_description, semantics);\n\t\t_assignVertexDescriptionImpl(newvd);\n\t}", "code_tokens": ["public", "void", "dropAttribute", "(", "int", "semantics", ")", "{", "_touch", "(", ")", ";", "if", "(", "!", "m_description", ".", "hasAttribute", "(", "semantics", ")", ")", "return", ";", "VertexDescription", "newvd", "=", "VertexDescriptionDesignerImpl", ".", "removeSemanticsFromVertexDescription", "(", "m_description", ",", "semantics", ")", ";", "_assignVertexDescriptionImpl", "(", "newvd", ")", ";", "}"], "docstring": "Drops an attribute from the Geometry. Dropping the attribute is\nequivalent to setting the attribute to the default value for each vertex,\nHowever, it is faster and the result Geometry has smaller memory\nfootprint and smaller size when persisted.\n@param semantics The VertexDescription.Semantics to drop.", "docstring_tokens": ["Drops", "an", "attribute", "from", "the", "Geometry", ".", "Dropping", "the", "attribute", "is", "equivalent", "to", "setting", "the", "attribute", "to", "the", "default", "value", "for", "each", "vertex", "However", "it", "is", "faster", "and", "the", "result", "Geometry", "has", "smaller", "memory", "footprint", "and", "smaller", "size", "when", "persisted", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Geometry.java#L241-L248", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Geometry.java", "func_name": "Geometry.vertex_count", "original_string": "public static int vertex_count(Geometry geom) {\n\t\tGeometry.Type gt = geom.getType();\n\t\tif (Geometry.isMultiVertex(gt.value()))\n\t\t\treturn ((MultiVertexGeometry) geom).getPointCount();\n\n\t\tif (geom.isEmpty())\n\t\t\treturn 0;\n\n\t\tif (gt == Geometry.Type.Envelope)\n\t\t\treturn 4;\n\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn 1;\n\n\t\tif (Geometry.isSegment(gt.value()))\n\t\t\treturn 2;\n\n\t\tthrow new GeometryException(\"missing type\");\n\t}", "language": "java", "code": "public static int vertex_count(Geometry geom) {\n\t\tGeometry.Type gt = geom.getType();\n\t\tif (Geometry.isMultiVertex(gt.value()))\n\t\t\treturn ((MultiVertexGeometry) geom).getPointCount();\n\n\t\tif (geom.isEmpty())\n\t\t\treturn 0;\n\n\t\tif (gt == Geometry.Type.Envelope)\n\t\t\treturn 4;\n\n\t\tif (gt == Geometry.Type.Point)\n\t\t\treturn 1;\n\n\t\tif (Geometry.isSegment(gt.value()))\n\t\t\treturn 2;\n\n\t\tthrow new GeometryException(\"missing type\");\n\t}", "code_tokens": ["public", "static", "int", "vertex_count", "(", "Geometry", "geom", ")", "{", "Geometry", ".", "Type", "gt", "=", "geom", ".", "getType", "(", ")", ";", "if", "(", "Geometry", ".", "isMultiVertex", "(", "gt", ".", "value", "(", ")", ")", ")", "return", "(", "(", "MultiVertexGeometry", ")", "geom", ")", ".", "getPointCount", "(", ")", ";", "if", "(", "geom", ".", "isEmpty", "(", ")", ")", "return", "0", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Envelope", ")", "return", "4", ";", "if", "(", "gt", "==", "Geometry", ".", "Type", ".", "Point", ")", "return", "1", ";", "if", "(", "Geometry", ".", "isSegment", "(", "gt", ".", "value", "(", ")", ")", ")", "return", "2", ";", "throw", "new", "GeometryException", "(", "\"missing type\"", ")", ";", "}"], "docstring": "Returns count of geometry vertices: 1 for Point, 4 for Envelope,\nget_point_count for MultiVertexGeometry types, 2 for segment types Returns 0\nif geometry is empty.\n@param geom The geometry to get the vertex count for.\n@return The vertex count.", "docstring_tokens": ["Returns", "count", "of", "geometry", "vertices", ":", "1", "for", "Point", "4", "for", "Envelope", "get_point_count", "for", "MultiVertexGeometry", "types", "2", "for", "segment", "types", "Returns", "0", "if", "geometry", "is", "empty", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Geometry.java#L653-L671", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiList.java", "func_name": "IndexMultiList.createList", "original_string": "int createList() {\n\t\tint node = newList_();\n\t\tif (m_b_allow_navigation_between_lists) {\n\t\t\tm_lists.setField(node, 3, m_list_of_lists);\n\t\t\tif (m_list_of_lists != nullNode())\n\t\t\t\tm_lists.setField(m_list_of_lists, 2, node);\n\t\t\tm_list_of_lists = node;\n\t\t}\n\n\t\treturn node;\n\t}", "language": "java", "code": "int createList() {\n\t\tint node = newList_();\n\t\tif (m_b_allow_navigation_between_lists) {\n\t\t\tm_lists.setField(node, 3, m_list_of_lists);\n\t\t\tif (m_list_of_lists != nullNode())\n\t\t\t\tm_lists.setField(m_list_of_lists, 2, node);\n\t\t\tm_list_of_lists = node;\n\t\t}\n\n\t\treturn node;\n\t}", "code_tokens": ["int", "createList", "(", ")", "{", "int", "node", "=", "newList_", "(", ")", ";", "if", "(", "m_b_allow_navigation_between_lists", ")", "{", "m_lists", ".", "setField", "(", "node", ",", "3", ",", "m_list_of_lists", ")", ";", "if", "(", "m_list_of_lists", "!=", "nullNode", "(", ")", ")", "m_lists", ".", "setField", "(", "m_list_of_lists", ",", "2", ",", "node", ")", ";", "m_list_of_lists", "=", "node", ";", "}", "return", "node", ";", "}"], "docstring": "Creates new list and returns it's handle.", "docstring_tokens": ["Creates", "new", "list", "and", "returns", "it", "s", "handle", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiList.java#L79-L89", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiList.java", "func_name": "IndexMultiList.deleteList", "original_string": "void deleteList(int list) {\n\t\tint ptr = getFirst(list);\n\t\twhile (ptr != nullNode()) {\n\t\t\tint p = ptr;\n\t\t\tptr = getNext(ptr);\n\t\t\tfreeNode_(p);\n\t\t}\n\n\t\tif (m_b_allow_navigation_between_lists) {\n\t\t\tint prevList = m_lists.getField(list, 2);\n\t\t\tint nextList = m_lists.getField(list, 3);\n\t\t\tif (prevList != nullNode())\n\t\t\t\tm_lists.setField(prevList, 3, nextList);\n\t\t\telse\n\t\t\t\tm_list_of_lists = nextList;\n\n\t\t\tif (nextList != nullNode())\n\t\t\t\tm_lists.setField(nextList, 2, prevList);\n\t\t}\n\n\t\tfreeList_(list);\n\t}", "language": "java", "code": "void deleteList(int list) {\n\t\tint ptr = getFirst(list);\n\t\twhile (ptr != nullNode()) {\n\t\t\tint p = ptr;\n\t\t\tptr = getNext(ptr);\n\t\t\tfreeNode_(p);\n\t\t}\n\n\t\tif (m_b_allow_navigation_between_lists) {\n\t\t\tint prevList = m_lists.getField(list, 2);\n\t\t\tint nextList = m_lists.getField(list, 3);\n\t\t\tif (prevList != nullNode())\n\t\t\t\tm_lists.setField(prevList, 3, nextList);\n\t\t\telse\n\t\t\t\tm_list_of_lists = nextList;\n\n\t\t\tif (nextList != nullNode())\n\t\t\t\tm_lists.setField(nextList, 2, prevList);\n\t\t}\n\n\t\tfreeList_(list);\n\t}", "code_tokens": ["void", "deleteList", "(", "int", "list", ")", "{", "int", "ptr", "=", "getFirst", "(", "list", ")", ";", "while", "(", "ptr", "!=", "nullNode", "(", ")", ")", "{", "int", "p", "=", "ptr", ";", "ptr", "=", "getNext", "(", "ptr", ")", ";", "freeNode_", "(", "p", ")", ";", "}", "if", "(", "m_b_allow_navigation_between_lists", ")", "{", "int", "prevList", "=", "m_lists", ".", "getField", "(", "list", ",", "2", ")", ";", "int", "nextList", "=", "m_lists", ".", "getField", "(", "list", ",", "3", ")", ";", "if", "(", "prevList", "!=", "nullNode", "(", ")", ")", "m_lists", ".", "setField", "(", "prevList", ",", "3", ",", "nextList", ")", ";", "else", "m_list_of_lists", "=", "nextList", ";", "if", "(", "nextList", "!=", "nullNode", "(", ")", ")", "m_lists", ".", "setField", "(", "nextList", ",", "2", ",", "prevList", ")", ";", "}", "freeList_", "(", "list", ")", ";", "}"], "docstring": "Deletes a list.", "docstring_tokens": ["Deletes", "a", "list", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiList.java#L92-L113", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiList.java", "func_name": "IndexMultiList.addElement", "original_string": "int addElement(int list, int element) {\n\t\tint head = m_lists.getField(list, 0);\n\t\tint tail = m_lists.getField(list, 1);\n\t\tint node = newNode_();\n\t\tif (tail != nullNode()) {\n\t\t\tassert (head != nullNode());\n\t\t\tm_listNodes.setField(tail, 1, node);\n\t\t\tm_lists.setField(list, 1, node);\n\t\t} else {// empty list\n\t\t\tassert (head == nullNode());\n\t\t\tm_lists.setField(list, 0, node);\n\t\t\tm_lists.setField(list, 1, node);\n\t\t}\n\n\t\tm_listNodes.setField(node, 0, element);\n\t\treturn node;\n\t}", "language": "java", "code": "int addElement(int list, int element) {\n\t\tint head = m_lists.getField(list, 0);\n\t\tint tail = m_lists.getField(list, 1);\n\t\tint node = newNode_();\n\t\tif (tail != nullNode()) {\n\t\t\tassert (head != nullNode());\n\t\t\tm_listNodes.setField(tail, 1, node);\n\t\t\tm_lists.setField(list, 1, node);\n\t\t} else {// empty list\n\t\t\tassert (head == nullNode());\n\t\t\tm_lists.setField(list, 0, node);\n\t\t\tm_lists.setField(list, 1, node);\n\t\t}\n\n\t\tm_listNodes.setField(node, 0, element);\n\t\treturn node;\n\t}", "code_tokens": ["int", "addElement", "(", "int", "list", ",", "int", "element", ")", "{", "int", "head", "=", "m_lists", ".", "getField", "(", "list", ",", "0", ")", ";", "int", "tail", "=", "m_lists", ".", "getField", "(", "list", ",", "1", ")", ";", "int", "node", "=", "newNode_", "(", ")", ";", "if", "(", "tail", "!=", "nullNode", "(", ")", ")", "{", "assert", "(", "head", "!=", "nullNode", "(", ")", ")", ";", "m_listNodes", ".", "setField", "(", "tail", ",", "1", ",", "node", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "node", ")", ";", "}", "else", "{", "// empty list", "assert", "(", "head", "==", "nullNode", "(", ")", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "0", ",", "node", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "node", ")", ";", "}", "m_listNodes", ".", "setField", "(", "node", ",", "0", ",", "element", ")", ";", "return", "node", ";", "}"], "docstring": "the new", "docstring_tokens": ["the", "new"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiList.java#L122-L138", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiList.java", "func_name": "IndexMultiList.deleteElement", "original_string": "void deleteElement(int list, int prevNode, int node) {\n\t\tif (prevNode != nullNode()) {\n\t\t\tassert (m_listNodes.getField(prevNode, 1) == node);\n\t\t\tm_listNodes.setField(prevNode, 1, m_listNodes.getField(node, 1));\n\t\t\tif (m_lists.getField(list, 1) == node)// deleting a tail\n\t\t\t{\n\t\t\t\tm_lists.setField(list, 1, prevNode);\n\t\t\t}\n\t\t} else {\n\t\t\tassert (m_lists.getField(list, 0) == node);\n\t\t\tm_lists.setField(list, 0, m_listNodes.getField(node, 1));\n\t\t\tif (m_lists.getField(list, 1) == node) {// removing last element\n\t\t\t\tassert (m_listNodes.getField(node, 1) == nullNode());\n\t\t\t\tm_lists.setField(list, 1, nullNode());\n\t\t\t}\n\t\t}\n\t\tfreeNode_(node);\n\t}", "language": "java", "code": "void deleteElement(int list, int prevNode, int node) {\n\t\tif (prevNode != nullNode()) {\n\t\t\tassert (m_listNodes.getField(prevNode, 1) == node);\n\t\t\tm_listNodes.setField(prevNode, 1, m_listNodes.getField(node, 1));\n\t\t\tif (m_lists.getField(list, 1) == node)// deleting a tail\n\t\t\t{\n\t\t\t\tm_lists.setField(list, 1, prevNode);\n\t\t\t}\n\t\t} else {\n\t\t\tassert (m_lists.getField(list, 0) == node);\n\t\t\tm_lists.setField(list, 0, m_listNodes.getField(node, 1));\n\t\t\tif (m_lists.getField(list, 1) == node) {// removing last element\n\t\t\t\tassert (m_listNodes.getField(node, 1) == nullNode());\n\t\t\t\tm_lists.setField(list, 1, nullNode());\n\t\t\t}\n\t\t}\n\t\tfreeNode_(node);\n\t}", "code_tokens": ["void", "deleteElement", "(", "int", "list", ",", "int", "prevNode", ",", "int", "node", ")", "{", "if", "(", "prevNode", "!=", "nullNode", "(", ")", ")", "{", "assert", "(", "m_listNodes", ".", "getField", "(", "prevNode", ",", "1", ")", "==", "node", ")", ";", "m_listNodes", ".", "setField", "(", "prevNode", ",", "1", ",", "m_listNodes", ".", "getField", "(", "node", ",", "1", ")", ")", ";", "if", "(", "m_lists", ".", "getField", "(", "list", ",", "1", ")", "==", "node", ")", "// deleting a tail", "{", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "prevNode", ")", ";", "}", "}", "else", "{", "assert", "(", "m_lists", ".", "getField", "(", "list", ",", "0", ")", "==", "node", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "0", ",", "m_listNodes", ".", "getField", "(", "node", ",", "1", ")", ")", ";", "if", "(", "m_lists", ".", "getField", "(", "list", ",", "1", ")", "==", "node", ")", "{", "// removing last element", "assert", "(", "m_listNodes", ".", "getField", "(", "node", ",", "1", ")", "==", "nullNode", "(", ")", ")", ";", "m_lists", ".", "setField", "(", "list", ",", "1", ",", "nullNode", "(", ")", ")", ";", "}", "}", "freeNode_", "(", "node", ")", ";", "}"], "docstring": "required, because the list is singly connected).", "docstring_tokens": ["required", "because", "the", "list", "is", "singly", "connected", ")", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiList.java#L147-L164", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexMultiList.java", "func_name": "IndexMultiList.concatenateLists", "original_string": "int concatenateLists(int list1, int list2) {\n\t\tint tailNode1 = m_lists.getField(list1, 1);\n\t\tint headNode2 = m_lists.getField(list2, 0);\n\t\tif (headNode2 != nullNode())// do not concatenate empty lists\n\t\t{\n\t\t\tif (tailNode1 != nullNode()) {\n\t\t\t\t// connect head of list2 to the tail of list1.\n\t\t\t\tm_listNodes.setField(tailNode1, 1, headNode2);\n\t\t\t\t// set the tail of the list1 to be the tail of list2.\n\t\t\t\tm_lists.setField(list1, 1, m_lists.getField(list2, 1));\n\t\t\t} else {// list1 is empty, while list2 is not.\n\t\t\t\tm_lists.setField(list1, 0, headNode2);\n\t\t\t\tm_lists.setField(list1, 1, m_lists.getField(list2, 1));\n\t\t\t}\n\t\t}\n\n\t\tif (m_b_allow_navigation_between_lists) {\n\t\t\tint prevList = m_lists.getField(list2, 2);\n\t\t\tint nextList = m_lists.getField(list2, 3);\n\t\t\tif (prevList != nullNode())\n\t\t\t\tm_lists.setField(prevList, 3, nextList);\n\t\t\telse\n\t\t\t\tm_list_of_lists = nextList;\n\n\t\t\tif (nextList != nullNode())\n\t\t\t\tm_lists.setField(nextList, 2, prevList);\n\t\t}\n\n\t\tfreeList_(list2);\n\t\treturn list1;\n\t}", "language": "java", "code": "int concatenateLists(int list1, int list2) {\n\t\tint tailNode1 = m_lists.getField(list1, 1);\n\t\tint headNode2 = m_lists.getField(list2, 0);\n\t\tif (headNode2 != nullNode())// do not concatenate empty lists\n\t\t{\n\t\t\tif (tailNode1 != nullNode()) {\n\t\t\t\t// connect head of list2 to the tail of list1.\n\t\t\t\tm_listNodes.setField(tailNode1, 1, headNode2);\n\t\t\t\t// set the tail of the list1 to be the tail of list2.\n\t\t\t\tm_lists.setField(list1, 1, m_lists.getField(list2, 1));\n\t\t\t} else {// list1 is empty, while list2 is not.\n\t\t\t\tm_lists.setField(list1, 0, headNode2);\n\t\t\t\tm_lists.setField(list1, 1, m_lists.getField(list2, 1));\n\t\t\t}\n\t\t}\n\n\t\tif (m_b_allow_navigation_between_lists) {\n\t\t\tint prevList = m_lists.getField(list2, 2);\n\t\t\tint nextList = m_lists.getField(list2, 3);\n\t\t\tif (prevList != nullNode())\n\t\t\t\tm_lists.setField(prevList, 3, nextList);\n\t\t\telse\n\t\t\t\tm_list_of_lists = nextList;\n\n\t\t\tif (nextList != nullNode())\n\t\t\t\tm_lists.setField(nextList, 2, prevList);\n\t\t}\n\n\t\tfreeList_(list2);\n\t\treturn list1;\n\t}", "code_tokens": ["int", "concatenateLists", "(", "int", "list1", ",", "int", "list2", ")", "{", "int", "tailNode1", "=", "m_lists", ".", "getField", "(", "list1", ",", "1", ")", ";", "int", "headNode2", "=", "m_lists", ".", "getField", "(", "list2", ",", "0", ")", ";", "if", "(", "headNode2", "!=", "nullNode", "(", ")", ")", "// do not concatenate empty lists", "{", "if", "(", "tailNode1", "!=", "nullNode", "(", ")", ")", "{", "// connect head of list2 to the tail of list1.", "m_listNodes", ".", "setField", "(", "tailNode1", ",", "1", ",", "headNode2", ")", ";", "// set the tail of the list1 to be the tail of list2.", "m_lists", ".", "setField", "(", "list1", ",", "1", ",", "m_lists", ".", "getField", "(", "list2", ",", "1", ")", ")", ";", "}", "else", "{", "// list1 is empty, while list2 is not.", "m_lists", ".", "setField", "(", "list1", ",", "0", ",", "headNode2", ")", ";", "m_lists", ".", "setField", "(", "list1", ",", "1", ",", "m_lists", ".", "getField", "(", "list2", ",", "1", ")", ")", ";", "}", "}", "if", "(", "m_b_allow_navigation_between_lists", ")", "{", "int", "prevList", "=", "m_lists", ".", "getField", "(", "list2", ",", "2", ")", ";", "int", "nextList", "=", "m_lists", ".", "getField", "(", "list2", ",", "3", ")", ";", "if", "(", "prevList", "!=", "nullNode", "(", ")", ")", "m_lists", ".", "setField", "(", "prevList", ",", "3", ",", "nextList", ")", ";", "else", "m_list_of_lists", "=", "nextList", ";", "if", "(", "nextList", "!=", "nullNode", "(", ")", ")", "m_lists", ".", "setField", "(", "nextList", ",", "2", ",", "prevList", ")", ";", "}", "freeList_", "(", "list2", ")", ";", "return", "list1", ";", "}"], "docstring": "Returns list1.", "docstring_tokens": ["Returns", "list1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexMultiList.java#L169-L199", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.addElement", "original_string": "public int addElement(int element, int hash) {\n\t\tint bit_bucket = hash % (m_bit_filter.length << 5);\n\t\tm_bit_filter[(bit_bucket >> 5)] |= (1 << (bit_bucket & 0x1F));\n\t\tint bucket = hash % m_hashBuckets.size();\n\t\tint list = m_hashBuckets.get(bucket);\n\t\tif (list == -1) {\n\t\t\tlist = m_lists.createList();\n\t\t\tm_hashBuckets.set(bucket, list);\n\t\t}\n\t\tint node = m_lists.addElement(list, element);\n\t\treturn node;\n\t}", "language": "java", "code": "public int addElement(int element, int hash) {\n\t\tint bit_bucket = hash % (m_bit_filter.length << 5);\n\t\tm_bit_filter[(bit_bucket >> 5)] |= (1 << (bit_bucket & 0x1F));\n\t\tint bucket = hash % m_hashBuckets.size();\n\t\tint list = m_hashBuckets.get(bucket);\n\t\tif (list == -1) {\n\t\t\tlist = m_lists.createList();\n\t\t\tm_hashBuckets.set(bucket, list);\n\t\t}\n\t\tint node = m_lists.addElement(list, element);\n\t\treturn node;\n\t}", "code_tokens": ["public", "int", "addElement", "(", "int", "element", ",", "int", "hash", ")", "{", "int", "bit_bucket", "=", "hash", "%", "(", "m_bit_filter", ".", "length", "<<", "5", ")", ";", "m_bit_filter", "[", "(", "bit_bucket", ">>", "5", ")", "]", "|=", "(", "1", "<<", "(", "bit_bucket", "&", "0x1F", ")", ")", ";", "int", "bucket", "=", "hash", "%", "m_hashBuckets", ".", "size", "(", ")", ";", "int", "list", "=", "m_hashBuckets", ".", "get", "(", "bucket", ")", ";", "if", "(", "list", "==", "-", "1", ")", "{", "list", "=", "m_lists", ".", "createList", "(", ")", ";", "m_hashBuckets", ".", "set", "(", "bucket", ",", "list", ")", ";", "}", "int", "node", "=", "m_lists", ".", "addElement", "(", "list", ",", "element", ")", ";", "return", "node", ";", "}"], "docstring": "Adds new element to the hash table.", "docstring_tokens": ["Adds", "new", "element", "to", "the", "hash", "table", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L63-L74", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.getFirstInBucket", "original_string": "public int getFirstInBucket(int hashValue) {\n\t\t  int bit_bucket = hashValue % (m_bit_filter.length << 5);\n\t\t  if ((m_bit_filter[(bit_bucket >> 5)] & (1 << (bit_bucket & 0x1F))) == 0)\n\t\t    return -1;\n\t\t\n\t\tint bucket = hashValue % m_hashBuckets.size();\n\t\tint list = m_hashBuckets.get(bucket);\n\t\tif (list == -1)\n\t\t\treturn -1;\n\n\t\treturn m_lists.getFirst(list);\n\n\t}", "language": "java", "code": "public int getFirstInBucket(int hashValue) {\n\t\t  int bit_bucket = hashValue % (m_bit_filter.length << 5);\n\t\t  if ((m_bit_filter[(bit_bucket >> 5)] & (1 << (bit_bucket & 0x1F))) == 0)\n\t\t    return -1;\n\t\t\n\t\tint bucket = hashValue % m_hashBuckets.size();\n\t\tint list = m_hashBuckets.get(bucket);\n\t\tif (list == -1)\n\t\t\treturn -1;\n\n\t\treturn m_lists.getFirst(list);\n\n\t}", "code_tokens": ["public", "int", "getFirstInBucket", "(", "int", "hashValue", ")", "{", "int", "bit_bucket", "=", "hashValue", "%", "(", "m_bit_filter", ".", "length", "<<", "5", ")", ";", "if", "(", "(", "m_bit_filter", "[", "(", "bit_bucket", ">>", "5", ")", "]", "&", "(", "1", "<<", "(", "bit_bucket", "&", "0x1F", ")", ")", ")", "==", "0", ")", "return", "-", "1", ";", "int", "bucket", "=", "hashValue", "%", "m_hashBuckets", ".", "size", "(", ")", ";", "int", "list", "=", "m_hashBuckets", ".", "get", "(", "bucket", ")", ";", "if", "(", "list", "==", "-", "1", ")", "return", "-", "1", ";", "return", "m_lists", ".", "getFirst", "(", "list", ")", ";", "}"], "docstring": "hashValue.", "docstring_tokens": ["hashValue", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L144-L156", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.findNode", "original_string": "public int findNode(int element) {\n\t\tint hash = m_hash.getHash(element);\n\t\tint ptr = getFirstInBucket(hash);\n\t\twhile (ptr != -1) {\n\t\t\tint e = m_lists.getElement(ptr);\n\t\t\tif (m_hash.equal(e, element)) {\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\treturn -1;\n\n\t}", "language": "java", "code": "public int findNode(int element) {\n\t\tint hash = m_hash.getHash(element);\n\t\tint ptr = getFirstInBucket(hash);\n\t\twhile (ptr != -1) {\n\t\t\tint e = m_lists.getElement(ptr);\n\t\t\tif (m_hash.equal(e, element)) {\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\treturn -1;\n\n\t}", "code_tokens": ["public", "int", "findNode", "(", "int", "element", ")", "{", "int", "hash", "=", "m_hash", ".", "getHash", "(", "element", ")", ";", "int", "ptr", "=", "getFirstInBucket", "(", "hash", ")", ";", "while", "(", "ptr", "!=", "-", "1", ")", "{", "int", "e", "=", "m_lists", ".", "getElement", "(", "ptr", ")", ";", "if", "(", "m_hash", ".", "equal", "(", "e", ",", "element", ")", ")", "{", "return", "ptr", ";", "}", "ptr", "=", "m_lists", ".", "getNext", "(", "ptr", ")", ";", "}", "return", "-", "1", ";", "}"], "docstring": "the given one.", "docstring_tokens": ["the", "given", "one", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L166-L179", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.findNode", "original_string": "public int findNode(Object elementDescriptor) {\n\t\tint hash = m_hash.getHash(elementDescriptor);\n\t\tint ptr = getFirstInBucket(hash);;\n\t\twhile (ptr != -1) {\n\t\t\tint e = m_lists.getElement(ptr);\n\t\t\tif (m_hash.equal(elementDescriptor, e)) {\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\treturn -1;\n\n\t}", "language": "java", "code": "public int findNode(Object elementDescriptor) {\n\t\tint hash = m_hash.getHash(elementDescriptor);\n\t\tint ptr = getFirstInBucket(hash);;\n\t\twhile (ptr != -1) {\n\t\t\tint e = m_lists.getElement(ptr);\n\t\t\tif (m_hash.equal(elementDescriptor, e)) {\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\treturn -1;\n\n\t}", "code_tokens": ["public", "int", "findNode", "(", "Object", "elementDescriptor", ")", "{", "int", "hash", "=", "m_hash", ".", "getHash", "(", "elementDescriptor", ")", ";", "int", "ptr", "=", "getFirstInBucket", "(", "hash", ")", ";", ";", "while", "(", "ptr", "!=", "-", "1", ")", "{", "int", "e", "=", "m_lists", ".", "getElement", "(", "ptr", ")", ";", "if", "(", "m_hash", ".", "equal", "(", "elementDescriptor", ",", "e", ")", ")", "{", "return", "ptr", ";", "}", "ptr", "=", "m_lists", ".", "getNext", "(", "ptr", ")", ";", "}", "return", "-", "1", ";", "}"], "docstring": "the given element descriptor.", "docstring_tokens": ["the", "given", "element", "descriptor", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L183-L196", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.getNextNode", "original_string": "public int getNextNode(int elementHandle) {\n\t\tint element = m_lists.getElement(elementHandle);\n\t\tint ptr = m_lists.getNext(elementHandle);\n\t\twhile (ptr != -1) {\n\t\t\tint e = m_lists.getElement(ptr);\n\t\t\tif (m_hash.equal(e, element)) {\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\treturn -1;\n\n\t}", "language": "java", "code": "public int getNextNode(int elementHandle) {\n\t\tint element = m_lists.getElement(elementHandle);\n\t\tint ptr = m_lists.getNext(elementHandle);\n\t\twhile (ptr != -1) {\n\t\t\tint e = m_lists.getElement(ptr);\n\t\t\tif (m_hash.equal(e, element)) {\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\treturn -1;\n\n\t}", "code_tokens": ["public", "int", "getNextNode", "(", "int", "elementHandle", ")", "{", "int", "element", "=", "m_lists", ".", "getElement", "(", "elementHandle", ")", ";", "int", "ptr", "=", "m_lists", ".", "getNext", "(", "elementHandle", ")", ";", "while", "(", "ptr", "!=", "-", "1", ")", "{", "int", "e", "=", "m_lists", ".", "getElement", "(", "ptr", ")", ";", "if", "(", "m_hash", ".", "equal", "(", "e", ",", "element", ")", ")", "{", "return", "ptr", ";", "}", "ptr", "=", "m_lists", ".", "getNext", "(", "ptr", ")", ";", "}", "return", "-", "1", ";", "}"], "docstring": "Gets next equal node.", "docstring_tokens": ["Gets", "next", "equal", "node", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L199-L212", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.deleteNode", "original_string": "public void deleteNode(int node) {\n\t\tint element = getElement(node);\n\t\tint hash = m_hash.getHash(element);\n\t\tint bucket = hash % m_hashBuckets.size();\n\t\tint list = m_hashBuckets.get(bucket);\n\t\tif (list == -1)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tint ptr = m_lists.getFirst(list);\n\t\tint prev = -1;\n\t\twhile (ptr != -1) {\n\t\t\tif (ptr == node) {\n\t\t\t\tm_lists.deleteElement(list, prev, ptr);\n\t\t\t\tif (m_lists.getFirst(list) == -1) {\n\t\t\t\t\tm_lists.deleteList(list);// do not keep empty lists\n\t\t\t\t\tm_hashBuckets.set(bucket, -1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprev = ptr;\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\tthrow new IllegalArgumentException();\n\n\t}", "language": "java", "code": "public void deleteNode(int node) {\n\t\tint element = getElement(node);\n\t\tint hash = m_hash.getHash(element);\n\t\tint bucket = hash % m_hashBuckets.size();\n\t\tint list = m_hashBuckets.get(bucket);\n\t\tif (list == -1)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tint ptr = m_lists.getFirst(list);\n\t\tint prev = -1;\n\t\twhile (ptr != -1) {\n\t\t\tif (ptr == node) {\n\t\t\t\tm_lists.deleteElement(list, prev, ptr);\n\t\t\t\tif (m_lists.getFirst(list) == -1) {\n\t\t\t\t\tm_lists.deleteList(list);// do not keep empty lists\n\t\t\t\t\tm_hashBuckets.set(bucket, -1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprev = ptr;\n\t\t\tptr = m_lists.getNext(ptr);\n\t\t}\n\n\t\tthrow new IllegalArgumentException();\n\n\t}", "code_tokens": ["public", "void", "deleteNode", "(", "int", "node", ")", "{", "int", "element", "=", "getElement", "(", "node", ")", ";", "int", "hash", "=", "m_hash", ".", "getHash", "(", "element", ")", ";", "int", "bucket", "=", "hash", "%", "m_hashBuckets", ".", "size", "(", ")", ";", "int", "list", "=", "m_hashBuckets", ".", "get", "(", "bucket", ")", ";", "if", "(", "list", "==", "-", "1", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "int", "ptr", "=", "m_lists", ".", "getFirst", "(", "list", ")", ";", "int", "prev", "=", "-", "1", ";", "while", "(", "ptr", "!=", "-", "1", ")", "{", "if", "(", "ptr", "==", "node", ")", "{", "m_lists", ".", "deleteElement", "(", "list", ",", "prev", ",", "ptr", ")", ";", "if", "(", "m_lists", ".", "getFirst", "(", "list", ")", "==", "-", "1", ")", "{", "m_lists", ".", "deleteList", "(", "list", ")", ";", "// do not keep empty lists", "m_hashBuckets", ".", "set", "(", "bucket", ",", "-", "1", ")", ";", "}", "return", ";", "}", "prev", "=", "ptr", ";", "ptr", "=", "m_lists", ".", "getNext", "(", "ptr", ")", ";", "}", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}"], "docstring": "Removes a node.", "docstring_tokens": ["Removes", "a", "node", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L215-L240", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/IndexHashTable.java", "func_name": "IndexHashTable.clear", "original_string": "public void clear() {\n\t\tArrays.fill(m_bit_filter, 0);\n\t\tm_hashBuckets = new AttributeStreamOfInt32(m_hashBuckets.size(),\n\t\t\t\tnullNode());\n\t\tm_lists.clear();\n\n\t}", "language": "java", "code": "public void clear() {\n\t\tArrays.fill(m_bit_filter, 0);\n\t\tm_hashBuckets = new AttributeStreamOfInt32(m_hashBuckets.size(),\n\t\t\t\tnullNode());\n\t\tm_lists.clear();\n\n\t}", "code_tokens": ["public", "void", "clear", "(", ")", "{", "Arrays", ".", "fill", "(", "m_bit_filter", ",", "0", ")", ";", "m_hashBuckets", "=", "new", "AttributeStreamOfInt32", "(", "m_hashBuckets", ".", "size", "(", ")", ",", "nullNode", "(", ")", ")", ";", "m_lists", ".", "clear", "(", ")", ";", "}"], "docstring": "Removes all elements from the hash table.", "docstring_tokens": ["Removes", "all", "elements", "from", "the", "hash", "table", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/IndexHashTable.java#L264-L270", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/auth/FileLoginManager.java", "func_name": "FileLoginManager.load", "original_string": "@CommandArgument\n  public void load(\n      @OptionArgument(\"filename\") String filename) {\n\n    users.clear();\n\n    try {\n      BufferedReader reader = new BufferedReader(new FileReader(filename));\n\n      while (reader.ready()) {\n        User user = User.fromString(reader.readLine());\n        users.put(user.username, user);\n      }\n    } catch (FileNotFoundException e) {\n      System.err.println(String.format(\"File not found: '%s'\", filename));\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }", "language": "java", "code": "@CommandArgument\n  public void load(\n      @OptionArgument(\"filename\") String filename) {\n\n    users.clear();\n\n    try {\n      BufferedReader reader = new BufferedReader(new FileReader(filename));\n\n      while (reader.ready()) {\n        User user = User.fromString(reader.readLine());\n        users.put(user.username, user);\n      }\n    } catch (FileNotFoundException e) {\n      System.err.println(String.format(\"File not found: '%s'\", filename));\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }", "code_tokens": ["@", "CommandArgument", "public", "void", "load", "(", "@", "OptionArgument", "(", "\"filename\"", ")", "String", "filename", ")", "{", "users", ".", "clear", "(", ")", ";", "try", "{", "BufferedReader", "reader", "=", "new", "BufferedReader", "(", "new", "FileReader", "(", "filename", ")", ")", ";", "while", "(", "reader", ".", "ready", "(", ")", ")", "{", "User", "user", "=", "User", ".", "fromString", "(", "reader", ".", "readLine", "(", ")", ")", ";", "users", ".", "put", "(", "user", ".", "username", ",", "user", ")", ";", "}", "}", "catch", "(", "FileNotFoundException", "e", ")", "{", "System", ".", "err", ".", "println", "(", "String", ".", "format", "(", "\"File not found: '%s'\"", ",", "filename", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}"], "docstring": "Loads a users file.\n@param filename The filename of the users file to load.", "docstring_tokens": ["Loads", "a", "users", "file", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/auth/FileLoginManager.java#L117-L135", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/FloatArray.java", "func_name": "FloatArray.add", "original_string": "public void add(int index, float e) {\n    if (index < 0 || index > size) {\n      throw new IndexOutOfBoundsException();\n    }\n    ensureCapacity(size + 1);\n    if (index < size) {\n      for (int i = size; i > index; i--) {\n        elements[i] = elements[i - 1];\n      }\n    }\n    elements[index] = e;\n    size++;\n  }", "language": "java", "code": "public void add(int index, float e) {\n    if (index < 0 || index > size) {\n      throw new IndexOutOfBoundsException();\n    }\n    ensureCapacity(size + 1);\n    if (index < size) {\n      for (int i = size; i > index; i--) {\n        elements[i] = elements[i - 1];\n      }\n    }\n    elements[index] = e;\n    size++;\n  }", "code_tokens": ["public", "void", "add", "(", "int", "index", ",", "float", "e", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">", "size", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "}", "ensureCapacity", "(", "size", "+", "1", ")", ";", "if", "(", "index", "<", "size", ")", "{", "for", "(", "int", "i", "=", "size", ";", "i", ">", "index", ";", "i", "--", ")", "{", "elements", "[", "i", "]", "=", "elements", "[", "i", "-", "1", "]", ";", "}", "}", "elements", "[", "index", "]", "=", "e", ";", "size", "++", ";", "}"], "docstring": "Inserts a value into the array at the specified index.\n\n@param index\nThe index at which to insert the new value.\n@param e\nThe new value to insert.\n@throws IndexOutOfBoundsException\nif <code>index &lt; 0 || index &gt; size()</code>.", "docstring_tokens": ["Inserts", "a", "value", "into", "the", "array", "at", "the", "specified", "index", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/FloatArray.java#L394-L406", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/FloatArray.java", "func_name": "FloatArray.addAll", "original_string": "public boolean addAll(int index, FloatArray items) {\n    if (index < 0 || index > size) {\n      throw new IndexOutOfBoundsException();\n    }\n    ensureCapacity(size + items.size);\n    if (index < size) {\n      for (int i = size - 1; i >= index; i--) {\n        elements[i + items.size] = elements[i];\n      }\n    }\n    for (int i = 0; i < items.size; i++) {\n      elements[index++] = items.elements[i];\n    }\n    size += items.size;\n    return items.size > 0;\n  }", "language": "java", "code": "public boolean addAll(int index, FloatArray items) {\n    if (index < 0 || index > size) {\n      throw new IndexOutOfBoundsException();\n    }\n    ensureCapacity(size + items.size);\n    if (index < size) {\n      for (int i = size - 1; i >= index; i--) {\n        elements[i + items.size] = elements[i];\n      }\n    }\n    for (int i = 0; i < items.size; i++) {\n      elements[index++] = items.elements[i];\n    }\n    size += items.size;\n    return items.size > 0;\n  }", "code_tokens": ["public", "boolean", "addAll", "(", "int", "index", ",", "FloatArray", "items", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">", "size", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "}", "ensureCapacity", "(", "size", "+", "items", ".", "size", ")", ";", "if", "(", "index", "<", "size", ")", "{", "for", "(", "int", "i", "=", "size", "-", "1", ";", "i", ">=", "index", ";", "i", "--", ")", "{", "elements", "[", "i", "+", "items", ".", "size", "]", "=", "elements", "[", "i", "]", ";", "}", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "items", ".", "size", ";", "i", "++", ")", "{", "elements", "[", "index", "++", "]", "=", "items", ".", "elements", "[", "i", "]", ";", "}", "size", "+=", "items", ".", "size", ";", "return", "items", ".", "size", ">", "0", ";", "}"], "docstring": "Inserts values into the array at the specified index.\n\n@param index\nThe index at which to insert the new values.\n@param items\nA <code>FloatArray</code> containing the values to insert.\n@return A value indicating if the array has changed.\n@throws IndexOutOfBoundsException\nif <code>index &lt; 0 || index &gt; size()</code>.", "docstring_tokens": ["Inserts", "values", "into", "the", "array", "at", "the", "specified", "index", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/FloatArray.java#L457-L472", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/io/FileUtil.java", "func_name": "FileUtil.isAncestor", "original_string": "public static boolean isAncestor(File file, File ancestor) throws IOException {\n    file = file.getCanonicalFile();\n    ancestor = ancestor.getCanonicalFile();\n    do {\n      if (file.equals(ancestor)) {\n        return true;\n      }\n      file = file.getParentFile();\n    } while (file != null);\n    return false;\n  }", "language": "java", "code": "public static boolean isAncestor(File file, File ancestor) throws IOException {\n    file = file.getCanonicalFile();\n    ancestor = ancestor.getCanonicalFile();\n    do {\n      if (file.equals(ancestor)) {\n        return true;\n      }\n      file = file.getParentFile();\n    } while (file != null);\n    return false;\n  }", "code_tokens": ["public", "static", "boolean", "isAncestor", "(", "File", "file", ",", "File", "ancestor", ")", "throws", "IOException", "{", "file", "=", "file", ".", "getCanonicalFile", "(", ")", ";", "ancestor", "=", "ancestor", ".", "getCanonicalFile", "(", ")", ";", "do", "{", "if", "(", "file", ".", "equals", "(", "ancestor", ")", ")", "{", "return", "true", ";", "}", "file", "=", "file", ".", "getParentFile", "(", ")", ";", "}", "while", "(", "file", "!=", "null", ")", ";", "return", "false", ";", "}"], "docstring": "Determines if the specified directory is an ancestor of the specified\nfile or directory.\n@param file The file or directory to test.\n@param ancestor The directory for which to determine whether\n<code>file</code> is an ancestor.\n@return <code>true</code> if <code>ancestor</code> is equal to or an\nancestor of <code>file</code>, <code>false</code> otherwise.\n@throws IOException if an error occurs in attempting to canonicalize\n{@code file} or {@code ancestor}.", "docstring_tokens": ["Determines", "if", "the", "specified", "directory", "is", "an", "ancestor", "of", "the", "specified", "file", "or", "directory", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/io/FileUtil.java#L194-L204", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/io/FileUtil.java", "func_name": "FileUtil.postOrderTraversal", "original_string": "public static boolean postOrderTraversal(File root, FileVisitor visitor) throws Exception {\n    if (root.isDirectory()) {\n      for (File child : root.listFiles()) {\n        if (!postOrderTraversal(child, visitor)) {\n          return false;\n        }\n      }\n    }\n    return visitor.visit(root);\n  }", "language": "java", "code": "public static boolean postOrderTraversal(File root, FileVisitor visitor) throws Exception {\n    if (root.isDirectory()) {\n      for (File child : root.listFiles()) {\n        if (!postOrderTraversal(child, visitor)) {\n          return false;\n        }\n      }\n    }\n    return visitor.visit(root);\n  }", "code_tokens": ["public", "static", "boolean", "postOrderTraversal", "(", "File", "root", ",", "FileVisitor", "visitor", ")", "throws", "Exception", "{", "if", "(", "root", ".", "isDirectory", "(", ")", ")", "{", "for", "(", "File", "child", ":", "root", ".", "listFiles", "(", ")", ")", "{", "if", "(", "!", "postOrderTraversal", "(", "child", ",", "visitor", ")", ")", "{", "return", "false", ";", "}", "}", "}", "return", "visitor", ".", "visit", "(", "root", ")", ";", "}"], "docstring": "Walks a directory tree using post-order traversal.  The contents of a\ndirectory are visited before the directory itself is visited.\n@param root The <code>File</code> indicating the file or directory to\nwalk.\n@param visitor The <code>FileVisitor</code> to use to visit files and\ndirectories while walking the tree.\n@return A value indicating whether the tree walk was completed without\n{@link FileVisitor#visit(File)} ever returning false.\n@throws Exception If {@link FileVisitor#visit(File)} threw an exception.\n@see FileVisitor#visit(File)", "docstring_tokens": ["Walks", "a", "directory", "tree", "using", "post", "-", "order", "traversal", ".", "The", "contents", "of", "a", "directory", "are", "visited", "before", "the", "directory", "itself", "is", "visited", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/io/FileUtil.java#L230-L239", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/io/FileUtil.java", "func_name": "FileUtil.preOrderTraversal", "original_string": "public static boolean preOrderTraversal(File root, FileVisitor visitor) throws Exception {\n    if (!visitor.visit(root)) {\n      return false;\n    }\n    if (root.isDirectory()) {\n      for (File child : root.listFiles()) {\n        if (!preOrderTraversal(child, visitor)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }", "language": "java", "code": "public static boolean preOrderTraversal(File root, FileVisitor visitor) throws Exception {\n    if (!visitor.visit(root)) {\n      return false;\n    }\n    if (root.isDirectory()) {\n      for (File child : root.listFiles()) {\n        if (!preOrderTraversal(child, visitor)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }", "code_tokens": ["public", "static", "boolean", "preOrderTraversal", "(", "File", "root", ",", "FileVisitor", "visitor", ")", "throws", "Exception", "{", "if", "(", "!", "visitor", ".", "visit", "(", "root", ")", ")", "{", "return", "false", ";", "}", "if", "(", "root", ".", "isDirectory", "(", ")", ")", "{", "for", "(", "File", "child", ":", "root", ".", "listFiles", "(", ")", ")", "{", "if", "(", "!", "preOrderTraversal", "(", "child", ",", "visitor", ")", ")", "{", "return", "false", ";", "}", "}", "}", "return", "true", ";", "}"], "docstring": "Walks a directory tree using pre-order traversal.  The contents of a\ndirectory are visited after the directory itself is visited.\n@param root The <code>File</code> indicating the file or directory to\nwalk.\n@param visitor The <code>FileVisitor</code> to use to visit files and\ndirectories while walking the tree.\n@return A value indicating whether the tree walk was completed without\n{@link FileVisitor#visit(File)} ever returning false.\n@throws Exception If {@link FileVisitor#visit(File)} threw an exception.\n@see FileVisitor#visit(File)", "docstring_tokens": ["Walks", "a", "directory", "tree", "using", "pre", "-", "order", "traversal", ".", "The", "contents", "of", "a", "directory", "are", "visited", "after", "the", "directory", "itself", "is", "visited", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/io/FileUtil.java#L253-L265", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/io/FileUtil.java", "func_name": "FileUtil.getExtension", "original_string": "public static String getExtension(String fileName) {\n    int pos = fileName.lastIndexOf('.');\n    if (pos < 0) {\n      return \"\";\n    }\n    return fileName.substring(pos + 1);\n  }", "language": "java", "code": "public static String getExtension(String fileName) {\n    int pos = fileName.lastIndexOf('.');\n    if (pos < 0) {\n      return \"\";\n    }\n    return fileName.substring(pos + 1);\n  }", "code_tokens": ["public", "static", "String", "getExtension", "(", "String", "fileName", ")", "{", "int", "pos", "=", "fileName", ".", "lastIndexOf", "(", "'", "'", ")", ";", "if", "(", "pos", "<", "0", ")", "{", "return", "\"\"", ";", "}", "return", "fileName", ".", "substring", "(", "pos", "+", "1", ")", ";", "}"], "docstring": "Gets the extension part of the specified file name.\n@param fileName The name of the file to get the extension of.\n@return The extension of the file name.", "docstring_tokens": ["Gets", "the", "extension", "part", "of", "the", "specified", "file", "name", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/io/FileUtil.java#L375-L381", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/io/FileUtil.java", "func_name": "FileUtil.getRelativePath", "original_string": "public static String getRelativePath(File file, File base) throws IOException {\n    StringWriter path = new StringWriter();\n\n    while (!isAncestor(file, base)) {\n      path.append(\"../\");\n    }\n\n    String fileName = file.getAbsolutePath();\n    String baseName = base.getAbsolutePath();\n    int prefixLength = baseName.length();\n\n    if (!baseName.endsWith(\"/\")) {\n      prefixLength++;\n    }\n\n    path.append(fileName.substring(prefixLength));\n\n    return path.toString();\n  }", "language": "java", "code": "public static String getRelativePath(File file, File base) throws IOException {\n    StringWriter path = new StringWriter();\n\n    while (!isAncestor(file, base)) {\n      path.append(\"../\");\n    }\n\n    String fileName = file.getAbsolutePath();\n    String baseName = base.getAbsolutePath();\n    int prefixLength = baseName.length();\n\n    if (!baseName.endsWith(\"/\")) {\n      prefixLength++;\n    }\n\n    path.append(fileName.substring(prefixLength));\n\n    return path.toString();\n  }", "code_tokens": ["public", "static", "String", "getRelativePath", "(", "File", "file", ",", "File", "base", ")", "throws", "IOException", "{", "StringWriter", "path", "=", "new", "StringWriter", "(", ")", ";", "while", "(", "!", "isAncestor", "(", "file", ",", "base", ")", ")", "{", "path", ".", "append", "(", "\"../\"", ")", ";", "}", "String", "fileName", "=", "file", ".", "getAbsolutePath", "(", ")", ";", "String", "baseName", "=", "base", ".", "getAbsolutePath", "(", ")", ";", "int", "prefixLength", "=", "baseName", ".", "length", "(", ")", ";", "if", "(", "!", "baseName", ".", "endsWith", "(", "\"/\"", ")", ")", "{", "prefixLength", "++", ";", "}", "path", ".", "append", "(", "fileName", ".", "substring", "(", "prefixLength", ")", ")", ";", "return", "path", ".", "toString", "(", ")", ";", "}"], "docstring": "Gets the <code>String</code> representing the path to a file relative to\na given directory.\n@param file The <code>File</code> for which to obtain the relative path.\n@param base The <code>File</code> representing the directory that the\nresulting path should be relative to.\n@return The <code>String</code> representing the relative path.\n@throws IOException If a directory along the walk from <code>base</code>\nto <code>file</code> could not be read.", "docstring_tokens": ["Gets", "the", "<code", ">", "String<", "/", "code", ">", "representing", "the", "path", "to", "a", "file", "relative", "to", "a", "given", "directory", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/io/FileUtil.java#L317-L335", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/sql/DbUtil.java", "func_name": "DbUtil.queryInt", "original_string": "public static int queryInt(PreparedStatement stmt, int def) throws SQLException {\n    ResultSet rs = null;\n    try {\n      rs = stmt.executeQuery();\n      if (rs.next()) {\n        int value = rs.getInt(1);\n        if (!rs.wasNull()) {\n          return value;\n        }\n      }\n      return def;\n    } finally {\n      close(rs);\n    }\n  }", "language": "java", "code": "public static int queryInt(PreparedStatement stmt, int def) throws SQLException {\n    ResultSet rs = null;\n    try {\n      rs = stmt.executeQuery();\n      if (rs.next()) {\n        int value = rs.getInt(1);\n        if (!rs.wasNull()) {\n          return value;\n        }\n      }\n      return def;\n    } finally {\n      close(rs);\n    }\n  }", "code_tokens": ["public", "static", "int", "queryInt", "(", "PreparedStatement", "stmt", ",", "int", "def", ")", "throws", "SQLException", "{", "ResultSet", "rs", "=", "null", ";", "try", "{", "rs", "=", "stmt", ".", "executeQuery", "(", ")", ";", "if", "(", "rs", ".", "next", "(", ")", ")", "{", "int", "value", "=", "rs", ".", "getInt", "(", "1", ")", ";", "if", "(", "!", "rs", ".", "wasNull", "(", ")", ")", "{", "return", "value", ";", "}", "}", "return", "def", ";", "}", "finally", "{", "close", "(", "rs", ")", ";", "}", "}"], "docstring": "Runs a SQL query that returns a single integer value.\n@param stmt The <code>PreparedStatement</code> to run.\n@param def The default value to return if the query returns no results.\n@return The value returned by the query, or <code>def</code> if the\nquery returns no results.  It is assumed that the query\nreturns a result set consisting of a single row and column, and\nthat this value is an integer.  Any additional rows or columns\nreturned will be ignored.\n@throws SQLException If an error occurs while attempting to communicate\nwith the database.", "docstring_tokens": ["Runs", "a", "SQL", "query", "that", "returns", "a", "single", "integer", "value", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/sql/DbUtil.java#L109-L123", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/sql/DbUtil.java", "func_name": "DbUtil.queryString", "original_string": "public static String queryString(Connection con, String def, String query, Object... param) throws SQLException {\n    PreparedStatement stmt = null;\n    try {\n      stmt = con.prepareStatement(query);\n      stmt.setMaxRows(1);\n      for (int i = 0; i < param.length; i++) {\n        stmt.setObject(i + 1, param[i]);\n      }\n      return queryString(stmt, def);\n    } finally {\n      close(stmt);\n    }\n  }", "language": "java", "code": "public static String queryString(Connection con, String def, String query, Object... param) throws SQLException {\n    PreparedStatement stmt = null;\n    try {\n      stmt = con.prepareStatement(query);\n      stmt.setMaxRows(1);\n      for (int i = 0; i < param.length; i++) {\n        stmt.setObject(i + 1, param[i]);\n      }\n      return queryString(stmt, def);\n    } finally {\n      close(stmt);\n    }\n  }", "code_tokens": ["public", "static", "String", "queryString", "(", "Connection", "con", ",", "String", "def", ",", "String", "query", ",", "Object", "...", "param", ")", "throws", "SQLException", "{", "PreparedStatement", "stmt", "=", "null", ";", "try", "{", "stmt", "=", "con", ".", "prepareStatement", "(", "query", ")", ";", "stmt", ".", "setMaxRows", "(", "1", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "param", ".", "length", ";", "i", "++", ")", "{", "stmt", ".", "setObject", "(", "i", "+", "1", ",", "param", "[", "i", "]", ")", ";", "}", "return", "queryString", "(", "stmt", ",", "def", ")", ";", "}", "finally", "{", "close", "(", "stmt", ")", ";", "}", "}"], "docstring": "Runs a SQL query that returns a single <code>String</code> value.\n@param con The <code>Connection</code> against which to run the query.\n@param def The default value to return if the query returns no results.\n@param query The SQL query to run.\n@param param The parameters to the SQL query.\n@return The value returned by the query, or <code>def</code> if the\nquery returns no results.  It is assumed that the query\nreturns a result set consisting of a single row and column, and\nthat this value is a <code>String</code>.  Any additional rows or\ncolumns returned will be ignored.\n@throws SQLException If an error occurs while attempting to communicate\nwith the database.", "docstring_tokens": ["Runs", "a", "SQL", "query", "that", "returns", "a", "single", "<code", ">", "String<", "/", "code", ">", "value", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/sql/DbUtil.java#L163-L175", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/sql/DbUtil.java", "func_name": "DbUtil.update", "original_string": "public static int update(Connection con, String query, Object... param) throws SQLException {\n    PreparedStatement stmt = null;\n    try {\n      stmt = con.prepareStatement(query);\n      for (int i = 0; i < param.length; i++) {\n        stmt.setObject(i + 1, param[i]);\n      }\n      return stmt.executeUpdate();\n    } finally {\n      close(stmt);\n    }\n  }", "language": "java", "code": "public static int update(Connection con, String query, Object... param) throws SQLException {\n    PreparedStatement stmt = null;\n    try {\n      stmt = con.prepareStatement(query);\n      for (int i = 0; i < param.length; i++) {\n        stmt.setObject(i + 1, param[i]);\n      }\n      return stmt.executeUpdate();\n    } finally {\n      close(stmt);\n    }\n  }", "code_tokens": ["public", "static", "int", "update", "(", "Connection", "con", ",", "String", "query", ",", "Object", "...", "param", ")", "throws", "SQLException", "{", "PreparedStatement", "stmt", "=", "null", ";", "try", "{", "stmt", "=", "con", ".", "prepareStatement", "(", "query", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "param", ".", "length", ";", "i", "++", ")", "{", "stmt", ".", "setObject", "(", "i", "+", "1", ",", "param", "[", "i", "]", ")", ";", "}", "return", "stmt", ".", "executeUpdate", "(", ")", ";", "}", "finally", "{", "close", "(", "stmt", ")", ";", "}", "}"], "docstring": "Runs a SQL query that inserts, updates, or deletes rows.\n@param con The <code>Connection</code> against which to run the query.\n@param query The SQL query to run.\n@param param The parameters to the SQL query.\n@return The number of rows affected by the query.\n@throws SQLException If an error occurs while attempting to communicate\nwith the database.", "docstring_tokens": ["Runs", "a", "SQL", "query", "that", "inserts", "updates", "or", "deletes", "rows", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/sql/DbUtil.java#L301-L312", "partition": "train"}
{"repo": "bwkimmel/java-util", "path": "src/main/java/ca/eandb/util/sql/DbUtil.java", "func_name": "DbUtil.close", "original_string": "public static void close(ResultSet rs, Statement stmt, Connection con) {\n    close(rs);\n    close(stmt);\n    close(con);\n  }", "language": "java", "code": "public static void close(ResultSet rs, Statement stmt, Connection con) {\n    close(rs);\n    close(stmt);\n    close(con);\n  }", "code_tokens": ["public", "static", "void", "close", "(", "ResultSet", "rs", ",", "Statement", "stmt", ",", "Connection", "con", ")", "{", "close", "(", "rs", ")", ";", "close", "(", "stmt", ")", ";", "close", "(", "con", ")", ";", "}"], "docstring": "Closes a result set, statement, and connection.  Any\n<code>SQLException</code>s thrown are ignored.\n@param rs The <code>ResultSet</code> to close.  If this value is\n<code>null</code>, no <code>ResultSet</code> is closed.\n@param stmt The <code>Statement</code> to close.  If this value is\n<code>null</code>, no <code>Statement</code> is closed.\n@param con The <code>Connection</code> to close.  If this value is\n<code>null</code>, no <code>Connection</code> is closed.", "docstring_tokens": ["Closes", "a", "result", "set", "statement", "and", "connection", ".", "Any", "<code", ">", "SQLException<", "/", "code", ">", "s", "thrown", "are", "ignored", "."], "sha": "0c03664d42f0e6b111f64447f222aa73c2819e5c", "url": "https://github.com/bwkimmel/java-util/blob/0c03664d42f0e6b111f64447f222aa73c2819e5c/src/main/java/ca/eandb/util/sql/DbUtil.java#L385-L389", "partition": "train"}
